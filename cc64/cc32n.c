/*
Toy C compiler for Windows.

This code is placed in the Public Domain.

Generated C code (not original non-C sources); build with gcc or tcc.

--------------------------------------

'BCC' Compiler for 'C'-like language.

Major C Features Not Supported:

 * VLAs
 * Compound literals
 * Designated initialisers
 * Bit fields in structs (will just be ints)

Restrictions:

 * Limited complexity of static initialisation data for pointer/array expressions
 * Limited complexity of non-static initialisation data (can't remember
   off-hand what it is)
 * Standard headers not fully populated

Known problems:

 * Callback functions (those called from code not compiled with bcc,
   such as compare functions for qsort(), or MainWndProc(), need one of:
     CALLBACK
     $callback
     #pragma $callback
   in front. (Because full Win64 ABI call convention not supported.)

 * There may be some bugs in supporting 'float' types

Building BCC using 64-bit compiler; use -m64 if defaults to 32-bit:

   gcc cc64.c -obcc.exe
   tcc cc64.c -obcc.exe -luser32

 May not work with msvc due to long string constants. Not recently tested with
 anything else except itself:

   bcc cc64.c               # build to cc64.exe (can't overwrite bcc.exe)

Building BCC using 32-bit compiler:

   gcc cc32.c -obcc.exe
   tcc cc32.c -obcc.exe -luser32

Note that the 32-bit version will still expect a 64-bit msvcrt.dll and generates
64-bit executables. However -e and -s options can still be used.


 Standard headers are incorporated into the executable.

Use as follows:

  bcc hello.c

 to produce hello.exe.

For further instructions try one of:

  bcc
  bcc -help

*/

/*
  M to C  Whole Program Translator
  Input:  cc.m plus imported modules
  Output: cc.c (this file, or renamed from that)
          File represents entire program
  Target: C 32-bit
  OS:     Linux

  Modules:
  Module 1: cc.m
  Module 2: <Built-in: msysnewc.m>
  Module 3: <Built-in: clibnewc.m>
  Module 4: <Built-in: mlib.m>
  Module 5: <Built-in: osnos.m>
  Module 6: ./cc_decls.m
  Module 7: ./cc_tables.m
  Module 8: ./cc_support.m
  Module 9: ./cc_lex.m
  Module 10: ./cc_headers.m
  Module 11: ./cc_lib.m
  Module 12: ./cc_parse.m
  Module 13: ./cc_genmcl.m
  Module 14: ./cc_libmcl.m
  Module 15: ./cc_blockmcl.m
  Module 16: ./cc_genasm.m
  Module 17: ./cc_export.m
  Module 18: ./cc_assembler.m
  Module 19: c:/ax/ax_tables.m
  Module 20: c:/ax/ax_decls.m
  Module 21: c:/ax/ax_lex.m
  Module 22: c:/ax/ax_parse.m
  Module 23: c:/ax/ax_lib.m
  Module 24: c:/ax/ax_genss.m
  Module 25: c:/ax/ax_objdecls.m
  Module 26: c:/ax/ax_writeexe.m
  Module 27: c:/ax/ax_disasm.m
  Module 28: c:/ax/ax_writeobj.m

*********** Start of C Code **********/


#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <ctype.h>
#include <string.h>
#include <math.h>
#include <time.h>
/*#include <sys/types.h>
#include <sys/stat.h>*/

#pragma pack(1)

typedef int8_t i8;
typedef int16_t i16;
typedef int32_t i32;
typedef int64_t i64;

typedef uint8_t u8;
typedef uint16_t u16;
typedef uint32_t u32;
typedef uint64_t u64;

typedef unsigned char byte;

typedef void* var;

#ifndef CALLBACK
#define CALLBACK
#endif


/* Forward Struct Declarations */
struct msysnewc_procinforec;
struct msysnewc_fmtrec;
struct mlib_strbuffer;
struct osnos_rsystemtime;
struct osnos_os_getdllprocaddr_rec;
struct cc_decls_tokenrec;
struct cc_decls_mparamrec;
struct cc_decls_caserec;
struct cc_decls_paramrec;
struct cc_decls_attribrec;
struct cc_decls_fieldrec;
struct cc_decls_strec;
struct cc_decls_unitrec;
struct cc_decls_modulerec;
struct cc_decls_dllprocrec;
struct cc_decls_procrec;
struct cc_lex_stackinforec;
struct cc_parse_readdeclspec_declrec;
struct cc_libmcl_opndrec;
struct cc_libmcl_mclrec;
struct cc_genasm_genrealtable_fprec;
struct ax_decls_fwdrec;
struct ax_decls_opndrec;
struct ax_decls_strec;
struct ax_decls_relocrec;
struct ax_decls_dbuffer;
struct ax_decls_modulerec;
struct ax_decls_stlistrec;
struct ax_lib_mclrec;
struct ax_objdecls_imagefileheader;
struct ax_objdecls_imagedir;
struct ax_objdecls_optionalheader;
struct ax_objdecls_imagesectionheader;
struct ax_objdecls_imagesymbol;
struct ax_objdecls_importdirrec;
struct ax_objdecls_coffrelocrec;
struct ax_objdecls_auxsectionrec;
struct ax_writeexe_sectionrec;
struct ax_writeexe_importrec;
struct ax_writeexe_dllrec;

/* Struct Definitions */
struct msysnewc_procinforec {
    u16 fnindex;
    byte rettype;
    byte nparams;
    byte paramlist[12];
};

struct msysnewc_fmtrec {
    byte minwidth;
    i8 precision;
    byte base;
    byte quotechar;
    byte padchar;
    byte realfmt;
    byte plus;
    byte sepchar;
    byte lettercase;
    byte justify;
    byte suffix;
    byte usigned;
    byte charmode;
    byte heapmode;
    byte param;
    byte spare;
};

struct mlib_strbuffer {
    byte *  strptr;
    i32 length;
    i32 allocated;
};

struct osnos_rsystemtime {
    i64 year;
    i64 month;
    i64 dayofweek;
    i64 day;
    i64 hour;
    i64 minute;
    i64 second;
    i64 milliseconds;
};

struct osnos_os_getdllprocaddr_rec {
    byte *  name;
    void *  addr;
};

struct cc_decls_tokenrec {
    union {
        i64 value;
        double xvalue;
        u64 uvalue;
        byte *  svalue;
        struct cc_decls_strec *  symptr;
    };
    struct cc_decls_tokenrec* nexttoken;
    union {
        struct {
            byte subcode;
            byte flags;
        };
        u16 subcodex;
    };
    byte symbol;
    byte fileno;
    u32 lineno;
    i32 length;
    union {
        i32 numberoffset;
        i16 paramno;
        i16 pasteno;
    };
};

struct cc_decls_mparamrec {
    struct cc_decls_strec *  def;
    struct cc_decls_mparamrec* nextmparam;
};

struct cc_decls_caserec {
    struct cc_decls_caserec* nextcase;
    i64 value;
};

struct cc_decls_paramrec {
    struct cc_decls_strec *  def;
    struct cc_decls_paramrec* nextparam;
    i32 mode;
    i16 nparams;
    i16 flags;
};

struct cc_decls_attribrec {
    byte ax_static;
    byte ax_equals;
    byte ax_varparams;
    byte ax_used;
    byte ax_forward;
    byte ax_frame;
    byte ax_autovar;
    byte ax_nparams;
    byte ax_callback;
    byte ax_moduleno;
    byte ax_loop;
    union {
        byte ax_align;
        byte ax_dllindex;
        byte ax_extmodno;
        byte ax_flmacro;
    };
};

struct cc_decls_fieldrec {
    struct cc_decls_strec *  def;
    struct cc_decls_strec *  gendef;
    struct cc_decls_fieldrec* nextfield;
    i64 offset;
};

struct cc_decls_strec {
    byte *  name;
    struct cc_decls_strec* owner;
    struct cc_decls_strec* deflist;
    struct cc_decls_strec* deflistx;
    struct cc_decls_strec* nextdef;
    struct cc_decls_strec* nextdupl;
    struct cc_decls_strec* prevdupl;
    union {
        void *  mclcode;
        void *  opnd;
    };
    union {
        struct cc_decls_paramrec *  nextparam;
        struct cc_decls_unitrec *  callchain;
        struct cc_decls_strec* nextmacro;
        struct cc_decls_fieldrec *  nextfield;
    };
    union {
        struct cc_decls_unitrec *  code;
        struct cc_decls_tokenrec *  tokenlist;
    };
    union {
        struct cc_decls_paramrec *  paramlist;
        struct cc_decls_mparamrec *  mparamlist;
        byte *  macrovalue;
    };
    union {
        void *  address;
        i64 offset;
        byte oldsymbol;
    };
    u32 lineno;
    i32 index;
    union {
        struct {
            u16 blockno;
            u16 namespace;
        };
        u32 nsblock;
    };
    i16 subcode;
    i16 mode;
    byte namelen;
    byte symbol;
    byte nameid;
    byte scope;
    struct cc_decls_attribrec attribs;
};

struct cc_decls_unitrec {
    union {
        struct cc_decls_strec *  def;
        i64 value;
        u64 uvalue;
        double xvalue;
        byte *  svalue;
        u16 *  wsvalue;
        struct cc_decls_strec *  labeldef;
        struct cc_decls_caserec *  nextcase;
        i32 ptrscale;
        i32 offset;
    };
    struct cc_decls_unitrec* nextunit;
    struct cc_decls_unitrec* a;
    struct cc_decls_unitrec* b;
    struct cc_decls_unitrec* c;
    i32 tag;
    u32 lineno;
    union {
        i32 opcode;
        i32 index;
        u32 uindex;
        i32 slength;
        i32 wslength;
        i32 alength;
        i32 scale;
        i32 aparams;
        i32 count;
    };
    i32 mode;
    byte simple;
    byte fileno;
    union {
        byte callconv;
        byte convmem;
        byte isstrconst;
    };
    union {
        byte strarray;
        byte convtomem;
    };
    byte iswstrconst;
    byte spare1;
    u16 spare2;
};

struct cc_decls_modulerec {
    byte *  name;
    struct cc_decls_strec *  stmodule;
    i64 fileno;
    byte *  asmstr;
    byte *  mhdrstr;
    byte importmap[200];
};

struct cc_decls_dllprocrec {
    byte *  name;
    void (*address)(void);
    i64 dllindex;
};

struct cc_decls_procrec {
    struct cc_decls_strec *  def;
    struct cc_decls_procrec* nextproc;
};

struct cc_lex_stackinforec {
    byte *  startptr;
    byte *  sptr;
    i32 lineno;
    i32 fileno;
};

struct cc_parse_readdeclspec_declrec {
    i32 typeno;
    byte isconst;
    byte isvolatile;
    byte isrestrict;
    byte linkage;
    byte isinline;
    byte isshort;
    byte islong;
    byte isllong;
    byte issigned;
    byte isunsigned;
    byte isusertype;
};

struct cc_libmcl_opndrec {
    struct cc_decls_strec *  def;
    union {
        i64 value;
        double xvalue;
        byte *  svalue;
        u16 *  wsvalue;
    };
    i32 size;
    union {
        i32 index;
        i32 slength;
        i32 wslength;
    };
    byte mode;
    byte reg;
    byte regix;
    byte valtype;
    byte scale;
    byte isglobal;
    byte isfloat;
    byte s3;
};

struct cc_libmcl_mclrec {
    struct cc_libmcl_mclrec* nextmcl;
    struct cc_libmcl_opndrec *  a;
    struct cc_libmcl_opndrec *  b;
    byte opcode;
    byte cond;
    byte fileno;
    byte spare;
    i32 lineno;
};

struct cc_genasm_genrealtable_fprec {
    union {
        double x64;
        i64 ix64;
    };
    union {
        float x32;
        i32 ix32;
    };
};

struct ax_decls_fwdrec {
    struct ax_decls_fwdrec* nextfwd;
    i32 offset;
    i16 reltype;
    i16 seg;
};

struct ax_decls_opndrec {
    struct ax_decls_strec *  labeldef;
    union {
        i64 value;
        double xvalue;
        byte *  svalue;
    };
    byte mode;
    byte size;
    byte reg;
    byte regix;
    byte scale;
    byte addrsize;
    byte valtype;
    byte spare2;
};

struct ax_decls_strec {
    byte *  name;
    struct ax_decls_fwdrec *  fwdrefs;
    struct ax_decls_opndrec *  expr;
    i32 offset;
    i32 stindex;
    i32 importindex;
    byte symbol;
    byte ksymbol;
    byte subcode;
    byte regsize;
    byte scope;
    byte reftype;
    byte segment;
    byte namelen;
    struct ax_decls_strec* basedef;
    struct ax_decls_strec* nextdef;
    struct ax_decls_strec* nextdupl;
    i32 moduleno;
    u32 htindex;
    u32 htfirstindex;
    byte spare[48];
};

struct ax_decls_relocrec {
    struct ax_decls_relocrec* nextreloc;
    i64 reloctype;
    i64 offset;
    i64 stindex;
};

struct ax_decls_dbuffer {
    byte *  pstart;
    union {
        byte *  pcurr;
        u16 *  pcurr16;
        u32 *  pcurr32;
        u64 *  pcurr64;
    };
    byte *  pend;
    i64 alloc;
};

struct ax_decls_modulerec {
    byte *  filename;
    byte *  name;
    byte *  source;
};

struct ax_decls_stlistrec {
    struct ax_decls_strec *  def;
    struct ax_decls_stlistrec* nextitem;
};

struct ax_lib_mclrec {
    struct ax_lib_mclrec* nextmcl;
    struct ax_decls_opndrec *  a;
    struct ax_decls_opndrec *  b;
    u16 opcode;
    u16 c;
    i64 lineno;
};

struct ax_objdecls_imagefileheader {
    u16 machine;
    u16 nsections;
    u32 timedatestamp;
    u32 symtaboffset;
    u32 nsymbols;
    u16 optheadersize;
    u16 characteristics;
};

struct ax_objdecls_imagedir {
    u32 virtualaddr;
    u32 size;
};

struct ax_objdecls_optionalheader {
    u16 magic;
    byte majorlv;
    byte minorlv;
    u32 codesize;
    u32 idatasize;
    u32 zdatasize;
    u32 entrypoint;
    u32 codebase;
    u64 imagebase;
    u32 sectionalignment;
    u32 filealignment;
    u16 majorosv;
    u16 minorosv;
    u16 majorimagev;
    u16 minorimagev;
    u16 majorssv;
    u16 minorssv;
    u32 win32version;
    u32 imagesize;
    u32 headerssize;
    u32 checksum;
    u16 subsystem;
    u16 dllcharacteristics;
    u64 stackreserve;
    u64 stackcommit;
    u64 heapreserve;
    u64 heapcommit;
    u32 loaderflags;
    u32 rvadims;
    struct ax_objdecls_imagedir exporttable;
    struct ax_objdecls_imagedir importtable;
    struct ax_objdecls_imagedir resourcetable;
    struct ax_objdecls_imagedir exceptiontable;
    struct ax_objdecls_imagedir certtable;
    struct ax_objdecls_imagedir basereloctable;
    struct ax_objdecls_imagedir debug;
    struct ax_objdecls_imagedir architecture;
    struct ax_objdecls_imagedir globalptr;
    struct ax_objdecls_imagedir tlstable;
    struct ax_objdecls_imagedir loadconfigtable;
    struct ax_objdecls_imagedir boundimport;
    struct ax_objdecls_imagedir iat;
    struct ax_objdecls_imagedir delayimportdescr;
    struct ax_objdecls_imagedir clrheader;
    struct ax_objdecls_imagedir reserved;
};

struct ax_objdecls_imagesectionheader {
    byte name[8];
    union {
        u32 physical_address;
        u32 virtual_size;
    };
    u32 virtual_address;
    u32 rawdata_size;
    u32 rawdata_offset;
    u32 relocations_ptr;
    u32 linenos_offset;
    u16 nrelocs;
    u16 nlinenos;
    u32 characteristics;
};

struct ax_objdecls_imagesymbol {
    union {
        byte shortname[8];
        struct {
            u32 shortx;
            u32 longx;
        };
        u64 longname;
    };
    u32 value;
    i16 sectionno;
    u16 symtype;
    byte storageclass;
    byte nauxsymbols;
};

struct ax_objdecls_importdirrec {
    u32 implookuprva;
    u32 timedatestamp;
    u32 fwdchain;
    u32 namerva;
    u32 impaddressrva;
};

struct ax_objdecls_coffrelocrec {
    i32 virtualaddr;
    i32 stindex;
    i16 reloctype;
};

struct ax_objdecls_auxsectionrec {
    i32 length;
    i16 nrelocs;
    i16 nlines;
    i32 checksum;
    i16 sectionno;
    i32 dummy;
};

struct ax_writeexe_sectionrec {
    union {
        struct ax_decls_dbuffer *  data;
        byte *  bytedata;
    };
    byte *  name;
    i64 segtype;
    i64 rawsize;
    i64 rawoffset;
    i64 virtsize;
    i64 virtoffset;
    struct ax_decls_relocrec *  relocs;
    i64 nrelocs;
};

struct ax_writeexe_importrec {
    struct ax_decls_strec *  def;
    i64 libno;
    byte *  name;
    i64 hintnameoffset;
    i64 iatoffset;
    i64 thunkoffset;
};

struct ax_writeexe_dllrec {
    byte *  name;
    i64 nprocs;
    i64 nametableoffset;
    i64 addrtableoffset;
    i64 dllnameoffset;
    i64 dllextraoffset;
};


/* PROCDECLS */
void start(void);
static void cc_compilemodules(i64 a,i64 b,i64 pass);
static void cc_debugcompile(void);
static void cc_do_loadmodule(i64 n);
static void cc_do_preprocess(i64 n);
static void cc_do_parsemodule(i64 n);
static void cc_do_genmcl(i64 n);
static void cc_do_genasm(i64 n);
static void cc_do_runprog(void);
static i64 cc_loadmainmodule(byte * filespec);
static i64 cc_addmodule(byte * modulename,i64 fileno,i64 id);
static void cc_initlogfile(void);
static void cc_closelogfile(void);
static void cc_initdata(void);
static void cc_initsearchdirs(void);
static void cc_showsearchdirs(void);
static void cc_showast(i64 n);
static void cc_showstflat(byte * caption);
static void cc_showsttree(byte * caption,i64 n);
static void cc_showmcl(byte * caption,i64 n);
static void cc_showasm(i64 n);
static void cc_showfiles(void);
static void cc_starttiming(void);
static void cc_showtiming(void);
void cc_showlps(byte * caption,i64 t);
static void cc_getinputoptions(void);
static void cc_do_option(i64 sw,byte * value);
static void cc_showincludepaths(void);
static void cc_showhelp(void);
static void cc_showextrainfo(void);
static void cc_showcaption(void);
static void cc_do_genlink(void);
static void cc_resetcompiler(void);
static void cc_showcompilerstate(void);
static i64 cc_addnewmodules(void);
static void cc_writeatfile(void);
i64 msysnewc_m_getdotindex(u64 a,i64 i);
void msysnewc_m_setdotindex(u64 * a,i64 i,i64 x);
i64 msysnewc_m_getdotslice(u64 a,i64 i,i64 j);
void msysnewc_m_setdotslice(u64 * a,i64 i,i64 j,u64 x);
i64 msysnewc_m_get_nprocs(void);
i64 msysnewc_m_get_nexports(void);
void * msysnewc_m_get_procname(i64 n);
byte * msysnewc_m_get_procaddr(i64 n);
void * msysnewc_m_get_procexport(i64 n);
static void msysnewc_pushio(void);
void msysnewc_m_print_startfile(void * dev);
void msysnewc_m_print_startstr(byte * s);
void msysnewc_m_print_startptr(byte * * p);
void msysnewc_m_print_startcon(void);
void msysnewc_m_print_setfmt(byte * format);
void msysnewc_m_print_end(void);
void msysnewc_m_print_ptr(void * a,byte * fmtstyle);
void msysnewc_m_print_i64(i64 a,byte * fmtstyle);
void msysnewc_m_print_u64(u64 a,byte * fmtstyle);
void msysnewc_m_print_r64(double x,byte * fmtstyle);
void msysnewc_m_print_r32(float x,byte * fmtstyle);
void msysnewc_m_print_c8(i64 a,byte * fmtstyle);
void msysnewc_m_print_str(byte * s,byte * fmtstyle);
void msysnewc_m_print_newline(void);
void msysnewc_m_print_nogap(void);
void msysnewc_printstr(byte * s);
void msysnewc_printstr_n(byte * s,i64 n);
void msysnewc_printstrn_app(byte * s,i64 length,void * f);
static byte * msysnewc_makezstring(byte * s,i64 n,byte * local);
static void msysnewc_freezstring(byte * t,i64 n);
static void msysnewc_printchar(i64 ch);
void msysnewc_nextfmtchars(i64 lastx);
void msysnewc_strtofmt(byte * s,i64 slen,struct msysnewc_fmtrec * fmt);
static i64 msysnewc_domultichar(byte * p,i64 n,byte * dest,struct msysnewc_fmtrec * fmt);
static i64 msysnewc_expandstr(byte * s,byte * t,i64 n,struct msysnewc_fmtrec * fmt);
static u64 msysnewc_xdivrem(u64 a,u64 b,u64 * remainder);
static i64 msysnewc_u64tostr(u64 aa,byte * s,u64 base,i64 sep);
static i64 msysnewc_i64tostrfmt(i64 aa,byte * s,struct msysnewc_fmtrec * fmt);
static i64 msysnewc_u64tostrfmt(i64 aa,byte * s,struct msysnewc_fmtrec * fmt);
static i64 msysnewc_i64mintostr(byte * s,i64 base,i64 sep);
static i64 msysnewc_strtostrfmt(byte * s,byte * t,i64 n,struct msysnewc_fmtrec * fmt);
static void msysnewc_tostr_i64(i64 a,struct msysnewc_fmtrec * fmt);
static void msysnewc_tostr_u64(u64 a,struct msysnewc_fmtrec * fmt);
static void msysnewc_tostr_r64(double x,struct msysnewc_fmtrec * fmt);
static void msysnewc_tostr_str(byte * s,struct msysnewc_fmtrec * fmt);
static struct msysnewc_fmtrec * msysnewc_getfmt(byte * fmtstyle);
byte * msysnewc_strint(i64 a,byte * fmtstyle);
void msysnewc_getstrint(i64 a,byte * dest);
byte * msysnewc_strword(u64 a,byte * fmtstyle);
byte * msysnewc_strreal(double a,byte * fmtstyle);
static byte * msysnewc_getstr(byte * s,struct msysnewc_fmtrec * fmt);
static void msysnewc_initreadbuffer(void);
void msysnewc_m_read_conline(void);
void msysnewc_m_read_fileline(void * f);
void msysnewc_m_read_strline(byte * s);
static byte * msysnewc_readitem(i64 * itemlength);
i64 msysnewc_strtoint(byte * s,i64 length,i64 base);
i64 msysnewc_m_read_i64(i64 fmt);
double msysnewc_m_read_r64(i64 fmt);
void msysnewc_m_read_str(byte * dest,i64 destlen,i64 fmt);
void msysnewc_readstr(byte * dest,i64 fmt,i64 destlen);
void msysnewc_rereadln(void);
void msysnewc_reread(void);
i64 msysnewc_valint(byte * s,i64 fmt);
double msysnewc_valreal(byte * s);
static void msysnewc_iconvlcn(byte * s,i64 n);
static void msysnewc_iconvucn(byte * s,i64 n);
static void msysnewc_convlcstring(byte * s);
static void msysnewc_convucstring(byte * s);
i64 msysnewc_m_power_i64(i64 n,i64 a);
void msysnewc_m_intoverflow(void);
void msysnewc_m_dotindex(u64 i,u64 a);
void msysnewc_m_dotslice(u64 j,u64 i,u64 a);
void msysnewc_m_popdotindex(u64 i,u64 * p,u64 x);
void msysnewc_m_popdotslice(u64 j,u64 i,u64 * p,u64 x);
i64 msysnewc_m_imin(i64 a,i64 b);
i64 msysnewc_m_imax(i64 a,i64 b);
double msysnewc_m_sign(double x);
void * mlib_pcm_alloc(i64 n);
void mlib_pcm_freestr(byte * s);
void mlib_pcm_free(void * p,i64 n);
void mlib_pcm_freeac(void * p,i64 alloc);
void mlib_pcm_copymem4(void * p,void * q,i64 n);
void mlib_pcm_clearmem(void * p,i64 n);
void mlib_pcm_init(void);
i64 mlib_pcm_getac(i64 size);
void * mlib_pcm_newblock(i64 itemsize);
i64 mlib_pcm_round(i64 n);
i64 mlib_pcm_array(i64 n);
void mlib_pcm_printfreelist(i64 size,u32 * p);
void mlib_pcm_diags(byte * caption);
void * mlib_pcm_allocz(i64 n);
byte * mlib_pcm_copyheapstring(byte * s);
byte * mlib_pcm_copyheapstringn(byte * s,i64 n);
byte * mlib_pcm_copyheapblock(byte * s,i64 length);
static void mlib_addtomemalloc(i32 * ptr,i64 size);
static void mlib_removefrommemalloc(i32 * ptr,i64 size);
void * mlib_allocmem(i64 n);
void * mlib_reallocmem(void * p,i64 n);
void mlib_abortprogram(byte * s);
i64 mlib_getfilesize(void * handlex);
void mlib_readrandom(void * handlex,byte * mem,i64 offset,i64 size);
i64 mlib_writerandom(void * handlex,byte * mem,i64 offset,i64 size);
i64 mlib_setfilepos(void * file,i64 offset);
i64 mlib_getfilepos(void * file);
byte * mlib_readfile(byte * filename);
i64 mlib_writefile(byte * filename,byte * data,i64 size);
i64 mlib_checkfile(byte * file);
void mlib_readlinen(void * handlex,byte * buffer,i64 size);
void mlib_iconvlcn(byte * s,i64 n);
void mlib_iconvucn(byte * s,i64 n);
void mlib_convlcstring(byte * s);
void mlib_convucstring(byte * s);
byte * mlib_changeext(byte * s,byte * newext);
byte * mlib_extractext(byte * s,i64 period);
byte * mlib_extractpath(byte * s);
byte * mlib_extractfile(byte * s);
byte * mlib_extractbasefile(byte * s);
byte * mlib_addext(byte * s,byte * newext);
void * mlib_alloctable(i64 n,i64 size);
void * mlib_zalloctable(i64 n,i64 size);
void mlib_checkfreelists(byte * s);
void * mlib_pcm_alloc32(void);
void mlib_pcm_free32(void * p);
void mlib_outbyte(void * f,i64 x);
void mlib_outword16(void * f,u64 x);
void mlib_outword(void * f,u64 x);
void mlib_outword64(void * f,u64 x);
i64 mlib_myeof(void * f);
void * mlib_pcm_smallallocz(i64 n);
void * mlib_pcm_smallalloc(i64 n);
void mlib_strbuffer_add(struct mlib_strbuffer * dest,byte * s,i64 n);
void mlib_gs_init(struct mlib_strbuffer * dest);
void mlib_gs_free(struct mlib_strbuffer * dest);
void mlib_gs_str(struct mlib_strbuffer * dest,byte * s);
void mlib_gs_char(struct mlib_strbuffer * dest,i64 c);
void mlib_gs_strn(struct mlib_strbuffer * dest,byte * s,i64 length);
void mlib_gs_strvar(struct mlib_strbuffer * dest,struct mlib_strbuffer * s);
void mlib_gs_strint(struct mlib_strbuffer * dest,i64 a);
void mlib_gs_strln(struct mlib_strbuffer * dest,byte * s);
void mlib_gs_strsp(struct mlib_strbuffer * dest,byte * s);
void mlib_gs_line(struct mlib_strbuffer * dest);
i64 mlib_gs_getcol(struct mlib_strbuffer * dest);
void mlib_gs_leftstr(struct mlib_strbuffer * dest,byte * s,i64 w,i64 padch);
void mlib_gs_leftint(struct mlib_strbuffer * dest,i64 a,i64 w,i64 padch);
void mlib_gs_padto(struct mlib_strbuffer * dest,i64 col,i64 ch);
void mlib_gs_println(struct mlib_strbuffer * dest,void * f);
i64 mlib_nextcmdparam(i64 * paramno,byte * * name,byte * * value,byte * defext);
static i64 mlib_readnextfileitem(byte * * fileptr,byte * * item);
void mlib_ipadstr(byte * s,i64 width,byte * padchar);
byte * mlib_padstr(byte * s,i64 width,byte * padchar);
byte * mlib_chr(i64 c);
i64 mlib_cmpstring(byte * s,byte * t);
i64 mlib_cmpstringn(byte * s,byte * t,i64 n);
i64 mlib_eqstring(byte * s,byte * t);
i64 mlib_cmpbytes(void * p,void * q,i64 n);
i64 mlib_eqbytes(void * p,void * q,i64 n);
void mlib_mseed(u64 a,u64 b);
u64 mlib_mrandom(void);
i64 mlib_mrandomp(void);
i64 mlib_mrandomint(i64 n);
i64 mlib_mrandomrange(i64 a,i64 b);
double mlib_mrandomreal(void);
double mlib_mrandomreal1(void);
byte * mlib_checkpackfile(void);
void osnos_os_init(void);
i64 osnos_os_execwait(byte * cmdline,i64 newconsole,byte * workdir);
i64 osnos_os_execcmd(byte * cmdline,i64 newconsole);
i64 osnos_os_getch(void);
i64 osnos_os_kbhit(void);
void osnos_os_flushkeys(void);
void * osnos_os_getconsolein(void);
void * osnos_os_getconsoleout(void);
void * osnos_os_proginstance(void);
u64 osnos_os_getdllinst(byte * name);
void (*osnos_os_getdllprocaddr(i32 hinst,byte * name))(void);
void osnos_os_initwindows(void);
i64 osnos_os_getchx(void);
byte * osnos_os_getos(void);
i64 osnos_os_getoscode(void);
i64 osnos_os_iswindows(void);
i64 osnos_os_shellexec(byte * opc,byte * file);
void osnos_os_sleep(i64 a);
void * osnos_os_getstdin(void);
void * osnos_os_getstdout(void);
byte * osnos_os_gethostname(void);
i64 osnos_os_gethostsize(void);
byte * osnos_os_getmpath(void);
void osnos_os_exitprocess(i64 x);
i64 osnos_os_gettimestamp(void);
i64 osnos_os_gettickcount(void);
i64 osnos_os_clock(void);
i64 osnos_os_getclockspersec(void);
void osnos_os_setmesshandler(void * addr);
i64 osnos_os_filelastwritetime(byte * filename);
i64 osnos_os_hpcounter(void);
i64 osnos_os_hpfrequency(void);
void osnos_os_getsystime(void * tm);
void osnos_os_peek(void);
static void cc_support_stopcompiler(byte * filename,i64 lineno);
void cc_support_mcerror(byte * mess);
void cc_support_serror(byte * mess);
void cc_support_serror_gen(byte * mess);
void cc_support_serror_ss(byte * mess,byte * a,byte * b);
void cc_support_serror_s(byte * mess,byte * a);
void cc_support_terror_gen(byte * mess);
void cc_support_terror(byte * mess);
void cc_support_terror_s(byte * mess,byte * a);
void cc_support_terror_ss(byte * mess,byte * a,byte * b);
void cc_support_gerror_gen(byte * mess,struct cc_decls_unitrec * p);
void cc_support_gerror(byte * mess,struct cc_decls_unitrec * p);
void cc_support_gerror_s(byte * mess,byte * s,struct cc_decls_unitrec * p);
void cc_support_nxerror(byte * mess,struct cc_decls_unitrec * p);
i64 cc_support_testelem(byte (*p)[],i64 n);
void cc_support_setelem(byte (*p)[],i64 n);
i64 cc_support_nextpoweroftwo(i64 x);
void cc_support_loaderror(byte * mess,byte * mess2);
i64 cc_support_loadfromstdin(byte * file);
i64 cc_support_loadsourcefile(byte * file,byte * shortfile);
static byte * cc_support_splicelines(byte * s);
i64 cc_support_loadbuiltin(byte * shortfile,byte * hdrtext);
static void cc_support_gs_copytostr(struct mlib_strbuffer * source,byte * s);
void cc_support_gs_additem(struct mlib_strbuffer * dest,byte * s);
static i64 cc_support_isalphanum(i64 c);
static void cc_support_showmacrolineno(void);
void cc_lex_lex_preprocess_only(byte * infile,i64 showtokens,i64 nn,i64 toconsole);
void cc_lex_lexreadtoken(void);
static void cc_lex_readrealnumber(byte * pstart,byte * intstart,i64 intlen,i64 base);
static i64 cc_lex_readexponent(i64 * badexpon);
static void cc_lex_lxerror(byte * mess);
void cc_lex_printsymbol(struct cc_decls_tokenrec * lp);
void cc_lex_lexsetup(void);
void cc_lex_printstrn(byte * s,i64 length,void * f);
static byte * cc_lex_scannumber(i64 base);
static i64 cc_lex_lookup(void);
u64 cc_lex_gethashvalue(byte * s,i64 length);
static void cc_lex_inithashtable(void);
static void cc_lex_fillhashtable(void);
static i64 cc_lex_dolexdirective(void);
static i64 cc_lex_getlexdirective(void);
void cc_lex_startlex(byte * caption,i64 fileno);
void cc_lex_endlex(void);
void cc_lex_ps(byte * caption);
void cc_lex_psnext(byte * caption);
i64 cc_lex_gethashtablesize(void);
static void cc_lex_readlinecomment(void);
static void cc_lex_readblockcomment(void);
static void cc_lex_readhex(byte * pstart);
static void cc_lex_readbinary(byte * pstart);
static void cc_lex_readoctal(byte * pstart);
static void cc_lex_readdecimal(byte * pstart);
static i64 cc_lex_checknumbersuffix(void);
static void cc_lex_stacksourcefile(byte * file,i64 syshdr);
static void cc_lex_unstacksourcefile(void);
static i64 cc_lex_getsourcefile(byte * file,i64 syshdr);
void cc_lex_lex(void);
static void cc_lex_shownumberstr(struct cc_decls_tokenrec * l,void * f);
struct cc_decls_strec * cc_lex_addnamestr(byte * name);
static void cc_lex_lxreadstring(i64 termchar,i64 fwide);
static void cc_lex_addlisttoken(struct cc_decls_tokenrec * * ulist,struct cc_decls_tokenrec * * ulistx,struct cc_decls_tokenrec * p);
static void cc_lex_addlisttoken_copy(struct cc_decls_tokenrec * * ulist,struct cc_decls_tokenrec * * ulistx,struct cc_decls_tokenrec * q);
static void cc_lex_addlist_nextlx(struct cc_decls_tokenrec * * ulist,struct cc_decls_tokenrec * * ulistx);
static void cc_lex_addlisttoken_seq(struct cc_decls_tokenrec * * ulist,struct cc_decls_tokenrec * * ulistx,struct cc_decls_tokenrec * seq);
static void cc_lex_addlistmparam(struct cc_decls_mparamrec * * ulist,struct cc_decls_mparamrec * * ulistx,struct cc_decls_mparamrec * p);
static void cc_lex_dodefine(void);
static void cc_lex_readalphanumeric(byte * pstart);
static i64 cc_lex_inmacrostack(struct cc_decls_strec * d,struct cc_decls_tokenrec * macrostack);
static void cc_lex_showtokens(byte * caption,struct cc_decls_tokenrec * tk);
static void cc_lex_lexa(struct cc_decls_tokenrec * * tk);
static void cc_lex_lexm(void);
static i64 cc_lex_peeklb(void);
static i64 cc_lex_peektk(struct cc_decls_tokenrec * tk);
static struct cc_decls_tokenrec * cc_lex_expandobjmacro(struct cc_decls_strec * m,struct cc_decls_tokenrec * macrostack,struct cc_decls_tokenrec * * tksource,i64 frombaselevel);
static struct cc_decls_tokenrec * cc_lex_expandfnmacro(struct cc_decls_strec * m,struct cc_decls_tokenrec * macrostack,struct cc_decls_tokenrec * * tksource,i64 frombaselevel,i64 * endlineno);
static struct cc_decls_tokenrec * cc_lex_scantokenseq(struct cc_decls_tokenrec * tk,struct cc_decls_tokenrec * macrostack,i64 * expanded);
static i64 cc_lex_readmacrocall(struct cc_decls_strec * d,struct cc_decls_tokenrec * (*args)[],struct cc_decls_tokenrec * * tksource);
static struct cc_decls_tokenrec * cc_lex_substituteargs(struct cc_decls_strec * m,struct cc_decls_tokenrec * (*args)[],struct cc_decls_tokenrec * (*expargs)[],i64 nargs,struct cc_decls_tokenrec * macrostack);
static byte * cc_lex_strtoken(struct cc_decls_tokenrec * lp,i64 * length);
static byte * cc_lex_strstring(byte * s,i64 length,i64 * newlength,i64 quotechar);
void cc_lex_emittoken(struct cc_decls_tokenrec * lp,struct mlib_strbuffer * dest,i64 forcespace);
void cc_lex_showtoken(struct cc_decls_tokenrec * lp);
static void cc_lex_stringify(struct cc_decls_tokenrec * seq,struct cc_decls_tokenrec * dest);
static void cc_lex_pastetokens(struct cc_decls_tokenrec * tk,struct cc_decls_tokenrec * * tknext);
static i64 cc_lex_getifexpr(void);
static i64 cc_lex_evalcondexpr(i64 * sx);
static i64 cc_lex_evalorexpr(i64 * sx);
static i64 cc_lex_evalandexpr(i64 * sx);
static i64 cc_lex_evaliorexpr(i64 * sx);
static i64 cc_lex_evalixorexpr(i64 * sx);
static i64 cc_lex_evaliandexpr(i64 * sx);
static i64 cc_lex_evaleqexpr(i64 * sx);
static i64 cc_lex_evalcmpexpr(i64 * sx);
static i64 cc_lex_evalshiftexpr(i64 * sx);
static i64 cc_lex_evaladdexpr(i64 * sx);
static i64 cc_lex_evalmulexpr(i64 * sx);
static i64 cc_lex_evalunaryexpr(i64 * sx);
static i64 cc_lex_evalterm(i64 * sx);
static i64 cc_lex_getifdef(void);
static i64 cc_lex_skipcode(void);
static void cc_lex_freetokens(struct cc_decls_tokenrec * tk);
void cc_lex_fastreadtoken(void);
static struct cc_decls_tokenrec * cc_lex_alloctoken(void);
static struct cc_decls_tokenrec * cc_lex_alloctokenz(void);
static void cc_lex_expandpredefmacro(i64 pdmcode,struct cc_decls_tokenrec * tk,i64 lineno);
static void cc_lex_dopragmadir(void);
static i64 cc_lex_needspace(i64 a,i64 b);
void cc_lex_dospecialinclude(void);
static void cc_lex_addautomodule(byte * headername,i64 fileno);
static void cc_lex_setnumberoffset(i64 offset);
static void cc_lex_setfileno(i64 fileno);
static void cc_lex_setfilenox(struct cc_decls_tokenrec * tk,i64 fileno);
static i64 cc_lex_getfileno(void);
static i64 cc_lex_getfilenox(struct cc_decls_tokenrec * tk);
static i64 cc_lex_getnumberoffsetx(struct cc_decls_tokenrec * tk);
void cc_lex_freehashtable(void);
static void cc_lex_freestentry(struct cc_decls_strec * d);
static void cc_lex_regenlookup(struct cc_decls_strec * d);
static void cc_lex_printhashtable(byte * caption);
static void cc_lex_newhashtable(void);
static void cc_lex_old_readrealnumber(byte * pstart,byte * intstart,i64 intlen,i64 base);
byte * cc_headers_findheader(byte * name);
void cc_headers_writeheaders(void);
void cc_headers_checkbcclib(void);
byte * cc_headers_getbcclib(void);
i64 cc_headers_isheaderfile(byte * file);
static struct cc_decls_strec * cc_lib_newstrec(void);
void cc_lib_initcclib(void);
void cc_lib_printst(void * f,struct cc_decls_strec * p,i64 level);
static void cc_lib_printstrec(void * f,struct cc_decls_strec * p,i64 level);
void cc_lib_printstflat(void * f);
struct cc_decls_unitrec * cc_lib_createname(struct cc_decls_strec * p);
struct cc_decls_unitrec * cc_lib_createunit0(i64 tag);
struct cc_decls_unitrec * cc_lib_createunit1(i64 tag,struct cc_decls_unitrec * p);
struct cc_decls_unitrec * cc_lib_createunit2(i64 tag,struct cc_decls_unitrec * p,struct cc_decls_unitrec * q);
struct cc_decls_unitrec * cc_lib_createunit3(i64 tag,struct cc_decls_unitrec * p,struct cc_decls_unitrec * q,struct cc_decls_unitrec * r);
struct cc_decls_unitrec * cc_lib_createconstunit(u64 a,i64 t);
struct cc_decls_unitrec * cc_lib_createstringconstunit(byte * s,i64 length);
struct cc_decls_unitrec * cc_lib_createwstringconstunit(u16 * s,i64 length);
i64 cc_lib_getoptocode(i64 opc);
i64 cc_lib_getconstvalue(struct cc_decls_unitrec * p,i64 id);
byte * cc_lib_nextautotype(void);
i64 cc_lib_createconstmode(i64 m);
i64 cc_lib_createrefmode(i64 m);
i64 cc_lib_createprocmode(i64 m,struct cc_decls_paramrec * pm);
i64 cc_lib_createarraymode(i64 m,i64 length);
i64 cc_lib_createenummode(struct cc_decls_strec * e);
i64 cc_lib_createstructmode(struct cc_decls_strec * s,i64 smode);
void cc_lib_setnameptr(struct cc_decls_unitrec * p);
void cc_lib_printcode_all(void * f,byte * caption);
void cc_lib_printcode(void * f,byte * caption,i64 n);
void cc_lib_printunit(void * dev,struct cc_decls_unitrec * p,i64 level,byte * prefix);
static void cc_lib_printunitlist(void * dev,struct cc_decls_unitrec * p,i64 level,byte * prefix);
static byte * cc_lib_getprefix(i64 level,byte * prefix,struct cc_decls_unitrec * p);
byte * cc_lib_getdottedname(struct cc_decls_strec * p);
static byte * cc_lib_getlineinfok(void);
struct cc_decls_strec * cc_lib_getautofieldname(void);
void cc_lib_convertstring(byte * s,byte * t,i64 length);
struct mlib_strbuffer * cc_lib_strexpr(struct cc_decls_unitrec * p);
static void cc_lib_jeval(struct mlib_strbuffer * dest,struct cc_decls_unitrec * p);
byte * cc_lib_getopcjname(i64 opc);
byte * cc_lib_strmode(i64 m,i64 expand);
byte * cc_lib_strmode2(i64 m,i64 expand);
void cc_lib_istrmode(i64 m,i64 expand,byte * dest);
i64 cc_lib_countunits(struct cc_decls_unitrec * p);
static void cc_lib_purgesymbol(struct cc_decls_strec * p,struct cc_decls_strec * prev,i64 del);
void cc_lib_purgesymbollist(struct cc_decls_strec * p,i64 ismodule,i64 del);
void cc_lib_purgeprocs(struct cc_decls_strec * p,i64 del);
void cc_lib_purgeproc(struct cc_decls_strec * p,i64 del);
void cc_lib_printmodelist(void * f);
byte * cc_lib_typename(i64 m);
struct cc_decls_unitrec * cc_lib_allocunitrec(void);
static i64 cc_lib_copymode(i64 m);
static i64 cc_lib_createnewmode(i64 m);
void cc_lib_addlistunit(struct cc_decls_unitrec * * ulist,struct cc_decls_unitrec * * ulistx,struct cc_decls_unitrec * p);
void cc_lib_addlistdef(struct cc_decls_strec * * ulist,struct cc_decls_strec * * ulistx,struct cc_decls_strec * p);
void cc_lib_addlistparam(struct cc_decls_paramrec * * ulist,struct cc_decls_paramrec * * ulistx,struct cc_decls_paramrec * p);
void cc_lib_checksymbol(i64 symbol);
void cc_lib_skipsymbol(i64 symbol);
void cc_lib_inittypetables(void);
struct cc_decls_strec * cc_lib_createdupldef(struct cc_decls_strec * owner,struct cc_decls_strec * symptr,i64 id);
struct cc_decls_strec * cc_lib_createnewmoduledef(struct cc_decls_strec * owner,struct cc_decls_strec * symptr);
struct cc_decls_strec * cc_lib_createnewproc(struct cc_decls_strec * owner,struct cc_decls_strec * symptr);
struct cc_decls_strec * cc_lib_resolvename(struct cc_decls_strec * owner,struct cc_decls_strec * symptr,i64 ns,i64 blockno);
struct cc_decls_strec * cc_lib_checkdupl(struct cc_decls_strec * owner,struct cc_decls_strec * symptr,i64 ns,i64 blockno);
struct cc_decls_strec * cc_lib_checkdupl_inproc(struct cc_decls_strec * owner,struct cc_decls_strec * symptr,i64 ns,i64 blockno);
i64 cc_lib_getalignment(i64 m);
i64 cc_lib_isexported(struct cc_decls_strec * d);
i64 cc_lib_isimported(struct cc_decls_strec * d);
i64 cc_lib_isstructunion(i64 m);
byte * cc_lib_getstname(struct cc_decls_strec * d);
i64 cc_lib_isrealcc(i64 m);
i64 cc_lib_isintcc(i64 m);
static void cc_parse_readmodule(void);
i64 cc_parse_parsemodule(i64 n);
static i64 cc_parse_readdeclspec(struct cc_decls_strec * owner,i64 * linkage);
static i64 cc_parse_istypestarter(void);
static struct cc_decls_unitrec * cc_parse_readexpression(void);
static struct cc_decls_unitrec * cc_parse_readassignexpr(void);
static struct cc_decls_unitrec * cc_parse_readcondexpr(void);
static struct cc_decls_unitrec * cc_parse_readorlexpr(void);
static struct cc_decls_unitrec * cc_parse_readandlexpr(void);
static struct cc_decls_unitrec * cc_parse_readiorexpr(void);
static struct cc_decls_unitrec * cc_parse_readixorexpr(void);
static struct cc_decls_unitrec * cc_parse_readiandexpr(void);
static struct cc_decls_unitrec * cc_parse_readeqexpr(void);
static struct cc_decls_unitrec * cc_parse_readrelexpr(void);
static struct cc_decls_unitrec * cc_parse_readshiftexpr(void);
static struct cc_decls_unitrec * cc_parse_readaddexpr(void);
static struct cc_decls_unitrec * cc_parse_readmulexpr(void);
static struct cc_decls_unitrec * cc_parse_readterm(void);
static struct cc_decls_unitrec * cc_parse_readexprlist(struct cc_decls_unitrec * p);
static struct cc_decls_strec * cc_parse_readmodulevar(struct cc_decls_strec * d,i64 m,i64 linkage);
static struct cc_decls_strec * cc_parse_readframevar(struct cc_decls_strec * d,i64 m,i64 linkage);
static i64 cc_parse_readtype(struct cc_decls_strec * owner,struct cc_decls_strec * * d,i64 m,struct cc_decls_paramrec * * pm);
static void cc_parse_readnamedtype(struct cc_decls_strec * owner,struct cc_decls_strec * * d,i64 (*modtype)[],void * (*modvalue)[],i64 * nmodifiers);
static i64 cc_parse_readconstintexpr(void);
static struct cc_decls_unitrec * cc_parse_readinitexpr(struct cc_decls_strec * owner,i64 m);
static struct cc_decls_unitrec * cc_parse_readinitexpr2(struct cc_decls_strec * owner,i64 m,i64 istop);
static void cc_parse_pushblock(void);
static void cc_parse_popblock(void);
static struct cc_decls_unitrec * cc_parse_readcompoundstmt(i64 params);
static struct cc_decls_unitrec * cc_parse_readblock(i64 ifelse);
static struct cc_decls_unitrec * cc_parse_readstatement(void);
static struct cc_decls_unitrec * cc_parse_readifstmt(void);
static struct cc_decls_unitrec * cc_parse_readforstmt(void);
static struct cc_decls_unitrec * cc_parse_readwhilestmt(void);
static struct cc_decls_unitrec * cc_parse_readdostmt(void);
static struct cc_decls_unitrec * cc_parse_readreturnstmt(void);
static struct cc_decls_unitrec * cc_parse_readgotostmt(void);
static struct cc_decls_unitrec * cc_parse_readswitchstmt(void);
static struct cc_decls_unitrec * cc_parse_readcaselabel(void);
static struct cc_decls_unitrec * cc_parse_readexprstmt(void);
static struct cc_decls_unitrec * cc_parse_readcond(void);
static i64 cc_parse_isusertype(struct cc_decls_strec * owner);
static struct cc_decls_unitrec * cc_parse_readlocaldecl(void);
static struct cc_decls_strec * cc_parse_createtypedef(struct cc_decls_strec * owner,struct cc_decls_strec * symptr,i64 mode);
static struct cc_decls_paramrec * cc_parse_readparams(struct cc_decls_strec * owner);
static i64 cc_parse_readcasttype(struct cc_decls_strec * * d,i64 allowname,struct cc_decls_paramrec * * pm);
static struct cc_decls_strec * cc_parse_readfunction(struct cc_decls_strec * d,i64 m,i64 linkage,struct cc_decls_paramrec * pm,i64 * wasdef);
static void cc_parse_readfunctionbody(struct cc_decls_strec * f);
static struct cc_decls_unitrec * cc_parse_createnegop(struct cc_decls_unitrec * p);
static struct cc_decls_unitrec * cc_parse_createabsop(struct cc_decls_unitrec * p);
static struct cc_decls_unitrec * cc_parse_createsqrtop(struct cc_decls_unitrec * p);
static struct cc_decls_unitrec * cc_parse_createinotop(struct cc_decls_unitrec * p);
static struct cc_decls_unitrec * cc_parse_createptrop(struct cc_decls_unitrec * p);
static struct cc_decls_unitrec * cc_parse_createincrop(i64 opc,struct cc_decls_unitrec * p);
static struct cc_decls_unitrec * cc_parse_createlengthofop(struct cc_decls_unitrec * p);
static struct cc_decls_unitrec * cc_parse_createaddrofop(struct cc_decls_unitrec * p);
static struct cc_decls_unitrec * cc_parse_createaddop(struct cc_decls_unitrec * x,struct cc_decls_unitrec * y);
static struct cc_decls_unitrec * cc_parse_createsubop(struct cc_decls_unitrec * x,struct cc_decls_unitrec * y);
static struct cc_decls_unitrec * cc_parse_createmulop(struct cc_decls_unitrec * x,struct cc_decls_unitrec * y);
static struct cc_decls_unitrec * cc_parse_createdivop(struct cc_decls_unitrec * x,struct cc_decls_unitrec * y);
static struct cc_decls_unitrec * cc_parse_createremop(struct cc_decls_unitrec * x,struct cc_decls_unitrec * y);
static void cc_parse_insertunit(struct cc_decls_unitrec * p,i64 tag);
static struct cc_decls_unitrec * cc_parse_eval_add(i64 opc,struct cc_decls_unitrec * x,struct cc_decls_unitrec * y,i64 t);
static struct cc_decls_unitrec * cc_parse_eval_sub(i64 opc,struct cc_decls_unitrec * x,struct cc_decls_unitrec * y,i64 t);
static struct cc_decls_unitrec * cc_parse_eval_mul(i64 opc,struct cc_decls_unitrec * x,struct cc_decls_unitrec * y,i64 t);
static struct cc_decls_unitrec * cc_parse_eval_div(i64 opc,struct cc_decls_unitrec * x,struct cc_decls_unitrec * y,i64 t);
static struct cc_decls_unitrec * cc_parse_eval_rem(i64 opc,struct cc_decls_unitrec * x,struct cc_decls_unitrec * y,i64 t);
static i64 cc_parse_eval_convert(struct cc_decls_unitrec * p,i64 t,i64 opc);
static void cc_parse_coercecond(struct cc_decls_unitrec * p);
static void cc_parse_coercebasetype(struct cc_decls_unitrec * p);
static void cc_parse_checklvalue(struct cc_decls_unitrec * p);
static struct cc_decls_unitrec * cc_parse_createcall(struct cc_decls_unitrec * p,struct cc_decls_unitrec * q);
static struct cc_decls_unitrec * cc_parse_arraytopointer(struct cc_decls_unitrec * p);
static struct cc_decls_unitrec * cc_parse_createindexop(struct cc_decls_unitrec * p,struct cc_decls_unitrec * q);
static i64 cc_parse_readstructdecl(struct cc_decls_strec * owner);
static i64 cc_parse_checkpointertypes(i64 s,i64 t,i64 hard);
static i64 cc_parse_comparemode(i64 s,i64 t);
static i64 cc_parse_readenumdecl(struct cc_decls_strec * owner);
static void cc_parse_readenumnames(struct cc_decls_strec * owner);
static struct cc_decls_unitrec * cc_parse_createdotop(i64 opc,struct cc_decls_unitrec * p,struct cc_decls_strec * d);
static struct cc_decls_unitrec * cc_parse_mulunit(struct cc_decls_unitrec * p,i64 elemtype);
static struct cc_decls_unitrec * cc_parse_divunit(struct cc_decls_unitrec * p,i64 elemtype);
static struct cc_decls_unitrec * cc_parse_createassignopref(i64 opc,struct cc_decls_unitrec * p,struct cc_decls_unitrec * q);
static void cc_parse_addnewfield(struct cc_decls_fieldrec * * flist,struct cc_decls_strec * d,i64 offset);
static void cc_parse_pushloop(i64 looptype);
static void cc_parse_poploop(void);
static void cc_parse_addcasevalue(i64 value);
static i64 cc_parse_roundoffset(i64 offset,i64 alignment);
static void cc_parse_fixmemopnd(struct cc_decls_unitrec * p);
static struct cc_decls_unitrec * cc_parse_docast(struct cc_decls_unitrec * p,i64 t,i64 hard,i64 inplace);
static struct cc_decls_unitrec * cc_parse_coercemode(struct cc_decls_unitrec * p,i64 t);
static void cc_parse_coercemode_inplace(struct cc_decls_unitrec * p,i64 t);
static void cc_parse_dostaticassert(void);
static struct cc_decls_unitrec * cc_parse_createsizeofop(struct cc_decls_unitrec * p);
static struct cc_decls_unitrec * cc_parse_readgeneric(void);
static void cc_parse_readstructinfosym(void);
static i64 cc_parse_getmemmode(struct cc_decls_unitrec * p);
static struct cc_decls_unitrec * cc_parse_readstrinclude(void);
i64 cc_genmcl_codegen_mcl(i64 n);
static void cc_genmcl_genprocdef(struct cc_decls_strec * p);
static void cc_genmcl_dolabel(struct cc_decls_strec * d);
static void cc_genmcl_dolabel_fn(struct cc_decls_strec * d,i64 dollar);
static void cc_genmcl_dostaticvar(struct cc_decls_strec * d);
static void cc_genmcl_dostaticvar_fn(struct cc_decls_strec * d);
static void cc_genmcl_genprocentry(i64 fbytes,i64 pbytes);
static void cc_genmcl_genidata(struct cc_decls_unitrec * p,i64 doterm,i64 am,i64 offset);
static void cc_genmcl_genmainprelude(void);
void cc_libmcl_mclinit(void);
i64 cc_libmcl_gettargetdata(i64 f64);
void cc_libmcl_initmcdest(void);
void cc_libmcl_genmc(i64 opcode,struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
void cc_libmcl_genmc_cond(i64 opcode,i64 cond,struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
struct cc_libmcl_mclrec * cc_libmcl_lastmc(void);
void cc_libmcl_genmcstr(i64 opcode,byte * s);
static struct cc_libmcl_opndrec * cc_libmcl_newopnd(void);
struct cc_libmcl_opndrec * cc_libmcl_duplopnd(struct cc_libmcl_opndrec * a);
struct cc_libmcl_opndrec * cc_libmcl_genxreg(i64 xreg,i64 size);
struct cc_libmcl_opndrec * cc_libmcl_genindex(i64 areg,i64 ireg,i64 scale,i64 offset,i64 size,i64 labno,struct cc_decls_strec * def);
static void cc_libmcl_writemclblock(struct cc_libmcl_mclrec * m);
struct mlib_strbuffer * cc_libmcl_writemclcode(byte * caption,i64 nmodule);
void cc_libmcl_gencomment(byte * s);
struct cc_libmcl_opndrec * cc_libmcl_genstrimm(byte * s,i64 length);
struct cc_libmcl_opndrec * cc_libmcl_genwstrimm(u16 * s,i64 length);
struct cc_libmcl_opndrec * cc_libmcl_genname(byte * s);
static void cc_libmcl_writemcl(i64 index,struct cc_libmcl_mclrec * mcl);
byte * cc_libmcl_strmcl(struct cc_libmcl_mclrec * mcl);
byte * cc_libmcl_stropnd(struct cc_libmcl_opndrec * a,i64 sizeprefix,i64 debug);
byte * cc_libmcl_strvalue(struct cc_libmcl_opndrec * a);
void cc_libmcl_setsegment(i64 seg,i64 align);
byte * cc_libmcl_getprocname(struct cc_decls_strec * d);
i64 cc_libmcl_widenstr(byte * s,i64 w);
void cc_libmcl_genassem(byte * s);
byte * cc_libmcl_strlabel(i64 n);
struct cc_libmcl_opndrec * cc_libmcl_makeindirect(struct cc_libmcl_opndrec * a,i64 size);
struct cc_libmcl_opndrec * cc_libmcl_applyoffset(struct cc_libmcl_opndrec * a,i64 offset,i64 size);
struct cc_libmcl_opndrec * cc_libmcl_applysize(struct cc_libmcl_opndrec * a,i64 size);
i64 cc_libmcl_isframe(struct cc_decls_strec * d);
void cc_libmcl_genreturn(i64 fbytes,i64 pbytes);
byte * cc_libmcl_getsizeprefix(i64 size,i64 enable);
i64 cc_libmcl_needsizeprefix(i64 opcode,struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
struct cc_libmcl_opndrec * cc_libmcl_changeopndsize(struct cc_libmcl_opndrec * a,i64 size);
struct cc_libmcl_opndrec * cc_libmcl_genint(i64 x,i64 size);
struct cc_libmcl_opndrec * cc_libmcl_genreal(double x,i64 size);
struct cc_libmcl_opndrec * cc_libmcl_genimm(struct cc_decls_unitrec * p,i64 size);
struct cc_libmcl_opndrec * cc_libmcl_genlabel(i64 x,i64 isglobal);
struct cc_libmcl_opndrec * cc_libmcl_genmem_u(struct cc_decls_unitrec * p,i64 size);
struct cc_libmcl_opndrec * cc_libmcl_genmem_d(struct cc_decls_strec * d,i64 size);
struct cc_libmcl_opndrec * cc_libmcl_genmemaddr_u(struct cc_decls_unitrec * p);
struct cc_libmcl_opndrec * cc_libmcl_genmemaddr_d(struct cc_decls_strec * d);
struct cc_libmcl_opndrec * cc_libmcl_genreg(i64 reg,i64 size);
struct cc_libmcl_opndrec * cc_libmcl_genireg(i64 reg,i64 size);
i64 cc_libmcl_getopndsize_u(struct cc_decls_unitrec * p);
i64 cc_libmcl_getopndsize_d(struct cc_decls_strec * d);
i64 cc_libmcl_getmclcond(i64 opc,i64 m);
byte * cc_libmcl_getfullname(struct cc_decls_strec * d);
i64 cc_libmcl_roundsizetg(i64 size);
i64 cc_libmcl_iscallbackfn(struct cc_decls_strec * p);
byte * cc_libmcl_getregname(i64 reg,i64 size);
byte * cc_libmcl_getblockname(i64 reg,i64 size);
byte * cc_libmcl_fgetregname(i64 reg,i64 size);
i64 cc_libmcl_issimple(struct cc_decls_unitrec * p);
static i64 cc_libmcl_issimple0(struct cc_decls_unitrec * p,i64 level);
i64 cc_libmcl_issimplepm(struct cc_decls_unitrec * p);
i64 cc_libmcl_getaregs(struct cc_libmcl_opndrec * ax);
i64 cc_libmcl_getlregs(struct cc_libmcl_opndrec * ax);
i64 cc_libmcl_isintconst(struct cc_decls_unitrec * p);
i64 cc_libmcl__getnextreg(struct cc_libmcl_opndrec * ax,i64 reg);
i64 cc_libmcl_getnextreg(struct cc_libmcl_opndrec * ax,i64 r);
i64 cc_libmcl_ispoweroftwo(i64 x);
static i64 cc_libmcl_sameoperand(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static struct cc_libmcl_mclrec * cc_libmcl_findlastmcl(void);
void cc_libmcl_genmsource(i64 lineno);
i64 cc_libmcl_roundto(i64 a,i64 n);
void cc_libmcl_pushstack(i64 n);
void cc_libmcl_pushstackfp(i64 n);
void cc_libmcl_popstack(i64 n);
i64 cc_libmcl_definelabel(void);
i64 cc_libmcl_createfwdlabel(void);
void cc_libmcl_definefwdlabel(i64 lab);
void cc_libmcl_genjumpl(i64 lab);
void cc_libmcl_setalign(i64 align);
i64 cc_libmcl_gettypecat(struct cc_decls_unitrec * a);
void cc_libmcl_doblockcall(i64 size);
struct cc_libmcl_opndrec * cc_libmcl_getblockreg(i64 size);
void cc_libmcl_copyretvalue(i64 size);
void cc_libmcl_enterproc(byte * name);
void cc_libmcl_leaveproc(byte * name);
void cc_blockmcl_do_stmt(struct cc_decls_unitrec * p);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_expr(struct cc_decls_unitrec * p,i64 reg,i64 am);
static void cc_blockmcl_loneexpr(struct cc_decls_unitrec * p);
static void cc_blockmcl_do_assign(struct cc_decls_unitrec * a,struct cc_decls_unitrec * b);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_assign(struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg);
static i64 cc_blockmcl_saveexpr(struct cc_decls_unitrec * a,i64 reg);
static i64 cc_blockmcl_fsaveexpr(struct cc_decls_unitrec * a,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_restoreexpr(i64 tx,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_frestoreexpr(i64 tx,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_getlvalueopnd(struct cc_decls_unitrec * a,i64 reg);
static void cc_blockmcl_storeopnd(struct cc_libmcl_opndrec * ax,struct cc_libmcl_opndrec * bx);
static void cc_blockmcl_pushexpr(struct cc_decls_unitrec * a,i64 reg);
static void cc_blockmcl_fpushexpr(struct cc_decls_unitrec * a,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_const(struct cc_decls_unitrec * p,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_constant(struct cc_decls_strec * d,i64 reg);
static void cc_blockmcl_do_labeldef(struct cc_decls_strec * d);
static void cc_blockmcl_do_goto(struct cc_decls_strec * d);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_add(struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_fadd(i64 opc,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_loadexpr(struct cc_decls_unitrec * a,i64 reg,i64 isassign);
static struct cc_libmcl_opndrec * cc_blockmcl_evalexpr(struct cc_decls_unitrec * p,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_evaladdr(struct cc_decls_unitrec * p,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_evalptr(struct cc_decls_unitrec * p,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_floadexpr(struct cc_decls_unitrec * a,i64 xreg);
static struct cc_libmcl_opndrec * cc_blockmcl_fevalexpr(struct cc_decls_unitrec * p,i64 xreg);
static void cc_blockmcl_do_if(struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,struct cc_decls_unitrec * c);
static void cc_blockmcl_genjumpcond(i64 opc,struct cc_decls_unitrec * p,i64 lab,i64 reg);
static void cc_blockmcl_gcomparejump(i64 jumpopc,struct cc_decls_unitrec * p,struct cc_decls_unitrec * lhs,struct cc_decls_unitrec * rhs,i64 lab,i64 reg);
static i64 cc_blockmcl_reversecond(i64 op);
static void cc_blockmcl_do_preincr(struct cc_decls_unitrec * a,i64 addop,i64 incrop);
static i64 cc_blockmcl_reversemclcond(i64 cond);
static void cc_blockmcl_do_while(struct cc_decls_unitrec * pcond,struct cc_decls_unitrec * pbody);
static void cc_blockmcl_do_while1(struct cc_decls_unitrec * pbody);
static void cc_blockmcl_stacklooplabels(i64 a,i64 b);
static void cc_blockmcl_do_dowhile(struct cc_decls_unitrec * pbody,struct cc_decls_unitrec * pcond);
static void cc_blockmcl_do_for(struct cc_decls_unitrec * pinit,struct cc_decls_unitrec * pbody);
static i64 cc_blockmcl_pushffparams(struct cc_decls_unitrec * p,i64 variadic);
static void cc_blockmcl_pushoneparam(struct cc_decls_unitrec * q,i64 variadic);
static void cc_blockmcl_pushfloatparam(struct cc_decls_unitrec * q);
static void cc_blockmcl_loadfloatparam(struct cc_decls_unitrec * q,i64 regoffset,i64 iscomplex);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_call(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg);
static void cc_blockmcl_do_return(struct cc_decls_unitrec * a);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_sub(struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_mul(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_div(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_shl(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_iand(i64 opc,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_preincrx(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_postincrx(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_makeindexopnd(struct cc_decls_unitrec * a,struct cc_decls_unitrec * index,i64 scale,i64 size,i64 offset,i64 reg);
static void cc_blockmcl_mulreg(i64 reg,i64 x);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_ptr(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,i64 reg,i64 am);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_addptr(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg,i64 am);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_subptr(struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg,i64 am);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_convert(struct cc_decls_unitrec * a,i64 t,i64 opc,i64 reg);
static void cc_blockmcl_do_decl(struct cc_decls_strec * d);
static struct cc_libmcl_opndrec * cc_blockmcl_do_assignblock(struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 regx);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_widen(struct cc_decls_unitrec * a,i64 m,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_neg(struct cc_decls_unitrec * a,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_fneg(struct cc_decls_unitrec * a,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_inot(struct cc_decls_unitrec * a,i64 reg);
static void cc_blockmcl_do_switch(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_rem(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_ifx(struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,struct cc_decls_unitrec * c,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_addto(i64 opc,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 regx);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_faddto(i64 opc,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 regx);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_eq(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg);
static void cc_blockmcl_do_exprlist(struct cc_decls_unitrec * a);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_exprlist(struct cc_decls_unitrec * a,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_shlto(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 regx);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_multo(struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 regx);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_notl(struct cc_decls_unitrec * a,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_istruel(struct cc_decls_unitrec * a,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_andorl(struct cc_decls_unitrec * p,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_sqrt(struct cc_decls_unitrec * a,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_scale(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_divto(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 regx);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_name(struct cc_decls_unitrec * p,i64 reg,i64 am);
static void cc_blockmcl_divreg(i64 reg,i64 x);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_addrof(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,i64 reg,i64 am);
static struct cc_libmcl_opndrec * cc_blockmcl_dx_dot(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg,i64 am);
static void cc_blockmcl_loadviaptr(struct cc_libmcl_opndrec * w,struct cc_libmcl_opndrec * ptropnd,i64 sgned);
i64 cc_genasm_codegen_writeasm(i64 moduleno,byte * outfile);
void cc_genasm_inita64(void);
void cc_genasm_terma64(void);
static void cc_genasm_writetoasm(struct cc_libmcl_mclrec * m);
void cc_genasm_mcltoa64(struct cc_libmcl_mclrec * m);
static void cc_genasm_passthru(i64 opc);
static void cc_genasm_convmcl(void);
static void cc_genasm_do_changeop(i64 opc);
static void cc_genasm_do_comment(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_blank(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_end(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_label(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_labelname(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_mov(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_push(struct cc_libmcl_opndrec * a);
static void cc_genasm_do_pop(struct cc_libmcl_opndrec * a);
static void cc_genasm_do_lea(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_cmovcc(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b,i64 cond);
static void cc_genasm_do_fmov(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_iwiden(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_uwiden(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_inarrow(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_unarrow(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_call(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_ret(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_retn(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_jmp(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_jmpcc(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b,i64 cond);
static void cc_genasm_do_exch(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_add(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_sub(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_imul(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_idiv(struct cc_libmcl_opndrec * a);
static void cc_genasm_do_irem(struct cc_libmcl_opndrec * a);
static void cc_genasm_do_urem(struct cc_libmcl_opndrec * a);
static void cc_genasm_do_and(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_or(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_xor(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_test(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_cmp(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_shl(i64 opc,struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_neg(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_not(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_inc(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_dec(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_setcc(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b,i64 cond);
static void cc_genasm_do_fneg(struct cc_libmcl_opndrec * a);
static void cc_genasm_do_fabs(struct cc_libmcl_opndrec * a);
static void cc_genasm_do_fsqrt(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_ufix(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_ifix(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_ufloat(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_ifloat(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_db(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_dw(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_dd(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_dq(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_align(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_segment(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_do_assem(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b);
static void cc_genasm_strmclasm(struct cc_libmcl_mclrec * mcl);
void cc_genasm_stropndx(struct cc_libmcl_opndrec * a,i64 sizeprefix,i64 debug);
static void cc_genasm_strmclx(struct cc_libmcl_mclrec * mcl);
static byte * cc_genasm_fgetregnamex(i64 reg);
byte * cc_genasm_getstringname(i64 n);
byte * cc_genasm_getwstringname(i64 n);
byte * cc_genasm_getrealname(i64 n);
byte * cc_genasm_getsrealname(i64 n);
byte * cc_genasm_getdintname(i64 n);
i64 cc_genasm_getstringindex(byte * s,i64 length);
i64 cc_genasm_getwstringindex(u16 * s,i64 length);
static i64 cc_genasm_getrealindex(double x);
static i64 cc_genasm_getdintindex(i64 x);
static void cc_genasm_strvaluex(struct cc_libmcl_opndrec * a);
static void cc_genasm_convertimm(struct cc_libmcl_opndrec * a,i64 sx);
static void cc_genasm_genstringtable(void);
static void cc_genasm_genwstringtable(void);
static void cc_genasm_do_defstr(byte * s,i64 length);
static void cc_genasm_do_defwstr(u16 * s,i64 length);
static void cc_genasm_genrealtable(void);
static void cc_genasm_gendinttable(void);
static void cc_genasm_writefabs(void);
static void cc_genasm_domclseq(struct cc_libmcl_mclrec * m);
static void cc_genasm_asmstr(byte * s);
static void cc_genasm_asmstrln(byte * s);
static void cc_genasm_asmline(void);
static void cc_genasm_asmln(void);
static void cc_genasm_asmint(i64 a);
static void cc_genasm_asmchar(i64 c);
static void cc_genasm_asmterm(void);
static void cc_genasm_initasmline(void);
static byte * cc_genasm_getregnamex(i64 reg,i64 size);
static void cc_genasm_genstring(byte * s,i64 length);
static void cc_genasm_genwstring(u16 * s,i64 length);
static void cc_genasm_extendrealtable(void);
static void cc_genasm_extenddinttable(void);
static void cc_genasm_extendstringtable(void);
void cc_export_writemheader(byte * infile);
static void cc_export_showmacroseq(struct cc_decls_tokenrec * tk);
static void cc_export_mmstr(byte * s);
static void cc_export_mmleftstr(byte * s,i64 n);
static void cc_export_mmstrln(byte * s);
static void cc_export_mmint(i64 a);
static void cc_export_mmline(void);
static void cc_export_writefunction(struct cc_decls_strec * d);
static void cc_export_mmmode(i64 m,i64 expand);
static void cc_export_writerecord(i64 m,i64 rectype,i64 level);
static void cc_export_writefnptr(i64 m);
static byte * cc_export_fixname(byte * name);
i64 cc_assembler_assembler(byte * outputfile,byte * (*asmfiles)[],byte * (*dllfiles)[],i64 nasmfiles,i64 ndllfiles,i64 fobj,i64 fcaption,byte * (*assemsources)[],byte * entrypointname);
static void cc_assembler_loadsourcefiles(byte * (*assemsources)[]);
static void cc_assembler_parsemodules(void);
static void cc_assembler_fixopnd(struct ax_decls_opndrec * a);
static void cc_assembler_initall(void);
static void cc_assembler_loaderror(byte * mess);
static void cc_assembler_loaderror_s(byte * mess,byte * s);
static void cc_assembler_addmodule(byte * name);
static void cc_assembler_addsearchlib(byte * name);
static struct ax_decls_strec * cc_assembler_getemptyst(struct ax_decls_strec * d);
static struct ax_decls_strec * cc_assembler_findduplname(struct ax_decls_strec * d);
static void cc_assembler_adddupl(struct ax_decls_strec * d);
static void cc_assembler_scanglobals(void);
static void cc_assembler_resethashtable(void);
void ax_lex_lex(void);
void ax_lex_initlex(void);
static void ax_lex_readreal(byte (*s)[],i64 slen,i64 intlen,i64 exponseen);
static void ax_lex_readnumber(i64 c);
static void ax_lex_readbinary(void);
static void ax_lex_readhex(void);
void ax_lex_ps(byte * caption);
void ax_lex_printsymbol(void * dev);
static void ax_lex_clearhashtable(void);
static void ax_lex_inithashtable(void);
static void ax_lex_addreservedword(byte * name,i64 symbol,i64 subcode);
void ax_lex_printhashtable(void * devx,byte * caption);
static i64 ax_lex_lookuplex(byte * name,i64 length);
void ax_lex_initsourcefile(byte * source);
struct ax_decls_strec * ax_lex_addnamestr(byte * name);
void ax_lex_lxerror(byte * m);
static i64 ax_lex_gethashvalue(byte * s);
void ax_lex_skiptoeol(void);
static byte * ax_lex_makestring(byte * p,i64 length);
void ax_parse_readmodule(i64 moduleno);
void ax_parse_checkundefined(void);
static void ax_parse_checksymbol(i64 symbol);
static void ax_parse_readinstr(void);
static void ax_parse_readcondinstr(i64 opc);
static struct ax_decls_opndrec * ax_parse_readoperand(void);
static struct ax_decls_opndrec * ax_parse_readexpression(void);
static void ax_parse_readterm(void);
static void ax_parse_readreg(i64 * reg,i64 * regsize,i64 * scale);
static struct ax_decls_opndrec * ax_parse_readaddrmode(i64 size);
void ax_lib_initlib(void);
void ax_lib_genmc(i64 opcode,struct ax_decls_opndrec * a,struct ax_decls_opndrec * b);
void ax_lib_genmcstr(i64 opcode,byte * s);
static struct ax_decls_opndrec * ax_lib_newopnd(i64 mode);
struct ax_decls_opndrec * ax_lib_genxreg(i64 xreg);
struct ax_decls_opndrec * ax_lib_genindex(i64 areg,i64 ireg,i64 scale,struct ax_decls_opndrec * x,i64 size,i64 addrsize);
struct mlib_strbuffer * ax_lib_writemclblock(void);
void ax_lib_gencomment(byte * s);
struct ax_decls_opndrec * ax_lib_genstrimm(byte * s);
static byte * ax_lib_getsizetag(i64 size);
static void ax_lib_writemcl(i64 index,struct ax_lib_mclrec * mcl);
byte * ax_lib_strmcl(struct ax_lib_mclrec * mcl);
byte * ax_lib_stropnd(struct ax_decls_opndrec * a,i64 sizeprefix);
static byte * ax_lib_strdef(struct ax_decls_strec * def);
void ax_lib_setsegment(i64 seg);
static byte * ax_lib_getsizeprefix(i64 size,i64 enable);
static i64 ax_lib_needsizeprefix(i64 opcode,struct ax_decls_opndrec * a,struct ax_decls_opndrec * b);
struct ax_decls_opndrec * ax_lib_genimm_expr(struct ax_decls_strec * d,i64 value,i64 t,i64 size);
struct ax_decls_opndrec * ax_lib_genint(i64 x,i64 size);
struct ax_decls_opndrec * ax_lib_genlab(struct ax_decls_strec * d,i64 size);
struct ax_decls_opndrec * ax_lib_genmem(struct ax_decls_strec * d,i64 size);
struct ax_decls_opndrec * ax_lib_genreg0(i64 reg,i64 size);
byte * ax_lib_getfullname(struct ax_decls_strec * d);
byte * ax_lib_getregname(i64 reg,i64 size);
byte * ax_lib_xgetregname(i64 reg);
void ax_lib_printst(void * f);
void ax_lib_printstrec(void * f,struct ax_decls_strec * d);
void ax_lib_adddef(struct ax_decls_strec * d);
void ax_lib_addimport(struct ax_decls_strec * d);
void ax_lib_createlabel(struct ax_decls_strec * symptr,i64 symbol);
void ax_lib_createnamedconst(struct ax_decls_strec * symptr,struct ax_decls_opndrec * expr);
void ax_lib_gerror(byte * mess);
void ax_lib_serror(byte * mess);
void ax_lib_serror_s(byte * mess,byte * param);
static byte * ax_lib_inttostr(i64 a);
static byte * ax_lib_realtostr(double a);
struct ax_decls_dbuffer * ax_lib_buffercreate(i64 size);
static void ax_lib_bufferexpand(struct ax_decls_dbuffer * a);
void ax_lib_buffercheck(struct ax_decls_dbuffer * a,i64 n);
i64 ax_lib_bufferlength(struct ax_decls_dbuffer * a);
void * ax_lib_bufferelemptr(struct ax_decls_dbuffer * a,i64 offset);
void ax_lib_addbyte(struct ax_decls_dbuffer * a,i64 x);
void ax_lib_addword(struct ax_decls_dbuffer * a,i64 x);
void ax_lib_adddword(struct ax_decls_dbuffer * a,i64 x);
void ax_lib_addqword(struct ax_decls_dbuffer * a,i64 x);
void ax_lib_printmodulesymbols(void * f);
void ax_lib_printimportsymbols(void * f);
void ax_lib_printdupltable(void * f);
void ax_genss_genss(void);
static void ax_genss_doinstr(struct ax_lib_mclrec * m,i64 index);
static void ax_genss_genbyte(i64 x);
static void ax_genss_genword(i64 x);
static void ax_genss_gendword(i64 x);
static void ax_genss_genqword(i64 x);
static void ax_genss_genopnd(struct ax_decls_opndrec * a,i64 size);
static void ax_genss_addrelocitem(i64 reloctype,struct ax_decls_strec * d);
static i64 ax_genss_getstindex(struct ax_decls_strec * d);
static void ax_genss_genrel32(struct ax_decls_opndrec * a);
static void ax_genss_genabs32(struct ax_decls_opndrec * a);
static void ax_genss_genabs64(struct ax_decls_opndrec * a);
static i64 ax_genss_getrel32(struct ax_decls_strec * d,i64 offset);
static void ax_genss_dofwdrefs(struct ax_decls_strec * d);
static void ax_genss_genrex(void);
static i64 ax_genss_isbytesized(i64 x);
static i64 ax_genss_isdwordsized(i64 x);
static void ax_genss_do_push(struct ax_decls_opndrec * a);
static void ax_genss_do_pop(struct ax_decls_opndrec * a);
static void ax_genss_do_inc(struct ax_decls_opndrec * a,i64 code);
static void ax_genss_do_neg(struct ax_decls_opndrec * a,i64 code);
static void ax_genss_genamode(struct ax_decls_opndrec * a,i64 am);
static i64 ax_genss_makemodrm(i64 mode,i64 opc,i64 rm);
static void ax_genss_setopsize(struct ax_decls_opndrec * a);
static void ax_genss_setaddrsize(struct ax_decls_opndrec * a);
static i64 ax_genss_getdispsize(struct ax_decls_opndrec * a,i64 mand);
static i64 ax_genss_genrm(struct ax_decls_opndrec * a,i64 opc);
static void ax_genss_genrmbyte(i64 mode,i64 opc,i64 rm);
static i64 ax_genss_makeam(i64 m,i64 s,i64 d);
static void ax_genss_do_arith(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 code);
static void ax_genss_do_mov(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b);
static i64 ax_genss_getregcoder(i64 reg);
static i64 ax_genss_getregcodeb(i64 reg);
static i64 ax_genss_getregcodebx(i64 reg);
static i64 ax_genss_getregcoderx(i64 reg);
static void ax_genss_do_lea(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b);
static void ax_genss_do_movsx(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 opc);
static void ax_genss_checkhighreg(struct ax_decls_opndrec * a);
static void ax_genss_do_exch(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b);
static void ax_genss_do_movsxd(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b);
static void ax_genss_do_imul2(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b);
static void ax_genss_do_imul3(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,struct ax_decls_opndrec * c);
static void ax_genss_do_shift(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 opc);
static void ax_genss_do_test(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b);
static void ax_genss_do_loop(struct ax_decls_opndrec * a,i64 opc);
static void ax_genss_do_jcxz(struct ax_decls_opndrec * a,i64 opsize);
static void ax_genss_do_setcc(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b);
static void ax_genss_do_movxmm(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 size);
static void ax_genss_do_arithxmm(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 prefix,i64 opc);
static void ax_genss_do_logicxmm(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 opc,i64 size);
static void ax_genss_do_convertfloat(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 prefix);
static void ax_genss_do_fix(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 prefix,i64 opc);
static void ax_genss_do_float(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 prefix);
static void ax_genss_do_call(struct ax_decls_opndrec * a);
static void ax_genss_do_jmp(struct ax_decls_opndrec * a,struct ax_lib_mclrec * m);
static i64 ax_genss_getcurrdatalen(i64 id);
static void ax_genss_do_cmovcc(struct ax_decls_opndrec * c,struct ax_decls_opndrec * a,struct ax_decls_opndrec * b);
static void ax_genss_do_fmem(struct ax_decls_opndrec * a,i64 freal,i64 code);
static i64 ax_genss_getr32bits(double x);
static void ax_genss_genrel8(struct ax_decls_opndrec * a);
static i64 ax_genss_checkshortjump(struct ax_lib_mclrec * m,struct ax_decls_strec * d);
static struct ax_decls_fwdrec * ax_genss_addfwdref(struct ax_decls_fwdrec * p,i64 offset,i64 reltype,i64 seg);
static void ax_genss_switchseg(i64 newseg);
static void ax_genss_do_movdqx(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 opc);
static void ax_genss_do_popcnt(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b);
static void ax_genss_do_bsf(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 opc);
static void ax_genss_extendsymboltable(void);
static void ax_genss_do_pcmpistri(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 c,i64 opc);
void ax_writeexe_writeexe(byte * outfile);
void ax_writeexe_genexe(byte * entrypoint);
static void ax_writeexe_loadlibs(void);
struct mlib_strbuffer * ax_writeexe_writessdata(i64 fexe);
void ax_writeexe_initsectiontable(void);
static void ax_writeexe_showssdata(i64 fexe);
static void ax_writeexe_showsectiondata(struct ax_writeexe_sectionrec * d);
static void ax_writeexe_showsectioncode(struct ax_writeexe_sectionrec * p);
static void ax_writeexe_showsectionrelocs2(byte * caption,struct ax_decls_relocrec * relocs,i64 nrelocs);
static void ax_writeexe_gs_value(byte * caption,i64 value);
static void ax_writeexe_showsymboltable2(void);
static void ax_writeexe_showimporttable(void);
static i64 ax_writeexe_roundtoblock(i64 n,i64 align);
static void ax_writeexe_showsections(void);
static byte * ax_writeexe_extractlibname(byte * name,i64 * libno,i64 moduleno);
static void ax_writeexe_scanst(void);
static void ax_writeexe_relocdata(struct ax_writeexe_sectionrec * s);
static void ax_writeexe_writerecordx(void * r,i64 length);
static void ax_writeexe_writedosstub(void);
static void ax_writeexe_writepesig(void);
static void ax_writeexe_writepadding(i64 offset);
static void ax_writeexe_writefileheader(void);
static void ax_writeexe_writeoptheader(void);
static void ax_writeexe_writesectionheader(struct ax_writeexe_sectionrec * s);
static void ax_writeexe_writesectiondata(struct ax_writeexe_sectionrec * s);
static void ax_writeexe_getoffsets(void);
byte * ax_disasm_decodeinstr(byte * * cptr,byte * baseaddr);
static void ax_disasm_decodetwobyteinstr(void);
static void ax_disasm_decodeaddr(i64 w);
static i64 ax_disasm_readbyte(void);
static i64 ax_disasm_readsbyte(void);
static u64 ax_disasm_readword16(void);
static i64 ax_disasm_readint16(void);
static u64 ax_disasm_readword32(void);
static i64 ax_disasm_readint32(void);
static i64 ax_disasm_readint64(void);
static i64 ax_disasm_getreg(i64 regcode,i64 upper);
static byte * ax_disasm_strreg(i64 reg,i64 opsize);
static byte * ax_disasm_strfreg(i64 freg);
static void ax_disasm_printaddrmode(i64 xmm);
static void ax_disasm_genstr(byte * s);
static void ax_disasm_genintd(i64 a);
static void ax_disasm_genhex(i64 a);
static i64 ax_disasm_readimm(void);
static i64 ax_disasm_readimm8(void);
static byte * ax_disasm_strxmm(i64 reg);
static byte * ax_disasm_strmmx(i64 reg);
static void ax_disasm_decode8087(i64 ttt);
static void ax_disasm_do87arith(byte * opcstr,i64 ttt,i64 freg);
static void ax_disasm_do87mem(byte * opcstr,i64 mf);
static void ax_disasm_getsil(i64 * reg);
static void ax_disasm_getsilx(i64 * reg);
void ax_writeobj_writess(byte * outfile);
static void ax_writeobj_writerecord(void * r,i64 length);
static void ax_writeobj_writerelocs(struct ax_decls_relocrec * r,i64 nrelocs);
static void ax_writeobj_writedata(struct ax_decls_dbuffer * data);
static void ax_writeobj_writesymboltable(void);
static void ax_writeobj_writestringtable(void);
static struct ax_objdecls_imagesymbol * ax_writeobj_makesymbol(byte * name,i64 namelen,i64 value,i64 sectionno,i64 symtype,i64 storage,i64 naux);
static void ax_writeobj_addsymbol(struct ax_objdecls_imagesymbol * r);
static void ax_writeobj_initsymboltable(byte * filename);
static struct ax_objdecls_imagesymbol * ax_writeobj_strtoaux(byte * s);
static struct ax_objdecls_auxsectionrec * ax_writeobj_sectiontoaux(struct ax_decls_dbuffer * data,i64 nrelocs);
static i64 ax_writeobj_addstringentry(byte * s,i64 length);
static void ax_writeobj_convertsymboltable(void);
static void ax_writeobj_writecoff(byte * outfile);

/* VARS */
static byte *  cc_modenames[4] = {(byte*)"preprocess_mode",(byte*)"compile_mode",(byte*)"link_mode",(byte*)"run_mode"};
static i64 cc_cc_mode;
static byte *  cc_linkoption;
static byte *  cc_destfilename;
static byte *  cc_destfileext;
static byte cc_fdebugcompiler;
static byte cc_fshowpaths;
static byte cc_fshowheaders;
static byte cc_fwriteheaders;
static byte cc_fgetlib;
static byte cc_fshowinfo;
static byte cc_fstdin;
static byte cc_fstdout;
static byte cc_fmheaders;
static byte cc_fshowlog;
static byte cc_fatfile;
static byte cc_fshowtiming;
static byte cc_fbcclib;
static byte *  cc_entrypointname;
static byte *  cc_optionnames[31] = {
    (byte*)"e",
    (byte*)"c",
    (byte*)"s",
    (byte*)"obj",
    (byte*)"exe",
    (byte*)"run",
    (byte*)"paths",
    (byte*)"headers",
    (byte*)"stdin",
    (byte*)"stdout",
    (byte*)"i",
    (byte*)"includes",
    (byte*)"time",
    (byte*)"v",
    (byte*)"v2",
    (byte*)"q",
    (byte*)"h",
    (byte*)"help",
    (byte*)"info",
    (byte*)"ext",
    (byte*)"writeheaders",
    (byte*)"old",
    (byte*)"getlib",
    (byte*)"mheaders",
    (byte*)"auto",
    (byte*)"out",
    (byte*)"at",
    (byte*)"debug",
    (byte*)"bcclib",
    (byte*)"callback",
    (byte*)"entry"
};
static i64 cc_totallines = (i64)0;
static i64 cc_nstringobjects = (i64)0;
static byte *  cc_extraparams[128];
static byte *  cc_extravalues[128];
static i64 cc_nextraparams = (i64)0;
i64 cc_progstart;
i64 cc_progend;
static void *  msysnewc__fnaddresses[]= {
    &start,
    &cc_compilemodules,
    &cc_debugcompile,
    &cc_do_loadmodule,
    &cc_do_preprocess,
    &cc_do_parsemodule,
    &cc_do_genmcl,
    &cc_do_genasm,
    &cc_do_runprog,
    &cc_loadmainmodule,
    &cc_addmodule,
    &cc_initlogfile,
    &cc_closelogfile,
    &cc_initdata,
    &cc_initsearchdirs,
    &cc_showsearchdirs,
    &cc_showast,
    &cc_showstflat,
    &cc_showsttree,
    &cc_showmcl,
    &cc_showasm,
    &cc_showfiles,
    &cc_starttiming,
    &cc_showtiming,
    &cc_showlps,
    &cc_getinputoptions,
    &cc_do_option,
    &cc_showincludepaths,
    &cc_showhelp,
    &cc_showextrainfo,
    &cc_showcaption,
    &cc_do_genlink,
    &cc_resetcompiler,
    &cc_showcompilerstate,
    &cc_addnewmodules,
    &cc_writeatfile,
    &msysnewc_m_getdotindex,
    &msysnewc_m_setdotindex,
    &msysnewc_m_getdotslice,
    &msysnewc_m_setdotslice,
    &msysnewc_m_get_nprocs,
    &msysnewc_m_get_nexports,
    &msysnewc_m_get_procname,
    &msysnewc_m_get_procaddr,
    &msysnewc_m_get_procexport,
    &msysnewc_pushio,
    &msysnewc_m_print_startfile,
    &msysnewc_m_print_startstr,
    &msysnewc_m_print_startptr,
    &msysnewc_m_print_startcon,
    &msysnewc_m_print_setfmt,
    &msysnewc_m_print_end,
    &msysnewc_m_print_ptr,
    &msysnewc_m_print_i64,
    &msysnewc_m_print_u64,
    &msysnewc_m_print_r64,
    &msysnewc_m_print_r32,
    &msysnewc_m_print_c8,
    &msysnewc_m_print_str,
    &msysnewc_m_print_newline,
    &msysnewc_m_print_nogap,
    &msysnewc_printstr,
    &msysnewc_printstr_n,
    &msysnewc_printstrn_app,
    &msysnewc_makezstring,
    &msysnewc_freezstring,
    &msysnewc_printchar,
    &msysnewc_nextfmtchars,
    &msysnewc_strtofmt,
    &msysnewc_domultichar,
    &msysnewc_expandstr,
    &msysnewc_xdivrem,
    &msysnewc_u64tostr,
    &msysnewc_i64tostrfmt,
    &msysnewc_u64tostrfmt,
    &msysnewc_i64mintostr,
    &msysnewc_strtostrfmt,
    &msysnewc_tostr_i64,
    &msysnewc_tostr_u64,
    &msysnewc_tostr_r64,
    &msysnewc_tostr_str,
    &msysnewc_getfmt,
    &msysnewc_strint,
    &msysnewc_getstrint,
    &msysnewc_strword,
    &msysnewc_strreal,
    &msysnewc_getstr,
    &msysnewc_initreadbuffer,
    &msysnewc_m_read_conline,
    &msysnewc_m_read_fileline,
    &msysnewc_m_read_strline,
    &msysnewc_readitem,
    &msysnewc_strtoint,
    &msysnewc_m_read_i64,
    &msysnewc_m_read_r64,
    &msysnewc_m_read_str,
    &msysnewc_readstr,
    &msysnewc_rereadln,
    &msysnewc_reread,
    &msysnewc_valint,
    &msysnewc_valreal,
    &msysnewc_iconvlcn,
    &msysnewc_iconvucn,
    &msysnewc_convlcstring,
    &msysnewc_convucstring,
    &msysnewc_m_power_i64,
    &msysnewc_m_intoverflow,
    &msysnewc_m_dotindex,
    &msysnewc_m_dotslice,
    &msysnewc_m_popdotindex,
    &msysnewc_m_popdotslice,
    &msysnewc_m_imin,
    &msysnewc_m_imax,
    &msysnewc_m_sign,
    &mlib_pcm_alloc,
    &mlib_pcm_freestr,
    &mlib_pcm_free,
    &mlib_pcm_freeac,
    &mlib_pcm_copymem4,
    &mlib_pcm_clearmem,
    &mlib_pcm_init,
    &mlib_pcm_getac,
    &mlib_pcm_newblock,
    &mlib_pcm_round,
    &mlib_pcm_array,
    &mlib_pcm_printfreelist,
    &mlib_pcm_diags,
    &mlib_pcm_allocz,
    &mlib_pcm_copyheapstring,
    &mlib_pcm_copyheapstringn,
    &mlib_pcm_copyheapblock,
    &mlib_addtomemalloc,
    &mlib_removefrommemalloc,
    &mlib_allocmem,
    &mlib_reallocmem,
    &mlib_abortprogram,
    &mlib_getfilesize,
    &mlib_readrandom,
    &mlib_writerandom,
    &mlib_setfilepos,
    &mlib_getfilepos,
    &mlib_readfile,
    &mlib_writefile,
    &mlib_checkfile,
    &mlib_readlinen,
    &mlib_iconvlcn,
    &mlib_iconvucn,
    &mlib_convlcstring,
    &mlib_convucstring,
    &mlib_changeext,
    &mlib_extractext,
    &mlib_extractpath,
    &mlib_extractfile,
    &mlib_extractbasefile,
    &mlib_addext,
    &mlib_alloctable,
    &mlib_zalloctable,
    &mlib_checkfreelists,
    &mlib_pcm_alloc32,
    &mlib_pcm_free32,
    &mlib_outbyte,
    &mlib_outword16,
    &mlib_outword,
    &mlib_outword64,
    &mlib_myeof,
    &mlib_pcm_smallallocz,
    &mlib_pcm_smallalloc,
    &mlib_strbuffer_add,
    &mlib_gs_init,
    &mlib_gs_free,
    &mlib_gs_str,
    &mlib_gs_char,
    &mlib_gs_strn,
    &mlib_gs_strvar,
    &mlib_gs_strint,
    &mlib_gs_strln,
    &mlib_gs_strsp,
    &mlib_gs_line,
    &mlib_gs_getcol,
    &mlib_gs_leftstr,
    &mlib_gs_leftint,
    &mlib_gs_padto,
    &mlib_gs_println,
    &mlib_nextcmdparam,
    &mlib_readnextfileitem,
    &mlib_ipadstr,
    &mlib_padstr,
    &mlib_chr,
    &mlib_cmpstring,
    &mlib_cmpstringn,
    &mlib_eqstring,
    &mlib_cmpbytes,
    &mlib_eqbytes,
    &mlib_mseed,
    &mlib_mrandom,
    &mlib_mrandomp,
    &mlib_mrandomint,
    &mlib_mrandomrange,
    &mlib_mrandomreal,
    &mlib_mrandomreal1,
    &mlib_checkpackfile,
    &osnos_os_init,
    &osnos_os_execwait,
    &osnos_os_execcmd,
    &osnos_os_getch,
    &osnos_os_kbhit,
    &osnos_os_flushkeys,
    &osnos_os_getconsolein,
    &osnos_os_getconsoleout,
    &osnos_os_proginstance,
    &osnos_os_getdllinst,
    &osnos_os_getdllprocaddr,
    &osnos_os_initwindows,
    &osnos_os_getchx,
    &osnos_os_getos,
    &osnos_os_getoscode,
    &osnos_os_iswindows,
    &osnos_os_shellexec,
    &osnos_os_sleep,
    &osnos_os_getstdin,
    &osnos_os_getstdout,
    &osnos_os_gethostname,
    &osnos_os_gethostsize,
    &osnos_os_getmpath,
    &osnos_os_exitprocess,
    &osnos_os_gettimestamp,
    &osnos_os_gettickcount,
    &osnos_os_clock,
    &osnos_os_getclockspersec,
    &osnos_os_setmesshandler,
    &osnos_os_filelastwritetime,
    &osnos_os_hpcounter,
    &osnos_os_hpfrequency,
    &osnos_os_getsystime,
    &osnos_os_peek,
    &cc_support_stopcompiler,
    &cc_support_mcerror,
    &cc_support_serror,
    &cc_support_serror_gen,
    &cc_support_serror_ss,
    &cc_support_serror_s,
    &cc_support_terror_gen,
    &cc_support_terror,
    &cc_support_terror_s,
    &cc_support_terror_ss,
    &cc_support_gerror_gen,
    &cc_support_gerror,
    &cc_support_gerror_s,
    &cc_support_nxerror,
    &cc_support_testelem,
    &cc_support_setelem,
    &cc_support_nextpoweroftwo,
    &cc_support_loaderror,
    &cc_support_loadfromstdin,
    &cc_support_loadsourcefile,
    &cc_support_splicelines,
    &cc_support_loadbuiltin,
    &cc_support_gs_copytostr,
    &cc_support_gs_additem,
    &cc_support_isalphanum,
    &cc_support_showmacrolineno,
    &cc_lex_lex_preprocess_only,
    &cc_lex_lexreadtoken,
    &cc_lex_readrealnumber,
    &cc_lex_readexponent,
    &cc_lex_lxerror,
    &cc_lex_printsymbol,
    &cc_lex_lexsetup,
    &cc_lex_printstrn,
    &cc_lex_scannumber,
    &cc_lex_lookup,
    &cc_lex_gethashvalue,
    &cc_lex_inithashtable,
    &cc_lex_fillhashtable,
    &cc_lex_dolexdirective,
    &cc_lex_getlexdirective,
    &cc_lex_startlex,
    &cc_lex_endlex,
    &cc_lex_ps,
    &cc_lex_psnext,
    &cc_lex_gethashtablesize,
    &cc_lex_readlinecomment,
    &cc_lex_readblockcomment,
    &cc_lex_readhex,
    &cc_lex_readbinary,
    &cc_lex_readoctal,
    &cc_lex_readdecimal,
    &cc_lex_checknumbersuffix,
    &cc_lex_stacksourcefile,
    &cc_lex_unstacksourcefile,
    &cc_lex_getsourcefile,
    &cc_lex_lex,
    &cc_lex_shownumberstr,
    &cc_lex_addnamestr,
    &cc_lex_lxreadstring,
    &cc_lex_addlisttoken,
    &cc_lex_addlisttoken_copy,
    &cc_lex_addlist_nextlx,
    &cc_lex_addlisttoken_seq,
    &cc_lex_addlistmparam,
    &cc_lex_dodefine,
    &cc_lex_readalphanumeric,
    &cc_lex_inmacrostack,
    &cc_lex_showtokens,
    &cc_lex_lexa,
    &cc_lex_lexm,
    &cc_lex_peeklb,
    &cc_lex_peektk,
    &cc_lex_expandobjmacro,
    &cc_lex_expandfnmacro,
    &cc_lex_scantokenseq,
    &cc_lex_readmacrocall,
    &cc_lex_substituteargs,
    &cc_lex_strtoken,
    &cc_lex_strstring,
    &cc_lex_emittoken,
    &cc_lex_showtoken,
    &cc_lex_stringify,
    &cc_lex_pastetokens,
    &cc_lex_getifexpr,
    &cc_lex_evalcondexpr,
    &cc_lex_evalorexpr,
    &cc_lex_evalandexpr,
    &cc_lex_evaliorexpr,
    &cc_lex_evalixorexpr,
    &cc_lex_evaliandexpr,
    &cc_lex_evaleqexpr,
    &cc_lex_evalcmpexpr,
    &cc_lex_evalshiftexpr,
    &cc_lex_evaladdexpr,
    &cc_lex_evalmulexpr,
    &cc_lex_evalunaryexpr,
    &cc_lex_evalterm,
    &cc_lex_getifdef,
    &cc_lex_skipcode,
    &cc_lex_freetokens,
    &cc_lex_fastreadtoken,
    &cc_lex_alloctoken,
    &cc_lex_alloctokenz,
    &cc_lex_expandpredefmacro,
    &cc_lex_dopragmadir,
    &cc_lex_needspace,
    &cc_lex_dospecialinclude,
    &cc_lex_addautomodule,
    &cc_lex_setnumberoffset,
    &cc_lex_setfileno,
    &cc_lex_setfilenox,
    &cc_lex_getfileno,
    &cc_lex_getfilenox,
    &cc_lex_getnumberoffsetx,
    &cc_lex_freehashtable,
    &cc_lex_freestentry,
    &cc_lex_regenlookup,
    &cc_lex_printhashtable,
    &cc_lex_newhashtable,
    &cc_lex_old_readrealnumber,
    &cc_headers_findheader,
    &cc_headers_writeheaders,
    &cc_headers_checkbcclib,
    &cc_headers_getbcclib,
    &cc_headers_isheaderfile,
    &cc_lib_newstrec,
    &cc_lib_initcclib,
    &cc_lib_printst,
    &cc_lib_printstrec,
    &cc_lib_printstflat,
    &cc_lib_createname,
    &cc_lib_createunit0,
    &cc_lib_createunit1,
    &cc_lib_createunit2,
    &cc_lib_createunit3,
    &cc_lib_createconstunit,
    &cc_lib_createstringconstunit,
    &cc_lib_createwstringconstunit,
    &cc_lib_getoptocode,
    &cc_lib_getconstvalue,
    &cc_lib_nextautotype,
    &cc_lib_createconstmode,
    &cc_lib_createrefmode,
    &cc_lib_createprocmode,
    &cc_lib_createarraymode,
    &cc_lib_createenummode,
    &cc_lib_createstructmode,
    &cc_lib_setnameptr,
    &cc_lib_printcode_all,
    &cc_lib_printcode,
    &cc_lib_printunit,
    &cc_lib_printunitlist,
    &cc_lib_getprefix,
    &cc_lib_getdottedname,
    &cc_lib_getlineinfok,
    &cc_lib_getautofieldname,
    &cc_lib_convertstring,
    &cc_lib_strexpr,
    &cc_lib_jeval,
    &cc_lib_getopcjname,
    &cc_lib_strmode,
    &cc_lib_strmode2,
    &cc_lib_istrmode,
    &cc_lib_countunits,
    &cc_lib_purgesymbol,
    &cc_lib_purgesymbollist,
    &cc_lib_purgeprocs,
    &cc_lib_purgeproc,
    &cc_lib_printmodelist,
    &cc_lib_typename,
    &cc_lib_allocunitrec,
    &cc_lib_copymode,
    &cc_lib_createnewmode,
    &cc_lib_addlistunit,
    &cc_lib_addlistdef,
    &cc_lib_addlistparam,
    &cc_lib_checksymbol,
    &cc_lib_skipsymbol,
    &cc_lib_inittypetables,
    &cc_lib_createdupldef,
    &cc_lib_createnewmoduledef,
    &cc_lib_createnewproc,
    &cc_lib_resolvename,
    &cc_lib_checkdupl,
    &cc_lib_checkdupl_inproc,
    &cc_lib_getalignment,
    &cc_lib_isexported,
    &cc_lib_isimported,
    &cc_lib_isstructunion,
    &cc_lib_getstname,
    &cc_lib_isrealcc,
    &cc_lib_isintcc,
    &cc_parse_readmodule,
    &cc_parse_parsemodule,
    &cc_parse_readdeclspec,
    &cc_parse_istypestarter,
    &cc_parse_readexpression,
    &cc_parse_readassignexpr,
    &cc_parse_readcondexpr,
    &cc_parse_readorlexpr,
    &cc_parse_readandlexpr,
    &cc_parse_readiorexpr,
    &cc_parse_readixorexpr,
    &cc_parse_readiandexpr,
    &cc_parse_readeqexpr,
    &cc_parse_readrelexpr,
    &cc_parse_readshiftexpr,
    &cc_parse_readaddexpr,
    &cc_parse_readmulexpr,
    &cc_parse_readterm,
    &cc_parse_readexprlist,
    &cc_parse_readmodulevar,
    &cc_parse_readframevar,
    &cc_parse_readtype,
    &cc_parse_readnamedtype,
    &cc_parse_readconstintexpr,
    &cc_parse_readinitexpr,
    &cc_parse_readinitexpr2,
    &cc_parse_pushblock,
    &cc_parse_popblock,
    &cc_parse_readcompoundstmt,
    &cc_parse_readblock,
    &cc_parse_readstatement,
    &cc_parse_readifstmt,
    &cc_parse_readforstmt,
    &cc_parse_readwhilestmt,
    &cc_parse_readdostmt,
    &cc_parse_readreturnstmt,
    &cc_parse_readgotostmt,
    &cc_parse_readswitchstmt,
    &cc_parse_readcaselabel,
    &cc_parse_readexprstmt,
    &cc_parse_readcond,
    &cc_parse_isusertype,
    &cc_parse_readlocaldecl,
    &cc_parse_createtypedef,
    &cc_parse_readparams,
    &cc_parse_readcasttype,
    &cc_parse_readfunction,
    &cc_parse_readfunctionbody,
    &cc_parse_createnegop,
    &cc_parse_createabsop,
    &cc_parse_createsqrtop,
    &cc_parse_createinotop,
    &cc_parse_createptrop,
    &cc_parse_createincrop,
    &cc_parse_createlengthofop,
    &cc_parse_createaddrofop,
    &cc_parse_createaddop,
    &cc_parse_createsubop,
    &cc_parse_createmulop,
    &cc_parse_createdivop,
    &cc_parse_createremop,
    &cc_parse_insertunit,
    &cc_parse_eval_add,
    &cc_parse_eval_sub,
    &cc_parse_eval_mul,
    &cc_parse_eval_div,
    &cc_parse_eval_rem,
    &cc_parse_eval_convert,
    &cc_parse_coercecond,
    &cc_parse_coercebasetype,
    &cc_parse_checklvalue,
    &cc_parse_createcall,
    &cc_parse_arraytopointer,
    &cc_parse_createindexop,
    &cc_parse_readstructdecl,
    &cc_parse_checkpointertypes,
    &cc_parse_comparemode,
    &cc_parse_readenumdecl,
    &cc_parse_readenumnames,
    &cc_parse_createdotop,
    &cc_parse_mulunit,
    &cc_parse_divunit,
    &cc_parse_createassignopref,
    &cc_parse_addnewfield,
    &cc_parse_pushloop,
    &cc_parse_poploop,
    &cc_parse_addcasevalue,
    &cc_parse_roundoffset,
    &cc_parse_fixmemopnd,
    &cc_parse_docast,
    &cc_parse_coercemode,
    &cc_parse_coercemode_inplace,
    &cc_parse_dostaticassert,
    &cc_parse_createsizeofop,
    &cc_parse_readgeneric,
    &cc_parse_readstructinfosym,
    &cc_parse_getmemmode,
    &cc_parse_readstrinclude,
    &cc_genmcl_codegen_mcl,
    &cc_genmcl_genprocdef,
    &cc_genmcl_dolabel,
    &cc_genmcl_dolabel_fn,
    &cc_genmcl_dostaticvar,
    &cc_genmcl_dostaticvar_fn,
    &cc_genmcl_genprocentry,
    &cc_genmcl_genidata,
    &cc_genmcl_genmainprelude,
    &cc_libmcl_mclinit,
    &cc_libmcl_gettargetdata,
    &cc_libmcl_initmcdest,
    &cc_libmcl_genmc,
    &cc_libmcl_genmc_cond,
    &cc_libmcl_lastmc,
    &cc_libmcl_genmcstr,
    &cc_libmcl_newopnd,
    &cc_libmcl_duplopnd,
    &cc_libmcl_genxreg,
    &cc_libmcl_genindex,
    &cc_libmcl_writemclblock,
    &cc_libmcl_writemclcode,
    &cc_libmcl_gencomment,
    &cc_libmcl_genstrimm,
    &cc_libmcl_genwstrimm,
    &cc_libmcl_genname,
    &cc_libmcl_writemcl,
    &cc_libmcl_strmcl,
    &cc_libmcl_stropnd,
    &cc_libmcl_strvalue,
    &cc_libmcl_setsegment,
    &cc_libmcl_getprocname,
    &cc_libmcl_widenstr,
    &cc_libmcl_genassem,
    &cc_libmcl_strlabel,
    &cc_libmcl_makeindirect,
    &cc_libmcl_applyoffset,
    &cc_libmcl_applysize,
    &cc_libmcl_isframe,
    &cc_libmcl_genreturn,
    &cc_libmcl_getsizeprefix,
    &cc_libmcl_needsizeprefix,
    &cc_libmcl_changeopndsize,
    &cc_libmcl_genint,
    &cc_libmcl_genreal,
    &cc_libmcl_genimm,
    &cc_libmcl_genlabel,
    &cc_libmcl_genmem_u,
    &cc_libmcl_genmem_d,
    &cc_libmcl_genmemaddr_u,
    &cc_libmcl_genmemaddr_d,
    &cc_libmcl_genreg,
    &cc_libmcl_genireg,
    &cc_libmcl_getopndsize_u,
    &cc_libmcl_getopndsize_d,
    &cc_libmcl_getmclcond,
    &cc_libmcl_getfullname,
    &cc_libmcl_roundsizetg,
    &cc_libmcl_iscallbackfn,
    &cc_libmcl_getregname,
    &cc_libmcl_getblockname,
    &cc_libmcl_fgetregname,
    &cc_libmcl_issimple,
    &cc_libmcl_issimple0,
    &cc_libmcl_issimplepm,
    &cc_libmcl_getaregs,
    &cc_libmcl_getlregs,
    &cc_libmcl_isintconst,
    &cc_libmcl__getnextreg,
    &cc_libmcl_getnextreg,
    &cc_libmcl_ispoweroftwo,
    &cc_libmcl_sameoperand,
    &cc_libmcl_findlastmcl,
    &cc_libmcl_genmsource,
    &cc_libmcl_roundto,
    &cc_libmcl_pushstack,
    &cc_libmcl_pushstackfp,
    &cc_libmcl_popstack,
    &cc_libmcl_definelabel,
    &cc_libmcl_createfwdlabel,
    &cc_libmcl_definefwdlabel,
    &cc_libmcl_genjumpl,
    &cc_libmcl_setalign,
    &cc_libmcl_gettypecat,
    &cc_libmcl_doblockcall,
    &cc_libmcl_getblockreg,
    &cc_libmcl_copyretvalue,
    &cc_libmcl_enterproc,
    &cc_libmcl_leaveproc,
    &cc_blockmcl_do_stmt,
    &cc_blockmcl_dx_expr,
    &cc_blockmcl_loneexpr,
    &cc_blockmcl_do_assign,
    &cc_blockmcl_dx_assign,
    &cc_blockmcl_saveexpr,
    &cc_blockmcl_fsaveexpr,
    &cc_blockmcl_restoreexpr,
    &cc_blockmcl_frestoreexpr,
    &cc_blockmcl_getlvalueopnd,
    &cc_blockmcl_storeopnd,
    &cc_blockmcl_pushexpr,
    &cc_blockmcl_fpushexpr,
    &cc_blockmcl_dx_const,
    &cc_blockmcl_dx_constant,
    &cc_blockmcl_do_labeldef,
    &cc_blockmcl_do_goto,
    &cc_blockmcl_dx_add,
    &cc_blockmcl_dx_fadd,
    &cc_blockmcl_loadexpr,
    &cc_blockmcl_evalexpr,
    &cc_blockmcl_evaladdr,
    &cc_blockmcl_evalptr,
    &cc_blockmcl_floadexpr,
    &cc_blockmcl_fevalexpr,
    &cc_blockmcl_do_if,
    &cc_blockmcl_genjumpcond,
    &cc_blockmcl_gcomparejump,
    &cc_blockmcl_reversecond,
    &cc_blockmcl_do_preincr,
    &cc_blockmcl_reversemclcond,
    &cc_blockmcl_do_while,
    &cc_blockmcl_do_while1,
    &cc_blockmcl_stacklooplabels,
    &cc_blockmcl_do_dowhile,
    &cc_blockmcl_do_for,
    &cc_blockmcl_pushffparams,
    &cc_blockmcl_pushoneparam,
    &cc_blockmcl_pushfloatparam,
    &cc_blockmcl_loadfloatparam,
    &cc_blockmcl_dx_call,
    &cc_blockmcl_do_return,
    &cc_blockmcl_dx_sub,
    &cc_blockmcl_dx_mul,
    &cc_blockmcl_dx_div,
    &cc_blockmcl_dx_shl,
    &cc_blockmcl_dx_iand,
    &cc_blockmcl_dx_preincrx,
    &cc_blockmcl_dx_postincrx,
    &cc_blockmcl_makeindexopnd,
    &cc_blockmcl_mulreg,
    &cc_blockmcl_dx_ptr,
    &cc_blockmcl_dx_addptr,
    &cc_blockmcl_dx_subptr,
    &cc_blockmcl_dx_convert,
    &cc_blockmcl_do_decl,
    &cc_blockmcl_do_assignblock,
    &cc_blockmcl_dx_widen,
    &cc_blockmcl_dx_neg,
    &cc_blockmcl_dx_fneg,
    &cc_blockmcl_dx_inot,
    &cc_blockmcl_do_switch,
    &cc_blockmcl_dx_rem,
    &cc_blockmcl_dx_ifx,
    &cc_blockmcl_dx_addto,
    &cc_blockmcl_dx_faddto,
    &cc_blockmcl_dx_eq,
    &cc_blockmcl_do_exprlist,
    &cc_blockmcl_dx_exprlist,
    &cc_blockmcl_dx_shlto,
    &cc_blockmcl_dx_multo,
    &cc_blockmcl_dx_notl,
    &cc_blockmcl_dx_istruel,
    &cc_blockmcl_dx_andorl,
    &cc_blockmcl_dx_sqrt,
    &cc_blockmcl_dx_scale,
    &cc_blockmcl_dx_divto,
    &cc_blockmcl_dx_name,
    &cc_blockmcl_divreg,
    &cc_blockmcl_dx_addrof,
    &cc_blockmcl_dx_dot,
    &cc_blockmcl_loadviaptr,
    &cc_genasm_codegen_writeasm,
    &cc_genasm_inita64,
    &cc_genasm_terma64,
    &cc_genasm_writetoasm,
    &cc_genasm_mcltoa64,
    &cc_genasm_passthru,
    &cc_genasm_convmcl,
    &cc_genasm_do_changeop,
    &cc_genasm_do_comment,
    &cc_genasm_do_blank,
    &cc_genasm_do_end,
    &cc_genasm_do_label,
    &cc_genasm_do_labelname,
    &cc_genasm_do_mov,
    &cc_genasm_do_push,
    &cc_genasm_do_pop,
    &cc_genasm_do_lea,
    &cc_genasm_do_cmovcc,
    &cc_genasm_do_fmov,
    &cc_genasm_do_iwiden,
    &cc_genasm_do_uwiden,
    &cc_genasm_do_inarrow,
    &cc_genasm_do_unarrow,
    &cc_genasm_do_call,
    &cc_genasm_do_ret,
    &cc_genasm_do_retn,
    &cc_genasm_do_jmp,
    &cc_genasm_do_jmpcc,
    &cc_genasm_do_exch,
    &cc_genasm_do_add,
    &cc_genasm_do_sub,
    &cc_genasm_do_imul,
    &cc_genasm_do_idiv,
    &cc_genasm_do_irem,
    &cc_genasm_do_urem,
    &cc_genasm_do_and,
    &cc_genasm_do_or,
    &cc_genasm_do_xor,
    &cc_genasm_do_test,
    &cc_genasm_do_cmp,
    &cc_genasm_do_shl,
    &cc_genasm_do_neg,
    &cc_genasm_do_not,
    &cc_genasm_do_inc,
    &cc_genasm_do_dec,
    &cc_genasm_do_setcc,
    &cc_genasm_do_fneg,
    &cc_genasm_do_fabs,
    &cc_genasm_do_fsqrt,
    &cc_genasm_do_ufix,
    &cc_genasm_do_ifix,
    &cc_genasm_do_ufloat,
    &cc_genasm_do_ifloat,
    &cc_genasm_do_db,
    &cc_genasm_do_dw,
    &cc_genasm_do_dd,
    &cc_genasm_do_dq,
    &cc_genasm_do_align,
    &cc_genasm_do_segment,
    &cc_genasm_do_assem,
    &cc_genasm_strmclasm,
    &cc_genasm_stropndx,
    &cc_genasm_strmclx,
    &cc_genasm_fgetregnamex,
    &cc_genasm_getstringname,
    &cc_genasm_getwstringname,
    &cc_genasm_getrealname,
    &cc_genasm_getsrealname,
    &cc_genasm_getdintname,
    &cc_genasm_getstringindex,
    &cc_genasm_getwstringindex,
    &cc_genasm_getrealindex,
    &cc_genasm_getdintindex,
    &cc_genasm_strvaluex,
    &cc_genasm_convertimm,
    &cc_genasm_genstringtable,
    &cc_genasm_genwstringtable,
    &cc_genasm_do_defstr,
    &cc_genasm_do_defwstr,
    &cc_genasm_genrealtable,
    &cc_genasm_gendinttable,
    &cc_genasm_writefabs,
    &cc_genasm_domclseq,
    &cc_genasm_asmstr,
    &cc_genasm_asmstrln,
    &cc_genasm_asmline,
    &cc_genasm_asmln,
    &cc_genasm_asmint,
    &cc_genasm_asmchar,
    &cc_genasm_asmterm,
    &cc_genasm_initasmline,
    &cc_genasm_getregnamex,
    &cc_genasm_genstring,
    &cc_genasm_genwstring,
    &cc_genasm_extendrealtable,
    &cc_genasm_extenddinttable,
    &cc_genasm_extendstringtable,
    &cc_export_writemheader,
    &cc_export_showmacroseq,
    &cc_export_mmstr,
    &cc_export_mmleftstr,
    &cc_export_mmstrln,
    &cc_export_mmint,
    &cc_export_mmline,
    &cc_export_writefunction,
    &cc_export_mmmode,
    &cc_export_writerecord,
    &cc_export_writefnptr,
    &cc_export_fixname,
    &cc_assembler_assembler,
    &cc_assembler_loadsourcefiles,
    &cc_assembler_parsemodules,
    &cc_assembler_fixopnd,
    &cc_assembler_initall,
    &cc_assembler_loaderror,
    &cc_assembler_loaderror_s,
    &cc_assembler_addmodule,
    &cc_assembler_addsearchlib,
    &cc_assembler_getemptyst,
    &cc_assembler_findduplname,
    &cc_assembler_adddupl,
    &cc_assembler_scanglobals,
    &cc_assembler_resethashtable,
    &ax_lex_lex,
    &ax_lex_initlex,
    &ax_lex_readreal,
    &ax_lex_readnumber,
    &ax_lex_readbinary,
    &ax_lex_readhex,
    &ax_lex_ps,
    &ax_lex_printsymbol,
    &ax_lex_clearhashtable,
    &ax_lex_inithashtable,
    &ax_lex_addreservedword,
    &ax_lex_printhashtable,
    &ax_lex_lookuplex,
    &ax_lex_initsourcefile,
    &ax_lex_addnamestr,
    &ax_lex_lxerror,
    &ax_lex_gethashvalue,
    &ax_lex_skiptoeol,
    &ax_lex_makestring,
    &ax_parse_readmodule,
    &ax_parse_checkundefined,
    &ax_parse_checksymbol,
    &ax_parse_readinstr,
    &ax_parse_readcondinstr,
    &ax_parse_readoperand,
    &ax_parse_readexpression,
    &ax_parse_readterm,
    &ax_parse_readreg,
    &ax_parse_readaddrmode,
    &ax_lib_initlib,
    &ax_lib_genmc,
    &ax_lib_genmcstr,
    &ax_lib_newopnd,
    &ax_lib_genxreg,
    &ax_lib_genindex,
    &ax_lib_writemclblock,
    &ax_lib_gencomment,
    &ax_lib_genstrimm,
    &ax_lib_getsizetag,
    &ax_lib_writemcl,
    &ax_lib_strmcl,
    &ax_lib_stropnd,
    &ax_lib_strdef,
    &ax_lib_setsegment,
    &ax_lib_getsizeprefix,
    &ax_lib_needsizeprefix,
    &ax_lib_genimm_expr,
    &ax_lib_genint,
    &ax_lib_genlab,
    &ax_lib_genmem,
    &ax_lib_genreg0,
    &ax_lib_getfullname,
    &ax_lib_getregname,
    &ax_lib_xgetregname,
    &ax_lib_printst,
    &ax_lib_printstrec,
    &ax_lib_adddef,
    &ax_lib_addimport,
    &ax_lib_createlabel,
    &ax_lib_createnamedconst,
    &ax_lib_gerror,
    &ax_lib_serror,
    &ax_lib_serror_s,
    &ax_lib_inttostr,
    &ax_lib_realtostr,
    &ax_lib_buffercreate,
    &ax_lib_bufferexpand,
    &ax_lib_buffercheck,
    &ax_lib_bufferlength,
    &ax_lib_bufferelemptr,
    &ax_lib_addbyte,
    &ax_lib_addword,
    &ax_lib_adddword,
    &ax_lib_addqword,
    &ax_lib_printmodulesymbols,
    &ax_lib_printimportsymbols,
    &ax_lib_printdupltable,
    &ax_genss_genss,
    &ax_genss_doinstr,
    &ax_genss_genbyte,
    &ax_genss_genword,
    &ax_genss_gendword,
    &ax_genss_genqword,
    &ax_genss_genopnd,
    &ax_genss_addrelocitem,
    &ax_genss_getstindex,
    &ax_genss_genrel32,
    &ax_genss_genabs32,
    &ax_genss_genabs64,
    &ax_genss_getrel32,
    &ax_genss_dofwdrefs,
    &ax_genss_genrex,
    &ax_genss_isbytesized,
    &ax_genss_isdwordsized,
    &ax_genss_do_push,
    &ax_genss_do_pop,
    &ax_genss_do_inc,
    &ax_genss_do_neg,
    &ax_genss_genamode,
    &ax_genss_makemodrm,
    &ax_genss_setopsize,
    &ax_genss_setaddrsize,
    &ax_genss_getdispsize,
    &ax_genss_genrm,
    &ax_genss_genrmbyte,
    &ax_genss_makeam,
    &ax_genss_do_arith,
    &ax_genss_do_mov,
    &ax_genss_getregcoder,
    &ax_genss_getregcodeb,
    &ax_genss_getregcodebx,
    &ax_genss_getregcoderx,
    &ax_genss_do_lea,
    &ax_genss_do_movsx,
    &ax_genss_checkhighreg,
    &ax_genss_do_exch,
    &ax_genss_do_movsxd,
    &ax_genss_do_imul2,
    &ax_genss_do_imul3,
    &ax_genss_do_shift,
    &ax_genss_do_test,
    &ax_genss_do_loop,
    &ax_genss_do_jcxz,
    &ax_genss_do_setcc,
    &ax_genss_do_movxmm,
    &ax_genss_do_arithxmm,
    &ax_genss_do_logicxmm,
    &ax_genss_do_convertfloat,
    &ax_genss_do_fix,
    &ax_genss_do_float,
    &ax_genss_do_call,
    &ax_genss_do_jmp,
    &ax_genss_getcurrdatalen,
    &ax_genss_do_cmovcc,
    &ax_genss_do_fmem,
    &ax_genss_getr32bits,
    &ax_genss_genrel8,
    &ax_genss_checkshortjump,
    &ax_genss_addfwdref,
    &ax_genss_switchseg,
    &ax_genss_do_movdqx,
    &ax_genss_do_popcnt,
    &ax_genss_do_bsf,
    &ax_genss_extendsymboltable,
    &ax_genss_do_pcmpistri,
    &ax_writeexe_writeexe,
    &ax_writeexe_genexe,
    &ax_writeexe_loadlibs,
    &ax_writeexe_writessdata,
    &ax_writeexe_initsectiontable,
    &ax_writeexe_showssdata,
    &ax_writeexe_showsectiondata,
    &ax_writeexe_showsectioncode,
    &ax_writeexe_showsectionrelocs2,
    &ax_writeexe_gs_value,
    &ax_writeexe_showsymboltable2,
    &ax_writeexe_showimporttable,
    &ax_writeexe_roundtoblock,
    &ax_writeexe_showsections,
    &ax_writeexe_extractlibname,
    &ax_writeexe_scanst,
    &ax_writeexe_relocdata,
    &ax_writeexe_writerecordx,
    &ax_writeexe_writedosstub,
    &ax_writeexe_writepesig,
    &ax_writeexe_writepadding,
    &ax_writeexe_writefileheader,
    &ax_writeexe_writeoptheader,
    &ax_writeexe_writesectionheader,
    &ax_writeexe_writesectiondata,
    &ax_writeexe_getoffsets,
    &ax_disasm_decodeinstr,
    &ax_disasm_decodetwobyteinstr,
    &ax_disasm_decodeaddr,
    &ax_disasm_readbyte,
    &ax_disasm_readsbyte,
    &ax_disasm_readword16,
    &ax_disasm_readint16,
    &ax_disasm_readword32,
    &ax_disasm_readint32,
    &ax_disasm_readint64,
    &ax_disasm_getreg,
    &ax_disasm_strreg,
    &ax_disasm_strfreg,
    &ax_disasm_printaddrmode,
    &ax_disasm_genstr,
    &ax_disasm_genintd,
    &ax_disasm_genhex,
    &ax_disasm_readimm,
    &ax_disasm_readimm8,
    &ax_disasm_strxmm,
    &ax_disasm_strmmx,
    &ax_disasm_decode8087,
    &ax_disasm_do87arith,
    &ax_disasm_do87mem,
    &ax_disasm_getsil,
    &ax_disasm_getsilx,
    &ax_writeobj_writess,
    &ax_writeobj_writerecord,
    &ax_writeobj_writerelocs,
    &ax_writeobj_writedata,
    &ax_writeobj_writesymboltable,
    &ax_writeobj_writestringtable,
    &ax_writeobj_makesymbol,
    &ax_writeobj_addsymbol,
    &ax_writeobj_initsymboltable,
    &ax_writeobj_strtoaux,
    &ax_writeobj_sectiontoaux,
    &ax_writeobj_addstringentry,
    &ax_writeobj_convertsymboltable,
    &ax_writeobj_writecoff,
0};
static byte *  msysnewc__fnnames[]= {
    (byte*)"start",
    (byte*)"compilemodules",
    (byte*)"debugcompile",
    (byte*)"do_loadmodule",
    (byte*)"do_preprocess",
    (byte*)"do_parsemodule",
    (byte*)"do_genmcl",
    (byte*)"do_genasm",
    (byte*)"do_runprog",
    (byte*)"loadmainmodule",
    (byte*)"addmodule",
    (byte*)"initlogfile",
    (byte*)"closelogfile",
    (byte*)"initdata",
    (byte*)"initsearchdirs",
    (byte*)"showsearchdirs",
    (byte*)"showast",
    (byte*)"showstflat",
    (byte*)"showsttree",
    (byte*)"showmcl",
    (byte*)"showasm",
    (byte*)"showfiles",
    (byte*)"starttiming",
    (byte*)"showtiming",
    (byte*)"showlps",
    (byte*)"getinputoptions",
    (byte*)"do_option",
    (byte*)"showincludepaths",
    (byte*)"showhelp",
    (byte*)"showextrainfo",
    (byte*)"showcaption",
    (byte*)"do_genlink",
    (byte*)"resetcompiler",
    (byte*)"showcompilerstate",
    (byte*)"addnewmodules",
    (byte*)"writeatfile",
    (byte*)"m_getdotindex",
    (byte*)"m_setdotindex",
    (byte*)"m_getdotslice",
    (byte*)"m_setdotslice",
    (byte*)"m_get_nprocs",
    (byte*)"m_get_nexports",
    (byte*)"m_get_procname",
    (byte*)"m_get_procaddr",
    (byte*)"m_get_procexport",
    (byte*)"pushio",
    (byte*)"m_print_startfile",
    (byte*)"m_print_startstr",
    (byte*)"m_print_startptr",
    (byte*)"m_print_startcon",
    (byte*)"m_print_setfmt",
    (byte*)"m_print_end",
    (byte*)"m_print_ptr",
    (byte*)"m_print_i64",
    (byte*)"m_print_u64",
    (byte*)"m_print_r64",
    (byte*)"m_print_r32",
    (byte*)"m_print_c8",
    (byte*)"m_print_str",
    (byte*)"m_print_newline",
    (byte*)"m_print_nogap",
    (byte*)"printstr",
    (byte*)"printstr_n",
    (byte*)"printstrn_app",
    (byte*)"makezstring",
    (byte*)"freezstring",
    (byte*)"printchar",
    (byte*)"nextfmtchars",
    (byte*)"strtofmt",
    (byte*)"domultichar",
    (byte*)"expandstr",
    (byte*)"xdivrem",
    (byte*)"u64tostr",
    (byte*)"i64tostrfmt",
    (byte*)"u64tostrfmt",
    (byte*)"i64mintostr",
    (byte*)"strtostrfmt",
    (byte*)"tostr_i64",
    (byte*)"tostr_u64",
    (byte*)"tostr_r64",
    (byte*)"tostr_str",
    (byte*)"getfmt",
    (byte*)"strint",
    (byte*)"getstrint",
    (byte*)"strword",
    (byte*)"strreal",
    (byte*)"getstr",
    (byte*)"initreadbuffer",
    (byte*)"m_read_conline",
    (byte*)"m_read_fileline",
    (byte*)"m_read_strline",
    (byte*)"readitem",
    (byte*)"strtoint",
    (byte*)"m_read_i64",
    (byte*)"m_read_r64",
    (byte*)"m_read_str",
    (byte*)"readstr",
    (byte*)"rereadln",
    (byte*)"reread",
    (byte*)"valint",
    (byte*)"valreal",
    (byte*)"iconvlcn",
    (byte*)"iconvucn",
    (byte*)"convlcstring",
    (byte*)"convucstring",
    (byte*)"m_power_i64",
    (byte*)"m_intoverflow",
    (byte*)"m_dotindex",
    (byte*)"m_dotslice",
    (byte*)"m_popdotindex",
    (byte*)"m_popdotslice",
    (byte*)"m_imin",
    (byte*)"m_imax",
    (byte*)"m_sign",
    (byte*)"pcm_alloc",
    (byte*)"pcm_freestr",
    (byte*)"pcm_free",
    (byte*)"pcm_freeac",
    (byte*)"pcm_copymem4",
    (byte*)"pcm_clearmem",
    (byte*)"pcm_init",
    (byte*)"pcm_getac",
    (byte*)"pcm_newblock",
    (byte*)"pcm_round",
    (byte*)"pcm_array",
    (byte*)"pcm_printfreelist",
    (byte*)"pcm_diags",
    (byte*)"pcm_allocz",
    (byte*)"pcm_copyheapstring",
    (byte*)"pcm_copyheapstringn",
    (byte*)"pcm_copyheapblock",
    (byte*)"addtomemalloc",
    (byte*)"removefrommemalloc",
    (byte*)"allocmem",
    (byte*)"reallocmem",
    (byte*)"abortprogram",
    (byte*)"getfilesize",
    (byte*)"readrandom",
    (byte*)"writerandom",
    (byte*)"setfilepos",
    (byte*)"getfilepos",
    (byte*)"readfile",
    (byte*)"writefile",
    (byte*)"checkfile",
    (byte*)"readlinen",
    (byte*)"iconvlcn",
    (byte*)"iconvucn",
    (byte*)"convlcstring",
    (byte*)"convucstring",
    (byte*)"changeext",
    (byte*)"extractext",
    (byte*)"extractpath",
    (byte*)"extractfile",
    (byte*)"extractbasefile",
    (byte*)"addext",
    (byte*)"alloctable",
    (byte*)"zalloctable",
    (byte*)"checkfreelists",
    (byte*)"pcm_alloc32",
    (byte*)"pcm_free32",
    (byte*)"outbyte",
    (byte*)"outword16",
    (byte*)"outword",
    (byte*)"outword64",
    (byte*)"myeof",
    (byte*)"pcm_smallallocz",
    (byte*)"pcm_smallalloc",
    (byte*)"strbuffer_add",
    (byte*)"gs_init",
    (byte*)"gs_free",
    (byte*)"gs_str",
    (byte*)"gs_char",
    (byte*)"gs_strn",
    (byte*)"gs_strvar",
    (byte*)"gs_strint",
    (byte*)"gs_strln",
    (byte*)"gs_strsp",
    (byte*)"gs_line",
    (byte*)"gs_getcol",
    (byte*)"gs_leftstr",
    (byte*)"gs_leftint",
    (byte*)"gs_padto",
    (byte*)"gs_println",
    (byte*)"nextcmdparam",
    (byte*)"readnextfileitem",
    (byte*)"ipadstr",
    (byte*)"padstr",
    (byte*)"chr",
    (byte*)"cmpstring",
    (byte*)"cmpstringn",
    (byte*)"eqstring",
    (byte*)"cmpbytes",
    (byte*)"eqbytes",
    (byte*)"mseed",
    (byte*)"mrandom",
    (byte*)"mrandomp",
    (byte*)"mrandomint",
    (byte*)"mrandomrange",
    (byte*)"mrandomreal",
    (byte*)"mrandomreal1",
    (byte*)"checkpackfile",
    (byte*)"os_init",
    (byte*)"os_execwait",
    (byte*)"os_execcmd",
    (byte*)"os_getch",
    (byte*)"os_kbhit",
    (byte*)"os_flushkeys",
    (byte*)"os_getconsolein",
    (byte*)"os_getconsoleout",
    (byte*)"os_proginstance",
    (byte*)"os_getdllinst",
    (byte*)"os_getdllprocaddr",
    (byte*)"os_initwindows",
    (byte*)"os_getchx",
    (byte*)"os_getos",
    (byte*)"os_getoscode",
    (byte*)"os_iswindows",
    (byte*)"os_shellexec",
    (byte*)"os_sleep",
    (byte*)"os_getstdin",
    (byte*)"os_getstdout",
    (byte*)"os_gethostname",
    (byte*)"os_gethostsize",
    (byte*)"os_getmpath",
    (byte*)"os_exitprocess",
    (byte*)"os_gettimestamp",
    (byte*)"os_gettickcount",
    (byte*)"os_clock",
    (byte*)"os_getclockspersec",
    (byte*)"os_setmesshandler",
    (byte*)"os_filelastwritetime",
    (byte*)"os_hpcounter",
    (byte*)"os_hpfrequency",
    (byte*)"os_getsystime",
    (byte*)"os_peek",
    (byte*)"stopcompiler",
    (byte*)"mcerror",
    (byte*)"serror",
    (byte*)"serror_gen",
    (byte*)"serror_ss",
    (byte*)"serror_s",
    (byte*)"terror_gen",
    (byte*)"terror",
    (byte*)"terror_s",
    (byte*)"terror_ss",
    (byte*)"gerror_gen",
    (byte*)"gerror",
    (byte*)"gerror_s",
    (byte*)"nxerror",
    (byte*)"testelem",
    (byte*)"setelem",
    (byte*)"nextpoweroftwo",
    (byte*)"loaderror",
    (byte*)"loadfromstdin",
    (byte*)"loadsourcefile",
    (byte*)"splicelines",
    (byte*)"loadbuiltin",
    (byte*)"gs_copytostr",
    (byte*)"gs_additem",
    (byte*)"isalphanum",
    (byte*)"showmacrolineno",
    (byte*)"lex_preprocess_only",
    (byte*)"lexreadtoken",
    (byte*)"readrealnumber",
    (byte*)"readexponent",
    (byte*)"lxerror",
    (byte*)"printsymbol",
    (byte*)"lexsetup",
    (byte*)"printstrn",
    (byte*)"scannumber",
    (byte*)"lookup",
    (byte*)"gethashvalue",
    (byte*)"inithashtable",
    (byte*)"fillhashtable",
    (byte*)"dolexdirective",
    (byte*)"getlexdirective",
    (byte*)"startlex",
    (byte*)"endlex",
    (byte*)"ps",
    (byte*)"psnext",
    (byte*)"gethashtablesize",
    (byte*)"readlinecomment",
    (byte*)"readblockcomment",
    (byte*)"readhex",
    (byte*)"readbinary",
    (byte*)"readoctal",
    (byte*)"readdecimal",
    (byte*)"checknumbersuffix",
    (byte*)"stacksourcefile",
    (byte*)"unstacksourcefile",
    (byte*)"getsourcefile",
    (byte*)"lex",
    (byte*)"shownumberstr",
    (byte*)"addnamestr",
    (byte*)"lxreadstring",
    (byte*)"addlisttoken",
    (byte*)"addlisttoken_copy",
    (byte*)"addlist_nextlx",
    (byte*)"addlisttoken_seq",
    (byte*)"addlistmparam",
    (byte*)"dodefine",
    (byte*)"readalphanumeric",
    (byte*)"inmacrostack",
    (byte*)"showtokens",
    (byte*)"lexa",
    (byte*)"lexm",
    (byte*)"peeklb",
    (byte*)"peektk",
    (byte*)"expandobjmacro",
    (byte*)"expandfnmacro",
    (byte*)"scantokenseq",
    (byte*)"readmacrocall",
    (byte*)"substituteargs",
    (byte*)"strtoken",
    (byte*)"strstring",
    (byte*)"emittoken",
    (byte*)"showtoken",
    (byte*)"stringify",
    (byte*)"pastetokens",
    (byte*)"getifexpr",
    (byte*)"evalcondexpr",
    (byte*)"evalorexpr",
    (byte*)"evalandexpr",
    (byte*)"evaliorexpr",
    (byte*)"evalixorexpr",
    (byte*)"evaliandexpr",
    (byte*)"evaleqexpr",
    (byte*)"evalcmpexpr",
    (byte*)"evalshiftexpr",
    (byte*)"evaladdexpr",
    (byte*)"evalmulexpr",
    (byte*)"evalunaryexpr",
    (byte*)"evalterm",
    (byte*)"getifdef",
    (byte*)"skipcode",
    (byte*)"freetokens",
    (byte*)"fastreadtoken",
    (byte*)"alloctoken",
    (byte*)"alloctokenz",
    (byte*)"expandpredefmacro",
    (byte*)"dopragmadir",
    (byte*)"needspace",
    (byte*)"dospecialinclude",
    (byte*)"addautomodule",
    (byte*)"setnumberoffset",
    (byte*)"setfileno",
    (byte*)"setfilenox",
    (byte*)"getfileno",
    (byte*)"getfilenox",
    (byte*)"getnumberoffsetx",
    (byte*)"freehashtable",
    (byte*)"freestentry",
    (byte*)"regenlookup",
    (byte*)"printhashtable",
    (byte*)"newhashtable",
    (byte*)"old_readrealnumber",
    (byte*)"findheader",
    (byte*)"writeheaders",
    (byte*)"checkbcclib",
    (byte*)"getbcclib",
    (byte*)"isheaderfile",
    (byte*)"newstrec",
    (byte*)"initcclib",
    (byte*)"printst",
    (byte*)"printstrec",
    (byte*)"printstflat",
    (byte*)"createname",
    (byte*)"createunit0",
    (byte*)"createunit1",
    (byte*)"createunit2",
    (byte*)"createunit3",
    (byte*)"createconstunit",
    (byte*)"createstringconstunit",
    (byte*)"createwstringconstunit",
    (byte*)"getoptocode",
    (byte*)"getconstvalue",
    (byte*)"nextautotype",
    (byte*)"createconstmode",
    (byte*)"createrefmode",
    (byte*)"createprocmode",
    (byte*)"createarraymode",
    (byte*)"createenummode",
    (byte*)"createstructmode",
    (byte*)"setnameptr",
    (byte*)"printcode_all",
    (byte*)"printcode",
    (byte*)"printunit",
    (byte*)"printunitlist",
    (byte*)"getprefix",
    (byte*)"getdottedname",
    (byte*)"getlineinfok",
    (byte*)"getautofieldname",
    (byte*)"convertstring",
    (byte*)"strexpr",
    (byte*)"jeval",
    (byte*)"getopcjname",
    (byte*)"strmode",
    (byte*)"strmode2",
    (byte*)"istrmode",
    (byte*)"countunits",
    (byte*)"purgesymbol",
    (byte*)"purgesymbollist",
    (byte*)"purgeprocs",
    (byte*)"purgeproc",
    (byte*)"printmodelist",
    (byte*)"typename",
    (byte*)"allocunitrec",
    (byte*)"copymode",
    (byte*)"createnewmode",
    (byte*)"addlistunit",
    (byte*)"addlistdef",
    (byte*)"addlistparam",
    (byte*)"checksymbol",
    (byte*)"skipsymbol",
    (byte*)"inittypetables",
    (byte*)"createdupldef",
    (byte*)"createnewmoduledef",
    (byte*)"createnewproc",
    (byte*)"resolvename",
    (byte*)"checkdupl",
    (byte*)"checkdupl_inproc",
    (byte*)"getalignment",
    (byte*)"isexported",
    (byte*)"isimported",
    (byte*)"isstructunion",
    (byte*)"getstname",
    (byte*)"isrealcc",
    (byte*)"isintcc",
    (byte*)"readmodule",
    (byte*)"parsemodule",
    (byte*)"readdeclspec",
    (byte*)"istypestarter",
    (byte*)"readexpression",
    (byte*)"readassignexpr",
    (byte*)"readcondexpr",
    (byte*)"readorlexpr",
    (byte*)"readandlexpr",
    (byte*)"readiorexpr",
    (byte*)"readixorexpr",
    (byte*)"readiandexpr",
    (byte*)"readeqexpr",
    (byte*)"readrelexpr",
    (byte*)"readshiftexpr",
    (byte*)"readaddexpr",
    (byte*)"readmulexpr",
    (byte*)"readterm",
    (byte*)"readexprlist",
    (byte*)"readmodulevar",
    (byte*)"readframevar",
    (byte*)"readtype",
    (byte*)"readnamedtype",
    (byte*)"readconstintexpr",
    (byte*)"readinitexpr",
    (byte*)"readinitexpr2",
    (byte*)"pushblock",
    (byte*)"popblock",
    (byte*)"readcompoundstmt",
    (byte*)"readblock",
    (byte*)"readstatement",
    (byte*)"readifstmt",
    (byte*)"readforstmt",
    (byte*)"readwhilestmt",
    (byte*)"readdostmt",
    (byte*)"readreturnstmt",
    (byte*)"readgotostmt",
    (byte*)"readswitchstmt",
    (byte*)"readcaselabel",
    (byte*)"readexprstmt",
    (byte*)"readcond",
    (byte*)"isusertype",
    (byte*)"readlocaldecl",
    (byte*)"createtypedef",
    (byte*)"readparams",
    (byte*)"readcasttype",
    (byte*)"readfunction",
    (byte*)"readfunctionbody",
    (byte*)"createnegop",
    (byte*)"createabsop",
    (byte*)"createsqrtop",
    (byte*)"createinotop",
    (byte*)"createptrop",
    (byte*)"createincrop",
    (byte*)"createlengthofop",
    (byte*)"createaddrofop",
    (byte*)"createaddop",
    (byte*)"createsubop",
    (byte*)"createmulop",
    (byte*)"createdivop",
    (byte*)"createremop",
    (byte*)"insertunit",
    (byte*)"eval_add",
    (byte*)"eval_sub",
    (byte*)"eval_mul",
    (byte*)"eval_div",
    (byte*)"eval_rem",
    (byte*)"eval_convert",
    (byte*)"coercecond",
    (byte*)"coercebasetype",
    (byte*)"checklvalue",
    (byte*)"createcall",
    (byte*)"arraytopointer",
    (byte*)"createindexop",
    (byte*)"readstructdecl",
    (byte*)"checkpointertypes",
    (byte*)"comparemode",
    (byte*)"readenumdecl",
    (byte*)"readenumnames",
    (byte*)"createdotop",
    (byte*)"mulunit",
    (byte*)"divunit",
    (byte*)"createassignopref",
    (byte*)"addnewfield",
    (byte*)"pushloop",
    (byte*)"poploop",
    (byte*)"addcasevalue",
    (byte*)"roundoffset",
    (byte*)"fixmemopnd",
    (byte*)"docast",
    (byte*)"coercemode",
    (byte*)"coercemode_inplace",
    (byte*)"dostaticassert",
    (byte*)"createsizeofop",
    (byte*)"readgeneric",
    (byte*)"readstructinfosym",
    (byte*)"getmemmode",
    (byte*)"readstrinclude",
    (byte*)"codegen_mcl",
    (byte*)"genprocdef",
    (byte*)"dolabel",
    (byte*)"dolabel_fn",
    (byte*)"dostaticvar",
    (byte*)"dostaticvar_fn",
    (byte*)"genprocentry",
    (byte*)"genidata",
    (byte*)"genmainprelude",
    (byte*)"mclinit",
    (byte*)"gettargetdata",
    (byte*)"initmcdest",
    (byte*)"genmc",
    (byte*)"genmc_cond",
    (byte*)"lastmc",
    (byte*)"genmcstr",
    (byte*)"newopnd",
    (byte*)"duplopnd",
    (byte*)"genxreg",
    (byte*)"genindex",
    (byte*)"writemclblock",
    (byte*)"writemclcode",
    (byte*)"gencomment",
    (byte*)"genstrimm",
    (byte*)"genwstrimm",
    (byte*)"genname",
    (byte*)"writemcl",
    (byte*)"strmcl",
    (byte*)"stropnd",
    (byte*)"strvalue",
    (byte*)"setsegment",
    (byte*)"getprocname",
    (byte*)"widenstr",
    (byte*)"genassem",
    (byte*)"strlabel",
    (byte*)"makeindirect",
    (byte*)"applyoffset",
    (byte*)"applysize",
    (byte*)"isframe",
    (byte*)"genreturn",
    (byte*)"getsizeprefix",
    (byte*)"needsizeprefix",
    (byte*)"changeopndsize",
    (byte*)"genint",
    (byte*)"genreal",
    (byte*)"genimm",
    (byte*)"genlabel",
    (byte*)"genmem_u",
    (byte*)"genmem_d",
    (byte*)"genmemaddr_u",
    (byte*)"genmemaddr_d",
    (byte*)"genreg",
    (byte*)"genireg",
    (byte*)"getopndsize_u",
    (byte*)"getopndsize_d",
    (byte*)"getmclcond",
    (byte*)"getfullname",
    (byte*)"roundsizetg",
    (byte*)"iscallbackfn",
    (byte*)"getregname",
    (byte*)"getblockname",
    (byte*)"fgetregname",
    (byte*)"issimple",
    (byte*)"issimple0",
    (byte*)"issimplepm",
    (byte*)"getaregs",
    (byte*)"getlregs",
    (byte*)"isintconst",
    (byte*)"_getnextreg",
    (byte*)"getnextreg",
    (byte*)"ispoweroftwo",
    (byte*)"sameoperand",
    (byte*)"findlastmcl",
    (byte*)"genmsource",
    (byte*)"roundto",
    (byte*)"pushstack",
    (byte*)"pushstackfp",
    (byte*)"popstack",
    (byte*)"definelabel",
    (byte*)"createfwdlabel",
    (byte*)"definefwdlabel",
    (byte*)"genjumpl",
    (byte*)"setalign",
    (byte*)"gettypecat",
    (byte*)"doblockcall",
    (byte*)"getblockreg",
    (byte*)"copyretvalue",
    (byte*)"enterproc",
    (byte*)"leaveproc",
    (byte*)"do_stmt",
    (byte*)"dx_expr",
    (byte*)"loneexpr",
    (byte*)"do_assign",
    (byte*)"dx_assign",
    (byte*)"saveexpr",
    (byte*)"fsaveexpr",
    (byte*)"restoreexpr",
    (byte*)"frestoreexpr",
    (byte*)"getlvalueopnd",
    (byte*)"storeopnd",
    (byte*)"pushexpr",
    (byte*)"fpushexpr",
    (byte*)"dx_const",
    (byte*)"dx_constant",
    (byte*)"do_labeldef",
    (byte*)"do_goto",
    (byte*)"dx_add",
    (byte*)"dx_fadd",
    (byte*)"loadexpr",
    (byte*)"evalexpr",
    (byte*)"evaladdr",
    (byte*)"evalptr",
    (byte*)"floadexpr",
    (byte*)"fevalexpr",
    (byte*)"do_if",
    (byte*)"genjumpcond",
    (byte*)"gcomparejump",
    (byte*)"reversecond",
    (byte*)"do_preincr",
    (byte*)"reversemclcond",
    (byte*)"do_while",
    (byte*)"do_while1",
    (byte*)"stacklooplabels",
    (byte*)"do_dowhile",
    (byte*)"do_for",
    (byte*)"pushffparams",
    (byte*)"pushoneparam",
    (byte*)"pushfloatparam",
    (byte*)"loadfloatparam",
    (byte*)"dx_call",
    (byte*)"do_return",
    (byte*)"dx_sub",
    (byte*)"dx_mul",
    (byte*)"dx_div",
    (byte*)"dx_shl",
    (byte*)"dx_iand",
    (byte*)"dx_preincrx",
    (byte*)"dx_postincrx",
    (byte*)"makeindexopnd",
    (byte*)"mulreg",
    (byte*)"dx_ptr",
    (byte*)"dx_addptr",
    (byte*)"dx_subptr",
    (byte*)"dx_convert",
    (byte*)"do_decl",
    (byte*)"do_assignblock",
    (byte*)"dx_widen",
    (byte*)"dx_neg",
    (byte*)"dx_fneg",
    (byte*)"dx_inot",
    (byte*)"do_switch",
    (byte*)"dx_rem",
    (byte*)"dx_ifx",
    (byte*)"dx_addto",
    (byte*)"dx_faddto",
    (byte*)"dx_eq",
    (byte*)"do_exprlist",
    (byte*)"dx_exprlist",
    (byte*)"dx_shlto",
    (byte*)"dx_multo",
    (byte*)"dx_notl",
    (byte*)"dx_istruel",
    (byte*)"dx_andorl",
    (byte*)"dx_sqrt",
    (byte*)"dx_scale",
    (byte*)"dx_divto",
    (byte*)"dx_name",
    (byte*)"divreg",
    (byte*)"dx_addrof",
    (byte*)"dx_dot",
    (byte*)"loadviaptr",
    (byte*)"codegen_writeasm",
    (byte*)"inita64",
    (byte*)"terma64",
    (byte*)"writetoasm",
    (byte*)"mcltoa64",
    (byte*)"passthru",
    (byte*)"convmcl",
    (byte*)"do_changeop",
    (byte*)"do_comment",
    (byte*)"do_blank",
    (byte*)"do_end",
    (byte*)"do_label",
    (byte*)"do_labelname",
    (byte*)"do_mov",
    (byte*)"do_push",
    (byte*)"do_pop",
    (byte*)"do_lea",
    (byte*)"do_cmovcc",
    (byte*)"do_fmov",
    (byte*)"do_iwiden",
    (byte*)"do_uwiden",
    (byte*)"do_inarrow",
    (byte*)"do_unarrow",
    (byte*)"do_call",
    (byte*)"do_ret",
    (byte*)"do_retn",
    (byte*)"do_jmp",
    (byte*)"do_jmpcc",
    (byte*)"do_exch",
    (byte*)"do_add",
    (byte*)"do_sub",
    (byte*)"do_imul",
    (byte*)"do_idiv",
    (byte*)"do_irem",
    (byte*)"do_urem",
    (byte*)"do_and",
    (byte*)"do_or",
    (byte*)"do_xor",
    (byte*)"do_test",
    (byte*)"do_cmp",
    (byte*)"do_shl",
    (byte*)"do_neg",
    (byte*)"do_not",
    (byte*)"do_inc",
    (byte*)"do_dec",
    (byte*)"do_setcc",
    (byte*)"do_fneg",
    (byte*)"do_fabs",
    (byte*)"do_fsqrt",
    (byte*)"do_ufix",
    (byte*)"do_ifix",
    (byte*)"do_ufloat",
    (byte*)"do_ifloat",
    (byte*)"do_db",
    (byte*)"do_dw",
    (byte*)"do_dd",
    (byte*)"do_dq",
    (byte*)"do_align",
    (byte*)"do_segment",
    (byte*)"do_assem",
    (byte*)"strmclasm",
    (byte*)"stropndx",
    (byte*)"strmclx",
    (byte*)"fgetregnamex",
    (byte*)"getstringname",
    (byte*)"getwstringname",
    (byte*)"getrealname",
    (byte*)"getsrealname",
    (byte*)"getdintname",
    (byte*)"getstringindex",
    (byte*)"getwstringindex",
    (byte*)"getrealindex",
    (byte*)"getdintindex",
    (byte*)"strvaluex",
    (byte*)"convertimm",
    (byte*)"genstringtable",
    (byte*)"genwstringtable",
    (byte*)"do_defstr",
    (byte*)"do_defwstr",
    (byte*)"genrealtable",
    (byte*)"gendinttable",
    (byte*)"writefabs",
    (byte*)"domclseq",
    (byte*)"asmstr",
    (byte*)"asmstrln",
    (byte*)"asmline",
    (byte*)"asmln",
    (byte*)"asmint",
    (byte*)"asmchar",
    (byte*)"asmterm",
    (byte*)"initasmline",
    (byte*)"getregnamex",
    (byte*)"genstring",
    (byte*)"genwstring",
    (byte*)"extendrealtable",
    (byte*)"extenddinttable",
    (byte*)"extendstringtable",
    (byte*)"writemheader",
    (byte*)"showmacroseq",
    (byte*)"mmstr",
    (byte*)"mmleftstr",
    (byte*)"mmstrln",
    (byte*)"mmint",
    (byte*)"mmline",
    (byte*)"writefunction",
    (byte*)"mmmode",
    (byte*)"writerecord",
    (byte*)"writefnptr",
    (byte*)"fixname",
    (byte*)"assembler",
    (byte*)"loadsourcefiles",
    (byte*)"parsemodules",
    (byte*)"fixopnd",
    (byte*)"initall",
    (byte*)"loaderror",
    (byte*)"loaderror_s",
    (byte*)"addmodule",
    (byte*)"addsearchlib",
    (byte*)"getemptyst",
    (byte*)"findduplname",
    (byte*)"adddupl",
    (byte*)"scanglobals",
    (byte*)"resethashtable",
    (byte*)"lex",
    (byte*)"initlex",
    (byte*)"readreal",
    (byte*)"readnumber",
    (byte*)"readbinary",
    (byte*)"readhex",
    (byte*)"ps",
    (byte*)"printsymbol",
    (byte*)"clearhashtable",
    (byte*)"inithashtable",
    (byte*)"addreservedword",
    (byte*)"printhashtable",
    (byte*)"lookuplex",
    (byte*)"initsourcefile",
    (byte*)"addnamestr",
    (byte*)"lxerror",
    (byte*)"gethashvalue",
    (byte*)"skiptoeol",
    (byte*)"makestring",
    (byte*)"readmodule",
    (byte*)"checkundefined",
    (byte*)"checksymbol",
    (byte*)"readinstr",
    (byte*)"readcondinstr",
    (byte*)"readoperand",
    (byte*)"readexpression",
    (byte*)"readterm",
    (byte*)"readreg",
    (byte*)"readaddrmode",
    (byte*)"initlib",
    (byte*)"genmc",
    (byte*)"genmcstr",
    (byte*)"newopnd",
    (byte*)"genxreg",
    (byte*)"genindex",
    (byte*)"writemclblock",
    (byte*)"gencomment",
    (byte*)"genstrimm",
    (byte*)"getsizetag",
    (byte*)"writemcl",
    (byte*)"strmcl",
    (byte*)"stropnd",
    (byte*)"strdef",
    (byte*)"setsegment",
    (byte*)"getsizeprefix",
    (byte*)"needsizeprefix",
    (byte*)"genimm_expr",
    (byte*)"genint",
    (byte*)"genlab",
    (byte*)"genmem",
    (byte*)"genreg0",
    (byte*)"getfullname",
    (byte*)"getregname",
    (byte*)"xgetregname",
    (byte*)"printst",
    (byte*)"printstrec",
    (byte*)"adddef",
    (byte*)"addimport",
    (byte*)"createlabel",
    (byte*)"createnamedconst",
    (byte*)"gerror",
    (byte*)"serror",
    (byte*)"serror_s",
    (byte*)"inttostr",
    (byte*)"realtostr",
    (byte*)"buffercreate",
    (byte*)"bufferexpand",
    (byte*)"buffercheck",
    (byte*)"bufferlength",
    (byte*)"bufferelemptr",
    (byte*)"addbyte",
    (byte*)"addword",
    (byte*)"adddword",
    (byte*)"addqword",
    (byte*)"printmodulesymbols",
    (byte*)"printimportsymbols",
    (byte*)"printdupltable",
    (byte*)"genss",
    (byte*)"doinstr",
    (byte*)"genbyte",
    (byte*)"genword",
    (byte*)"gendword",
    (byte*)"genqword",
    (byte*)"genopnd",
    (byte*)"addrelocitem",
    (byte*)"getstindex",
    (byte*)"genrel32",
    (byte*)"genabs32",
    (byte*)"genabs64",
    (byte*)"getrel32",
    (byte*)"dofwdrefs",
    (byte*)"genrex",
    (byte*)"isbytesized",
    (byte*)"isdwordsized",
    (byte*)"do_push",
    (byte*)"do_pop",
    (byte*)"do_inc",
    (byte*)"do_neg",
    (byte*)"genamode",
    (byte*)"makemodrm",
    (byte*)"setopsize",
    (byte*)"setaddrsize",
    (byte*)"getdispsize",
    (byte*)"genrm",
    (byte*)"genrmbyte",
    (byte*)"makeam",
    (byte*)"do_arith",
    (byte*)"do_mov",
    (byte*)"getregcoder",
    (byte*)"getregcodeb",
    (byte*)"getregcodebx",
    (byte*)"getregcoderx",
    (byte*)"do_lea",
    (byte*)"do_movsx",
    (byte*)"checkhighreg",
    (byte*)"do_exch",
    (byte*)"do_movsxd",
    (byte*)"do_imul2",
    (byte*)"do_imul3",
    (byte*)"do_shift",
    (byte*)"do_test",
    (byte*)"do_loop",
    (byte*)"do_jcxz",
    (byte*)"do_setcc",
    (byte*)"do_movxmm",
    (byte*)"do_arithxmm",
    (byte*)"do_logicxmm",
    (byte*)"do_convertfloat",
    (byte*)"do_fix",
    (byte*)"do_float",
    (byte*)"do_call",
    (byte*)"do_jmp",
    (byte*)"getcurrdatalen",
    (byte*)"do_cmovcc",
    (byte*)"do_fmem",
    (byte*)"getr32bits",
    (byte*)"genrel8",
    (byte*)"checkshortjump",
    (byte*)"addfwdref",
    (byte*)"switchseg",
    (byte*)"do_movdqx",
    (byte*)"do_popcnt",
    (byte*)"do_bsf",
    (byte*)"extendsymboltable",
    (byte*)"do_pcmpistri",
    (byte*)"writeexe",
    (byte*)"genexe",
    (byte*)"loadlibs",
    (byte*)"writessdata",
    (byte*)"initsectiontable",
    (byte*)"showssdata",
    (byte*)"showsectiondata",
    (byte*)"showsectioncode",
    (byte*)"showsectionrelocs2",
    (byte*)"gs_value",
    (byte*)"showsymboltable2",
    (byte*)"showimporttable",
    (byte*)"roundtoblock",
    (byte*)"showsections",
    (byte*)"extractlibname",
    (byte*)"scanst",
    (byte*)"relocdata",
    (byte*)"writerecordx",
    (byte*)"writedosstub",
    (byte*)"writepesig",
    (byte*)"writepadding",
    (byte*)"writefileheader",
    (byte*)"writeoptheader",
    (byte*)"writesectionheader",
    (byte*)"writesectiondata",
    (byte*)"getoffsets",
    (byte*)"decodeinstr",
    (byte*)"decodetwobyteinstr",
    (byte*)"decodeaddr",
    (byte*)"readbyte",
    (byte*)"readsbyte",
    (byte*)"readword16",
    (byte*)"readint16",
    (byte*)"readword32",
    (byte*)"readint32",
    (byte*)"readint64",
    (byte*)"getreg",
    (byte*)"strreg",
    (byte*)"strfreg",
    (byte*)"printaddrmode",
    (byte*)"genstr",
    (byte*)"genintd",
    (byte*)"genhex",
    (byte*)"readimm",
    (byte*)"readimm8",
    (byte*)"strxmm",
    (byte*)"strmmx",
    (byte*)"decode8087",
    (byte*)"do87arith",
    (byte*)"do87mem",
    (byte*)"getsil",
    (byte*)"getsilx",
    (byte*)"writess",
    (byte*)"writerecord",
    (byte*)"writerelocs",
    (byte*)"writedata",
    (byte*)"writesymboltable",
    (byte*)"writestringtable",
    (byte*)"makesymbol",
    (byte*)"addsymbol",
    (byte*)"initsymboltable",
    (byte*)"strtoaux",
    (byte*)"sectiontoaux",
    (byte*)"addstringentry",
    (byte*)"convertsymboltable",
    (byte*)"writecoff",
(byte*)""};
static struct msysnewc_procinforec msysnewc__fnexports[]= {
	{0, 0,0, {0,0,0, 0,0,0, 0,0,0, 0,0,0}}}
;
static i64 msysnewc__fnnprocs=1031;
static i64 msysnewc__fnnexports=0;
static i64 msysnewc_fmtparam;
i64 msysnewc_needgap = (i64)0;
static i64 msysnewc_outdev = (i64)1;
static void *  msysnewc_outchan = 0;
static byte *  msysnewc_fmtstr = 0;
static void *  msysnewc_outchan_stack[10];
static i64 msysnewc_outdev_stack[10];
static byte *  msysnewc_fmtstr_stack[10];
static byte msysnewc_needgap_stack[10];
static byte *  msysnewc_ptr_stack[10];
static i64 msysnewc_niostack = (i64)0;
static byte msysnewc_digits[16] = {
    '0',
    '1',
    '2',
    '3',
    '4',
    '5',
    '6',
    '7',
    '8',
    '9',
    'A',
    'B',
    'C',
    'D',
    'E',
    'F'
};
static struct msysnewc_fmtrec msysnewc_defaultfmt = {
    (u8)0u,
    (i8)0,
    (u8)10u,
    (u64)0u,
    ' ',
    'f',
    (u64)0u,
    (u64)0u,
    (u64)0u,
    'R',
    (u64)0u,
    (u64)0u,
    (u64)0u,
    (u64)0u,
    (u64)0u,
    (u8)0u
};
static byte *  msysnewc_rd_buffer;
static i64 msysnewc_rd_length;
static byte *  msysnewc_rd_pos;
static byte *  msysnewc_rd_lastpos;
static i64 msysnewc_termchar;
static i64 msysnewc_itemerror;
i64 msysnewc_nsysparams;
byte *  msysnewc_sysparams[128];
static u64 msysnewc_callbackstack[9][8];
static i64 msysnewc_ncallbacks = (i64)0;
static u64 msysnewc_mask63 = (u64)9223372036854775807u;
static double msysnewc_offset64 = (double)9223372036854775800.;
static double msysnewc_offset32 = (double)9223372036854775800.;
i64 mlib_mdebug;
u64 mlib_allocupper[301];
i64 mlib_alloccode;
i64 mlib_allocbytes;
i64 mlib_fdebug = (i64)0;
i64 mlib_rfsize;
static u64 mlib_maxmemory;
static i64 mlib_maxalloccode;
static byte mlib_pcm_setup = (u8)0u;
static i64 mlib_show = (i64)0;
i64 mlib_memtotal = (i64)0;
i64 mlib_smallmemtotal = (i64)0;
i64 mlib_smallmemobjs = (i64)0;
i64 mlib_maxmemtotal = (i64)0;
static i32 *  mlib_memalloctable[500001];
static i32 mlib_memallocsize[500001];
static byte *  mlib_pcheapstart;
static byte *  mlib_pcheapend;
static byte *  mlib_pcheapptr;
static byte mlib_sizeindextable[2049];
u32 *  mlib_freelist[9];
byte *  mlib_pmnames[6] = {(byte*)"pm_end",(byte*)"pm_option",(byte*)"pm_sourcefile",(byte*)"pm_libfile",(byte*)"pm_colon",(byte*)"pm_extra"};
static i64 mlib_seed[2] = {(i64)2993073034246558322,(i64)1617678968452121188};
static i64 osnos_init_flag = (i64)0;
i64 cc_decls_ntypes;
i64 cc_decls_ntypesreset;
struct cc_decls_strec *  cc_decls_ttnamedef[20000];
i64 cc_decls_ttbasetype[20000];
i64 cc_decls_ttlength[20000];
byte cc_decls_ttconst[20000];
byte cc_decls_ttrestrict[20000];
byte cc_decls_ttvolatile[20000];
i64 cc_decls_ttusertype[20000];
i64 cc_decls_tttarget[20000];
i64 cc_decls_ttreftype[20000];
i64 cc_decls_ttconsttype[20000];
i64 cc_decls_ttsize[20000];
i64 cc_decls_ttbitwidth[20000];
byte cc_decls_ttisref[20000];
struct cc_decls_paramrec *  cc_decls_ttparams[20000];
struct cc_decls_strec *  cc_decls_tttypedef[20000];
i64 cc_decls_trefchar;
i64 cc_decls_trefwchar;
struct cc_decls_modulerec cc_decls_moduletable[201];
byte *  cc_decls_inputfiles[201];
byte *  cc_decls_libfiles[201];
byte *  cc_decls_sourcefilenames[601];
byte *  cc_decls_sourcefilepaths[601];
byte *  cc_decls_sourcefiletext[601];
i32 cc_decls_sourcefilesizes[601];
byte *  cc_decls_automodulenames[201];
i64 cc_decls_nmodules;
i64 cc_decls_nautomodules;
i64 cc_decls_nsourcefiles;
i64 cc_decls_ninputfiles;
i64 cc_decls_nlibfiles;
i64 cc_decls_currmoduleno;
struct cc_decls_modulerec *  cc_decls_currmodule;
byte *  cc_decls_searchdirs[20];
i64 cc_decls_nsearchdirs = (i64)0;
byte *  cc_decls_includepaths[20];
i64 cc_decls_nincludepaths = (i64)0;
struct cc_decls_strec *  cc_decls_stprogram;
struct cc_decls_strec *  cc_decls_stmodule;
void *  cc_decls_logdev;
i64 cc_decls_logdest = (i64)0;
i64 cc_decls_optflag = (i64)0;
struct cc_decls_unitrec *  cc_decls_nullunit;
i64 cc_decls_fverbose = (i64)0;
i64 cc_decls_fquiet = (i64)0;
i64 cc_decls_fshownames = (i64)0;
i64 cc_decls_fshowincludes = (i64)0;
i64 cc_decls_fautomodules = (i64)0;
i64 cc_decls_fmodern = (i64)1;
i64 cc_decls_foptimise = (i64)0;
i64 cc_decls_wintarget = (i64)1;
i64 cc_decls_lintarget = (i64)0;
i64 cc_decls_nostarget = (i64)0;
i64 cc_decls_clineno = (i64)0;
i64 cc_decls_fastasm = (i64)0;
i64 cc_decls_fcallback = (i64)0;
struct cc_decls_tokenrec cc_decls_lx;
struct cc_decls_tokenrec cc_decls_nextlx;
i64 cc_decls_debug = (i64)0;
i64 cc_decls_nalllines;
i64 cc_decls_nlookups;
i64 cc_decls_nkeywords;
i64 cc_decls_hstsize = (i64)16384;
i64 cc_decls_hstmask;
struct cc_decls_strec * (*cc_decls_hashtable)[];
i32 cc_decls_blockowner[2101];
i32 cc_decls_blockcounts[2101];
i32 cc_decls_blockstack[101];
i64 cc_decls_currblockno;
i64 cc_decls_nextblockno;
i64 cc_decls_blocklevel;
struct cc_decls_strec *  cc_decls_currproc;
i64 cc_decls_labelno = (i64)0;
i64 cc_decls_dointheaders = (i64)1;
byte *  cc_decls_dheaderfile = 0;
i64 cc_decls_structpadding = (i64)1;
i64 cc_decls_callbackflag = (i64)0;
i64 cc_decls_slineno;
i64 cc_decls_sfileno;
byte *  cc_decls_oemname = (byte*)"BCC";
i64 cc_decls_nformats;
i64 cc_decls_ngoto;
i64 cc_decls_nbreak;
i64 cc_decls_nbreaksw;
i64 cc_decls_nblocks;
i64 cc_decls_ncompoundblocks;
i64 cc_decls_nlines;
i64 cc_decls_nsemis;
i64 cc_decls_nsemilines;
byte *  cc_tables_stdtypenames[23] = {
    (byte*)"none",
    (byte*)"void",
    (byte*)"schar",
    (byte*)"short",
    (byte*)"int",
    (byte*)"llong",
    (byte*)"bool",
    (byte*)"uchar",
    (byte*)"ushort",
    (byte*)"uint",
    (byte*)"ullong",
    (byte*)"float",
    (byte*)"double",
    (byte*)"ldouble",
    (byte*)"complex",
    (byte*)"enum",
    (byte*)"ref",
    (byte*)"proc",
    (byte*)"label",
    (byte*)"array",
    (byte*)"struct",
    (byte*)"union",
    (byte*)"tlast"
};
byte cc_tables_stdtypewidths[23] = {
    (u8)0u,
    (u8)0u,
    (u8)8u,
    (u8)16u,
    (u8)32u,
    (u8)64u,
    (u8)8u,
    (u8)8u,
    (u8)16u,
    (u8)32u,
    (u8)64u,
    (u8)32u,
    (u8)64u,
    (u8)128u,
    (u8)128u,
    (u8)0u,
    (u8)64u,
    (u8)64u,
    (u8)64u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u
};
byte cc_tables_stdtypesigned[23] = {
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u
};
byte cc_tables_stdexpandtypes[23] = {
    (u8)0u,
    (u8)0u,
    (u8)4u,
    (u8)4u,
    (u8)0u,
    (u8)0u,
    (u8)9u,
    (u8)9u,
    (u8)9u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u
};
byte cc_tables_stdtypecat[23] = {
    (u8)0u,
    (u8)0u,
    (u8)73u,
    (u8)73u,
    (u8)73u,
    (u8)73u,
    (u8)85u,
    (u8)85u,
    (u8)85u,
    (u8)85u,
    (u8)85u,
    (u8)82u,
    (u8)82u,
    (u8)82u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u
};
byte *  cc_tables_stdtypemnames[23] = {
    (byte*)"",
    (byte*)"void",
    (byte*)"i8",
    (byte*)"i16",
    (byte*)"i32",
    (byte*)"i64",
    (byte*)"byte",
    (byte*)"byte",
    (byte*)"u16",
    (byte*)"u32",
    (byte*)"u64",
    (byte*)"r32",
    (byte*)"r64",
    (byte*)"r64",
    (byte*)"",
    (byte*)"",
    (byte*)"",
    (byte*)"",
    (byte*)"",
    (byte*)"",
    (byte*)"",
    (byte*)"",
    (byte*)""
};
byte *  cc_tables_typespecnames[16] = {
    (byte*)"ts_void",
    (byte*)"ts_char",
    (byte*)"ts_short",
    (byte*)"ts_long",
    (byte*)"ts_int",
    (byte*)"ts_float",
    (byte*)"ts_double",
    (byte*)"ts_signed",
    (byte*)"ts_unsigned",
    (byte*)"ts_bool",
    (byte*)"ts_complex",
    (byte*)"ts_user",
    (byte*)"ts_struct",
    (byte*)"ts_union",
    (byte*)"ts_enum",
    (byte*)"ts_atomic"
};
i32 cc_tables_typespectypes[16] = {
    (i32)1,
    (i32)2,
    (i32)0,
    (i32)0,
    (i32)4,
    (i32)11,
    (i32)12,
    (i32)0,
    (i32)0,
    (i32)6,
    (i32)14,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0
};
byte cc_tables_typespecsizes[16] = {
    (u8)0u,
    (u8)1u,
    (u8)2u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)8u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)4u,
    (u8)0u
};
byte *  cc_tables_pmflagnames[4] = {(byte*)"pm_normal",(byte*)"pm_notset",(byte*)"pm_empty",(byte*)"pm_variadic"};
byte *  cc_tables_scopenames[5] = {(byte*)"-",(byte*)"Fn",(byte*)"Loc",(byte*)"Imp",(byte*)"Exp"};
byte *  cc_tables_ccnames[6] = {(byte*)"open_cc",(byte*)"own_cc",(byte*)"clang_cc",(byte*)"stdcall_cc",(byte*)"callback_cc",(byte*)"dummy_cc"};
byte *  cc_tables_linkagenames[6] = {(byte*)"none_ss",(byte*)"static_ss",(byte*)"auto_ss",(byte*)"register_ss",(byte*)"extern_ss",(byte*)"typedef_ss"};
byte *  cc_tables_typequalnames[4] = {(byte*)"const_qual",(byte*)"volatile_qual",(byte*)"restrict_qual",(byte*)"atomic_qual"};
byte *  cc_tables_fnspecnames[3] = {(byte*)"inline_fnspec",(byte*)"noreturn_fnspec",(byte*)"callback_fnspec"};
byte *  cc_tables_jtagnames[79] = {
    (byte*)"j_none",
    (byte*)"j_const",
    (byte*)"j_null",
    (byte*)"j_name",
    (byte*)"j_widenmem",
    (byte*)"j_funcname",
    (byte*)"j_block",
    (byte*)"j_tempdecl",
    (byte*)"j_decl",
    (byte*)"j_callproc",
    (byte*)"j_return",
    (byte*)"j_returnx",
    (byte*)"j_assign",
    (byte*)"j_if",
    (byte*)"j_for",
    (byte*)"j_while",
    (byte*)"j_dowhile",
    (byte*)"j_goto",
    (byte*)"j_labelstmt",
    (byte*)"j_casestmt",
    (byte*)"j_defaultstmt",
    (byte*)"j_break",
    (byte*)"j_continue",
    (byte*)"j_switch",
    (byte*)"j_breaksw",
    (byte*)"&& andl",
    (byte*)"|| orl",
    (byte*)"! notl",
    (byte*)"j_istruel",
    (byte*)"j_makelist",
    (byte*)"j_exprlist",
    (byte*)"j_callfn",
    (byte*)"j_ifx",
    (byte*)"&&",
    (byte*)"==",
    (byte*)"!=",
    (byte*)"<",
    (byte*)"<=",
    (byte*)">",
    (byte*)">=",
    (byte*)"+ add",
    (byte*)"- sub",
    (byte*)"* mul",
    (byte*)"/ div",
    (byte*)"% mod",
    (byte*)"& iand",
    (byte*)"| ior",
    (byte*)"^ ixor",
    (byte*)"<<",
    (byte*)">>",
    (byte*)"j_dot",
    (byte*)"j_idot",
    (byte*)"j_index",
    (byte*)"ptr",
    (byte*)"addptr",
    (byte*)"subptr",
    (byte*)"addrof &",
    (byte*)"j_convert",
    (byte*)"j_scale",
    (byte*)"- neg",
    (byte*)"abs",
    (byte*)"~ inot",
    (byte*)"+=",
    (byte*)"-=",
    (byte*)"*=",
    (byte*)"/=",
    (byte*)"%=",
    (byte*)"&=",
    (byte*)"|=",
    (byte*)"^=",
    (byte*)"<<=",
    (byte*)">>=",
    (byte*)"sqrt",
    (byte*)"++ preincr",
    (byte*)"-- preincr",
    (byte*)"++ postincr",
    (byte*)"-- postdecr",
    (byte*)"cputime",
    (byte*)"j_dummy"
};
byte *  cc_tables_symbolnames[104] = {
    (byte*)"errorsym",
    (byte*)"dotsym",
    (byte*)"idotsym",
    (byte*)"lexhashsym",
    (byte*)"hashsym",
    (byte*)"lithashsym",
    (byte*)"hashhashsym",
    (byte*)"commasym",
    (byte*)"semisym",
    (byte*)"colonsym",
    (byte*)"assignsym",
    (byte*)"lbracksym",
    (byte*)"rbracksym",
    (byte*)"lsqsym",
    (byte*)"rsqsym",
    (byte*)"lcurlysym",
    (byte*)"rcurlysym",
    (byte*)"questionsym",
    (byte*)"curlsym",
    (byte*)"ellipsissym",
    (byte*)"backslashsym",
    (byte*)"addsym",
    (byte*)"subsym",
    (byte*)"mulsym",
    (byte*)"divsym",
    (byte*)"remsym",
    (byte*)"iorsym",
    (byte*)"iandsym",
    (byte*)"ixorsym",
    (byte*)"orlsym",
    (byte*)"andlsym",
    (byte*)"shlsym",
    (byte*)"shrsym",
    (byte*)"inotsym",
    (byte*)"notlsym",
    (byte*)"incrsym",
    (byte*)"decrsym",
    (byte*)"abssym",
    (byte*)"eqsym",
    (byte*)"nesym",
    (byte*)"ltsym",
    (byte*)"lesym",
    (byte*)"gesym",
    (byte*)"gtsym",
    (byte*)"addtosym",
    (byte*)"subtosym",
    (byte*)"multosym",
    (byte*)"divtosym",
    (byte*)"remtosym",
    (byte*)"iortosym",
    (byte*)"iandtosym",
    (byte*)"ixortosym",
    (byte*)"shltosym",
    (byte*)"shrtosym",
    (byte*)"sqrtsym",
    (byte*)"eolsym",
    (byte*)"eofsym",
    (byte*)"rawnumbersym",
    (byte*)"intconstsym",
    (byte*)"realconstsym",
    (byte*)"charconstsym",
    (byte*)"wcharconstsym",
    (byte*)"stringconstsym",
    (byte*)"wstringconstsym",
    (byte*)"whitespacesym",
    (byte*)"placeholdersym",
    (byte*)"kstrincludesym",
    (byte*)"namesym",
    (byte*)"ksourcedirsym",
    (byte*)"predefmacrosym",
    (byte*)"ktypespecsym",
    (byte*)"kifsym",
    (byte*)"kelsesym",
    (byte*)"kcasesym",
    (byte*)"kdefaultsym",
    (byte*)"kforsym",
    (byte*)"kwhilesym",
    (byte*)"kdosym",
    (byte*)"kreturnsym",
    (byte*)"kbreaksym",
    (byte*)"kcontinuesym",
    (byte*)"kgotosym",
    (byte*)"kswitchsym",
    (byte*)"kstructsym",
    (byte*)"kunionsym",
    (byte*)"klinkagesym",
    (byte*)"ktypequalsym",
    (byte*)"kfnspecsym",
    (byte*)"kalignassym",
    (byte*)"kenumsym",
    (byte*)"ksizeofsym",
    (byte*)"klengthofsym",
    (byte*)"kdefinedsym",
    (byte*)"kgenericsym",
    (byte*)"kalignofsym",
    (byte*)"kshowmodesym",
    (byte*)"kshowtypesym",
    (byte*)"ktypeofsym",
    (byte*)"kstrtypesym",
    (byte*)"kmccassertsym",
    (byte*)"kcputimesym",
    (byte*)"kconstantsym",
    (byte*)"kstructinfosym",
    (byte*)"kdummysym"
};
byte *  cc_tables_shortsymbolnames[104] = {
    (byte*)"",
    (byte*)".",
    (byte*)"->",
    (byte*)"#",
    (byte*)"#",
    (byte*)"#",
    (byte*)"##",
    (byte*)",",
    (byte*)";",
    (byte*)":",
    (byte*)"=",
    (byte*)"(",
    (byte*)")",
    (byte*)"[",
    (byte*)"]",
    (byte*)"{",
    (byte*)"}",
    (byte*)"?",
    (byte*)"~",
    (byte*)"...",
    (byte*)"\\",
    (byte*)"+",
    (byte*)"-",
    (byte*)"*",
    (byte*)"/",
    (byte*)"%",
    (byte*)"|",
    (byte*)"&",
    (byte*)"^",
    (byte*)"||",
    (byte*)"&&",
    (byte*)"<<",
    (byte*)">>",
    (byte*)"~",
    (byte*)"!",
    (byte*)"++",
    (byte*)"--",
    (byte*)"abs",
    (byte*)"==",
    (byte*)"!=",
    (byte*)"<",
    (byte*)"<=",
    (byte*)">=",
    (byte*)">",
    (byte*)"+=",
    (byte*)"-=",
    (byte*)"*=",
    (byte*)"/=",
    (byte*)"%=",
    (byte*)"|=",
    (byte*)"&=",
    (byte*)"^=",
    (byte*)"<<=",
    (byte*)">>=",
    (byte*)"sqrt",
    (byte*)"",
    (byte*)"",
    (byte*)"n",
    (byte*)"n",
    (byte*)"n",
    (byte*)"s",
    (byte*)"s",
    (byte*)"s",
    (byte*)"s",
    (byte*)"w",
    (byte*)"",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)"k",
    (byte*)""
};
byte cc_tables_symboltojtag[104] = {
    (u8)0u,
    (u8)50u,
    (u8)51u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)12u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)40u,
    (u8)41u,
    (u8)42u,
    (u8)43u,
    (u8)44u,
    (u8)46u,
    (u8)45u,
    (u8)47u,
    (u8)26u,
    (u8)25u,
    (u8)48u,
    (u8)49u,
    (u8)61u,
    (u8)27u,
    (u8)73u,
    (u8)74u,
    (u8)60u,
    (u8)34u,
    (u8)35u,
    (u8)36u,
    (u8)37u,
    (u8)39u,
    (u8)38u,
    (u8)62u,
    (u8)63u,
    (u8)64u,
    (u8)65u,
    (u8)66u,
    (u8)68u,
    (u8)67u,
    (u8)69u,
    (u8)70u,
    (u8)71u,
    (u8)72u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u
};
byte *  cc_tables_sourcedirnames[20] = {
    (byte*)"definedir",
    (byte*)"emitdir",
    (byte*)"ifdir",
    (byte*)"elifdir",
    (byte*)"elsedir",
    (byte*)"endifdir",
    (byte*)"includedir",
    (byte*)"ifdefdir",
    (byte*)"ifndefdir",
    (byte*)"undefdir",
    (byte*)"errordir",
    (byte*)"warningdir",
    (byte*)"messagedir",
    (byte*)"pausedir",
    (byte*)"debugondir",
    (byte*)"debugoffdir",
    (byte*)"showmacrodir",
    (byte*)"blankdir",
    (byte*)"linedir",
    (byte*)"pragmadir"
};
byte *  cc_tables_namespacenames[5] = {(byte*)"ns_none",(byte*)"ns_general",(byte*)"ns_tags",(byte*)"ns_labels",(byte*)"ns_fields"};
byte *  cc_tables_namenames[16] = {
    (byte*)"nullid",
    (byte*)"macroid",
    (byte*)"programid",
    (byte*)"moduleid",
    (byte*)"extmoduleid",
    (byte*)"typeid",
    (byte*)"procid",
    (byte*)"staticid",
    (byte*)"frameid",
    (byte*)"paramid",
    (byte*)"fieldid",
    (byte*)"enumid",
    (byte*)"enumtagid",
    (byte*)"structtagid",
    (byte*)"constantid",
    (byte*)"labelid"
};
i32 cc_tables_namespaces[16] = {
    (i32)1,
    (i32)1,
    (i32)1,
    (i32)1,
    (i32)1,
    (i32)2,
    (i32)2,
    (i32)2,
    (i32)2,
    (i32)2,
    (i32)5,
    (i32)2,
    (i32)3,
    (i32)3,
    (i32)2,
    (i32)4
};
byte *  cc_tables_stnames[77] = {
    (byte*)"if",
    (byte*)"else",
    (byte*)"case",
    (byte*)"default",
    (byte*)"for",
    (byte*)"do",
    (byte*)"while",
    (byte*)"return",
    (byte*)"break",
    (byte*)"continue",
    (byte*)"goto",
    (byte*)"switch",
    (byte*)"struct",
    (byte*)"union",
    (byte*)"include",
    (byte*)"define",
    (byte*)"elif",
    (byte*)"ifdef",
    (byte*)"ifndef",
    (byte*)"endif",
    (byte*)"undef",
    (byte*)"error",
    (byte*)"warning",
    (byte*)"message",
    (byte*)"MESSAGE",
    (byte*)"pragma",
    (byte*)"line",
    (byte*)"pause",
    (byte*)"debugon",
    (byte*)"debugoff",
    (byte*)"showmacro",
    (byte*)"strinclude",
    (byte*)"auto",
    (byte*)"register",
    (byte*)"static",
    (byte*)"extern",
    (byte*)"typedef",
    (byte*)"const",
    (byte*)"volatile",
    (byte*)"restrict",
    (byte*)"_Atomic",
    (byte*)"inline",
    (byte*)"_Noreturn",
    (byte*)"$callback",
    (byte*)"_Alignas",
    (byte*)"enum",
    (byte*)"void",
    (byte*)"char",
    (byte*)"short",
    (byte*)"long",
    (byte*)"int",
    (byte*)"float",
    (byte*)"double",
    (byte*)"signed",
    (byte*)"unsigned",
    (byte*)"_Bool",
    (byte*)"_Complex",
    (byte*)"__DATE__",
    (byte*)"__FILE__",
    (byte*)"__LINE__",
    (byte*)"__TIME__",
    (byte*)"__BCC__",
    (byte*)"__func__",
    (byte*)"__FUNCTION__",
    (byte*)"sizeof",
    (byte*)"$sqrt",
    (byte*)"defined",
    (byte*)"_Generic",
    (byte*)"_Alignof",
    (byte*)"$showmode",
    (byte*)"$showtype",
    (byte*)"typeof",
    (byte*)"strtype",
    (byte*)"_Static_assert",
    (byte*)"cputime",
    (byte*)"structinfo",
    (byte*)"$$dummy"
};
i32 cc_tables_stsymbols[77] = {
    (i32)72,
    (i32)73,
    (i32)74,
    (i32)75,
    (i32)76,
    (i32)78,
    (i32)77,
    (i32)79,
    (i32)80,
    (i32)81,
    (i32)82,
    (i32)83,
    (i32)84,
    (i32)85,
    (i32)69,
    (i32)69,
    (i32)69,
    (i32)69,
    (i32)69,
    (i32)69,
    (i32)69,
    (i32)69,
    (i32)69,
    (i32)69,
    (i32)69,
    (i32)69,
    (i32)69,
    (i32)69,
    (i32)69,
    (i32)69,
    (i32)69,
    (i32)67,
    (i32)86,
    (i32)86,
    (i32)86,
    (i32)86,
    (i32)86,
    (i32)87,
    (i32)87,
    (i32)87,
    (i32)87,
    (i32)88,
    (i32)88,
    (i32)88,
    (i32)89,
    (i32)90,
    (i32)71,
    (i32)71,
    (i32)71,
    (i32)71,
    (i32)71,
    (i32)71,
    (i32)71,
    (i32)71,
    (i32)71,
    (i32)71,
    (i32)71,
    (i32)70,
    (i32)70,
    (i32)70,
    (i32)70,
    (i32)70,
    (i32)70,
    (i32)70,
    (i32)91,
    (i32)55,
    (i32)93,
    (i32)94,
    (i32)95,
    (i32)96,
    (i32)97,
    (i32)98,
    (i32)99,
    (i32)100,
    (i32)101,
    (i32)103,
    (i32)0
};
i32 cc_tables_stsubcodes[77] = {
    (i32)13,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)7,
    (i32)1,
    (i32)4,
    (i32)8,
    (i32)9,
    (i32)6,
    (i32)10,
    (i32)11,
    (i32)12,
    (i32)13,
    (i32)13,
    (i32)20,
    (i32)19,
    (i32)14,
    (i32)15,
    (i32)16,
    (i32)17,
    (i32)0,
    (i32)2,
    (i32)3,
    (i32)1,
    (i32)4,
    (i32)5,
    (i32)1,
    (i32)2,
    (i32)3,
    (i32)4,
    (i32)1,
    (i32)2,
    (i32)3,
    (i32)0,
    (i32)0,
    (i32)1,
    (i32)2,
    (i32)3,
    (i32)4,
    (i32)5,
    (i32)6,
    (i32)7,
    (i32)8,
    (i32)9,
    (i32)2,
    (i32)11,
    (i32)1,
    (i32)3,
    (i32)4,
    (i32)2,
    (i32)7,
    (i32)5,
    (i32)5,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0,
    (i32)0
};
byte *  cc_tables_convnames[14] = {
    (byte*)"no_conv",
    (byte*)"soft_c",
    (byte*)"hard_c",
    (byte*)"swiden_c",
    (byte*)"uwiden_c",
    (byte*)"sfloat_c",
    (byte*)"ufloat_c",
    (byte*)"sfix_c",
    (byte*)"ufix_c",
    (byte*)"fwiden_c",
    (byte*)"fnarrow_c",
    (byte*)"narrow_c",
    (byte*)"truncate_c",
    (byte*)"bool_c"
};
byte cc_tables_dominantmode[32][32];
byte cc_tables_conversionops[16][16];
byte cc_tables_dominantsetuptable[144][3] = {
    {(u8)2u,(u8)2u,(u8)4u},
    {(u8)2u,(u8)3u,(u8)4u},
    {(u8)2u,(u8)4u,(u8)4u},
    {(u8)2u,(u8)5u,(u8)5u},
    {(u8)2u,(u8)6u,(u8)4u},
    {(u8)2u,(u8)7u,(u8)4u},
    {(u8)2u,(u8)8u,(u8)4u},
    {(u8)2u,(u8)9u,(u8)4u},
    {(u8)2u,(u8)10u,(u8)5u},
    {(u8)2u,(u8)11u,(u8)11u},
    {(u8)2u,(u8)12u,(u8)12u},
    {(u8)2u,(u8)13u,(u8)13u},
    {(u8)3u,(u8)2u,(u8)4u},
    {(u8)3u,(u8)3u,(u8)4u},
    {(u8)3u,(u8)4u,(u8)4u},
    {(u8)3u,(u8)5u,(u8)5u},
    {(u8)3u,(u8)6u,(u8)4u},
    {(u8)3u,(u8)7u,(u8)4u},
    {(u8)3u,(u8)8u,(u8)4u},
    {(u8)3u,(u8)9u,(u8)4u},
    {(u8)3u,(u8)10u,(u8)5u},
    {(u8)3u,(u8)11u,(u8)11u},
    {(u8)3u,(u8)12u,(u8)12u},
    {(u8)3u,(u8)13u,(u8)13u},
    {(u8)4u,(u8)2u,(u8)4u},
    {(u8)4u,(u8)3u,(u8)4u},
    {(u8)4u,(u8)4u,(u8)4u},
    {(u8)4u,(u8)5u,(u8)5u},
    {(u8)4u,(u8)6u,(u8)4u},
    {(u8)4u,(u8)7u,(u8)4u},
    {(u8)4u,(u8)8u,(u8)4u},
    {(u8)4u,(u8)9u,(u8)9u},
    {(u8)4u,(u8)10u,(u8)5u},
    {(u8)4u,(u8)11u,(u8)11u},
    {(u8)4u,(u8)12u,(u8)12u},
    {(u8)4u,(u8)13u,(u8)13u},
    {(u8)5u,(u8)2u,(u8)5u},
    {(u8)5u,(u8)3u,(u8)5u},
    {(u8)5u,(u8)4u,(u8)5u},
    {(u8)5u,(u8)5u,(u8)5u},
    {(u8)5u,(u8)6u,(u8)5u},
    {(u8)5u,(u8)7u,(u8)5u},
    {(u8)5u,(u8)8u,(u8)5u},
    {(u8)5u,(u8)9u,(u8)5u},
    {(u8)5u,(u8)10u,(u8)10u},
    {(u8)5u,(u8)11u,(u8)11u},
    {(u8)5u,(u8)12u,(u8)12u},
    {(u8)5u,(u8)13u,(u8)13u},
    {(u8)6u,(u8)2u,(u8)4u},
    {(u8)6u,(u8)3u,(u8)4u},
    {(u8)6u,(u8)4u,(u8)4u},
    {(u8)6u,(u8)5u,(u8)5u},
    {(u8)6u,(u8)6u,(u8)9u},
    {(u8)6u,(u8)7u,(u8)9u},
    {(u8)6u,(u8)8u,(u8)9u},
    {(u8)6u,(u8)9u,(u8)9u},
    {(u8)6u,(u8)10u,(u8)10u},
    {(u8)6u,(u8)11u,(u8)11u},
    {(u8)6u,(u8)12u,(u8)12u},
    {(u8)6u,(u8)13u,(u8)13u},
    {(u8)7u,(u8)2u,(u8)4u},
    {(u8)7u,(u8)3u,(u8)4u},
    {(u8)7u,(u8)4u,(u8)4u},
    {(u8)7u,(u8)5u,(u8)5u},
    {(u8)7u,(u8)6u,(u8)0u},
    {(u8)7u,(u8)7u,(u8)9u},
    {(u8)7u,(u8)8u,(u8)9u},
    {(u8)7u,(u8)9u,(u8)9u},
    {(u8)7u,(u8)10u,(u8)10u},
    {(u8)7u,(u8)11u,(u8)11u},
    {(u8)7u,(u8)12u,(u8)12u},
    {(u8)7u,(u8)13u,(u8)13u},
    {(u8)8u,(u8)2u,(u8)4u},
    {(u8)8u,(u8)3u,(u8)4u},
    {(u8)8u,(u8)4u,(u8)4u},
    {(u8)8u,(u8)5u,(u8)5u},
    {(u8)8u,(u8)6u,(u8)9u},
    {(u8)8u,(u8)7u,(u8)9u},
    {(u8)8u,(u8)8u,(u8)9u},
    {(u8)8u,(u8)9u,(u8)9u},
    {(u8)8u,(u8)10u,(u8)10u},
    {(u8)8u,(u8)11u,(u8)11u},
    {(u8)8u,(u8)12u,(u8)12u},
    {(u8)8u,(u8)13u,(u8)13u},
    {(u8)9u,(u8)2u,(u8)4u},
    {(u8)9u,(u8)3u,(u8)4u},
    {(u8)9u,(u8)4u,(u8)9u},
    {(u8)9u,(u8)5u,(u8)5u},
    {(u8)9u,(u8)6u,(u8)9u},
    {(u8)9u,(u8)7u,(u8)9u},
    {(u8)9u,(u8)8u,(u8)9u},
    {(u8)9u,(u8)9u,(u8)9u},
    {(u8)9u,(u8)10u,(u8)10u},
    {(u8)9u,(u8)11u,(u8)11u},
    {(u8)9u,(u8)12u,(u8)12u},
    {(u8)9u,(u8)13u,(u8)13u},
    {(u8)10u,(u8)2u,(u8)10u},
    {(u8)10u,(u8)3u,(u8)10u},
    {(u8)10u,(u8)4u,(u8)10u},
    {(u8)10u,(u8)5u,(u8)10u},
    {(u8)10u,(u8)6u,(u8)10u},
    {(u8)10u,(u8)7u,(u8)10u},
    {(u8)10u,(u8)8u,(u8)10u},
    {(u8)10u,(u8)9u,(u8)10u},
    {(u8)10u,(u8)10u,(u8)10u},
    {(u8)10u,(u8)11u,(u8)11u},
    {(u8)10u,(u8)12u,(u8)12u},
    {(u8)10u,(u8)13u,(u8)13u},
    {(u8)11u,(u8)2u,(u8)12u},
    {(u8)11u,(u8)3u,(u8)12u},
    {(u8)11u,(u8)4u,(u8)12u},
    {(u8)11u,(u8)5u,(u8)12u},
    {(u8)11u,(u8)6u,(u8)12u},
    {(u8)11u,(u8)7u,(u8)12u},
    {(u8)11u,(u8)8u,(u8)12u},
    {(u8)11u,(u8)9u,(u8)12u},
    {(u8)11u,(u8)10u,(u8)12u},
    {(u8)11u,(u8)11u,(u8)11u},
    {(u8)11u,(u8)12u,(u8)12u},
    {(u8)11u,(u8)13u,(u8)13u},
    {(u8)12u,(u8)2u,(u8)12u},
    {(u8)12u,(u8)3u,(u8)12u},
    {(u8)12u,(u8)4u,(u8)12u},
    {(u8)12u,(u8)5u,(u8)12u},
    {(u8)12u,(u8)6u,(u8)12u},
    {(u8)12u,(u8)7u,(u8)12u},
    {(u8)12u,(u8)8u,(u8)12u},
    {(u8)12u,(u8)9u,(u8)12u},
    {(u8)12u,(u8)10u,(u8)12u},
    {(u8)12u,(u8)11u,(u8)12u},
    {(u8)12u,(u8)12u,(u8)12u},
    {(u8)12u,(u8)13u,(u8)13u},
    {(u8)13u,(u8)2u,(u8)12u},
    {(u8)13u,(u8)3u,(u8)12u},
    {(u8)13u,(u8)4u,(u8)12u},
    {(u8)13u,(u8)5u,(u8)12u},
    {(u8)13u,(u8)6u,(u8)12u},
    {(u8)13u,(u8)7u,(u8)12u},
    {(u8)13u,(u8)8u,(u8)12u},
    {(u8)13u,(u8)9u,(u8)12u},
    {(u8)13u,(u8)10u,(u8)12u},
    {(u8)13u,(u8)11u,(u8)12u},
    {(u8)13u,(u8)12u,(u8)12u},
    {(u8)13u,(u8)13u,(u8)13u}
};
byte cc_tables_convsetuptable[144][3] = {
    {(u8)2u,(u8)2u,(u8)3u},
    {(u8)2u,(u8)3u,(u8)3u},
    {(u8)2u,(u8)4u,(u8)3u},
    {(u8)2u,(u8)5u,(u8)3u},
    {(u8)2u,(u8)6u,(u8)13u},
    {(u8)2u,(u8)7u,(u8)1u},
    {(u8)2u,(u8)8u,(u8)3u},
    {(u8)2u,(u8)9u,(u8)3u},
    {(u8)2u,(u8)10u,(u8)3u},
    {(u8)2u,(u8)11u,(u8)5u},
    {(u8)2u,(u8)12u,(u8)5u},
    {(u8)2u,(u8)13u,(u8)5u},
    {(u8)3u,(u8)2u,(u8)12u},
    {(u8)3u,(u8)3u,(u8)0u},
    {(u8)3u,(u8)4u,(u8)3u},
    {(u8)3u,(u8)5u,(u8)3u},
    {(u8)3u,(u8)6u,(u8)13u},
    {(u8)3u,(u8)7u,(u8)12u},
    {(u8)3u,(u8)8u,(u8)1u},
    {(u8)3u,(u8)9u,(u8)3u},
    {(u8)3u,(u8)10u,(u8)3u},
    {(u8)3u,(u8)11u,(u8)5u},
    {(u8)3u,(u8)12u,(u8)5u},
    {(u8)3u,(u8)13u,(u8)5u},
    {(u8)4u,(u8)2u,(u8)12u},
    {(u8)4u,(u8)3u,(u8)12u},
    {(u8)4u,(u8)4u,(u8)0u},
    {(u8)4u,(u8)5u,(u8)3u},
    {(u8)4u,(u8)6u,(u8)13u},
    {(u8)4u,(u8)7u,(u8)12u},
    {(u8)4u,(u8)8u,(u8)12u},
    {(u8)4u,(u8)9u,(u8)1u},
    {(u8)4u,(u8)10u,(u8)3u},
    {(u8)4u,(u8)11u,(u8)5u},
    {(u8)4u,(u8)12u,(u8)5u},
    {(u8)4u,(u8)13u,(u8)5u},
    {(u8)5u,(u8)2u,(u8)12u},
    {(u8)5u,(u8)3u,(u8)12u},
    {(u8)5u,(u8)4u,(u8)12u},
    {(u8)5u,(u8)5u,(u8)0u},
    {(u8)5u,(u8)6u,(u8)13u},
    {(u8)5u,(u8)7u,(u8)12u},
    {(u8)5u,(u8)8u,(u8)12u},
    {(u8)5u,(u8)9u,(u8)12u},
    {(u8)5u,(u8)10u,(u8)1u},
    {(u8)5u,(u8)11u,(u8)5u},
    {(u8)5u,(u8)12u,(u8)5u},
    {(u8)5u,(u8)13u,(u8)5u},
    {(u8)6u,(u8)2u,(u8)1u},
    {(u8)6u,(u8)3u,(u8)4u},
    {(u8)6u,(u8)4u,(u8)4u},
    {(u8)6u,(u8)5u,(u8)4u},
    {(u8)6u,(u8)6u,(u8)0u},
    {(u8)6u,(u8)7u,(u8)1u},
    {(u8)6u,(u8)8u,(u8)4u},
    {(u8)6u,(u8)9u,(u8)4u},
    {(u8)6u,(u8)10u,(u8)4u},
    {(u8)6u,(u8)11u,(u8)6u},
    {(u8)6u,(u8)12u,(u8)6u},
    {(u8)6u,(u8)13u,(u8)6u},
    {(u8)7u,(u8)2u,(u8)1u},
    {(u8)7u,(u8)3u,(u8)4u},
    {(u8)7u,(u8)4u,(u8)4u},
    {(u8)7u,(u8)5u,(u8)4u},
    {(u8)7u,(u8)6u,(u8)13u},
    {(u8)7u,(u8)7u,(u8)1u},
    {(u8)7u,(u8)8u,(u8)4u},
    {(u8)7u,(u8)9u,(u8)4u},
    {(u8)7u,(u8)10u,(u8)4u},
    {(u8)7u,(u8)11u,(u8)6u},
    {(u8)7u,(u8)12u,(u8)6u},
    {(u8)7u,(u8)13u,(u8)6u},
    {(u8)8u,(u8)2u,(u8)12u},
    {(u8)8u,(u8)3u,(u8)1u},
    {(u8)8u,(u8)4u,(u8)4u},
    {(u8)8u,(u8)5u,(u8)4u},
    {(u8)8u,(u8)6u,(u8)13u},
    {(u8)8u,(u8)7u,(u8)12u},
    {(u8)8u,(u8)8u,(u8)0u},
    {(u8)8u,(u8)9u,(u8)4u},
    {(u8)8u,(u8)10u,(u8)4u},
    {(u8)8u,(u8)11u,(u8)6u},
    {(u8)8u,(u8)12u,(u8)6u},
    {(u8)8u,(u8)13u,(u8)6u},
    {(u8)9u,(u8)2u,(u8)12u},
    {(u8)9u,(u8)3u,(u8)12u},
    {(u8)9u,(u8)4u,(u8)1u},
    {(u8)9u,(u8)5u,(u8)4u},
    {(u8)9u,(u8)6u,(u8)13u},
    {(u8)9u,(u8)7u,(u8)12u},
    {(u8)9u,(u8)8u,(u8)12u},
    {(u8)9u,(u8)9u,(u8)0u},
    {(u8)9u,(u8)10u,(u8)4u},
    {(u8)9u,(u8)11u,(u8)6u},
    {(u8)9u,(u8)12u,(u8)6u},
    {(u8)9u,(u8)13u,(u8)6u},
    {(u8)10u,(u8)2u,(u8)12u},
    {(u8)10u,(u8)3u,(u8)12u},
    {(u8)10u,(u8)4u,(u8)12u},
    {(u8)10u,(u8)5u,(u8)1u},
    {(u8)10u,(u8)6u,(u8)13u},
    {(u8)10u,(u8)7u,(u8)12u},
    {(u8)10u,(u8)8u,(u8)12u},
    {(u8)10u,(u8)9u,(u8)12u},
    {(u8)10u,(u8)10u,(u8)0u},
    {(u8)10u,(u8)11u,(u8)6u},
    {(u8)10u,(u8)12u,(u8)6u},
    {(u8)10u,(u8)13u,(u8)6u},
    {(u8)11u,(u8)2u,(u8)7u},
    {(u8)11u,(u8)3u,(u8)7u},
    {(u8)11u,(u8)4u,(u8)7u},
    {(u8)11u,(u8)5u,(u8)7u},
    {(u8)11u,(u8)6u,(u8)8u},
    {(u8)11u,(u8)7u,(u8)8u},
    {(u8)11u,(u8)8u,(u8)8u},
    {(u8)11u,(u8)9u,(u8)8u},
    {(u8)11u,(u8)10u,(u8)8u},
    {(u8)11u,(u8)11u,(u8)0u},
    {(u8)11u,(u8)12u,(u8)9u},
    {(u8)11u,(u8)13u,(u8)9u},
    {(u8)12u,(u8)2u,(u8)7u},
    {(u8)12u,(u8)3u,(u8)7u},
    {(u8)12u,(u8)4u,(u8)7u},
    {(u8)12u,(u8)5u,(u8)7u},
    {(u8)12u,(u8)6u,(u8)8u},
    {(u8)12u,(u8)7u,(u8)8u},
    {(u8)12u,(u8)8u,(u8)8u},
    {(u8)12u,(u8)9u,(u8)8u},
    {(u8)12u,(u8)10u,(u8)8u},
    {(u8)12u,(u8)11u,(u8)10u},
    {(u8)12u,(u8)12u,(u8)0u},
    {(u8)12u,(u8)13u,(u8)0u},
    {(u8)13u,(u8)2u,(u8)7u},
    {(u8)13u,(u8)3u,(u8)7u},
    {(u8)13u,(u8)4u,(u8)7u},
    {(u8)13u,(u8)5u,(u8)7u},
    {(u8)13u,(u8)6u,(u8)8u},
    {(u8)13u,(u8)7u,(u8)8u},
    {(u8)13u,(u8)8u,(u8)8u},
    {(u8)13u,(u8)9u,(u8)8u},
    {(u8)13u,(u8)10u,(u8)8u},
    {(u8)13u,(u8)11u,(u8)10u},
    {(u8)13u,(u8)12u,(u8)0u},
    {(u8)13u,(u8)13u,(u8)0u}
};
i64 cc_tables_badexprs[34] = {
    (i64)1,
    (i64)3,
    (i64)32,
    (i64)25,
    (i64)26,
    (i64)27,
    (i64)28,
    (i64)30,
    (i64)33,
    (i64)34,
    (i64)35,
    (i64)36,
    (i64)37,
    (i64)39,
    (i64)38,
    (i64)40,
    (i64)41,
    (i64)42,
    (i64)43,
    (i64)44,
    (i64)45,
    (i64)46,
    (i64)47,
    (i64)48,
    (i64)49,
    (i64)50,
    (i64)51,
    (i64)52,
    (i64)53,
    (i64)54,
    (i64)55,
    (i64)59,
    (i64)60,
    (i64)61
};
byte cc_support_bytemasks[8] = {(u8)1u,(u8)2u,(u8)4u,(u8)8u,(u8)16u,(u8)32u,(u8)64u,(u8)128u};
static struct cc_decls_tokenrec *  cc_lex_tkptr = 0;
static i64 cc_lex_dowhitespace = (i64)0;
static i64 cc_lex_nincludes;
static struct cc_decls_tokenrec cc_lex_normaltkx;
static struct cc_decls_tokenrec *  cc_lex_normaltk = &cc_lex_normaltkx;
static i64 cc_lex_noexpand = (i64)0;
static struct cc_lex_stackinforec cc_lex_lx_stack[20];
static i64 cc_lex_lx_stackindex;
static i64 cc_lex_ifcondlevel = (i64)0;
static byte *  cc_lex_headerpathlist[20];
static byte cc_lex_headerpath[300];
static byte *  cc_lex_lxstart;
static byte *  cc_lex_lxsptr;
static i64 cc_lex_lxhashvalue;
static byte *  cc_lex_lxsvalue;
static byte cc_lex_alphamap[256];
static byte cc_lex_digitmap[256];
static byte cc_lex_commentmap[256];
static byte cc_lex_linecommentmap[256];
static byte cc_lex_spacemap[256];
static struct mlib_strbuffer *  cc_lex_destcopy;
static byte *  cc_lex_pastedtokenlist[87000];
static i64 cc_lex_npastedtokens = (i64)0;
static i64 cc_lex_isincludefile = (i64)0;
static i64 cc_lex_firstsymbol = (i64)1;
static byte *  cc_lex_reallxsptr;
i64 cc_lex_nhstsymbols;
static i64 cc_lex_hstthreshold;
static i64 cc_lex_lasttoken = (i64)0;
static byte *  cc_headers_bcclibstr = \
(byte*)";\tbcc support library\r\n\r\n;Offsets in buffer:\r\nkreturn\t= 0\r\nkstack\t= 8\r\nkframe\t= 16\r\n\r\n\tsegment code\r\n$mccsetjmp::\r\n\r\n;on entry to setjmp:\r\n;Dstack\t\tpoints to return address\r\n;D10\t\tpoints to address of buffer to store restore info\r\n;Caller will have subtracted 32 from Dstack, and will add it again on return\r\n\r\n; Store current state\r\n\r\n\tmov [D10+kstack],Dstack\r\n\tmov [D10+kframe],Dframe\r\n\tmov D0,[Dstack]\t\t\t; return address\r\n\tmov [D10+kreturn],D0\r\n\r\n\tmov\tA0,0\r\n\tret\r\n\r\n$mcclongjmp::\r\n\r\n;on entry to longjmp:\r\n;Dstack\t\tpoints to return address\r\n;D10\t\tpoints to address of buffer containing store restore info\r\n;D11\t\thas return value to use\r\n;Caller will have subtracted 32 from Dstack, and will add it again on return\r\n\r\n; Restore state as it was on call to setjmp\r\n\r\n\r\n\tmov Dstack,[D10+kstack]\t\t; restore stack value\r\n\tmov Dframe,[D10+kframe]\t\t; restore frame ptr\r\n\r\n\tmov D0,[D10+kreturn]\t\t; stored return address\r\n\tmov [Dstack+0],D0\t\t\t; replace return address, as it will return elsewhere\r\n\tmov A0,A11\t\t\t\t\t; return value (from 'setjmp', as it will be)\r\n\r\n\tret\r\n\r\n;Float routines for unsigned\r\n;Input passed in D10\r\n;Output in XMM15\r\n\r\nm$ufloat_r64u32::\r\n\tmov D10,D10\t\t\t\t\t; clear top half (already done if value just moved there)\r\n\tcvtsi2sd XMM15,D10\r\n\tret\r\n\r\nm$ufloat_r32u32::\r\n\tmov D10,D10\r\n\tcvtsi2ss XMM15,D10\r\n\tret\r\n\r\nm$ufloat_r64u64::\r\n\tcmp D10,0\r\n\tjl fl1\r\n;number is positive, so can treat like i64\r\n\tcvtsi2sd XMM15,D10\r\n\tret\r\nfl1:\t\t\t\t\t\t;negative value\r\n\tand D10,[mask63]\t\t;clear top bit (subtract 2**63)\r\n\tcvtsi2sd XMM15,D10\r\n\taddsd XMM15,[offset64]\t;(add 2**63 back to result)\r\n\tret\r\n\r\nm$ufloat_r32u64::\r\n\tcmp D10,0\r\n\tjl fl2\r\n;number is positive, so can treat like i64\r\n\tcvtsi2ss XMM15,D10\r\n\tret\r\nfl2:\t\t\t\t\t\t;negative value\r\n\tand D10,[mask63]\t\t;clear top bit (subtract 2**63)\r\n\tcvtsi2ss XMM15,D10\r\n\taddss XMM15,[offset32]\t;(add 2**63 back to result)\r\n\tret\r\n\r\n\tsegment idata\r\nmask63:\r\n\tdq 0x7fffffffffffffff\r\noffset64:\r\n\tdq 9223372036854775808.0\t\t! 2**63 as r64\r\noffset32:\r\n\tdd 9223372036854775808.0\t\t; 2**63 as r32\r\n\r\n\tsegment code\r\n__rdtsc::\r\n!\trdtsc\r\n\tmov eax,eax\r\n\tshl rdx,32\r\n\tor rax,rdx\r\n\tret\r\n\r\n\tsegment zdata\r\ncallbackstack:\r\n\tresb 576\t\t\t!8-level stack\r\n;\tresb 5'120'000\r\n\r\nncallbacks:\r\n\tresb 4\r\n\r\nsegment code\r\n\r\nm$pushcallback::\r\n\tinc dword [ncallbacks]\r\n\tmov A4,[ncallbacks]\r\n\tshl A4,6\t\t\t\t\t!8x8 bytes is size per entry\r\n\tlea D4,[A4+callbackstack]\r\n\r\n\tmov [D4],rbx\r\n\tmov [D4+8],rsi\r\n\tmov [D4+16],rdi\r\n\tmov [D4+24],r12\r\n\tmov [D4+32],r13\r\n\tmov [D4+40],r14\r\n\tmov [D4+48],r15\r\n\tret\r\n\r\nm$popcallback::\r\n\tmov A4,[ncallbacks]\r\n\tshl A4,6\t\t\t\t\t!8x8 bytes is size per entry\r\n\tlea D4,[A4+callbackstack]\r\n\tmov rbx,[D4]\r\n\tmov rsi,[D4+8]\r\n\tmov rdi,[D4+16]\r\n\tmov r12,[D4+24]\r\n\tmov r13,[D4+32]\r\n\tmov r14,[D4+40]\r\n\tmov r15,[D4+48]\r\n\tdec dword [ncallbacks]\r\n\tret\r\n\r\n\r\n";
static byte *  cc_headers_h_assert = (byte*)"/* Header assert.h */\r\n\r\n//#define assert(x) 0\r\n#define assert(x)\r\n";
static byte *  cc_headers_h_ctype = (byte*)"/* Header ctype.h */\r\n\r\nint tolower(int);\r\nint toupper(int);\r\nint isalpha(int);\r\nint isdigit(int);\r\nint isspace(int);\r\nint isalnum(int);\r\nint isupper(int);\r\nint islower(int);\r\n\r\nint isxdigit(int);\r\nint iscntrl(int);\r\nint isgraph(int);\r\nint ispunct(int);\r\nint isprint(int);\r\nint __isascii(int);\r\n#define isascii __isascii\r\n\r\nint __toascii(int);\r\n#define toascii __toascii\r\n";
static byte *  cc_headers_h_errno = (byte*)"/* Header errno.h */\r\n\r\n#ifndef $errno\r\n#define $errno\r\n\r\nextern int* _errno(void);\r\n#define errno (*_errno())\r\n\r\n#define EPERM 1\r\n#define ENOENT 2\r\n#define ESRCH 3\r\n#define EINTR 4\r\n#define EIO 5\r\n#define ENXIO 6\r\n#define E2BIG 7\r\n#define ENOEXEC 8\r\n#define EBADF 9\r\n#define ECHILD 10\r\n#define EAGAIN 11\r\n#define ENOMEM 12\r\n#define EACCES 13\r\n#define EFAULT 14\r\n#define ENOTBLK 15\r\n#define EBUSY 16\r\n#define EEXIST 17\r\n#define EXDEV 18\r\n#define ENODEV 19\r\n#define ENOTDIR 20\r\n#define EISDIR 21\r\n#define EINVAL 22\r\n#define ENFILE 23\r\n#define EMFILE 24\r\n#define ENOTTY 25\r\n#define ETXTBSY 26\r\n#define EFBIG 27\r\n#define ENOSPC 28\r\n#define ESPIPE 29\r\n#define EROFS 30\r\n#define EMLINK 31\r\n#define EPIPE 32\r\n#define EDOM 33\r\n#define ERANGE 34\r\n#define ENOMSG 35\r\n#define EIDRM 36\r\n#define ECHRNG 37\r\n#define EL2NSYNC 38\r\n#define EL3HLT 39\r\n#define EL3RST 40\r\n#define ELNRNG 41\r\n#define EUNATCH 42\r\n#define ENOCSI 43\r\n#define EL2HLT 44\r\n#define EDEADLK 45\r\n#define ENOLCK 46\r\n#define EBADE 50\r\n#define EBADR 51\r\n#define EXFULL 52\r\n#define ENOANO 53\r\n#define EBADRQC 54\r\n#define EBADSLT 55\r\n#define EDEADLOCK 56\r\n#define EBFONT 57\r\n#define ENOSTR 60\r\n#define ENODATA 61\r\n#define ETIME 62\r\n#define ENOSR 63\r\n#define ENONET 64\r\n#define ENOPKG 65\r\n#define EREMOTE 66\r\n#define ENOLINK 67\r\n#define EADV 68\r\n#define ESRMNT 69\r\n#define ECOMM 70\r\n#define EPROTO 71\r\n#define EMULTIHOP 74\r\n#define ELBIN 75\r\n#define EOVERFLOW 76\r\n#define EBADMSG 77\r\n#define ENOTUNIQ 80\r\n#define EBADFD 81\r\n#define EREMCHG 82\r\n#define ELIBACC 83\r\n#define ELIBBAD 84\r\n#define ELIBSCN 85\r\n#define ELIBMAX 86\r\n#define ELIBEXEC 87\r\n#define ENOSYS 88\r\n#define ENMFILE 89\r\n#define ENOTEMPTY 90\r\n#define ENAMETOOLONG 91\r\n#define EILSEQ 92\r\n#define __ELASTERROR 2000\r\n\r\n#endif\r\n";
static byte *  cc_headers_h_fenv = (byte*)"/* Header fenv.h */\r\n\r\nint feclearexcept(int);\r\nint fetestexcept(int);\r\n\r\n#define FE_INVALID 1\r\n#define FE_DENORMAL 2\r\n#define FE_INEXACT 32\r\n#define FE_DIVBYZERO 4 \r\n#define FE_OVERFLOW 8\r\n#define FE_UNDERFLOW 16\r\n#define FE_STACKFAULT 64\r\n#define FE_ALL_EXCEPT (FE_INVALID|FE_DENORMAL|FE_INEXACT|FE_DIVBYZERO|FE_OVERFLOW|FE_UNDERFLOW)\r\n";
static byte *  cc_headers_h_float = (byte*)"/* Header float.h */\r\n\r\n//#define DBL_MAX_10_EXP 308\r\n//#define DBL_MANT_DIG 53\r\n\r\n#define FLT_RADIX 2\r\n\r\n#define FLT_DIG 6\r\n#define FLT_MIN_EXP -125\r\n#define FLT_MIN 1.17549435E-38F // decimal constant\r\n#define FLT_MIN 0X1P-126F // hex constant\r\n#define FLT_TRUE_MIN 1.40129846E-45F // decimal constant\r\n#define FLT_TRUE_MIN 0X1P-149F // hex constant\r\n#define FLT_HAS_SUBNORM 1\r\n#define FLT_MIN_10_EXP -37\r\n#define FLT_MAX_EXP +128\r\n#define FLT_MAX 3.40282347E+38F // decimal constant\r\n#define FLT_MAX 0X1.fffffeP127F // hex constant\r\n#define FLT_MAX_10_EXP +38\r\n#define FLT_EPSILON 1.19209290e-07F\r\n#define FLT_MANT_DIG 23\r\n\r\n#define DBL_MANT_DIG 53\r\n#define DBL_EPSILON 2.2204460492503131E-16 // decimal constant\r\n//#define DBL_EPSILON 0X1P-52 // hex constant\r\n#define DBL_DECIMAL_DIG 17\r\n#define DBL_DIG 15\r\n#define DBL_MIN_EXP -1021\r\n#define DBL_MIN 2.2250738585072014E-308 // decimal constant\r\n//#define DBL_MIN 0X1P-1022 // hex constant\r\n#define DBL_TRUE_MIN 4.9406564584124654E-324 // decimal constant\r\n//#define DBL_TRUE_MIN 0X1P-1074 // hex constant\r\n#define DBL_HAS_SUBNORM 1\r\n#define DBL_MIN_10_EXP -307\r\n#define DBL_MAX_EXP +1024\r\n#define DBL_MAX 1.7976931348623157E+308 // decimal constant\r\n//#define DBL_MAX 0X1.fffffffffffffP1023 // h\r\n#define DBL_MAX_10_EXP +308\r\n\r\n#define LDBL_MIN DBL_MIN\r\n#define LDBL_MAX DBL_MAX\r\n#define LDBL_EPSILON 2.2204460492503131E-16\r\n#define LDBL_MANT_DIG 53\r\n#define LDBL_MIN_EXP -1021\r\n#define LDBL_MAX_EXP +1024\r\n\r\nint     _isnan(double);\r\n#define isnan _isnan\r\n";
static byte *  cc_headers_h_inttypes = (byte*)"/* Header inttypes.h */\r\n\r\n#include <stdint.h>\r\n\r\n/* fprintf macros for signed types */\r\n#define PRId8 \"d\"\r\n#define PRId16 \"d\"\r\n#define PRId32 \"d\"\r\n#define PRId64 \"I64d\"\r\n\r\n#define PRIdLEAST8 \"d\"\r\n#define PRIdLEAST16 \"d\"\r\n#define PRIdLEAST32 \"d\"\r\n#define PRIdLEAST64 \"I64d\"\r\n\r\n#define PRIdFAST8 \"d\"\r\n#define PRIdFAST16 \"d\"\r\n#define PRIdFAST32 \"d\"\r\n#define PRIdFAST64 \"I64d\"\r\n\r\n#define PRIdMAX \"I64d\"\r\n\r\n#define PRIi8 \"i\"\r\n#define PRIi16 \"i\"\r\n#define PRIi32 \"i\"\r\n#define PRIi64 \"I64i\"\r\n\r\n#define PRIiLEAST8 \"i\"\r\n#define PRIiLEAST16 \"i\"\r\n#define PRIiLEAST32 \"i\"\r\n#define PRIiLEAST64 \"I64i\"\r\n\r\n#define PRIiFAST8 \"i\"\r\n#define PRIiFAST16 \"i\"\r\n#define PRIiFAST32 \"i\"\r\n#define PRIiFAST64 \"I64i\"\r\n\r\n#define PRIiMAX \"I64i\"\r\n\r\n#define PRIo8 \"o\"\r\n#define PRIo16 \"o\"\r\n#define PRIo32 \"o\"\r\n#define PRIo64 \"I64o\"\r\n\r\n#define PRIoLEAST8 \"o\"\r\n#define PRIoLEAST16 \"o\"\r\n#define PRIoLEAST32 \"o\"\r\n#define PRIoLEAST64 \"I64o\"\r\n\r\n#define PRIoFAST8 \"o\"\r\n#define PRIoFAST16 \"o\"\r\n#define PRIoFAST32 \"o\"\r\n#define PRIoFAST64 \"I64o\"\r\n\r\n#define PRIoMAX \"I64o\"\r\n\r\n/* fprintf macros for unsigned types */\r\n#define PRIu8 \"u\"\r\n#define PRIu16 \"u\"\r\n#define PRIu32 \"u\"\r\n#define PRIu64 \"I64u\"\r\n\r\n\r\n#define PRIuLEAST8 \"u\"\r\n#define PRIuLEAST16 \"u\"\r\n#define PRIuLEAST32 \"u\"\r\n#define PRIuLEAST64 \"I64u\"\r\n\r\n#define PRIuFAST8 \"u\"\r\n#define PRIuFAST16 \"u\"\r\n#define PRIuFAST32 \"u\"\r\n#define PRIuFAST64 \"I64u\"\r\n\r\n#define PRIuMAX \"I64u\"\r\n\r\n#define PRIx8 \"x\"\r\n#define PRIx16 \"x\"\r\n#define PRIx32 \"x\"\r\n#define PRIx64 \"I64x\"\r\n\r\n#define PRIxLEAST8 \"x\"\r\n#define PRIxLEAST16 \"x\"\r\n#define PRIxLEAST32 \"x\"\r\n#define PRIxLEAST64 \"I64x\"\r\n\r\n#define PRIxFAST8 \"x\"\r\n#define PRIxFAST16 \"x\"\r\n#define PRIxFAST32 \"x\"\r\n#define PRIxFAST64 \"I64x\"\r\n\r\n#define PRIxMAX \"I64x\"\r\n\r\n#define PRIX8 \"X\"\r\n#define PRIX16 \"X\"\r\n#define PRIX32 \"X\"\r\n#define PRIX64 \"I64X\"\r\n\r\n#define PRIXLEAST8 \"X\"\r\n#define PRIXLEAST16 \"X\"\r\n#define PRIXLEAST32 \"X\"\r\n#define PRIXLEAST64 \"I64X\"\r\n\r\n#define PRIXFAST8 \"X\"\r\n#define PRIXFAST16 \"X\"\r\n#define PRIXFAST32 \"X\"\r\n#define PRIXFAST64 \"I64X\"\r\n\r\n#define PRIXMAX \"I64X\"\r\n\r\n";
static byte *  cc_headers_h_stdint = (byte*)"/* Header stdint.h */\r\n\r\n#ifndef $stdint\r\n#define $stdint\r\n\r\ntypedef signed char int8_t;\r\ntypedef short int16_t;\r\ntypedef int int32_t;\r\ntypedef long long int int64_t;\r\n\r\ntypedef unsigned char uint8_t;\r\ntypedef unsigned short uint16_t;\r\ntypedef unsigned int uint32_t;\r\ntypedef unsigned long long int uint64_t;\r\n\r\ntypedef long long int intptr_t;\r\ntypedef unsigned long long int uintptr_t;\r\ntypedef long long intmax_t;\r\ntypedef unsigned long long uintmax_t;\r\n\r\n#define INT8_MIN -128\r\n#define INT8_MAX 127\r\n#define INT16_MIN -32768\r\n#define INT16_MAX 32767\r\n#define INT32_MIN 0x80000000\r\n#define INT32_MAX 0x7FFFFFFF\r\n#define INT64_MIN 0x8000000000000000\r\n#define INT64_MAX 0x7FFFFFFFFFFFFFFF\r\n\r\n#define UINT8_MAX 255\r\n#define UINT16_MAX 65535\r\n#define UINT32_MAX 0xFFFFFFFF\r\n#define UINT64_MAX 0xFFFFFFFFFFFFFFFF\r\n\r\n#define INTPTR_MIN 0x8000000000000000\r\n#define INTPTR_MAX 0x7FFFFFFFFFFFFFFF\r\n#define UINTPTR_MAX 0xFFFFFFFFFFFFFFFF\r\n\r\n#define UINT64_MAX 0xFFFFFFFFFFFFFFFF\r\n#define SIZE_MAX 0xFFFFFFFFFFFFFFFF\r\n\r\n#define PTRDIFF_MIN 0x8000000000000000\r\n#define PTRDIFF_MAX 0x7FFFFFFFFFFFFFFF\r\n\r\n#define WCHAR_MIN 0\r\n#define WCHAR_MAX 65535\r\n\r\n#define WINT_MIN 0\r\n#define WINT_MAX 65535\r\n\r\n#define UINT64_C(x) (x##ull)\r\n\r\n#endif\r\n";
static byte *  cc_headers_h_limits = (byte*)"/* Header limits.h */\r\n\r\n#define CHAR_BIT 8\r\n\r\n#define CHAR_MIN 0\r\n#define CHAR_MAX 255\r\n\r\n#define UCHAR_MIN 0\r\n#define UCHAR_MAX 255\r\n\r\n#define SCHAR_MIN -128\r\n#define SCHAR_MAX 127\r\n\r\n#define SHRT_MIN -32768\r\n#define SHRT_MAX 32767\r\n\r\n#define USHRT_MIN 0\r\n#define USHRT_MAX 65536\r\n\r\n#define INT_MIN -2147483648\r\n#define INT_MAX  2147483647\r\n\r\n#define UINT_MIN 0\r\n#define UINT_MAX 4294967295\r\n\r\n#define LONG_MIN -2147483648\r\n#define LONG_MAX  2147483647\r\n\r\n#define ULONG_MIN 0\r\n#define ULONG_MAX 4294967295\r\n\r\n#define LLONG_MIN -9223372036854775808LL\r\n#define LLONG_MAX  9223372036854775807LL\r\n\r\n#define ULLONG_MIN 0\r\n#define ULLONG_MAX 0xFFFFFFFFFFFFFFFFLL\r\n";
static byte *  cc_headers_h_locale = (byte*)"/* Header locale.h */\r\n\r\n#define LC_ALL 0\r\n#define LC_COLLATE 1\r\n#define LC_CTYPE 2\r\n#define LC_MONETARY 3\r\n#define LC_NUMERIC 4\r\n#define LC_TIME 5\r\n\r\nstruct lconv {\r\n\tchar *decimal_point;\r\n\tchar *thousands_sep;\r\n\tchar *grouping;\r\n\tchar *int_curr_symbol;\r\n\tchar *currency_symbol;\r\n\tchar *mon_decimal_point;\r\n\tchar *mon_thousands_sep;\r\n\tchar *mon_grouping;\r\n\tchar *positive_sign;\r\n\tchar *negative_sign;\r\n\tchar int_frac_digits;\r\n\tchar frac_digits;\r\n\tchar p_cs_precedes;\r\n\tchar p_sep_by_space;\r\n\tchar n_cs_precedes;\r\n\tchar n_sep_by_space;\r\n\tchar p_sign_posn;\r\n\tchar n_sign_posn;\r\n};\r\nchar *setlocale(int category, const char *locale);\r\n\r\nstruct lconv *localeconv(void);\r\n\r\nchar * setlocale(int,const char *);\r\n";
static byte *  cc_headers_h__ansi = (byte*)"/* Header _ansi.h */\r\n";
static byte *  cc_headers_h_math = (byte*)"/* Header math.h */\r\n\r\n#define HUGE_VAL 1.7976931348623156e+308\r\n\r\ndouble floor(double);\r\ndouble ceil(double);\r\ndouble sqrt(double);\r\ndouble sin(double);\r\ndouble cos(double);\r\ndouble tan(double);\r\ndouble fmod(double,double);\r\ndouble asin(double);\r\ndouble acos(double);\r\ndouble atan(double);\r\ndouble log(double);\r\ndouble log10(double);\r\ndouble exp(double);\r\ndouble modf(double,double*);\r\ndouble atan2(double,double);\r\ndouble pow(double,double);\r\ndouble fabs(double);\r\ndouble sinh(double);\r\ndouble cosh(double);\r\ndouble tanh(double);\r\ndouble frexp(double,int*);\r\ndouble ldexp(double,int);\r\nint isnan(double);\r\n\r\nfloat sinf(float);\r\nfloat cosf(float);\r\nfloat tanf(float);\r\n\r\nfloat sqrtf(float);\r\nfloat acosf(float);\r\nfloat atan2f(float,float);\r\nfloat ceilf(float);\r\n\r\n\r\nlong double fminl(long double,long double);\r\nfloat fminf(float ,float);\r\ndouble fmin(double,double);\r\nfloat fabsf(float);\r\n\r\nfloat floorf(float);\r\n\r\ndouble _copysign(double,double);\r\n#define copysign _copysign\r\n\r\nlong double fmaxl(long double,long double);\r\ndouble fmax(double,double);\r\nfloat fmaxf(float,float);\r\nfloat fmodf(float,float);\r\n\r\n//long double exp2l(long double);\r\ndouble exp2(double);\r\nfloat exp2f(float);\r\n\r\n//double log2(double);\r\n#define log2(x) (log(x)*1.442695041)\r\n\r\n#define M_PI 3.1415926535897932384625433\r\n#define M_PI_2 (M_PI/2.0)\r\n#define M_2_PI 0.63661977236758134308\r\n\r\nint isinf(double);\r\n";
static byte *  cc_headers_h_setjmp = (byte*)"/* Header setjmp.h */\r\n\r\n\r\n#ifndef $setjmp\r\n#define $setjmp 1\r\n\r\ntypedef int jmp_buf[128];\r\n\r\n//void longjmp(char*, int);\r\n\r\n//void $mcclongjmp(char*, int);\r\nvoid $mcclongjmp(jmp_buf, int);\r\n\r\n//int $mccsetjmp(char*);\r\nint $mccsetjmp(jmp_buf);\r\n\r\n\r\n//int\t_setjmp(char*);\r\n//int\tsetjmp(char*);\r\n\r\n#define setjmp $mccsetjmp\r\n#define longjmp $mcclongjmp\r\n\r\n#endif\r\n\r\n";
static byte *  cc_headers_h_signal = (byte*)"/* Header signal.h */\r\n\r\n#define SIGINT    2\r\n#define SIGILL    4\r\n#define SIGFPE    8\r\n#define SIGSEGV  11\r\n#define SIGTERM  15\r\n#define SIGBREAK 21\r\n#define SIGABRT  22\r\n\r\n#define SIG_DFL (void (*)(int))0\r\n#define SIG_IGN (void (*)(int))1\r\n#define SIG_SGE (void (*)(int))3\r\n#define SIG_ACK (void (*)(int))4\r\n\r\n#define SIG_ERR (void (*)(int))-1\r\n\r\nextern void (*signal(int, void (*)(int)))(int);\r\n\r\nextern int raise(int);\r\n\r\n\r\ntypedef int sig_atomic_t;\r\n";
static byte *  cc_headers_h_stdarg = (byte*)"/* Header stdarg.h */\r\n\r\n#ifndef $STDARG\r\n #define $STDARG\r\n\r\n//coded for x64 target as used by mcc (with first four params also on stack)\r\n\r\n typedef char *\tva_list;\r\n #define va_start(ap,v) ap=((va_list)&v+8)\r\n #define va_arg(ap,t) *(t*)((ap+=8)-8)\r\n #define va_copy(dest,src) (dest=src)\r\n #define va_end(ap)\t( ap = (va_list)0 )\r\n#endif\r\n";
static byte *  cc_headers_h_stdbool = (byte*)"/* Header stdbool.h */\r\n\r\n#define bool unsigned char\r\n#define true 1\r\n#define false 0\r\n\r\n\r\n";
static byte *  cc_headers_h_stddef = (byte*)"/* Header stddef.h */\r\n\r\n#ifndef $stddef\r\n#define $stddef\r\n\r\ntypedef signed long long int ssize_t;\r\ntypedef unsigned long long int size_t;\r\n\r\n#define _WCHAR_T_DEFINED\r\n//typedef unsigned short wchar_t;\r\ntypedef signed short wchar_t;\r\n\r\n#define NULL ((void*)0)\r\n\r\n#define offsetof(a,b) (size_t) &( ((a*)0) -> b)\r\n\r\ntypedef long long int ptrdiff_t;\r\n\r\n#endif // stddef\r\n";
static byte *  cc_headers_h_stdio = \
(byte*)"/* Header stdio.h */\r\n\r\n#ifndef $stdio\r\n#define $stdio 1\r\n\r\n#define __attribute__(x)\r\n\r\n//#message \"STDIO included\"\r\n\r\n#ifndef $valist\r\n\ttypedef char* va_list;\r\n\t#define $valist\r\n#endif\r\n\r\n#include <stddef.h>\r\n\r\ntypedef long long int fpos_t;\r\n\r\n#define SEEK_SET 0\r\n#define SEEK_CUR 1\r\n#define SEEK_END 2\r\n\r\n#define EOF (-1)\r\n#define FILENAME_MAX 260\r\n\r\n#define L_tmpnam 10\r\n\r\ntypedef struct {\r\n\tchar *_ptr;\r\n\tint   _cnt;\r\n\tchar *_base;\r\n\tint   _flag;\r\n\tint   _file;\r\n\tint   _charbuf;\r\n\tint   _bufsiz;\r\n\tchar *_tmpfname;\r\n\t} FILE;\r\n\r\n// _iob-based \r\n//extern FILE _iob[];\r\n//#define stdin (&_iob[0])\r\n//#define stdout (&_iob[1])\r\n//#define stderr (&_iob[2])\r\n//\r\n\r\n// __iob_func-based\r\nextern char* __iob_func(void);\r\n\r\n#define stdin ((FILE*)(__iob_func()))\r\n#define stdout ((FILE*)(__iob_func()+sizeof(FILE)))\r\n#define stderr ((FILE*)(__iob_func()+sizeof(FILE)*2))\r\n\r\n#define _IOREAD 0x0001\r\n#define _IOWRT 0x0002\r\n\r\n#define _IOFBF 0x0000\r\n#define _IOLBF 0x0040\r\n#define _IONBF 0x0004\r\n\r\n#define _IOMYBUF 0x0008\r\n#define _IOEOF 0x0010\r\n#define _IOERR 0x0020\r\n#define _IOSTRG 0x0040\r\n#define _IORW 0x0080\r\n\r\n#define BUFSIZ 512\r\n\r\nFILE* fopen(const char*, const char*);\r\nint fclose(FILE*);\r\nlong ftell(FILE*);\r\nlong long int _ftelli64(FILE*);\r\nint fseek(FILE*,long,int);\r\nint _fseeki64(FILE*,long long int,int);\r\n\r\nsize_t fread(void*, size_t, size_t, FILE*);\r\nsize_t fwrite(const void*, size_t, size_t, FILE*);\r\nint remove(const char*);\r\nint rename(const char *,const char *);\r\nFILE* freopen(const char*, const char*, FILE*);\r\nFILE* _wfopen(const wchar_t*,const wchar_t *);\r\n\r\nint printf(const char*, ...);\r\nint sprintf(char*,const char*, ...);\r\nint fprintf(FILE*,const char*, ...);\r\nint sscanf(const char*, const char*, ...);\r\nint scanf(const char*, ...);\r\nint fscanf(FILE *,const char *, ...);\r\nint _snprintf(char *,size_t,const char*,...);\r\n#define snprintf _snprintf\r\nint _vsnprintf(char*, size_t, const char*, va_list);\r\nint vsnprintf(char*,size_t,const char*,va_list);\r\nint vsprintf(char*, const char*, va_list);\r\nint _wremove(const wchar_t*);\r\nint _wrename(const wchar_t*,const wchar_t*);\r\n\r\ntypedef char* va_list;\r\n\r\nint vfprintf(FILE*, const char*, va_list);\r\nint vprintf(const char*, va_list);\r\n\r\nint puts(const char*);\r\nchar* fgets(char*, int, FILE*);\r\nint fputs(const char*, FILE*);\r\nint fgetc(FILE*);\r\nint fputc(int, FILE*);\r\nint ungetc(int, FILE*);\r\nint getchar(void);\r\nint putchar(int);\r\nint fflush(FILE *);\r\nint getc(FILE *);\r\nint putc(int, FILE *);\r\n\r\nint feof(FILE*);\r\nint ferror(FILE*);\r\nvoid clearerr(FILE*);\r\n\r\nint fileno(FILE*);\r\nint _fileno(FILE*);\r\nint setvbuf(FILE*,char*,int,size_t);\r\nFILE* _popen(const char*, const char*);\r\nint _pclose(FILE*);\r\nint _unlink(const char *);\r\n#define unlink _unlink;\r\nFILE* _fdopen(int, const char *);\r\n#define fdopen _fdopen\r\nint fgetpos(FILE*, fpos_t*);\r\nint fsetpos(FILE*, const fpos_t*);\r\nvoid perror(char*);\r\nvoid setbuf(FILE*, char*);\r\n\r\nvoid rewind(FILE*);\r\n\r\nFILE* tmpfile(void);\r\n\r\nchar* tmpnam(char*);\r\nwchar_t getwc(FILE *);\r\n\r\nextern void* _wenviron;\r\n\r\n#endif\r\n\r\n";
static byte *  cc_headers_h_stdlib = (byte*)"/* Header stdlib.h */\r\n\r\n#ifndef $stdlib\r\n#define $stdlib 1\r\n\r\n#include <stddef.h>\r\n\r\n#define EXIT_FAILURE 1\r\n#define EXIT_SUCCESS 0\r\n\r\n#define RAND_MAX 32767\r\n\r\nvoid* malloc(size_t);\r\nvoid* realloc(void*, size_t);\r\nvoid* calloc(size_t, size_t);\r\n\r\nvoid free(void*);\r\n\r\nvoid exit(int);\r\n\r\nint system(const char*);\r\nint _wsystem(const wchar_t*);\r\n\r\nint abs(int);\r\nlong labs(long);\r\nlong long llabs(long);\r\nint rand(void);\r\nvoid srand(unsigned int);\r\nint atoi(const char*);\r\nlong atol(const char*);\r\ndouble atof(const char *);\r\nint\tatexit(void (*)(void));\r\n\r\nvoid qsort(void*, size_t, size_t, int (*)(void*, void*));\r\n\r\ntypedef struct {\r\n\tlong long int quot;\r\n\tlong long int rem;\r\n} lldiv_t;\r\n\r\nlldiv_t lldiv(long long int, long long int);\r\n\r\nchar* getenv(const char*);\r\nwchar_t* _wgetenv(const wchar_t*);\r\nint _wputenv(const wchar_t*);\r\n\r\n\r\ndouble strtod(const char*, char**);\r\nfloat strtof(const char *, char**);\r\nlong double strtold(const char*, char**);\r\nvoid abort(void);\r\nlong int strtol(const char*, char**, int);\r\n\r\nlong double strtold(const char *,char **);\r\n\r\nlong long int _strtoi64(const char *,char **,int);\r\n#define strtoll _strtoi64\r\n\r\nunsigned long long int _strtoui64(const char *,char **,int);\r\n\r\nunsigned long long int strtoull(const char*, char**, int);\r\nunsigned long strtoul(const char*, char**, int);\r\n\r\nsize_t _msize(void *);\r\n#define msize _msize\r\n\r\n#endif\r\n";
static byte *  cc_headers_h__syslist = (byte*)"/* Header _syslist.h */\r\n";
static byte *  cc_headers_h_string = (byte*)"/* Header string.h */\r\n\r\n#include <stddef.h>\r\n\r\nvoid* memcpy(void*, const void*, size_t);\r\nvoid* memmove(const void*, const void*, size_t);\r\nvoid* memset(void*, int, size_t);\r\nint memcmp(const void*, const void*, size_t);\r\nvoid* memchr(const void *, int, size_t);\r\n\r\nsize_t strlen(const char*);\r\nchar* strcpy(char*, const char*);\r\nchar* strncpy(char*, const char*, size_t);\r\nchar* strcat(char*, const char*);\r\nint strcmp(const char*, const char*);\r\nint strncmp(const char*, const char*, size_t);\r\nchar* strchr(const char*, int);\r\nchar* strstr(const char*, const char*);\r\nchar* strrchr(const char*, int);\r\nint _stricmp(const char*, const char*);\r\n#define stricmp _stricmp\r\n\r\nint _strnicmp(const char*, const char*, size_t);\r\n#define strnicmp _strnicmp\r\nchar* strncat(char*, const char*, size_t);\r\nchar* strtok(char*, const char*);\r\n\r\nsize_t strcspn(const char*, const char*);\r\nsize_t strspn(const char*, const char*);\r\nint strcoll(const char *, const char *);\r\n\r\nunsigned long strtoul(const char*, char**, int);\r\n\r\nchar* strerror(int);\r\nchar* strpbrk(const char*, const char*);\r\nsize_t strxfrm(char*, const char *, size_t);\r\n\r\nchar* _strupr(char*);\r\nchar* _strlwr(char*);\r\n#define strupr _strupr\r\n#define strlwr _strlwr\r\n\r\nchar*strnupr(char*,size_t);\r\nchar*strnlwr(char*,size_t);\r\nint strtrim(char*);\r\nchar*strrev(char*);\r\n\r\nchar* _strdup(const char*);\r\n#define strdup _strdup\r\n\r\nint _wcsicmp(const wchar_t *,const wchar_t *);\r\n\r\nwchar_t *wcspbrk(const wchar_t*,const wchar_t*);\r\n\r\nsize_t wcslen(const wchar_t*);\r\n";
static byte *  cc_headers_h_time = (byte*)"/* Header time.h */\r\n\r\n#ifndef $time\r\n#define $time\r\n\r\n#include <stddef.h>\r\n\r\ntypedef long clock_t;\r\nclock_t clock(void);\r\n\r\n//typedef long time_t;\r\n#ifndef _TIME_T_DEFINED\r\n#define _TIME_T_DEFINED\r\ntypedef long long int time_t;\r\n#endif\r\n\r\nstruct tm\r\n{\r\n  int\ttm_sec;\r\n  int\ttm_min;\r\n  int\ttm_hour;\r\n  int\ttm_mday;\r\n  int\ttm_mon;\r\n  int\ttm_year;\r\n  int\ttm_wday;\r\n  int\ttm_yday;\r\n  int\ttm_isdst;\r\n};\r\n\r\n//struct tm *localtime(time_t*);\r\nstruct tm* _localtime32(time_t*);\r\n#define localtime _localtime32\r\n\r\ntime_t _time64(time_t *_timer);\r\n#define time _time64\r\n\r\n#define CLOCKS_PER_SEC 1000\r\n\r\nstruct tm *gmtime(const time_t*);\r\nsize_t strftime(char *, size_t, const char *, const struct tm *);\r\ntime_t mktime(struct tm *);\r\ndouble difftime(time_t, time_t);\r\n\r\nchar* asctime(const struct tm*);\r\n//char* ctime(const time_t *_time);\r\nchar* _ctime64(const time_t *_time);\r\n#define ctime _ctime64\r\n\r\n#endif\r\n";
static byte *  cc_headers_h_utime = (byte*)"/* utime.h header */\r\n\r\n#include <sys/utime.h>\r\n";
static byte *  cc_headers_h_unistd = (byte*)"/* unistd.h header */\r\n";
static byte *  cc_headers_h_safelib = (byte*)"/* Header safelib.h */\r\n";
static byte *  cc_headers_h_wchar = (byte*)"/* Header wchar.h */\r\n\r\n#include <stddef.h>\r\n\r\n\r\n#define _WCHAR_T_DEFINED\r\ntypedef unsigned short wint_t;\r\n//typedef unsigned short wchar_t;\r\ntypedef signed short wchar_t;\r\n\r\nsize_t wcslen(const wchar_t*);\r\nwchar_t* wcscpy(wchar_t*,const wchar_t*);\r\n//wchar_t* _wgetenv(constwchar_t*);\r\nwchar_t* wcstok(wchar_t*,wchar_t*,wchar_t**);\r\nwchar_t* wcstok_s(wchar_t*,wchar_t*,wchar_t**);\r\n\r\nwchar_t* wcschr(wchar_t*,wchar_t);\r\nwchar_t* wcsstr(const wchar_t*,const wchar_t*);\r\n\r\n\r\nint wcscmp(const wchar_t*,const wchar_t*);\r\n";
static byte *  cc_headers_h_wctype = (byte*)"/* Header wctype.h */\r\n";
static byte *  cc_headers_h_systypes = (byte*)"/* types.h */\r\n#ifndef $systypes\r\n#define $systypes 1\r\n\r\ntypedef long int off_t;\r\ntypedef long int ino_t;\r\ntypedef unsigned int dev_t;\r\n\r\ntypedef long long time_t;\r\n\r\n#endif\r\n";
static byte *  cc_headers_h_sysstat = (byte*)"/* stat.h */\r\n\r\n#ifndef $sysstat\r\n#define $sysstat\r\n\r\n#include <stddef.h>\r\n\r\nstruct _stat {\r\n\tunsigned int\tst_dev;\r\n\tunsigned short\tst_ino;\r\n\tunsigned short\tst_mode;\r\n\tshort\t\t\tst_nlink;\r\n\tshort\t\t\tst_uid;\r\n\tshort\t\t\tst_gid;\r\n\tunsigned long\tst_rdev;\r\n\tunsigned int\tst_size;\r\n\tunsigned long long int\tst_atime;\r\n\tunsigned long long int\tst_mtime;\r\n\tunsigned long long int\tst_ctime;\r\n};\r\n\r\n#define stat _stat\r\n#define _stati64 _stat\r\n\r\n#define _S_IFMT 0xF000\r\n#define _S_IFDIR 0x4000\r\n#define _S_IFCHR 0x2000\r\n#define _S_IFIFO 0x1000\r\n#define _S_IFREG 0x8000\r\n#define _S_IREAD 0x0100\r\n#define _S_IWRITE 0x0080\r\n#define _S_IEXEC 0x0040\r\n\r\n#define S_IFMT 0xF000\r\n#define S_IFDIR 0x4000\r\n#define S_IFCHR 0x2000\r\n#define S_IFIFO 0x1000\r\n#define S_IFREG 0x8000\r\n#define S_IREAD 0x0100\r\n#define S_IWRITE 0x0080\r\n#define S_IEXEC 0x0040\r\n\r\n#define S_ISCHR(nd) (((nd) & S_IFMT) == S_IFCHR)\r\n#define S_ISDIR(nd) (((nd) & S_IFMT) == S_IFDIR)\r\n#define S_ISFIFO(nd) (((nd) & S_IFMT) == S_IFIFO)\r\n#define S_ISREG(nd) (((nd) & S_IFMT) == S_IFREG)\r\n\r\n\r\nint stat(const char *, struct stat*);\r\n\r\nint _fstati64(int, struct stat*);\r\n\r\nint fstat(int, struct stat *);\r\n#define _fstat fstat\r\n\r\nint _wstati64(const wchar_t,struct _stati64 *buffer);  \r\n\r\n\r\n\r\n#endif\r\n";
static byte *  cc_headers_h_systimeb = (byte*)"/* timeb.h */\r\n\r\n#ifndef $timeb\r\n#define $timeb\r\n\r\n#include <time.h>\r\n\r\nstruct _timeb {\r\n\ttime_t time;\r\n\tunsigned short millitm;\r\n\tshort timezone;\r\n\tshort dstflag;\r\n};\r\n#define timeb _timeb\r\n\r\nvoid _ftime64(struct _timeb*);\r\n#define _ftime _ftime64\r\n#define ftime _ftime64\r\n\r\n#endif\r\n";
static byte *  cc_headers_h_sysutime = (byte*)"/* sys/utime.h header */\r\n\r\n#ifndef $utime\r\n#define $utime\r\n\r\nstruct _utimbuf {\r\n\tlong actime;\r\n\tlong modtime;\r\n};\r\n\r\n\r\n#endif\r\n";
static byte *  cc_headers_h_memory = (byte*)"#include <malloc.h>\r\n";
static byte *  cc_headers_h_windows = "";

static byte *  cc_headers_h_fcntl = (byte*)"/* FCNTL.H */\r\n\r\nint _setmode(int,int);\r\n\r\n#ifndef _INC_FCNTL\r\n#define _INC_FCNTL\r\n\r\n#define _O_RDONLY 0x0000\r\n#define _O_WRONLY 0x0001\r\n#define _O_RDWR 0x0002\r\n#define _O_APPEND 0x0008\r\n#define _O_CREAT 0x0100\r\n#define _O_TRUNC 0x0200\r\n#define _O_EXCL 0x0400\r\n#define _O_TEXT 0x4000\r\n#define _O_BINARY 0x8000\r\n#define _O_WTEXT 0x10000\r\n#define _O_U16TEXT 0x20000\r\n#define _O_U8TEXT 0x40000\r\n#define _O_ACCMODE (_O_RDONLY|_O_WRONLY|_O_RDWR)\r\n\r\n#define _O_RAW _O_BINARY\r\n#define _O_NOINHERIT 0x0080\r\n#define _O_TEMPORARY 0x0040\r\n#define _O_SHORT_LIVED 0x1000\r\n\r\n#define _O_SEQUENTIAL 0x0020\r\n#define _O_RANDOM 0x0010\r\n\r\n#if !defined(NO_OLDNAMES) || defined(_POSIX)\r\n#define O_RDONLY _O_RDONLY\r\n#define O_WRONLY _O_WRONLY\r\n#define O_RDWR _O_RDWR\r\n#define O_APPEND _O_APPEND\r\n#define O_CREAT _O_CREAT\r\n#define O_TRUNC _O_TRUNC\r\n#define O_EXCL _O_EXCL\r\n#define O_TEXT _O_TEXT\r\n#define O_BINARY _O_BINARY\r\n#define O_RAW _O_BINARY\r\n#define O_TEMPORARY _O_TEMPORARY\r\n#define O_NOINHERIT _O_NOINHERIT\r\n#define O_SEQUENTIAL _O_SEQUENTIAL\r\n#define O_RANDOM _O_RANDOM\r\n#define O_ACCMODE _O_ACCMODE\r\n#endif\r\n\r\n#endif\r\n";
static byte *  cc_headers_h_io = (byte*)"\r\n#ifndef $io\r\n#define $io\r\n\r\n#include <stdint.h>\r\n#include <wchar.h>\r\n#include <time.h>\r\n\r\n/* io.h */\r\n\r\n#define _A_NORMAL 0x00\r\n#define _A_RDONLY 0x01\r\n#define _A_HIDDEN 0x02\r\n#define _A_SYSTEM 0x04\r\n#define _A_SUBDIR 0x10\r\n#define _A_ARCH 0x20\r\n\r\n\r\n//#message \"IO included\"\r\nstruct _finddata_t {\r\n        unsigned    attrib;\r\n        time_t      time_create;\r\n        time_t      time_access;\r\n        time_t      time_write;\r\n        unsigned long    size;\r\n        char        name[260];\r\n};\r\n\r\nint _isatty(int);\r\n\r\nint _read(int, void*, unsigned int);\r\n#define read _read\r\n\r\nint _open(const char*, int, ...);\r\n#define open _open\r\n\r\nlong _lseek(int, long, int);\r\n#define lseek _lseek\r\n\r\nint _close(int);\r\n#define close _close\r\n\r\nintptr_t _get_osfhandle(int);\r\nint _open_osfhandle(intptr_t,int);\r\n\r\nint _setmode(int,int);\r\n#define setmode _setmode\r\n\r\nint _wchmod(const wchar_t*, int);\r\n\r\nint _chmod(const char *, int);\r\n#define chmod _chmod\r\n\r\nint _dup(int);\r\n#define dup _dup\r\n\r\nintptr_t _findfirst(const char*, struct _finddata_t*);\r\nint _findnext(intptr_t, struct _finddata_t*);\r\nint _findclose(intptr_t);\r\n\r\nint _access(const char*,int);\r\n#define access _access\r\n\r\nint _wunlink(const wchar_t*);\r\n\r\n\r\n#endif\r\n";
static byte *  cc_headers_h_direct = (byte*)"#ifndef $direct\r\n#define $direct\r\n\r\ntypedef struct {\r\n unsigned int total_clusters;\r\n unsigned int avail_clusters;\r\n unsigned int sectors_per_cluster;\r\n unsigned int bytes_per_sector;\r\n} diskfree_t;\r\n\r\nint chdir(const char *);\r\nchar* _getcwd(char *, int);\r\n#define getcwd _getcwd\r\nint _mkdir(const char *);\r\nint _rmdir(const char *);\r\nint _wrmdir(const wchar_t*);\r\nint _wmkdir(const wchar_t*);\r\n\r\n#define mkdir _mkdir\r\n#define rmdir _rmdir\r\n\r\nint _chdrive(int);\r\nchar* _getdcwd(int, char *, int);\r\nwchar_t* _wgetcwd(wchar_t*, int);\r\nint _wchdir(const wchar_t*);\r\nint _getdrive(void);\r\nint _chdir(const char*);\r\n#define chdir _chdir\r\n\r\nunsigned long _getdrives(void);\r\nunsigned int _getdiskfree(unsigned int, diskfree_t*);\r\n\r\n#endif\r\n\r\n";
static byte *  cc_headers_h_process = (byte*)"/* Header process.h */\r\n#ifndef $process\r\n#define $process\r\n\r\n#define P_WAIT\t\t0\r\n#define P_NOWAIT\t1\r\n#define P_OVERLAY\t2\r\n#define P_DETACH\t4\r\n#define WAIT_CHILD 0\r\n#define _P_WAIT P_WAIT\r\n#define _P_NOWAIT P_NOWAIT\r\n#define _P_OVERLAY P_OVERLAY\r\n\r\nint _spawnvp(int, const char*, const char*const*);\r\n#define spawnvp _spawnvp\r\n\r\nvoid endthread(void);\r\nunsigned long _beginthreadex(void *,unsigned,unsigned (*)(void *),void *,unsigned,unsigned *);\r\nvoid _endthreadex(unsigned);\r\nint _cwait(int*, int, int);\r\n#define cwait _cwait\r\n//int _System(const char *cmd,int nCmdShow);\r\n\r\n//#define _WAIT_CHILD\t0\r\n//#endif\r\n#endif\r\n\r\n";
static byte *  cc_headers_h_malloc = (byte*)"#include <stddef.h>\r\n\r\nvoid* malloc(size_t);\r\nvoid* realloc(void *, size_t);\r\nvoid  free(void *);\r\n";
static byte *  cc_headers_h_bcc = (byte*)"#define __attribute__(x)\r\n#define _WIN32\r\n#define WIN32\r\n#define __WIN32__\r\n#define __inline\r\n#define __dllimport(x)\r\n#define __declspec(x)\r\n#define __stdcall\r\n#define CALLBACK $callback\r\n#define __cdecl\r\n#define EXTERN_C extern\r\n#define DECLSPEC_IMPORT\r\n#define __32BIT__\r\n";
static byte *  cc_headers_h_conio = (byte*)"/* conio.h */\r\n#include <stddef.h>\r\n#include <wchar.h>\r\n\r\nint _getch(void);\r\nint _kbhit(void);\r\nwint_t _getwch(void);\r\n\r\n#define getch _getch\r\n#define kbhit _kbhit\r\n\r\nint _putch(int);\r\nint _cprintf(char *, ...);\r\nint _getche(void);\r\nint _ungetch(int);\r\n\r\n#define putch _putch\r\n#define cprintf _cprintf\r\n#define getche _getche\r\n#define ungetch _ungetch\r\n";
static byte *  cc_headers_h_winsock2 = \
(byte*)"#ifndef _WINSOCK2_H\r\n#define _WINSOCK2_H\r\n\r\n#include <_mingw.h>\r\n#include <windows.h>\r\n\r\n#ifndef FD_SETSIZE\r\n#define FD_SETSIZE 64\r\n#endif\r\n\r\ntypedef unsigned int SOCKET;\r\n\r\ntypedef struct fd_set {\r\n  unsigned int   fd_count;\r\n  SOCKET  fd_array[FD_SETSIZE];\r\n} fd_set;\r\n\r\nextern int __stdcall __WSAFDIsSet(SOCKET,fd_set *);\r\n\r\n#ifndef FD_CLR\r\n#define FD_CLR(fd,set) do { unsigned int __i;\\\r\nfor (__i = 0; __i < ((fd_set *)(set))->fd_count ; __i++) {\\\r\n    if (((fd_set *)(set))->fd_array[__i] == (fd)) {\\\r\n    while (__i < ((fd_set *)(set))->fd_count-1) {\\\r\n        ((fd_set*)(set))->fd_array[__i] = ((fd_set*)(set))->fd_array[__i+1];\\\r\n        __i++;\\\r\n    }\\\r\n    ((fd_set*)(set))->fd_count--;\\\r\n    break;\\\r\n    }\\\r\n}\\\r\n} while (0)\r\n#endif\r\n\r\n#ifndef FD_SET\r\n/* this differs from the define in winsock.h and in cygwin sys/types.h */\r\n#define FD_SET(fd, set) do { unsigned int __i;\\\r\nfor (__i = 0; __i < ((fd_set *)(set))->fd_count ; __i++) {\\\r\n    if (((fd_set *)(set))->fd_array[__i] == (fd)) {\\\r\n        break;\\\r\n    }\\\r\n}\\\r\nif (__i == ((fd_set *)(set))->fd_count) {\\\r\n    if (((fd_set *)(set))->fd_count < FD_SETSIZE) {\\\r\n        ((fd_set *)(set))->fd_array[__i] = (fd);\\\r\n        ((fd_set *)(set))->fd_count++;\\\r\n    }\\\r\n}\\\r\n} while(0)\r\n#endif\r\n\r\n#ifndef FD_ZERO\r\n#define FD_ZERO(set) (((fd_set *)(set))->fd_count=0)\r\n#endif\r\n\r\n#ifndef FD_ISSET\r\n#define FD_ISSET(fd, set) __WSAFDIsSet((SOCKET)(fd), (fd_set *)(set))\r\n#endif\r\n\r\n#ifndef _TIMEVAL_DEFINED /* also in sys/time.h */\r\n#define _TIMEVAL_DEFINED\r\nstruct timeval {\r\n    long tv_sec;\r\n    long tv_usec;\r\n};\r\n#endif\r\n\r\nstruct in_addr {\r\n    union {\r\n        struct { unsigned char s_b1,s_b2,s_b3,s_b4; } S_un_b;\r\n        struct { unsigned short s_w1,s_w2; } S_un_w;\r\n        unsigned long S_addr;\r\n    } S_un;\r\n};\r\n#define s_addr  S_un.S_addr\r\n\r\nstruct sockaddr_in {\r\n    short sin_family;\r\n    unsigned short sin_port;\r\n    struct in_addr sin_addr;\r\n    char sin_zero[8];\r\n};\r\n\r\nstruct sockaddr {\r\n    unsigned short sa_family;\r\n    char sa_data[14];\r\n};\r\n\r\nstruct hostent {\r\n    char *h_name;\r\n    char **h_aliases;\r\n    short h_addrtype;\r\n    short h_length;\r\n    char **h_addr_list;\r\n};\r\n#define h_addr h_addr_list[0]\r\n\r\n#define WSADESCRIPTION_LEN  256\r\n#define WSASYS_STATUS_LEN   128\r\ntypedef struct WSAData {\r\n    WORD wVersion;\r\n    WORD wHighVersion;\r\n    char szDescription[WSADESCRIPTION_LEN+1];\r\n    char szSystemStatus[WSASYS_STATUS_LEN+1];\r\n    unsigned short iMaxSockets;\r\n    unsigned short iMaxUdpDg;\r\n    char *lpVendorInfo;\r\n} WSADATA;\r\ntypedef WSADATA *LPWSADATA;\r\n\r\n#define INVALID_SOCKET (SOCKET)(~0)\r\n#define SOCK_STREAM  1\r\n#define SO_REUSEADDR 4\r\n#define AF_INET 2\r\n#define MSG_PEEK 0x2\r\n#define INADDR_ANY (unsigned long)0x00000000\r\n#define INADDR_LOOPBACK 0x7f000001\r\n#define SOL_SOCKET 0xffff\r\n\r\n#define SD_RECEIVE  0x00\r\n#define SD_SEND     0x01\r\n#define SD_BOTH     0x02\r\n\r\n#define h_errno WSAGetLastError()\r\n\r\n#define WSABASEERR 10000\r\n#define TRY_AGAIN (WSABASEERR+1002)\r\n\r\nSOCKET __stdcall accept(SOCKET, struct sockaddr *, int *);\r\nint __stdcall bind(SOCKET, const struct sockaddr *, int);\r\nint __stdcall closesocket(SOCKET);\r\nint __stdcall connect(SOCKET, const struct sockaddr *, int);\r\nstruct hostent *__stdcall gethostbyname(const char *);\r\nint __stdcall gethostname(char *, int);\r\nint __stdcall getpeername(SOCKET, struct sockaddr *, int *);\r\nint __stdcall getsockname(SOCKET, struct sockaddr *, int *);\r\nunsigned long __stdcall htonl(unsigned long);\r\nunsigned short __stdcall htons(unsigned short);\r\nint __stdcall listen(SOCKET, int);\r\nunsigned long __stdcall ntohl(unsigned long);\r\nunsigned short __stdcall ntohs(unsigned short);\r\nint __stdcall recv(SOCKET, char *, int, int);\r\nint __stdcall recvfrom(SOCKET, char *, int, int, struct sockaddr *, int *);\r\nint __stdcall select(int nfds, fd_set *, fd_set *, fd_set *, const struct timeval *);\r\nint __stdcall send(SOCKET, const char *, int, int);\r\nint __stdcall sendto(SOCKET, const char *, int, int, const struct sockaddr *, int);\r\nint __stdcall setsockopt(SOCKET, int, int, const char *, int);\r\nint __stdcall shutdown(SOCKET, int);\r\nint __stdcall WSACleanup(void);\r\nint __stdcall WSAGetLastError(void);\r\nint __stdcall WSAStartup(WORD, LPWSADATA);\r\n\r\nSOCKET __stdcall socket(int, int, int);\r\n\r\n#endif\r\n\r\n";
static byte *  cc_headers_h__mingw = \
(byte*)"/*\r\n * _mingw.h\r\n *\r\n *  This file is for TinyCC and not part of the Mingw32 package.\r\n *\r\n *  THIS SOFTWARE IS NOT COPYRIGHTED\r\n *\r\n *  This source code is offered for use in the public domain. You may\r\n *  use, modify or distribute it freely.\r\n *\r\n *  This code is distributed in the hope that it will be useful but\r\n *  WITHOUT ANY WARRANTY. ALL WARRANTIES, EXPRESS OR IMPLIED ARE HEREBY\r\n *  DISCLAIMED. This includes but is not limited to warranties of\r\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\r\n *\r\n */\r\n\r\n#ifndef __MINGW_H\r\n#define __MINGW_H\r\n\r\n/* some winapi files define these before including _mingw.h --> */\r\n#undef __cdecl\r\n#undef _X86_\r\n#undef WIN32\r\n/* <-- */\r\n\r\n#include <stddef.h>\r\n#include <stdarg.h>\r\n\r\n#define __int8 char\r\n#define __int16 short\r\n#define __int32 int\r\n#define __int64 long long\r\n#define _HAVE_INT64\r\n\r\n#define __cdecl\r\n#define __declspec(x) __attribute__((x))\r\n#define __unaligned __attribute__((packed))\r\n#define __fastcall __attribute__((fastcall))\r\n\r\n#define __MSVCRT__ 1\r\n#undef _MSVCRT_\r\n#define __MINGW_IMPORT extern __declspec(dllimport)\r\n#define __MINGW_ATTRIB_NORETURN\r\n#define __MINGW_ATTRIB_CONST\r\n#define __MINGW_ATTRIB_DEPRECATED\r\n#define __MINGW_ATTRIB_MALLOC\r\n#define __MINGW_ATTRIB_PURE\r\n#define __MINGW_ATTRIB_NONNULL(arg)\r\n#define __MINGW_NOTHROW\r\n#define __GNUC_VA_LIST\r\n\r\n#define _CRTIMP extern\r\n#define __CRT_INLINE extern __inline__\r\n\r\n#define _CRT_ALIGN(x) __attribute__((aligned(x)))\r\n#define DECLSPEC_ALIGN(x) __attribute__((aligned(x)))\r\n#define _CRT_PACKING 8\r\n#define __CRT_UNALIGNED\r\n#define _CONST_RETURN\r\n\r\n#ifndef _TRUNCATE\r\n#define _TRUNCATE ((size_t)-1)\r\n#endif\r\n\r\n#define __CRT_STRINGIZE(_Value) #_Value\r\n#define _CRT_STRINGIZE(_Value) __CRT_STRINGIZE(_Value)\r\n#define __CRT_WIDE(_String) L ## _String\r\n#define _CRT_WIDE(_String) __CRT_WIDE(_String)\r\n\r\n#ifdef _WIN64\r\n#define __stdcall\r\n#define _AMD64_ 1\r\n#define __x86_64 1\r\n#define _M_X64 100 /* Visual Studio */\r\n#define _M_AMD64 100 /* Visual Studio */\r\n#define USE_MINGW_SETJMP_TWO_ARGS\r\n#define mingw_getsp tinyc_getbp\r\n#define __TRY__\r\n#else\r\n#define __stdcall __attribute__((__stdcall__))\r\n#define _X86_ 1\r\n#define _M_IX86 300 /* Visual Studio */\r\n#define WIN32 1\r\n#define _USE_32BIT_TIME_T\r\n#ifdef __arm__\r\n#define __TRY__\r\n#else\r\n#define __TRY__ void __try__(void**), *_sehrec[6]; __try__(_sehrec);\r\n#endif\r\n#endif\r\n\r\n/* in stddef.h */\r\n#define _SIZE_T_DEFINED\r\n#define _SSIZE_T_DEFINED\r\n#define _PTRDIFF_T_DEFINED\r\n#define _WCHAR_T_DEFINED\r\n#define _UINTPTR_T_DEFINED\r\n#define _INTPTR_T_DEFINED\r\n#define _INTEGRAL_MAX_BITS 64\r\n\r\n#ifndef _TIME32_T_DEFINED\r\n#define _TIME32_T_DEFINED\r\ntypedef long __time32_t;\r\n#endif\r\n\r\n#ifndef _TIME64_T_DEFINED\r\n#define _TIME64_T_DEFINED\r\ntypedef long long __time64_t;\r\n#endif\r\n\r\n#ifndef _TIME_T_DEFINED\r\n#define _TIME_T_DEFINED\r\n#ifdef _USE_32BIT_TIME_T\r\ntypedef __time32_t time_t;\r\n#else\r\ntypedef __time64_t time_t;\r\n#endif\r\n#endif\r\n\r\n#ifndef _WCTYPE_T_DEFINED\r\n#define _WCTYPE_T_DEFINED\r\ntypedef wchar_t wctype_t;\r\n#endif\r\n\r\n#ifndef _WINT_T\r\n#define _WINT_T\r\ntypedef short wint_t;\r\n#endif\r\n\r\ntypedef int errno_t;\r\n#define _ERRCODE_DEFINED\r\n\r\ntypedef struct threadlocaleinfostruct *pthreadlocinfo;\r\ntypedef struct threadmbcinfostruct *pthreadmbcinfo;\r\ntypedef struct localeinfo_struct _locale_tstruct,*_locale_t;\r\n\r\n/* for winapi */\r\n#define _ANONYMOUS_UNION\r\n#define _ANONYMOUS_STRUCT\r\n#define DECLSPEC_NORETURN\r\n#define DECLARE_STDCALL_P(type) __stdcall type\r\n#define NOSERVICE 1\r\n#define NOMCX 1\r\n#define NOIME 1\r\n#define __INTRIN_H_\r\n#ifndef DUMMYUNIONNAME\r\n#  define DUMMYUNIONNAME\r\n#  define DUMMYUNIONNAME1\r\n#  define DUMMYUNIONNAME2\r\n#  define DUMMYUNIONNAME3\r\n#  define DUMMYUNIONNAME4\r\n#  define DUMMYUNIONNAME5\r\n#endif\r\n#ifndef DUMMYSTRUCTNAME\r\n#  define DUMMYSTRUCTNAME\r\n#endif\r\n#ifndef WINVER\r\n# define WINVER 0x0502\r\n#endif\r\n#ifndef _WIN32_WINNT\r\n# define _WIN32_WINNT 0x502\r\n#endif\r\n\r\n#define __C89_NAMELESS\r\n#define __MINGW_EXTENSION\r\n#define WINAPI_FAMILY_PARTITION(X) 1\r\n#define MINGW_HAS_SECURE_API\r\n\r\n#endif /* __MINGW_H */\r\n";
static byte *  cc_headers_h_windowsx = (byte*)"/* Header windowsx.h */\r\n\r\n#ifndef $windowsx\r\n#define $windowsx 1\r\n\r\n#define GET_X_LPARAM(lp)                        ((int)(short)LOWORD(lp))\r\n#define GET_Y_LPARAM(lp)                        ((int)(short)HIWORD(lp))\r\n\r\n#endif // windowsx\r\n\r\n";
byte *  cc_headers_stdhdrnames[42] = {
    (byte*)"bcc.h",
    (byte*)"assert.h",
    (byte*)"ctype.h",
    (byte*)"errno.h",
    (byte*)"fenv.h",
    (byte*)"float.h",
    (byte*)"inttypes.h",
    (byte*)"stdint.h",
    (byte*)"limits.h",
    (byte*)"locale.h",
    (byte*)"_ansi.h",
    (byte*)"math.h",
    (byte*)"setjmp.h",
    (byte*)"signal.h",
    (byte*)"stdarg.h",
    (byte*)"stdbool.h",
    (byte*)"stddef.h",
    (byte*)"stdio.h",
    (byte*)"stdlib.h",
    (byte*)"_syslist.h",
    (byte*)"string.h",
    (byte*)"time.h",
    (byte*)"utime.h",
    (byte*)"unistd.h",
    (byte*)"safelib.h",
    (byte*)"wchar.h",
    (byte*)"wctype.h",
    (byte*)"sys/types.h",
    (byte*)"sys/stat.h",
    (byte*)"sys/timeb.h",
    (byte*)"sys/utime.h",
    (byte*)"malloc.h",
    (byte*)"windows.h",
    (byte*)"fcntl.h",
    (byte*)"io.h",
    (byte*)"direct.h",
    (byte*)"process.h",
    (byte*)"memory.h",
    (byte*)"conio.h",
    (byte*)"winsock2.h",
    (byte*)"_mingw.h",
    (byte*)"windowsx.h"
};
byte * *  cc_headers_stdhdrtext[42] = {
    &cc_headers_h_bcc,
    &cc_headers_h_assert,
    &cc_headers_h_ctype,
    &cc_headers_h_errno,
    &cc_headers_h_fenv,
    &cc_headers_h_float,
    &cc_headers_h_inttypes,
    &cc_headers_h_stdint,
    &cc_headers_h_limits,
    &cc_headers_h_locale,
    &cc_headers_h__ansi,
    &cc_headers_h_math,
    &cc_headers_h_setjmp,
    &cc_headers_h_signal,
    &cc_headers_h_stdarg,
    &cc_headers_h_stdbool,
    &cc_headers_h_stddef,
    &cc_headers_h_stdio,
    &cc_headers_h_stdlib,
    &cc_headers_h__syslist,
    &cc_headers_h_string,
    &cc_headers_h_time,
    &cc_headers_h_utime,
    &cc_headers_h_unistd,
    &cc_headers_h_safelib,
    &cc_headers_h_wchar,
    &cc_headers_h_wctype,
    &cc_headers_h_systypes,
    &cc_headers_h_sysstat,
    &cc_headers_h_systimeb,
    &cc_headers_h_sysutime,
    &cc_headers_h_malloc,
    &cc_headers_h_windows,
    &cc_headers_h_fcntl,
    &cc_headers_h_io,
    &cc_headers_h_direct,
    &cc_headers_h_process,
    &cc_headers_h_memory,
    &cc_headers_h_conio,
    &cc_headers_h_winsock2,
    &cc_headers_h__mingw,
    &cc_headers_h_windowsx
};
i64 cc_lib_autotypeno = (i64)0;
static i64 cc_lib_currlineno;
i64 cc_lib_nextafindex = (i64)0;
static struct mlib_strbuffer cc_lib_exprstrvar;
static struct mlib_strbuffer *  cc_lib_exprstr = &cc_lib_exprstrvar;
static struct cc_decls_unitrec *  cc_lib_unitheapptr = 0;
static i64 cc_lib_remainingunits = (i64)0;
static struct cc_decls_strec *  cc_parse_ist_symptr;
static i64 cc_parse_insidefor;
static byte cc_parse_looptypestack[100];
static i64 cc_parse_loopindex;
static struct cc_decls_caserec *  cc_parse_casevaluestack[100];
static byte cc_parse_iscallbackfnx;
static byte cc_parse_constantseen = (u8)0u;
static byte cc_parse_ingeneric = (u8)0u;
i64 cc_libmcl_nmemaddr;
i64 cc_libmcl_nmem;
i64 cc_libmcl_fshowfullnames = (i64)1;
i64 cc_libmcl_fshowmsource = (i64)0;
i64 cc_libmcl_fabsused = (i64)0;
i64 cc_libmcl_fchsused = (i64)0;
i64 cc_libmcl_kk0used = (i64)0;
i64 cc_libmcl_retindex;
i64 cc_libmcl_stackaligned;
byte *  cc_libmcl_mclnames[104] = {
    (byte*)"m_comment",
    (byte*)"m_blank",
    (byte*)"m_label",
    (byte*)"m_labelname",
    (byte*)"m_mov",
    (byte*)"m_push",
    (byte*)"m_pop",
    (byte*)"m_lea",
    (byte*)"m_cmovcc",
    (byte*)"m_fmov",
    (byte*)"m_iwiden",
    (byte*)"m_uwiden",
    (byte*)"m_inarrow",
    (byte*)"m_unarrow",
    (byte*)"m_call",
    (byte*)"m_ret",
    (byte*)"m_retn",
    (byte*)"m_jmp",
    (byte*)"m_jmpcc",
    (byte*)"m_exch",
    (byte*)"m_add",
    (byte*)"m_sub",
    (byte*)"m_imul",
    (byte*)"m_idiv",
    (byte*)"m_udiv",
    (byte*)"m_irem",
    (byte*)"m_urem",
    (byte*)"m_and",
    (byte*)"m_or",
    (byte*)"m_xor",
    (byte*)"m_test",
    (byte*)"m_cmp",
    (byte*)"m_shl",
    (byte*)"m_ishr",
    (byte*)"m_ushr",
    (byte*)"m_neg",
    (byte*)"m_not",
    (byte*)"m_inc",
    (byte*)"m_dec",
    (byte*)"m_setcc",
    (byte*)"m_fneg",
    (byte*)"m_fabs",
    (byte*)"m_fsqrt",
    (byte*)"m_fadd",
    (byte*)"m_fsub",
    (byte*)"m_fmul",
    (byte*)"m_fdiv",
    (byte*)"m_fcmp",
    (byte*)"m_ufix",
    (byte*)"m_ifix",
    (byte*)"m_ufloat",
    (byte*)"m_ifloat",
    (byte*)"m_fwiden",
    (byte*)"m_fnarrow",
    (byte*)"m_fmin",
    (byte*)"m_fmax",
    (byte*)"m_resb",
    (byte*)"m_db",
    (byte*)"m_dw",
    (byte*)"m_dd",
    (byte*)"m_dq",
    (byte*)"m_defstr",
    (byte*)"m_defwstr",
    (byte*)"m_align",
    (byte*)"m_segment",
    (byte*)"m_cdq",
    (byte*)"m_assem",
    (byte*)"m_end",
    (byte*)"mx_imul2",
    (byte*)"mx_sar",
    (byte*)"mx_shr",
    (byte*)"mx_div",
    (byte*)"mx_movzx",
    (byte*)"mx_movsx",
    (byte*)"mx_inot",
    (byte*)"mx_mul",
    (byte*)"mx_movd",
    (byte*)"mx_movq",
    (byte*)"mx_addss",
    (byte*)"mx_addsd",
    (byte*)"mx_subss",
    (byte*)"mx_subsd",
    (byte*)"mx_mulss",
    (byte*)"mx_mulsd",
    (byte*)"mx_divss",
    (byte*)"mx_divsd",
    (byte*)"mx_comiss",
    (byte*)"mx_comisd",
    (byte*)"mx_cvtsi2ss",
    (byte*)"mx_cvtsi2sd",
    (byte*)"mx_cvtss2sd",
    (byte*)"mx_cvtsd2ss",
    (byte*)"mx_cvttss2si",
    (byte*)"mx_cvttsd2si",
    (byte*)"mx_sqrtss",
    (byte*)"mx_sqrtsd",
    (byte*)"mx_minss",
    (byte*)"mx_maxss",
    (byte*)"mx_minsd",
    (byte*)"mx_maxsd",
    (byte*)"mx_xorps",
    (byte*)"mx_xorpd",
    (byte*)"mx_andps",
    (byte*)"mx_andpd"
};
byte *  cc_libmcl_opndnames[7] = {(byte*)"a_none",(byte*)"a_reg",(byte*)"a_imm",(byte*)"a_strimm",(byte*)"a_mem",(byte*)"a_code",(byte*)"a_xreg"};
byte *  cc_libmcl_regnames[18] = {
    (byte*)"rnone",
    (byte*)"r0",
    (byte*)"r1",
    (byte*)"r2",
    (byte*)"r3",
    (byte*)"r4",
    (byte*)"r5",
    (byte*)"r6",
    (byte*)"r7",
    (byte*)"r8",
    (byte*)"r9",
    (byte*)"r10",
    (byte*)"r11",
    (byte*)"r12",
    (byte*)"r13",
    (byte*)"rframe",
    (byte*)"rstack",
    (byte*)"rfpu"
};
byte *  cc_libmcl_xregnames[17] = {
    (byte*)"xnone",
    (byte*)"xr0",
    (byte*)"xr1",
    (byte*)"xr2",
    (byte*)"xr3",
    (byte*)"xr4",
    (byte*)"xr5",
    (byte*)"xr6",
    (byte*)"xr7",
    (byte*)"xr8",
    (byte*)"xr9",
    (byte*)"xr10",
    (byte*)"xr11",
    (byte*)"xr12",
    (byte*)"xr13",
    (byte*)"xr14",
    (byte*)"xr15"
};
byte *  cc_libmcl_condnames[22] = {
    (byte*)"ov",
    (byte*)"nov",
    (byte*)"ltu",
    (byte*)"geu",
    (byte*)"eq",
    (byte*)"ne",
    (byte*)"leu",
    (byte*)"gtu",
    (byte*)"s",
    (byte*)"ns",
    (byte*)"p",
    (byte*)"np",
    (byte*)"lt",
    (byte*)"ge",
    (byte*)"le",
    (byte*)"gt",
    (byte*)"flt",
    (byte*)"fge",
    (byte*)"fle",
    (byte*)"fgt",
    (byte*)"feq",
    (byte*)"fne"
};
byte *  cc_libmcl_asmcondnames[22] = {
    (byte*)"o",
    (byte*)"no",
    (byte*)"b",
    (byte*)"ae",
    (byte*)"z",
    (byte*)"nz",
    (byte*)"be",
    (byte*)"a",
    (byte*)"s",
    (byte*)"ns",
    (byte*)"p",
    (byte*)"np",
    (byte*)"l",
    (byte*)"ge",
    (byte*)"le",
    (byte*)"g",
    (byte*)"b",
    (byte*)"ae",
    (byte*)"be",
    (byte*)"a",
    (byte*)"z",
    (byte*)"nz"
};
byte *  cc_libmcl_valtypenames[11] = {
    (byte*)"no_val",
    (byte*)"int_val",
    (byte*)"real_val",
    (byte*)"string_val",
    (byte*)"wstring_val",
    (byte*)"label_val",
    (byte*)"name_val",
    (byte*)"stringix_val",
    (byte*)"wstringix_val",
    (byte*)"intix_val",
    (byte*)"realix_val"
};
struct cc_libmcl_mclrec *  cc_libmcl_mccode;
struct cc_libmcl_mclrec *  cc_libmcl_mccodex;
struct cc_libmcl_mclrec *  cc_libmcl_modulecode;
i64 cc_libmcl_currsegment = (i64)0;
i64 cc_libmcl_currzdataalign = (i64)0;
i64 cc_libmcl_curridataalign = (i64)0;
i64 cc_libmcl_framebytes;
i64 cc_libmcl_parambytes;
i64 cc_libmcl_frameoffset;
i64 cc_libmcl_isthreadedproc;
i64 cc_libmcl_iscallbackproc;
i64 cc_libmcl_structretoffset;
struct cc_libmcl_mclrec *  cc_libmcl_stacksetinstr;
i64 cc_libmcl_currblocksize;
i64 cc_libmcl_retbeforeblock;
struct cc_libmcl_opndrec *  cc_libmcl_dstackopnd;
struct cc_libmcl_opndrec *  cc_libmcl_dframeopnd;
struct cc_libmcl_opndrec *  cc_libmcl_zero_opnd = 0;
struct cc_decls_unitrec *  cc_libmcl_zero_unit;
static struct mlib_strbuffer cc_libmcl_sbuffer;
struct mlib_strbuffer *  cc_libmcl_dest = &cc_libmcl_sbuffer;
static i64 cc_blockmcl_continuestack[100];
static i64 cc_blockmcl_breakstack[100];
static i64 cc_blockmcl_loopindex;
static i64 (*cc_blockmcl_sw_labeltable)[];
static i64 (*cc_blockmcl_sw_valuetable)[];
static i64 cc_blockmcl_sw_lower;
static i64 cc_blockmcl_sw_ncases;
static byte cc_blockmcl_sw_defaultseen;
static i64 cc_blockmcl_sw_defaultlabel;
static i64 cc_blockmcl_sw_breaklabel;
static i64 cc_blockmcl_maxreg = (i64)0;
static struct cc_libmcl_mclrec *  cc_genasm_currmcl;
static u16 *  cc_genasm_wstringtable[1024];
static i64 cc_genasm_wstringlentable[1024];
static byte * (*cc_genasm_stringtable)[];
static i64 (*cc_genasm_stringlentable)[];
static double (*cc_genasm_realtable)[];
static i64 (*cc_genasm_dinttable)[];
static i64 cc_genasm_stringtablesize;
static i64 cc_genasm_realtablesize;
static i64 cc_genasm_dinttablesize;
i64 cc_genasm_nwstrings = (i64)0;
i64 cc_genasm_nstrings = (i64)0;
i64 cc_genasm_nreals = (i64)0;
i64 cc_genasm_ndints = (i64)0;
static byte *  cc_genasm_asmstart;
static byte *  cc_genasm_asmptr;
static byte *  cc_genasm_asmend;
static byte cc_genasm_asmbuffer[20000];
static struct mlib_strbuffer cc_export_mmbuffer;
static struct mlib_strbuffer *  cc_export_mm = &cc_export_mmbuffer;
byte *  ax_tables_symbolnames[33] = {
    (byte*)"errorsym",
    (byte*)"commasym",
    (byte*)"colonsym",
    (byte*)"dcolonsym",
    (byte*)"lsqsym",
    (byte*)"rsqsym",
    (byte*)"addsym",
    (byte*)"subsym",
    (byte*)"mulsym",
    (byte*)"eqsym",
    (byte*)"eolsym",
    (byte*)"eofsym",
    (byte*)"hashsym",
    (byte*)"intconstsym",
    (byte*)"realconstsym",
    (byte*)"stringconstsym",
    (byte*)"namesym",
    (byte*)"namedconstsym",
    (byte*)"fwdlocalsym",
    (byte*)"localsym",
    (byte*)"importedsym",
    (byte*)"exportedsym",
    (byte*)"kopcodesym",
    (byte*)"kregsym",
    (byte*)"kxregsym",
    (byte*)"kfregsym",
    (byte*)"kmregsym",
    (byte*)"kjmpccsym",
    (byte*)"ksetccsym",
    (byte*)"kmovccsym",
    (byte*)"kprefixsym",
    (byte*)"ksegnamesym",
    (byte*)"kdummysym"
};
byte *  ax_tables_mclnames[144] = {
    (byte*)"m_comment",
    (byte*)"m_blank",
    (byte*)"m_end",
    (byte*)"m_label",
    (byte*)"m_nop",
    (byte*)"m_param",
    (byte*)"m_assem",
    (byte*)"m_proc",
    (byte*)"m_mov",
    (byte*)"m_push",
    (byte*)"m_pop",
    (byte*)"m_lea",
    (byte*)"m_cmovcc",
    (byte*)"m_movd",
    (byte*)"m_movq",
    (byte*)"m_movsx",
    (byte*)"m_movzx",
    (byte*)"m_movsxd",
    (byte*)"m_call",
    (byte*)"m_ret",
    (byte*)"m_retn",
    (byte*)"m_jmp",
    (byte*)"m_jmpcc",
    (byte*)"m_xchg",
    (byte*)"m_add",
    (byte*)"m_sub",
    (byte*)"m_adc",
    (byte*)"m_sbb",
    (byte*)"m_imul",
    (byte*)"m_mul",
    (byte*)"m_imul2",
    (byte*)"m_imul3",
    (byte*)"m_idiv",
    (byte*)"m_div",
    (byte*)"m_and",
    (byte*)"m_or",
    (byte*)"m_xor",
    (byte*)"m_test",
    (byte*)"m_cmp",
    (byte*)"m_shl",
    (byte*)"m_sar",
    (byte*)"m_shr",
    (byte*)"m_rol",
    (byte*)"m_ror",
    (byte*)"m_rcl",
    (byte*)"m_rcr",
    (byte*)"m_neg",
    (byte*)"m_not",
    (byte*)"m_inc",
    (byte*)"m_dec",
    (byte*)"m_cbw",
    (byte*)"m_cwd",
    (byte*)"m_cdq",
    (byte*)"m_cqo",
    (byte*)"m_setcc",
    (byte*)"m_bsf",
    (byte*)"m_bsr",
    (byte*)"m_sqrtsd",
    (byte*)"m_sqrtss",
    (byte*)"m_addss",
    (byte*)"m_subss",
    (byte*)"m_mulss",
    (byte*)"m_divss",
    (byte*)"m_addsd",
    (byte*)"m_subsd",
    (byte*)"m_mulsd",
    (byte*)"m_divsd",
    (byte*)"m_comiss",
    (byte*)"m_comisd",
    (byte*)"m_xorpd",
    (byte*)"m_xorps",
    (byte*)"m_andpd",
    (byte*)"m_andps",
    (byte*)"m_pxor",
    (byte*)"m_pand",
    (byte*)"m_cvtss2si",
    (byte*)"m_cvtsd2si",
    (byte*)"m_cvttss2si",
    (byte*)"m_cvttsd2si",
    (byte*)"m_cvtsi2ss",
    (byte*)"m_cvtsi2sd",
    (byte*)"m_cvtsd2ss",
    (byte*)"m_cvtss2sd",
    (byte*)"m_movdqa",
    (byte*)"m_movdqu",
    (byte*)"m_pcmpistri",
    (byte*)"m_pcmpistrm",
    (byte*)"m_fld",
    (byte*)"m_fst",
    (byte*)"m_fstp",
    (byte*)"m_fild",
    (byte*)"m_fist",
    (byte*)"m_fistp",
    (byte*)"m_fadd",
    (byte*)"m_fsub",
    (byte*)"m_fmul",
    (byte*)"m_fdiv",
    (byte*)"m_fsqrt",
    (byte*)"m_fsin",
    (byte*)"m_fcos",
    (byte*)"m_fsincos",
    (byte*)"m_fptan",
    (byte*)"m_fpatan",
    (byte*)"m_fabs",
    (byte*)"m_fchs",
    (byte*)"m_minss",
    (byte*)"m_maxss",
    (byte*)"m_minsd",
    (byte*)"m_maxsd",
    (byte*)"m_db",
    (byte*)"m_dw",
    (byte*)"m_dd",
    (byte*)"m_dq",
    (byte*)"m_ddoffset",
    (byte*)"m_segment",
    (byte*)"m_isegment",
    (byte*)"m_zsegment",
    (byte*)"m_csegment",
    (byte*)"m_align",
    (byte*)"m_resb",
    (byte*)"m_resw",
    (byte*)"m_resd",
    (byte*)"m_resq",
    (byte*)"m_xlat",
    (byte*)"m_loopnz",
    (byte*)"m_loopz",
    (byte*)"m_loopcx",
    (byte*)"m_jecxz",
    (byte*)"m_jrcxz",
    (byte*)"m_cmpsb",
    (byte*)"m_cmpsw",
    (byte*)"m_cmpsd",
    (byte*)"m_cmpsq",
    (byte*)"m_rdtsc",
    (byte*)"m_popcnt",
    (byte*)"m_finit",
    (byte*)"m_fldz",
    (byte*)"m_fld1",
    (byte*)"m_fldpi",
    (byte*)"m_fld2t",
    (byte*)"m_fld2e",
    (byte*)"m_fldlg2",
    (byte*)"m_fldln2",
    (byte*)"m_halt"
};
byte ax_tables_mclnopnds[144] = {
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)1u,
    (u8)1u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)3u,
    (u8)3u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)2u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u
};
byte ax_tables_mclcodes[144] = {
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)144u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)232u,
    (u8)195u,
    (u8)0u,
    (u8)233u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)5u,
    (u8)2u,
    (u8)3u,
    (u8)5u,
    (u8)4u,
    (u8)0u,
    (u8)0u,
    (u8)7u,
    (u8)6u,
    (u8)4u,
    (u8)1u,
    (u8)6u,
    (u8)0u,
    (u8)7u,
    (u8)4u,
    (u8)7u,
    (u8)5u,
    (u8)0u,
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)3u,
    (u8)2u,
    (u8)0u,
    (u8)1u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)188u,
    (u8)189u,
    (u8)81u,
    (u8)81u,
    (u8)88u,
    (u8)92u,
    (u8)89u,
    (u8)94u,
    (u8)88u,
    (u8)92u,
    (u8)89u,
    (u8)94u,
    (u8)0u,
    (u8)0u,
    (u8)87u,
    (u8)87u,
    (u8)84u,
    (u8)84u,
    (u8)239u,
    (u8)219u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)102u,
    (u8)243u,
    (u8)99u,
    (u8)98u,
    (u8)0u,
    (u8)2u,
    (u8)3u,
    (u8)0u,
    (u8)2u,
    (u8)3u,
    (u8)193u,
    (u8)233u,
    (u8)201u,
    (u8)249u,
    (u8)250u,
    (u8)254u,
    (u8)255u,
    (u8)251u,
    (u8)242u,
    (u8)243u,
    (u8)225u,
    (u8)224u,
    (u8)93u,
    (u8)95u,
    (u8)93u,
    (u8)95u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)1u,
    (u8)2u,
    (u8)4u,
    (u8)8u,
    (u8)215u,
    (u8)224u,
    (u8)225u,
    (u8)226u,
    (u8)227u,
    (u8)227u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)49u,
    (u8)0u,
    (u8)0u,
    (u8)238u,
    (u8)232u,
    (u8)235u,
    (u8)233u,
    (u8)234u,
    (u8)236u,
    (u8)237u,
    (u8)244u
};
byte *  ax_tables_regnames[21] = {
    (byte*)"rnone",
    (byte*)"r0",
    (byte*)"r1",
    (byte*)"r2",
    (byte*)"r3",
    (byte*)"r4",
    (byte*)"r5",
    (byte*)"r6",
    (byte*)"r7",
    (byte*)"r8",
    (byte*)"r9",
    (byte*)"r10",
    (byte*)"r11",
    (byte*)"r12",
    (byte*)"r13",
    (byte*)"r14",
    (byte*)"r15",
    (byte*)"r16",
    (byte*)"r17",
    (byte*)"r18",
    (byte*)"r19"
};
byte ax_tables_regcodes[21] = {
    (u8)0u,
    (u8)0u,
    (u8)3u,
    (u8)6u,
    (u8)7u,
    (u8)10u,
    (u8)11u,
    (u8)12u,
    (u8)13u,
    (u8)14u,
    (u8)15u,
    (u8)1u,
    (u8)2u,
    (u8)8u,
    (u8)9u,
    (u8)5u,
    (u8)4u,
    (u8)4u,
    (u8)7u,
    (u8)5u,
    (u8)6u
};
byte *  ax_tables_dregnames[136] = {
    (byte*)"d0",
    (byte*)"d1",
    (byte*)"d2",
    (byte*)"d3",
    (byte*)"d4",
    (byte*)"d5",
    (byte*)"d6",
    (byte*)"d7",
    (byte*)"d8",
    (byte*)"d9",
    (byte*)"d10",
    (byte*)"d11",
    (byte*)"d12",
    (byte*)"d13",
    (byte*)"d14",
    (byte*)"d15",
    (byte*)"a0",
    (byte*)"a1",
    (byte*)"a2",
    (byte*)"a3",
    (byte*)"a4",
    (byte*)"a5",
    (byte*)"a6",
    (byte*)"a7",
    (byte*)"a8",
    (byte*)"a9",
    (byte*)"a10",
    (byte*)"a11",
    (byte*)"a12",
    (byte*)"a13",
    (byte*)"a14",
    (byte*)"a15",
    (byte*)"w0",
    (byte*)"w1",
    (byte*)"w2",
    (byte*)"w3",
    (byte*)"w4",
    (byte*)"w5",
    (byte*)"w6",
    (byte*)"w7",
    (byte*)"w8",
    (byte*)"w9",
    (byte*)"w10",
    (byte*)"w11",
    (byte*)"w12",
    (byte*)"w13",
    (byte*)"w14",
    (byte*)"w15",
    (byte*)"b0",
    (byte*)"b1",
    (byte*)"b2",
    (byte*)"b3",
    (byte*)"b4",
    (byte*)"b5",
    (byte*)"b6",
    (byte*)"b7",
    (byte*)"b8",
    (byte*)"b9",
    (byte*)"b10",
    (byte*)"b11",
    (byte*)"b12",
    (byte*)"b13",
    (byte*)"b14",
    (byte*)"b15",
    (byte*)"b16",
    (byte*)"b17",
    (byte*)"b18",
    (byte*)"b19",
    (byte*)"rax",
    (byte*)"rbx",
    (byte*)"rcx",
    (byte*)"rdx",
    (byte*)"rsi",
    (byte*)"rdi",
    (byte*)"rbp",
    (byte*)"rsp",
    (byte*)"r8",
    (byte*)"r9",
    (byte*)"r10",
    (byte*)"r11",
    (byte*)"r12",
    (byte*)"r13",
    (byte*)"r14",
    (byte*)"r15",
    (byte*)"eax",
    (byte*)"ebx",
    (byte*)"ecx",
    (byte*)"edx",
    (byte*)"esi",
    (byte*)"edi",
    (byte*)"ebp",
    (byte*)"esp",
    (byte*)"r8d",
    (byte*)"r9d",
    (byte*)"r10d",
    (byte*)"r11d",
    (byte*)"r12d",
    (byte*)"r13d",
    (byte*)"r14d",
    (byte*)"r15d",
    (byte*)"ax",
    (byte*)"bx",
    (byte*)"cx",
    (byte*)"dx",
    (byte*)"si",
    (byte*)"di",
    (byte*)"bp",
    (byte*)"sp",
    (byte*)"r8w",
    (byte*)"r9w",
    (byte*)"r10w",
    (byte*)"r11w",
    (byte*)"r12w",
    (byte*)"r13w",
    (byte*)"r14w",
    (byte*)"r15w",
    (byte*)"al",
    (byte*)"bl",
    (byte*)"cl",
    (byte*)"dl",
    (byte*)"ah",
    (byte*)"bh",
    (byte*)"ch",
    (byte*)"dh",
    (byte*)"sil",
    (byte*)"dil",
    (byte*)"bpl",
    (byte*)"spl",
    (byte*)"r8b",
    (byte*)"r9b",
    (byte*)"r10b",
    (byte*)"r11b",
    (byte*)"r12b",
    (byte*)"r13b",
    (byte*)"r14b",
    (byte*)"r15b"
};
byte ax_tables_regsizes[136] = {
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)8u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)4u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)2u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u,
    (u8)1u
};
byte ax_tables_regindices[136] = {
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)4u,
    (u8)5u,
    (u8)6u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)11u,
    (u8)12u,
    (u8)13u,
    (u8)14u,
    (u8)15u,
    (u8)16u,
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)4u,
    (u8)5u,
    (u8)6u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)11u,
    (u8)12u,
    (u8)13u,
    (u8)14u,
    (u8)15u,
    (u8)16u,
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)4u,
    (u8)5u,
    (u8)6u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)11u,
    (u8)12u,
    (u8)13u,
    (u8)14u,
    (u8)15u,
    (u8)16u,
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)4u,
    (u8)5u,
    (u8)6u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)11u,
    (u8)12u,
    (u8)13u,
    (u8)14u,
    (u8)15u,
    (u8)16u,
    (u8)17u,
    (u8)18u,
    (u8)19u,
    (u8)20u,
    (u8)1u,
    (u8)2u,
    (u8)11u,
    (u8)12u,
    (u8)3u,
    (u8)4u,
    (u8)15u,
    (u8)16u,
    (u8)13u,
    (u8)14u,
    (u8)5u,
    (u8)6u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)1u,
    (u8)2u,
    (u8)11u,
    (u8)12u,
    (u8)3u,
    (u8)4u,
    (u8)15u,
    (u8)16u,
    (u8)13u,
    (u8)14u,
    (u8)5u,
    (u8)6u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)1u,
    (u8)2u,
    (u8)11u,
    (u8)12u,
    (u8)3u,
    (u8)4u,
    (u8)15u,
    (u8)16u,
    (u8)13u,
    (u8)14u,
    (u8)5u,
    (u8)6u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)1u,
    (u8)2u,
    (u8)11u,
    (u8)12u,
    (u8)17u,
    (u8)18u,
    (u8)19u,
    (u8)20u,
    (u8)3u,
    (u8)4u,
    (u8)15u,
    (u8)16u,
    (u8)13u,
    (u8)14u,
    (u8)5u,
    (u8)6u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u
};
byte *  ax_tables_xregnames[16] = {
    (byte*)"xmm0",
    (byte*)"xmm1",
    (byte*)"xmm2",
    (byte*)"xmm3",
    (byte*)"xmm4",
    (byte*)"xmm5",
    (byte*)"xmm6",
    (byte*)"xmm7",
    (byte*)"xmm8",
    (byte*)"xmm9",
    (byte*)"xmm10",
    (byte*)"xmm11",
    (byte*)"xmm12",
    (byte*)"xmm13",
    (byte*)"xmm14",
    (byte*)"xmm15"
};
byte *  ax_tables_fregnames[8] = {(byte*)"st0",(byte*)"st1",(byte*)"st2",(byte*)"st3",(byte*)"st4",(byte*)"st5",(byte*)"st6",(byte*)"st7"};
byte *  ax_tables_mregnames[8] = {(byte*)"mmx0",(byte*)"mmx1",(byte*)"mmx2",(byte*)"mmx3",(byte*)"mmx4",(byte*)"mmx5",(byte*)"mmx6",(byte*)"mmx7"};
byte *  ax_tables_condnames[16] = {
    (byte*)"o",
    (byte*)"no",
    (byte*)"b",
    (byte*)"ae",
    (byte*)"z",
    (byte*)"nz",
    (byte*)"be",
    (byte*)"a",
    (byte*)"s",
    (byte*)"ns",
    (byte*)"p",
    (byte*)"np",
    (byte*)"l",
    (byte*)"ge",
    (byte*)"le",
    (byte*)"g"
};
byte *  ax_tables_jmpccnames[18] = {
    (byte*)"jo",
    (byte*)"jno",
    (byte*)"jb",
    (byte*)"jae",
    (byte*)"jz",
    (byte*)"jnz",
    (byte*)"jbe",
    (byte*)"ja",
    (byte*)"js",
    (byte*)"jns",
    (byte*)"jp",
    (byte*)"jnp",
    (byte*)"jl",
    (byte*)"jge",
    (byte*)"jle",
    (byte*)"jg",
    (byte*)"jc",
    (byte*)"jnc"
};
byte ax_tables_jmpcccodes[18] = {
    (u8)0u,
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)4u,
    (u8)5u,
    (u8)6u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)11u,
    (u8)12u,
    (u8)13u,
    (u8)14u,
    (u8)15u,
    (u8)2u,
    (u8)3u
};
byte *  ax_tables_setccnames[18] = {
    (byte*)"seto",
    (byte*)"setno",
    (byte*)"setb",
    (byte*)"setae",
    (byte*)"setz",
    (byte*)"setnz",
    (byte*)"setbe",
    (byte*)"seta",
    (byte*)"sets",
    (byte*)"setns",
    (byte*)"setp",
    (byte*)"setnp",
    (byte*)"setl",
    (byte*)"setge",
    (byte*)"setle",
    (byte*)"setg",
    (byte*)"setc",
    (byte*)"setnc"
};
byte ax_tables_setcccodes[18] = {
    (u8)0u,
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)4u,
    (u8)5u,
    (u8)6u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)11u,
    (u8)12u,
    (u8)13u,
    (u8)14u,
    (u8)15u,
    (u8)2u,
    (u8)3u
};
byte *  ax_tables_cmovccnames[18] = {
    (byte*)"cmovo",
    (byte*)"cmovno",
    (byte*)"cmovb",
    (byte*)"cmovae",
    (byte*)"cmovz",
    (byte*)"cmovnz",
    (byte*)"cmovbe",
    (byte*)"cmova",
    (byte*)"cmovs",
    (byte*)"cmovns",
    (byte*)"cmovp",
    (byte*)"cmovnp",
    (byte*)"cmovl",
    (byte*)"cmovge",
    (byte*)"cmovle",
    (byte*)"cmovg",
    (byte*)"cmovc",
    (byte*)"cmovnc"
};
byte ax_tables_cmovcccodes[18] = {
    (u8)0u,
    (u8)1u,
    (u8)2u,
    (u8)3u,
    (u8)4u,
    (u8)5u,
    (u8)6u,
    (u8)7u,
    (u8)8u,
    (u8)9u,
    (u8)10u,
    (u8)11u,
    (u8)12u,
    (u8)13u,
    (u8)14u,
    (u8)15u,
    (u8)2u,
    (u8)3u
};
byte *  ax_tables_prefixnames[8] = {(byte*)"byte",(byte*)"word",(byte*)"word16",(byte*)"word32",(byte*)"dword",(byte*)"word64",(byte*)"qword",(byte*)"word128"};
byte ax_tables_prefixsizes[8] = {(u8)1u,(u8)2u,(u8)2u,(u8)4u,(u8)4u,(u8)8u,(u8)8u,(u8)16u};
byte *  ax_tables_reftypenames[3] = {(byte*)"extern_ref",(byte*)"fwd_ref",(byte*)"back_ref"};
byte *  ax_tables_segmentnames[5] = {(byte*)"code_seg",(byte*)"idata_seg",(byte*)"zdata_seg",(byte*)"rodata_seg",(byte*)"impdata_seg"};
i64 ax_decls_lxfileno = (i64)0;
i64 ax_decls_lxlineno = (i64)0;
i64 ax_decls_nsourcefiles = (i64)0;
struct ax_decls_modulerec ax_decls_moduletable[200];
byte *  ax_decls_searchlibs[30];
i64 ax_decls_nmodules;
i64 ax_decls_nsearchlibs;
struct ax_decls_strec *  ax_decls_lexhashtable[2097152];
struct ax_decls_strec *  ax_decls_dupltable[2097152];
void *  ax_decls_logdev;
i64 ax_decls_fverbose = (i64)0;
i64 ax_decls_fquiet = (i64)0;
i64 ax_decls_linecount = (i64)0;
i64 ax_decls_nundefined = (i64)0;
i64 ax_decls_alineno = (i64)0;
i64 ax_decls_ss_zdatalen;
struct ax_decls_dbuffer *  ax_decls_ss_zdata;
struct ax_decls_dbuffer *  ax_decls_ss_idata;
struct ax_decls_dbuffer *  ax_decls_ss_code;
struct ax_decls_relocrec *  ax_decls_ss_idatarelocs;
struct ax_decls_relocrec *  ax_decls_ss_coderelocs;
i64 ax_decls_ss_nidatarelocs;
i64 ax_decls_ss_ncoderelocs;
struct ax_decls_strec * (*ax_decls_ss_symboltable)[];
i64 ax_decls_ss_nsymbols;
i64 ax_decls_ss_symboltablesize;
struct ax_decls_stlistrec *  ax_decls_globalimportlist;
struct ax_decls_strec *  ax_decls_modulenamelist;
i64 ax_decls_currmoduleno;
i64 ax_decls_nmclasm;
i64 ax_decls_nmclopndsasm;
static struct ax_decls_fwdrec ax_lex_dummy1;
static struct ax_decls_opndrec ax_lex_dummy2;
i64 ax_lex_lxsymbol;
i64 ax_lex_lxsubcode;
i64 ax_lex_lxvalue;
double ax_lex_lxxvalue;
byte *  ax_lex_lxsvalue;
i64 ax_lex_lxlength;
static i64 ax_lex_lxhashvalue;
byte *  ax_lex_lxsptr;
static byte *  ax_lex_lxstart;
struct ax_decls_strec *  ax_lex_lxsymptr;
static byte ax_lex_alphamap[256];
static byte ax_lex_digitmap[256];
static byte ax_lex_commentmap[256];
static struct ax_decls_fwdrec ax_parse_dummy1;
static struct ax_decls_strec *  ax_parse_exprlabeldef;
static i64 ax_parse_exprvalue;
static i64 ax_parse_exprtype;
static struct ax_decls_fwdrec ax_lib_dummy1;
byte *  ax_lib_opndnames[7] = {(byte*)"a_none",(byte*)"a_reg",(byte*)"a_imm",(byte*)"a_mem",(byte*)"a_cond",(byte*)"a_xreg",(byte*)"a_string"};
i64 ax_lib_currsegment = (i64)0;
struct ax_decls_opndrec ax_lib_dstackopnd;
struct ax_decls_opndrec ax_lib_dframeopnd;
i64 ax_lib_labelno = (i64)0;
struct ax_decls_opndrec *  ax_lib_zero_opnd = 0;
struct ax_lib_mclrec *  ax_lib_mccode;
struct ax_lib_mclrec *  ax_lib_mccodex;
static struct mlib_strbuffer ax_lib_destv;
struct mlib_strbuffer *  ax_lib_dest = &ax_lib_destv;
struct ax_decls_opndrec *  ax_lib_regtable[20][8];
static i64 ax_genss_rex;
static i64 ax_genss_sizeoverride;
static i64 ax_genss_addroverride;
static i64 ax_genss_f2override;
static i64 ax_genss_f3override;
static struct ax_decls_opndrec *  ax_genss_extraparam;
static i64 ax_genss_currseg = (i64)0;
static struct ax_decls_dbuffer *  ax_genss_currdata;
static struct ax_decls_relocrec *  ax_genss_currrelocs;
static i64 ax_genss_nrelocs;
static struct ax_lib_mclrec *  ax_genss_currmcl;
byte *  ax_objdecls_relocnames[7] = {(byte*)"abs_rel",(byte*)"addr64_rel",(byte*)"addr32_rel",(byte*)"addr32nb_rel",(byte*)"rel32_rel",(byte*)"rel321_rel",(byte*)"rel8_rel"};
byte *  ax_objdecls_coffscopenames[3] = {(byte*)"cofflocal_scope",(byte*)"export_scope",(byte*)"import_scope"};
static i64 ax_writeexe_libinsttable[30];
static byte *  ax_writeexe_libinstnames[30];
static i64 ax_writeexe_libnotable[30];
static i64 ax_writeexe_imagesize;
static i64 ax_writeexe_filesize;
static i64 (*ax_writeexe_thunktable)[];
static i64 ax_writeexe_fileiatoffset;
static i64 ax_writeexe_fileiatsize;
static struct ax_decls_strec *  ax_writeexe_stentrypoint;
static struct ax_decls_strec *  ax_writeexe_stentrypoint2;
static struct ax_decls_strec *  ax_writeexe_stentrypoint3;
static struct ax_writeexe_sectionrec ax_writeexe_sectiontable[10];
static i64 ax_writeexe_nsections;
static byte *  ax_writeexe_importdir;
static struct ax_writeexe_importrec ax_writeexe_importtable[3000];
static i64 ax_writeexe_nimports;
static struct ax_writeexe_dllrec ax_writeexe_dlltable[50];
static i64 ax_writeexe_ndlls;
static byte *  ax_writeexe_datastart;
static byte *  ax_writeexe_dataptr;
static byte *  ax_writeexe_userentrypoint;
static i64 ax_disasm_abc;
static double ax_disasm_xyz;
static i64 ax_disasm_res2;
static i64 ax_disasm_lx;
static i64 ax_disasm_nmodules;
static i64 ax_disasm_xfchsmask_pd;
static byte *  ax_disasm_opnames[8] = {(byte*)"add",(byte*)"or",(byte*)"adc",(byte*)"sbb",(byte*)"and",(byte*)"sub",(byte*)"xor",(byte*)"cmp"};
static byte *  ax_disasm_condnames[16] = {
    (byte*)"o",
    (byte*)"no",
    (byte*)"b",
    (byte*)"ae",
    (byte*)"z",
    (byte*)"nz",
    (byte*)"be",
    (byte*)"a",
    (byte*)"s",
    (byte*)"ns",
    (byte*)"p",
    (byte*)"np",
    (byte*)"l",
    (byte*)"ge",
    (byte*)"le",
    (byte*)"g"
};
static byte *  ax_disasm_addrmodenames[3] = {(byte*)"amreg",(byte*)"ammem",(byte*)"amrel"};
static i64 ax_disasm_rex;
static i64 ax_disasm_addrmode;
static i64 ax_disasm_rmreg;
static i64 ax_disasm_rmopc;
static i64 ax_disasm_basereg;
static i64 ax_disasm_indexreg;
static i64 ax_disasm_scale;
static i64 ax_disasm_opsize;
static i64 ax_disasm_offset;
static i64 ax_disasm_offsetsize;
static i64 ax_disasm_sizeoverride;
static i64 ax_disasm_addroverride;
static i64 ax_disasm_f2override;
static i64 ax_disasm_f3override;
static byte ax_disasm_deststr[256];
static byte *  ax_disasm_destptr;
static byte *  ax_disasm_codeptr;
static i64 ax_writeobj_symtaboffset;
static byte *  ax_writeobj_datastart;
static byte *  ax_writeobj_dataptr;
static struct ax_objdecls_imagesymbol ax_writeobj_symboltable[10001];
static i64 ax_writeobj_nsymbols;
static i64 ax_writeobj_stoffset = (i64)0;
static byte *  ax_writeobj_stringtable[5000];
static i64 ax_writeobj_stringlengths[5000];
static i64 ax_writeobj_nextstringoffset = (i64)0;
static i64 ax_writeobj_nstrings = (i64)0;

/* PROCDEFS */
/* START */
void start(void) {
    i64 pass;
    i64 nextmodule;
    cc_starttiming();
    cc_initdata();
    cc_getinputoptions();
    if (!!((u64)(cc_fdebugcompiler))) {
        cc_debugcompile();
        exit(0);
    };
    if ((cc_cc_mode >= (i64)3)) {
        cc_decls_fastasm = (i64)1;
    };
    cc_initsearchdirs();
    cc_initlogfile();
    nextmodule = (i64)1;
    pass = (i64)1;
    L1 :;
    do {
        cc_compilemodules(nextmodule,cc_decls_ninputfiles,pass++);
        nextmodule = cc_addnewmodules();
L2 :;
    } while (!(nextmodule == (i64)0));L3 :;
    ;
    if ((cc_cc_mode >= (i64)3)) {
        cc_do_genlink();
    };
    if ((cc_cc_mode == (i64)4)) {
        cc_do_runprog();
    };
    if (!!((u64)(cc_fshowtiming))) {
        cc_showtiming();
    };
    if (!!((u64)(cc_fmheaders))) {
        cc_export_writemheader(cc_decls_inputfiles[((i64)1)]);
    };
    if (!!((u64)(cc_fatfile))) {
        cc_writeatfile();
    };
    exit((i64)0);
}

int main(int nargs, char** args) {
int i;
	msysnewc_nsysparams=nargs;
	if (msysnewc_nsysparams>nargs) {puts("Too many params"); exit(1);}
	for (i=1; i<=nargs; ++i) msysnewc_sysparams[i-1]=(byte*)args[i-1];


	start();
	return 0;
}

static void cc_compilemodules(i64 a,i64 b,i64 pass) {
    byte str[256];
    byte *  ext;
    i64 m;
    if ((cc_destfileext == 0)) {
        if ((cc_cc_mode == (i64)1)) {
            ext = (byte*)"i";
        } else if (!(!!(cc_decls_fautomodules))) {
            ext = (byte*)"asm";
            if (((cc_decls_ninputfiles == (i64)1) && (cc_cc_mode >= (i64)3))) {
                ext = cc_linkoption;
            };
        } else {
            ext = (byte*)"asm";
        };
    } else {
        ext = cc_destfileext;
    };
    L4 :;
    for (m=a;m<=b;m+=(i64)1) {
L5 :;
        if (!!(cc_decls_fautomodules)) {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_setfmt((byte*)"## Compiling # to # (Pass #)");
            msysnewc_m_print_str(((pass == (i64)1)?(byte*)"  ":(byte*)"* "),NULL);
            msysnewc_m_print_i64(m,(byte*)"2");
            msysnewc_m_print_str(cc_decls_inputfiles[(m)],(byte*)"jl12");
            msysnewc_m_print_str(mlib_changeext(cc_decls_inputfiles[(m)],ext),(byte*)"jl16");
            msysnewc_m_print_i64(pass,NULL);
            msysnewc_m_print_end();
            ;
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(str,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        } else if (!(!!(cc_decls_fquiet))) {
            if ((cc_cc_mode == (i64)1)) {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((byte*)"Preprocessing",NULL);
                msysnewc_m_print_str(cc_decls_inputfiles[(m)],NULL);
                msysnewc_m_print_str((byte*)"to",NULL);
                msysnewc_m_print_str(mlib_changeext(cc_decls_inputfiles[(m)],(byte*)"i"),NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
            } else if ((cc_decls_ninputfiles == (i64)1)) {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((byte*)"Compiling",NULL);
                msysnewc_m_print_str(cc_decls_inputfiles[(m)],NULL);
                msysnewc_m_print_str((byte*)"to",NULL);
                msysnewc_m_print_str(mlib_changeext(cc_destfilename,ext),NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
            } else {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((byte*)"Compiling",NULL);
                msysnewc_m_print_str(cc_decls_inputfiles[(m)],NULL);
                msysnewc_m_print_str((byte*)"to",NULL);
                msysnewc_m_print_str(mlib_changeext(cc_decls_inputfiles[(m)],(byte*)"asm"),NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
            };
        };
        cc_do_loadmodule(m);
        if ((cc_cc_mode == (i64)1)) {
            cc_do_preprocess(m);
            cc_resetcompiler();
            goto L6 ;
        };
        cc_do_parsemodule(m);
        if (!(!!((u64)(cc_fatfile)))) {
            cc_do_genmcl(m);
            cc_do_genasm(m);
        };
        if (!(!!((u64)(cc_fmheaders)))) {
            cc_resetcompiler();
        };
L6 :;
    }L7 :;
    ;
}

static void cc_debugcompile(void) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"DEBUG COMPILE 123",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    cc_initsearchdirs();
    cc_decls_logdest = (i64)2;
    cc_initlogfile();
    cc_do_loadmodule((i64)1);
    cc_do_parsemodule((i64)1);
    cc_showast((i64)1);
    cc_do_genmcl((i64)1);
    cc_showmcl((byte*)"MCL",(i64)1);
    cc_do_genasm((i64)1);
    cc_showasm((i64)1);
    cc_showsttree((byte*)"ST",(i64)1);
    cc_closelogfile();
}

static void cc_do_loadmodule(i64 n) {
    if (!!(cc_decls_fverbose)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"Loading:",NULL);
        msysnewc_m_print_str(cc_decls_inputfiles[(n)],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    cc_loadmainmodule(cc_decls_inputfiles[(n)]);
}

static void cc_do_preprocess(i64 n) {
    cc_lex_lex_preprocess_only(cc_decls_inputfiles[(n)],(i64)1,n,(i64)(cc_fstdout));
}

static void cc_do_parsemodule(i64 n) {
    if (!!(cc_decls_fverbose)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"Parsing:",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    cc_parse_parsemodule(n);
}

static void cc_do_genmcl(i64 n) {
    cc_genmcl_codegen_mcl(n);
}

static void cc_do_genasm(i64 n) {
    byte *  outfileasm;
    outfileasm = mlib_pcm_copyheapstring(mlib_changeext(cc_decls_inputfiles[(n)],(byte*)"asm"));
    cc_genasm_codegen_writeasm(n,outfileasm);
}

static void cc_do_runprog(void) {
    byte str[300];
    i64 i;
    strcpy((i8 *)(str),(i8 *)(cc_destfilename));
    L8 :;
    for (i=(i64)1;i<=cc_nextraparams;i+=(i64)1) {
L9 :;
        strcat((i8 *)(str),(i8 *)((byte*)" "));
        strcat((i8 *)(str),(i8 *)(cc_extraparams[(i)-1]));
        if (!!(cc_extravalues[(i)-1])) {
            strcat((i8 *)(str),(i8 *)((byte*)":"));
            strcat((i8 *)(str),(i8 *)(cc_extravalues[(i)-1]));
        };
L10 :;
    }L11 :;
    ;
    osnos_os_execwait(str,(i64)0,(byte *)(0));
}

static i64 cc_loadmainmodule(byte * filespec) {
    byte modulename[100];
    byte path[300];
    i64 i;
    i64 fileno;
    mlib_pcm_clearmem((void *)(&cc_decls_moduletable[((i64)0)]),(i64)224);
    cc_decls_sourcefilenames[((i64)0)] = (byte*)"<dummy file>";
    cc_decls_sourcefilepaths[((i64)0)] = (byte*)"<dummy path>";
    cc_decls_sourcefiletext[((i64)0)] = (byte*)"<sourcefile0>";
    cc_decls_sourcefilesizes[((i64)0)] = (i64)(strlen((i8 *)(cc_decls_sourcefiletext[((i64)0)])));
    cc_decls_moduletable[((i64)0)].name = (byte*)"PROGRAM";
    cc_decls_moduletable[((i64)0)].fileno = (i64)0;
    cc_decls_stprogram = cc_lib_createdupldef((struct cc_decls_strec *)(0),cc_lex_addnamestr((byte*)"$prog"),(i64)2);
    cc_decls_moduletable[((i64)0)].stmodule = cc_decls_stprogram;
    if ((!(!!(mlib_checkfile(filespec))) && !(!!((u64)(cc_fstdin))))) {
        cc_support_loaderror((byte*)"Can't load main module: %s",filespec);
    };
    if (!!((u64)(cc_fstdin))) {
        fileno = cc_support_loadfromstdin(filespec);
    } else {
        fileno = cc_support_loadsourcefile(filespec,filespec);
    };
    strcpy((i8 *)(modulename),(i8 *)(mlib_extractbasefile(filespec)));
    strcpy((i8 *)(path),(i8 *)(mlib_extractpath(filespec)));
    if (!!((u64)(path[((i64)1)-1]))) {
        ++cc_decls_nsearchdirs;
        L12 :;
        for (i=cc_decls_nsearchdirs;i>=(i64)2;i-=(i64)1) {
L13 :;
            cc_decls_searchdirs[(i)-1] = cc_decls_searchdirs[((i - (i64)1))-1];
L14 :;
        }L15 :;
        ;
        cc_decls_searchdirs[((i64)1)-1] = mlib_pcm_copyheapstring(path);
    };
    cc_addmodule(modulename,fileno,(i64)3);
    return (i64)1;
}

static i64 cc_addmodule(byte * modulename,i64 fileno,i64 id) {
    struct cc_decls_modulerec m;
    struct cc_decls_modulerec *  pmodule;
    mlib_pcm_clearmem((void *)(&m),(i64)224);
    m.name = mlib_pcm_copyheapstring(modulename);
    m.fileno = fileno;
    cc_decls_stmodule = cc_lib_createnewmoduledef(cc_decls_stprogram,cc_lex_addnamestr(m.name));
    m.stmodule = cc_decls_stmodule;
    if ((cc_decls_nmodules >= (i64)200)) {
        cc_support_loaderror((byte*)"Too many modules %s",modulename);
    };
    pmodule = &cc_decls_moduletable[(++cc_decls_nmodules)];
    (*pmodule) = m;
    (*m.stmodule).attribs.ax_moduleno = (u64)(cc_decls_nmodules);
    if ((cc_decls_nmodules >= (i64)200)) {
        cc_support_loaderror((byte*)"Too many modules %s",modulename);
    };
    return cc_decls_nmodules;
}

static void cc_initlogfile(void) {
    if ((cc_decls_logdest==(i64)2)) {
        remove((i8 *)((byte*)"bcc.log"));
        cc_decls_logdev = fopen((i8 *)((byte*)"bcc.log"),(i8 *)((byte*)"w"));
    }else if ((cc_decls_logdest==(i64)0) || (cc_decls_logdest==(i64)1)) {
        cc_decls_logdev = osnos_os_getstdout();
    };
}

static void cc_closelogfile(void) {
    byte str[100];
    if ((cc_decls_logdest == (i64)2)) {
        fclose(cc_decls_logdev);
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_str((byte*)"\\m\\med.bat",NULL);
        msysnewc_m_print_str((byte*)"bcc.log",NULL);
        msysnewc_m_print_end();
        ;
        if (!!(mlib_checkfile((byte*)"cc.m"))) {
            osnos_os_execwait(str,(i64)1,(byte *)(0));
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)"Diagnostic outputs written to",NULL);
            msysnewc_m_print_str((byte*)"bcc.log",NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        };
    };
}

static void cc_initdata(void) {
    mlib_pcm_init();
    cc_lex_lexsetup();
    cc_lib_inittypetables();
    cc_lib_initcclib();
    cc_headers_checkbcclib();
}

static void cc_initsearchdirs(void) {
    i64 i;
    cc_decls_searchdirs[(++cc_decls_nsearchdirs)-1] = (byte*)"";
    if ((cc_decls_dointheaders == (i64)0)) {
        cc_decls_searchdirs[(++cc_decls_nsearchdirs)-1] = (byte*)"/cx/headers/";
    };
    L16 :;
    for (i=(i64)1;i<=cc_decls_nincludepaths;i+=(i64)1) {
L17 :;
        if (!!((u64)((*cc_decls_includepaths[(i)-1])))) {
            cc_decls_searchdirs[(++cc_decls_nsearchdirs)-1] = cc_decls_includepaths[(i)-1];
        };
L18 :;
    }L19 :;
    ;
}

static void cc_showsearchdirs(void) {
    i64 i;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"Include search paths:",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    if (!!(cc_decls_dointheaders)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"0: Internal standard headers (disable with -ext)",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    L20 :;
    for (i=(i64)1;i<=cc_decls_nsearchdirs;i+=(i64)1) {
L21 :;
        if (!!((u64)((*cc_decls_searchdirs[(i)-1])))) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_i64(i,NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str((byte*)":",NULL);
            msysnewc_m_print_str(cc_decls_searchdirs[(i)-1],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_i64(i,NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str((byte*)": .",NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        };
L22 :;
    }L23 :;
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

static void cc_showast(i64 n) {
    if (!!(cc_decls_logdest)) {
        if ((cc_decls_logdest == (i64)2)) {
            msysnewc_m_print_startfile(cc_decls_logdev);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        };
        cc_lib_printcode(cc_decls_logdev,(byte*)"PROC AST",n);
        msysnewc_m_print_startfile(cc_decls_logdev);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
}

static void cc_showstflat(byte * caption) {
    if (!!(cc_decls_logdest)) {
        if ((cc_decls_logdest == (i64)2)) {
        };
        msysnewc_m_print_startfile(cc_decls_logdev);
        msysnewc_m_print_str((byte*)"PROC",NULL);
        msysnewc_m_print_str(caption,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        cc_lib_printstflat(cc_decls_logdev);
        msysnewc_m_print_startfile(cc_decls_logdev);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
}

static void cc_showsttree(byte * caption,i64 n) {
    if (!!(cc_decls_logdest)) {
        if ((cc_decls_logdest == (i64)2)) {
        };
        msysnewc_m_print_startfile(cc_decls_logdev);
        msysnewc_m_print_str((byte*)"PROC",NULL);
        msysnewc_m_print_str(caption,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        cc_lib_printst(cc_decls_logdev,cc_decls_moduletable[(n)].stmodule,(i64)0);
        msysnewc_m_print_startfile(cc_decls_logdev);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
}

static void cc_showmcl(byte * caption,i64 n) {
    struct mlib_strbuffer *  mclstr;
    if (!!(cc_decls_logdest)) {
        mclstr = cc_libmcl_writemclcode(caption,n);
        mlib_gs_println(mclstr,cc_decls_logdev);
    };
}

static void cc_showasm(i64 n) {
    byte *  asmstr;
    byte *  caption;
    caption = (byte*)"PROC ASSEMBLY LISTING";
    asmstr = cc_decls_moduletable[(n)].asmstr;
    if ((asmstr == 0)) {
        return;
    };
    if (!!(cc_decls_logdest)) {
        msysnewc_m_print_startfile(cc_decls_logdev);
        msysnewc_m_print_str(caption,NULL);
        msysnewc_m_print_i64(n,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        msysnewc_m_print_startfile(cc_decls_logdev);
        msysnewc_m_print_str(asmstr,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
}

static void cc_showfiles(void) {
    i64 i;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"Sourcefiles:",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    L24 :;
    for (i=(i64)1;i<=cc_decls_nsourcefiles;i+=(i64)1) {
L25 :;
        msysnewc_m_print_startcon();
        msysnewc_m_print_i64(i,NULL);
        msysnewc_m_print_str((byte*)":",NULL);
        msysnewc_m_print_str(cc_decls_sourcefilepaths[(i)],NULL);
        msysnewc_m_print_str(cc_decls_sourcefilenames[(i)],NULL);
        msysnewc_m_print_str((byte*)"Size:",NULL);
        msysnewc_m_print_i64(cc_decls_sourcefilesizes[(i)],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
L26 :;
    }L27 :;
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

static void cc_starttiming(void) {
    cc_progstart = osnos_os_clock();
}

static void cc_showtiming(void) {
    cc_showlps((byte*)"Program",(osnos_os_clock() - cc_progstart));
}

void cc_showlps(byte * caption,i64 t) {
    byte str[256];
    i64 lps;
    i64 txi;
    double lpsx;
    txi = t;
    if ((t > (i64)1)) {
        lpsx = ((double)(cc_decls_nalllines) / (double)(t));
    } else {
        lps = (i64)((lpsx = (double)0.));
    };
    msysnewc_m_print_startcon();
    msysnewc_m_print_i64(cc_decls_nalllines,NULL);
    msysnewc_m_print_str((byte*)"Lines",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_setfmt((byte*)"#: # ms  #dK Lines per second");
    msysnewc_m_print_str(caption,(byte*)"18");
    msysnewc_m_print_i64(txi,(byte*)"4");
    msysnewc_m_print_i64((i64)(lpsx),(byte*)"8");
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(str,NULL);
    msysnewc_m_print_end();
    ;
}

static void cc_getinputoptions(void) {
    i64 paramno;
    i64 pmtype;
    i64 sw;
    i64 ncolons;
    byte *  name;
    byte *  value;
    byte *  ext;
    i64 av_1;
    paramno = (i64)2;
    ncolons = (i64)0;
    L28 :;
    while (1) {
        pmtype = mlib_nextcmdparam(&paramno,&name,&value,(byte*)".c");
        if ((pmtype==(i64)1)) {
            mlib_convlcstring(name);
            L30 :;
            for (sw=(i64)1;sw<=(i64)31;sw+=(i64)1) {
L31 :;
                if (!!(mlib_eqstring(name,cc_optionnames[(sw)-1]))) {
                    cc_do_option(sw,value);
                    goto L33 ;
                };
L32 :;
            }
            {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((byte*)"Unknown option:",NULL);
                msysnewc_m_print_str(name,NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                exit((i64)1);
            }L33 :;
            ;
        }else if ((pmtype==(i64)2)) {
            if ((cc_decls_ninputfiles >= (i64)200)) {
                cc_support_loaderror((byte*)"Too many input files",(byte*)"");
            };
            cc_decls_inputfiles[(++cc_decls_ninputfiles)] = mlib_pcm_copyheapstring(name);
        }else if ((pmtype==(i64)3)) {
            if ((cc_decls_nlibfiles >= (i64)200)) {
                cc_support_loaderror((byte*)"Too many lib files",(byte*)"");
            };
            cc_decls_libfiles[(++cc_decls_nlibfiles)] = mlib_pcm_copyheapstring(name);
        }else if ((pmtype==(i64)4)) {
            if ((++ncolons > (i64)1)) {
                name = (byte*)":";
                value = (byte *)(0);
                goto L34 ;
;
            };
        }else if ((pmtype==(i64)5)) {
            /*doextra:*/
L34 :;
;
            cc_extraparams[(++cc_nextraparams)-1] = mlib_pcm_copyheapstring(name);
            cc_extravalues[(cc_nextraparams)-1] = mlib_pcm_copyheapstring(value);
        }else if ((pmtype==(i64)0)) {
            goto L29 ;
        };
    }L29 :;
    ;
    if ((cc_cc_mode == (i64)0)) {
        cc_cc_mode = (i64)3;
    };
    if ((cc_linkoption == 0)) {
        cc_linkoption = (byte*)"exe";
    };
    if ((((cc_decls_ninputfiles == (i64)0) && !(!!((u64)(cc_fwriteheaders)))) && !(!!((u64)(cc_fgetlib))))) {
        cc_showcaption();
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"Usage:",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"\t",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(msysnewc_sysparams[((i64)1)-1],NULL);
        msysnewc_m_print_str((byte*)"prog[.c]                 # Compile prog.c to prog.exe",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"\t",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(msysnewc_sysparams[((i64)1)-1],NULL);
        msysnewc_m_print_str((byte*)"-help                    # Show options",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"\t",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(msysnewc_sysparams[((i64)1)-1],NULL);
        msysnewc_m_print_str((byte*)"-info                    # Further info",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        exit((i64)22);
    };
    if (!!((u64)(cc_fwriteheaders))) {
        cc_headers_writeheaders();
        exit((i64)20);
    };
    ext = cc_linkoption;
    if ((cc_cc_mode==(i64)1)) {
        ext = (byte*)"i";
    }else if ((cc_cc_mode==(i64)2)) {
        ext = (byte*)"asm";
    } else {
        ext = cc_linkoption;
    };
    if ((cc_destfilename == 0)) {
        cc_destfilename = mlib_pcm_copyheapstring(mlib_changeext(cc_decls_inputfiles[((i64)1)],ext));
    } else if (!!(mlib_eqstring(cc_destfileext,(byte*)""))) {
        cc_destfileext = ext;
    };
    if ((!!((u64)(cc_fmheaders)) && (cc_decls_ninputfiles > (i64)1))) {
        cc_support_loaderror((byte*)"-mheaders works on one file only",(byte*)"");
    };
}

static void cc_do_option(i64 sw,byte * value) {
    byte str[300];
    i64 length;
    if ((sw==(i64)4)) {
        cc_linkoption = (byte*)"obj";
        cc_cc_mode = (i64)3;
    }else if ((sw==(i64)5)) {
        cc_linkoption = (byte*)"exe";
        cc_cc_mode = (i64)3;
    }else if ((sw==(i64)1)) {
        cc_cc_mode = (i64)1;
    }else if ((sw==(i64)2)) {
        cc_linkoption = (byte*)"obj";
        cc_cc_mode = (i64)3;
    }else if ((sw==(i64)3)) {
        cc_cc_mode = (i64)2;
    }else if ((sw==(i64)6)) {
        cc_cc_mode = (i64)4;
    }else if ((sw==(i64)7)) {
        cc_fshowpaths = (u64)((i64)1);
    }else if ((sw==(i64)8)) {
        cc_fshowheaders = (u64)((i64)1);
    }else if ((sw==(i64)11)) {
        if ((cc_decls_nincludepaths > (i64)20)) {
            cc_support_loaderror((byte*)"Too many include paths",(byte*)"");
        };
        length = (i64)(strlen((i8 *)(value)));
        if (((i64)((*((value + length) - (i64)1)))==(i64)92) || ((i64)((*((value + length) - (i64)1)))==(i64)47)) {
        } else {
            strcpy((i8 *)(str),(i8 *)(value));
            strcat((i8 *)(str),(i8 *)((byte*)"/"));
            value = str;
        };
        cc_decls_includepaths[(++cc_decls_nincludepaths)-1] = mlib_pcm_copyheapstring(value);
    }else if ((sw==(i64)14)) {
        cc_decls_fverbose = (i64)1;
    }else if ((sw==(i64)15)) {
        cc_decls_fverbose = (i64)1;
    }else if ((sw==(i64)16)) {
        cc_decls_fquiet = (i64)1;
    }else if ((sw==(i64)17) || (sw==(i64)18)) {
        cc_showhelp();
    }else if ((sw==(i64)19)) {
        cc_showextrainfo();
    }else if ((sw==(i64)20)) {
        cc_decls_dointheaders = (i64)0;
    }else if ((sw==(i64)21)) {
        cc_fwriteheaders = (u64)((i64)1);
    }else if ((sw==(i64)23)) {
        cc_fgetlib = (u64)((i64)1);
    }else if ((sw==(i64)22)) {
        cc_decls_fmodern = (i64)0;
    }else if ((sw==(i64)9)) {
        cc_fstdin = (u64)((i64)1);
    }else if ((sw==(i64)10)) {
        cc_fstdout = (u64)((i64)1);
    }else if ((sw==(i64)12)) {
        cc_decls_fshowincludes = (i64)1;
    }else if ((sw==(i64)24)) {
        cc_fmheaders = (u64)((i64)1);
    }else if ((sw==(i64)25)) {
        cc_decls_fautomodules = (i64)1;
    }else if ((sw==(i64)26)) {
        cc_destfilename = mlib_pcm_copyheapstring(value);
        cc_destfileext = mlib_pcm_copyheapstring(mlib_extractext(value,(i64)0));
    }else if ((sw==(i64)27)) {
        cc_fatfile = (u64)((i64)1);
    }else if ((sw==(i64)13)) {
        cc_fshowtiming = (u64)((i64)1);
    }else if ((sw==(i64)28)) {
        cc_fdebugcompiler = (u64)((i64)1);
    }else if ((sw==(i64)29)) {
        cc_fbcclib = (u64)((i64)1);
    }else if ((sw==(i64)30)) {
        cc_decls_fcallback = (i64)1;
    }else if ((sw==(i64)31)) {
        cc_entrypointname = mlib_pcm_copyheapstring(value);
    };
}

static void cc_showincludepaths(void) {
    i64 i;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"Include paths",NULL);
    msysnewc_m_print_i64(cc_decls_nincludepaths,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    L35 :;
    for (i=(i64)1;i<=cc_decls_nincludepaths;i+=(i64)1) {
L36 :;
        msysnewc_m_print_startcon();
        msysnewc_m_print_i64(i,NULL);
        msysnewc_m_print_str(cc_decls_includepaths[(i)-1],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
L37 :;
    }L38 :;
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

static void cc_showhelp(void) {
    cc_showcaption();
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"C Subset Compiler for 64-bit Windows\r\n\r\nNormal use:\r\n\r\n    bcc prog            Compile file prog.c to prog.exe\r\n    bcc prog.c          Same (extension is optional)\r\n    bcc a b c d.dll     Compile a.c, b.c, c.c and link with d.dll to a.exe\r\n\r\nOptions:\r\n\r\n    -e              Write preprocessed output to prog.i\r\n    -s              Compile only, to .asm\r\n    -c              Same as -obj\r\n    -exe            (DEFAULT) compile and link to .exe file\r\n\r\n    -i:path         Add include path\r\n    -ext            Don't use internal standard headers\r\n    -old            Allow features such as () parameter lists, for old programs\r\n    -out:file       Name exe file\r\n\r\n    -obj            Link to single .obj file rather .exe\r\n    -run            Link to .exe then run that program\r\n    -auto           Locate .c files matched to headers and add to modules\r\n    @file           Read further files and options from a file\r\n\r\nOther Options:\r\n\r\n    -info           Show further information\r\n    -time           Show compiler timing stats\r\n    -writeheaders   Write out internal headers as .hdr (not .h) files\r\n    -at             Create an @ file of filenames suitable for most compilers\r\n    -stdin          Read C file from console\r\n    -stdout         Write preprocessor output to console, rather than .i file\r\n",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    exit((i64)23);
}

static void cc_showextrainfo(void) {
    static byte *  infotext = \
(byte*)"    The 'BCC' C Compiler. Included in the one executable file:\r\n\r\n       * A compiler that produces .asm (external or internal)\r\n       * A minimal set of standard headers\r\n       * A very minimal windows.h\r\n       * An assembler/linker generating one .exe or .obj file\r\n       * The bcclib.asm file (written out as needed)\r\n\r\n    BCC only targets x64 with Win64 call convention. It will compile\r\n    single or multiple .c files to one .asm, .exe or .obj file:\r\n\r\n      -e    Preprocess each module to .i file\r\n      -s    Compile all modules to one .asm file (NOT multiple)\r\n      -exe  (DEFAULT) Compile all modules to one .exe file\r\n      -obj  Compile all modules to one .obj file (NOT multiple)\r\n      -c    Same as -obj\r\n      -run  Compile to .exe then run the new program. Provide\r\n            params after \" : \" (spaces needed)\r\n\r\n    When there is one output file, it will be named based on the first\r\n    input file. Otherwise use -out option (see bcc -help).\r\n\r\n    .obj files can be linked using gcc on Windows. This option is\r\n    needed to be able to generate .dll files.\r\n\r\n    Libraries msvcrt.dll, gdi32.dll, user32.dll and kernel32.dll are\r\n    automatically included as search libraries for imported functions.\r\n\r\n    For other libraries, add .dll files to bcc command line or @ list.\r\n    (Note that when any .dll is specified, the default set of DLLs\r\n    is no longer included. You may need to explicitly specify msvcrt.dll etc.)\r\n    Other kinds of binary libraries (.a, .lib etc) are not supported.\r\n\r\n    (Programs using setjmp and certain internal ops will need bcclib.asm.\r\n    This file is automatically written by bcc if not present, and\r\n    automatically linked.)\r\n\r\n    Omissions, Restrictsions and Bugs (highlights only as there are dozens):\r\n\r\n       * No VLAs, compound literals, designated initialisers\r\n       * Restrictions on complexity of data initialisers\r\n       * Callback functions are buggy if called from external code (not\r\n         compiled with bcc). Fix by adding $callback attribute to such\r\n         functions, or the portable #pragma $callback just before.\r\n         Typically, functions passed to qsort().\r\n";
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(infotext,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    exit((i64)24);
}

static void cc_showcaption(void) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"BCC 'C' Compiler",NULL);
    msysnewc_m_print_str((byte*)"19-May-2020",NULL);
    msysnewc_m_print_str((byte*)"20:36:03",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

static void cc_do_genlink(void) {
    byte *  asmfiles[200];
    byte *  dllfiles[200];
    byte *  assemsources[200];
    byte *  exefile;
    byte *  ext;
    i64 nfiles;
    i64 i;
    nfiles = cc_decls_ninputfiles;
    L39 :;
    for (i=(i64)1;i<=cc_decls_ninputfiles;i+=(i64)1) {
L40 :;
        asmfiles[(i)-1] = mlib_pcm_copyheapstring(mlib_changeext(cc_decls_inputfiles[(i)],(byte*)"asm"));
        if (!!(cc_decls_fastasm)) {
            assemsources[(i)-1] = cc_decls_moduletable[(i)].asmstr;
        };
L41 :;
    }L42 :;
    ;
    if ((!(!!(mlib_eqstring(cc_linkoption,(byte*)"obj"))) || !!((u64)(cc_fbcclib)))) {
        ++nfiles;
        asmfiles[(nfiles)-1] = (byte*)"bcclib.asm";
        if (!!(cc_decls_fastasm)) {
            assemsources[(nfiles)-1] = cc_headers_getbcclib();
        };
    };
    L43 :;
    for (i=(i64)1;i<=cc_decls_nlibfiles;i+=(i64)1) {
L44 :;
        dllfiles[(i)-1] = mlib_pcm_copyheapstring(cc_decls_libfiles[(i)]);
L45 :;
    }L46 :;
    ;
    if ((cc_destfileext == 0)) {
        ext = cc_linkoption;
    } else {
        ext = cc_destfileext;
    };
    exefile = mlib_pcm_copyheapstring(mlib_changeext(cc_destfilename,ext));
    if (!(!!(cc_assembler_assembler(exefile,&asmfiles,&dllfiles,nfiles,cc_decls_nlibfiles,mlib_eqstring(cc_linkoption,(byte*)"obj"),(!!(cc_decls_fautomodules) || (cc_decls_ninputfiles > (i64)1)),(!!(cc_decls_fastasm)?&assemsources:(byte * (*)[])(0)),cc_entrypointname)))) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"Couldn't assemble or link",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        exit((i64)1);
    };
}

static void cc_resetcompiler(void) {
    i64 i;
    cc_lex_freehashtable();
    cc_decls_ntypes = cc_decls_ntypesreset;
    cc_genasm_nstrings = (cc_genasm_nreals = (cc_genasm_ndints = (i64)0));
    cc_decls_stprogram = (cc_decls_stmodule = (struct cc_decls_strec *)(0));
    cc_decls_currblockno = (cc_decls_nextblockno = (cc_decls_blocklevel = (i64)0));
    cc_lib_autotypeno = (i64)0;
    cc_lib_nextafindex = (i64)0;
    cc_decls_labelno = (i64)0;
    L47 :;
    for (i=(i64)1;i<=cc_decls_nsourcefiles;i+=(i64)1) {
L48 :;
        if (((i64)(cc_decls_sourcefilesizes[(i)]) > (i64)2048)) {
            free((void *)(cc_decls_sourcefiletext[(i)]));
        };
L49 :;
    }L50 :;
    ;
    cc_decls_nsourcefiles = (i64)0;
    mlib_pcm_clearmem((void *)(&cc_decls_ttnamedef),(i64)80000);
    mlib_pcm_clearmem((void *)(&cc_decls_ttbasetype),(i64)160000);
    mlib_pcm_clearmem((void *)(&cc_decls_ttlength),(i64)160000);
    mlib_pcm_clearmem((void *)(&cc_decls_ttconst),(i64)20000);
    mlib_pcm_clearmem((void *)(&cc_decls_ttrestrict),(i64)20000);
    mlib_pcm_clearmem((void *)(&cc_decls_ttvolatile),(i64)20000);
    mlib_pcm_clearmem((void *)(&cc_decls_ttusertype),(i64)160000);
    mlib_pcm_clearmem((void *)(&cc_decls_tttarget),(i64)160000);
    mlib_pcm_clearmem((void *)(&cc_decls_ttreftype),(i64)160000);
    mlib_pcm_clearmem((void *)(&cc_decls_ttconsttype),(i64)160000);
    mlib_pcm_clearmem((void *)(&cc_decls_ttsize),(i64)160000);
    mlib_pcm_clearmem((void *)(&cc_decls_ttbitwidth),(i64)160000);
    mlib_pcm_clearmem((void *)(&cc_decls_ttisref),(i64)20000);
    mlib_pcm_clearmem((void *)(&cc_decls_ttparams),(i64)80000);
    mlib_pcm_clearmem((void *)(&cc_decls_tttypedef),(i64)80000);
    cc_lib_inittypetables();
}

static void cc_showcompilerstate(void) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"========= COMPILER DATA AFTER ONE MODULE =========",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"NTYPES=",NULL);
    msysnewc_m_print_i64(cc_decls_ntypes,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"NMODULES=",NULL);
    msysnewc_m_print_i64(cc_decls_nmodules,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"NAUTOMODULES=",NULL);
    msysnewc_m_print_i64(cc_decls_nautomodules,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"NSOURCEFILES=",NULL);
    msysnewc_m_print_i64(cc_decls_nsourcefiles,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"NSEARCHDIRS=",NULL);
    msysnewc_m_print_i64(cc_decls_nsearchdirs,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"GETHASHTABLESIZE()=",NULL);
    msysnewc_m_print_i64(cc_lex_gethashtablesize(),NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"NSTRINGS=",NULL);
    msysnewc_m_print_i64(cc_genasm_nstrings,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"NREALS=",NULL);
    msysnewc_m_print_i64(cc_genasm_nreals,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"NDINTS=",NULL);
    msysnewc_m_print_i64(cc_genasm_ndints,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"STPROGRAM=",NULL);
    msysnewc_m_print_ptr(cc_decls_stprogram,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"STMODULE=",NULL);
    msysnewc_m_print_ptr(cc_decls_stmodule,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"CURRBLOCKNO=",NULL);
    msysnewc_m_print_i64(cc_decls_currblockno,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"BLOCKLEVEL=",NULL);
    msysnewc_m_print_i64(cc_decls_blocklevel,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"NEXTBLOCKNO=",NULL);
    msysnewc_m_print_i64(cc_decls_nextblockno,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"AUTOTYPENO=",NULL);
    msysnewc_m_print_i64(cc_lib_autotypeno,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"NEXTAFINDEX=",NULL);
    msysnewc_m_print_i64(cc_lib_nextafindex,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

static i64 cc_addnewmodules(void) {
    i64 nextinputfile;
    i64 n;
    i64 newfile;
    i64 i;
    i64 j;
    nextinputfile = (cc_decls_ninputfiles + (i64)1);
    n = (i64)0;
    L51 :;
    for (i=(i64)1;i<=cc_decls_nautomodules;i+=(i64)1) {
L52 :;
        newfile = (i64)1;
        L55 :;
        for (j=(i64)1;j<=cc_decls_ninputfiles;j+=(i64)1) {
L56 :;
            if (!!(mlib_eqstring(cc_decls_inputfiles[(j)],cc_decls_automodulenames[(i)]))) {
                newfile = (i64)0;
                goto L58 ;
            };
L57 :;
        }L58 :;
        ;
        if (!!(newfile)) {
            cc_decls_inputfiles[(++cc_decls_ninputfiles)] = cc_decls_automodulenames[(i)];
            ++n;
        };
L53 :;
    }L54 :;
    ;
    cc_decls_nautomodules = (i64)0;
    if ((n == (i64)0)) {
        return (i64)0;
    };
    return nextinputfile;
}

static void cc_writeatfile(void) {
    void *  f;
    byte *  file;
    i64 i;
    f = fopen((i8 *)((file = mlib_changeext(cc_destfilename,(byte*)""))),(i8 *)((byte*)"w"));
    if (!(!!(f))) {
        return;
    };
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"Writing @ file",NULL);
    msysnewc_m_print_str(file,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    L59 :;
    for (i=(i64)1;i<=cc_decls_ninputfiles;i+=(i64)1) {
L60 :;
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_str((byte*)"\t",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(cc_decls_inputfiles[(i)],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
L61 :;
    }L62 :;
    ;
    L63 :;
    for (i=(i64)1;i<=cc_decls_nlibfiles;i+=(i64)1) {
L64 :;
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_str((byte*)"\t",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(cc_decls_libfiles[(i)],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
L65 :;
    }L66 :;
    ;
    fclose(f);
}

i64 msysnewc_m_getdotindex(u64 a,i64 i) {
    return (((i64)(a) & ((i64)1 << i)) >> i);
}

void msysnewc_m_setdotindex(u64 * a,i64 i,i64 x) {
    u32 *  a32;
    if ((i >= (i64)32)) {
        (*a) = (u64)((((i64)((*a)) & ~(((i64)1 << i))) | (i64)(((u64)(x) << i))));
    } else {
        a32 = (u32 *)(a);
        (*a32) = (u64)((((i64)((u64)((*a32))) & ~(((i64)1 << i))) | (i64)(((u64)(x) << i))));
    };
}

i64 msysnewc_m_getdotslice(u64 a,i64 i,i64 j) {
    if ((i >= j)) {
        return (i64)(((a >> j) & ~(((u64)18446744073709551615u << ((i - j) + (i64)1)))));
    } else {
        return (i64)(((a >> i) & ~(((u64)18446744073709551615u << ((j - i) + (i64)1)))));
    };
}

void msysnewc_m_setdotslice(u64 * a,i64 i,i64 j,u64 x) {
    u64 mask64;
    u64 mask;
    u32 *  a32;
    if ((i > j)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"SETDOTSLICE?",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        exit((i64)52);
    };
    if ((j >= (i64)32)) {
        mask64 = (~(((u64)18446744073709551615u << ((j - i) + (i64)1))) << i);
        (*a) = (((*a) & ~(mask64)) | (x << i));
    } else {
        a32 = (u32 *)(a);
        mask = (~(((u64)18446744073709551615u << ((j - i) + (i64)1))) << i);
        (*a32) = (((u64)((*a32)) & ~(mask)) | (x << i));
    };
}

i64 msysnewc_m_get_nprocs(void) {
    return msysnewc__fnnprocs;
}

i64 msysnewc_m_get_nexports(void) {
    return msysnewc__fnnexports;
}

void * msysnewc_m_get_procname(i64 n) {
    return (void *)(msysnewc__fnnames[(n)-1]);
}

byte * msysnewc_m_get_procaddr(i64 n) {
    return (byte *)(msysnewc__fnaddresses[(n)-1]);
}

void * msysnewc_m_get_procexport(i64 n) {
    return (void *)(&msysnewc__fnexports[(n)-1]);
}

static void msysnewc_pushio(void) {
    if ((msysnewc_niostack >= (i64)10)) {
        printf((i8 *)((byte*)"Too many io levels\n"));
        exit((i64)53);
    };
    ++msysnewc_niostack;
    msysnewc_outchan_stack[(msysnewc_niostack)-1] = msysnewc_outchan;
    msysnewc_outdev_stack[(msysnewc_niostack)-1] = msysnewc_outdev;
    msysnewc_fmtstr_stack[(msysnewc_niostack)-1] = msysnewc_fmtstr;
    msysnewc_needgap_stack[(msysnewc_niostack)-1] = (u64)(msysnewc_needgap);
    msysnewc_needgap = (i64)0;
    msysnewc_fmtstr = (byte *)(0);
    msysnewc_outchan = 0;
}

void msysnewc_m_print_startfile(void * dev) {
    msysnewc_pushio();
    msysnewc_outchan = dev;
    if (!!(dev)) {
        msysnewc_outdev = (i64)2;
    } else {
        msysnewc_outdev = (i64)1;
    };
}

void msysnewc_m_print_startstr(byte * s) {
    byte * *  p;
    msysnewc_pushio();
    msysnewc_ptr_stack[(msysnewc_niostack)-1] = s;
    p = &msysnewc_ptr_stack[(msysnewc_niostack)-1];
    msysnewc_outchan = (void *)(p);
    msysnewc_outdev = (i64)3;
}

void msysnewc_m_print_startptr(byte * * p) {
    msysnewc_pushio();
    msysnewc_outchan = (void *)(p);
    msysnewc_outdev = (i64)3;
}

void msysnewc_m_print_startcon(void) {
    msysnewc_pushio();
    msysnewc_outdev = (i64)1;
}

void msysnewc_m_print_setfmt(byte * format) {
    msysnewc_fmtstr = format;
}

void msysnewc_m_print_end(void) {
    msysnewc_needgap = (i64)0;
    msysnewc_nextfmtchars((i64)1);
    if ((msysnewc_niostack == (i64)0)) {
        return;
    };
    msysnewc_outchan = msysnewc_outchan_stack[(msysnewc_niostack)-1];
    msysnewc_outdev = msysnewc_outdev_stack[(msysnewc_niostack)-1];
    msysnewc_fmtstr = msysnewc_fmtstr_stack[(msysnewc_niostack)-1];
    msysnewc_needgap = (i64)(msysnewc_needgap_stack[(msysnewc_niostack)-1]);
    --msysnewc_niostack;
}

void msysnewc_m_print_ptr(void * a,byte * fmtstyle) {
    msysnewc_nextfmtchars((i64)0);
    msysnewc_printstr(msysnewc_strword((u64)(u32)(a),(byte*)"z8h"));
    msysnewc_needgap = (i64)1;
}

void msysnewc_m_print_i64(i64 a,byte * fmtstyle) {
    byte s[40];
    struct msysnewc_fmtrec fmt;
    i64 n;
    msysnewc_nextfmtchars((i64)0);
    if ((fmtstyle == 0)) {
        if ((a >= (i64)0)) {
            n = msysnewc_u64tostr((u64)(a),s,(u64)((i64)10),(i64)0);
        } else {
            s[((i64)1)-1] = '-';
            n = (msysnewc_u64tostr((u64)(-(a)),&s[((i64)2)-1],(u64)((i64)10),(i64)0) + (i64)1);
        };
        msysnewc_printstr_n(s,n);
    } else {
        msysnewc_strtofmt(fmtstyle,(i64)-1,&fmt);
        if (((u64)(fmt.param) == 'V')) {
            msysnewc_fmtparam = a;
            msysnewc_needgap = (i64)0;
        } else {
            msysnewc_tostr_i64(a,&fmt);
        };
    };
    msysnewc_needgap = (i64)1;
}

void msysnewc_m_print_u64(u64 a,byte * fmtstyle) {
    struct msysnewc_fmtrec fmt;
    msysnewc_nextfmtchars((i64)0);
    if ((fmtstyle == 0)) {
        msysnewc_printstr(msysnewc_strword(a,(byte *)(0)));
    } else {
        msysnewc_strtofmt(fmtstyle,(i64)-1,&fmt);
        msysnewc_tostr_u64(a,&fmt);
    };
    msysnewc_needgap = (i64)1;
}

void msysnewc_m_print_r64(double x,byte * fmtstyle) {
    byte s[360];
    struct msysnewc_fmtrec fmt;
    msysnewc_nextfmtchars((i64)0);
    if ((fmtstyle == 0)) {
        sprintf((i8 *)(s),(i8 *)((byte*)"%f"),x);
        msysnewc_printstr(s);
    } else {
        msysnewc_strtofmt(fmtstyle,(i64)-1,&fmt);
        msysnewc_tostr_r64(x,&fmt);
    };
    msysnewc_needgap = (i64)1;
}

void msysnewc_m_print_r32(float x,byte * fmtstyle) {
    msysnewc_m_print_r64((double)(x),fmtstyle);
}

void msysnewc_m_print_c8(i64 a,byte * fmtstyle) {
    byte s[40];
    msysnewc_nextfmtchars((i64)0);
    s[((i64)1)-1] = (u64)(a);
    s[((i64)2)-1] = (u64)0u;
    msysnewc_printstr(s);
    msysnewc_needgap = (i64)1;
}

void msysnewc_m_print_str(byte * s,byte * fmtstyle) {
    struct msysnewc_fmtrec fmt;
    msysnewc_nextfmtchars((i64)0);
    if ((fmtstyle == 0)) {
        msysnewc_printstr(s);
    } else {
        msysnewc_strtofmt(fmtstyle,(i64)-1,&fmt);
        msysnewc_tostr_str(s,&fmt);
    };
    msysnewc_needgap = (i64)1;
}

void msysnewc_m_print_newline(void) {
    msysnewc_needgap = (i64)0;
    msysnewc_nextfmtchars((i64)1);
    msysnewc_printstr((byte*)"\r\n");
}

void msysnewc_m_print_nogap(void) {
    msysnewc_needgap = (i64)0;
}

void msysnewc_printstr(byte * s) {
    byte * *  p;
    if ((msysnewc_outdev==(i64)1)) {
        printf((i8 *)((byte*)"%s"),s);
    }else if ((msysnewc_outdev==(i64)2)) {
        fprintf(msysnewc_outchan,(i8 *)((byte*)"%s"),s);
    }else if ((msysnewc_outdev==(i64)3)) {
        p = (byte * *)(msysnewc_outchan);
        strcpy((i8 *)((*p)),(i8 *)(s));
        (*p) += (i64)(strlen((i8 *)(s)));
    };
}

void msysnewc_printstr_n(byte * s,i64 n) {
    byte str[256];
    byte * *  p;
    if ((n==(i64)-1)) {
        n = (i64)(strlen((i8 *)(s)));
    }else if ((n==(i64)0)) {
        return;
    };
    if ((msysnewc_outdev==(i64)3)) {
        p = (byte * *)(msysnewc_outchan);
        memcpy((void *)((*p)),(void *)(s),(u32)(n));
        (*p) += n;
        (*(*p)) = (u64)0u;
    }else if ((msysnewc_outdev==(i64)2)) {
        s = msysnewc_makezstring(s,n,str);
        fprintf(msysnewc_outchan,(i8 *)((byte*)"%s"),s);
        msysnewc_freezstring(s,n);
    }else if ((msysnewc_outdev==(i64)1)) {
        s = msysnewc_makezstring(s,n,str);
        printf((i8 *)((byte*)"%s"),s);
        msysnewc_freezstring(s,n);
    };
}

void msysnewc_printstrn_app(byte * s,i64 length,void * f) {
    if (!!(length)) {
        if ((f == 0)) {
            printf("%.*s",(i32)length,s);;
        } else {
            fprintf(f,"%.*s",(i32)length,s);;
        };
    };
}

static byte * msysnewc_makezstring(byte * s,i64 n,byte * local) {
    byte *  t;
    if ((n < (i64)256)) {
        memcpy((void *)(local),(void *)(s),(u32)(n));
        (*(local + n)) = (u64)0u;
        return local;
    } else {
        t = (byte *)(mlib_pcm_alloc((n + (i64)1)));
        memcpy((void *)(t),(void *)(s),(u32)(n));
        (*(t + n)) = (u64)0u;
        return t;
    };
}

static void msysnewc_freezstring(byte * t,i64 n) {
    if ((n >= (i64)256)) {
        mlib_pcm_free((void *)(t),(n + (i64)1));
    };
}

static void msysnewc_printchar(i64 ch) {
    byte * *  p;
    if ((msysnewc_outdev==(i64)1)) {
        printf("%c",(int)ch);
    }else if ((msysnewc_outdev==(i64)2)) {
        fprintf(msysnewc_outchan,"%c",(int)ch);
    }else if ((msysnewc_outdev==(i64)3)) {
        p = (byte * *)(msysnewc_outchan);
        (*(*p)) = (u64)(ch);
        (*p) += (i64)1;
        (*(*p)) = (u64)0u;
    };
}

void msysnewc_nextfmtchars(i64 lastx) {
    byte c;
    byte *  pstart;
    i64 n;
    if (!(!!(msysnewc_fmtstr))) {
        if (!!(msysnewc_needgap)) {
            msysnewc_printchar((i64)32);
        };
        msysnewc_needgap = (i64)0;
        return;
    };
    pstart = msysnewc_fmtstr;
    n = (i64)0;
    L67 :;
    while (!!((i64)1)) {
        c = (u64)((*msysnewc_fmtstr));
        switch ((int)(c)) {
        case 35:;
        {
            if (!!(lastx)) {
                goto L70 ;
;
            };
            ++msysnewc_fmtstr;
            if (!!(n)) {
                msysnewc_printstr_n(pstart,n);
            };
            return;
        }break;
        case 0:;
        {
            if (!!(n)) {
                msysnewc_printstr_n(pstart,n);
            } else if (!(!!(lastx))) {
                msysnewc_printstr_n((byte*)"|",(i64)1);
            };
            return;
        }break;
        case 126:;
        {
            if (!!(n)) {
                msysnewc_printstr_n(pstart,n);
                n = (i64)0;
            };
            ++msysnewc_fmtstr;
            c = (u64)((*msysnewc_fmtstr));
            if (!!((u64)(c))) {
                ++msysnewc_fmtstr;
                msysnewc_printchar((i64)(c));
            };
            pstart = msysnewc_fmtstr;
        }break;
        default: {
            /*skip:*/
L70 :;
;
            ++n;
            ++msysnewc_fmtstr;
        }
        } /* SW */
;
L68 :;
    }L69 :;
    ;
}

void msysnewc_strtofmt(byte * s,i64 slen,struct msysnewc_fmtrec * fmt) {
    byte c;
    byte wset;
    i64 n;
    byte str[100];
    (*fmt) = msysnewc_defaultfmt;
    if ((s == 0)) {
        return;
    };
    if ((slen == (i64)-1)) {
        slen = (i64)(strlen((i8 *)(s)));
    };
    memcpy((void *)(str),(void *)(s),(u32)(slen));
    str[(slen)] = (u64)0u;
    s = str;
    wset = (u64)((i64)0);
    L71 :;
    while (!!((u64)((*s)))) {
        c = (u64)((*s));
        ++s;
        switch ((int)(c)) {
        case 66:;
        case 98:;
        {
            (*fmt).base = (u64)((i64)2);
        }break;
        case 72:;
        case 104:;
        {
            (*fmt).base = (u64)((i64)16);
        }break;
        case 79:;
        case 111:;
        {
            (*fmt).base = (u64)((i64)8);
        }break;
        case 88:;
        case 120:;
        {
            c = (u64)((*s));
            if (!!((u64)(c))) {
                switch ((int)(c)) {
                case 48:;
                case 49:;
                case 50:;
                case 51:;
                case 52:;
                case 53:;
                case 54:;
                case 55:;
                case 56:;
                case 57:;
                {
                    c = ((u64)(c) - '0');
                }break;
                case 65:;
                case 66:;
                case 67:;
                case 68:;
                case 69:;
                case 70:;
                {
                    c = (u64)((((u64)(c) - 'A') + (i64)10));
                }break;
                case 97:;
                case 98:;
                case 99:;
                case 100:;
                case 101:;
                case 102:;
                {
                    c = (u64)((((u64)(c) - 'a') + (i64)10));
                }break;
                default: {
                    c = (u64)10u;
                }
                } /* SW */
;
                (*fmt).base = (u64)(c);
                ++s;
            };
        }break;
        case 81:;
        case 113:;
        {
            (*fmt).quotechar = '"';
        }break;
        case 126:;
        {
            (*fmt).quotechar = '~';
        }break;
        case 74:;
        case 106:;
        {
            (*fmt).justify = (u64)(toupper((i32)((*s))));
            if (!!((u64)((*s)))) {
                ++s;
            };
        }break;
        case 65:;
        {
            (*fmt).lettercase = 'A';
        }break;
        case 97:;
        {
            (*fmt).lettercase = 'a';
        }break;
        case 90:;
        case 122:;
        {
            (*fmt).padchar = '0';
        }break;
        case 83:;
        case 115:;
        {
            (*fmt).sepchar = (u64)((*s));
            if (!!((u64)((*s)))) {
                ++s;
            };
        }break;
        case 80:;
        case 112:;
        {
            (*fmt).padchar = (u64)((*s));
            if (!!((u64)((*s)))) {
                ++s;
            };
        }break;
        case 84:;
        case 116:;
        {
            (*fmt).suffix = (u64)((*s));
            if (!!((u64)((*s)))) {
                ++s;
            };
        }break;
        case 87:;
        case 119:;
        {
            (*fmt).usigned = 'W';
        }break;
        case 69:;
        case 101:;
        {
            (*fmt).realfmt = 'e';
        }break;
        case 70:;
        case 102:;
        {
            (*fmt).realfmt = 'f';
        }break;
        case 71:;
        case 103:;
        {
            (*fmt).realfmt = 'g';
        }break;
        case 46:;
        {
            wset = (u64)((i64)1);
        }break;
        case 44:;
        case 95:;
        {
            (*fmt).sepchar = (u64)(c);
        }break;
        case 43:;
        {
            (*fmt).plus = '+';
        }break;
        case 68:;
        case 100:;
        {
            (*fmt).charmode = 'D';
        }break;
        case 67:;
        case 99:;
        {
            (*fmt).charmode = 'C';
        }break;
        case 77:;
        case 109:;
        {
            (*fmt).heapmode = 'M';
        }break;
        case 86:;
        case 118:;
        {
            (*fmt).param = 'V';
        }break;
        case 42:;
        {
            n = msysnewc_fmtparam;
            goto L74 ;
;
        }break;
        default: {
            if ((((u64)(c) >= '0') && ((u64)(c) <= '9'))) {
                n = ((u64)(c) - '0');
                L75 :;
                while (1) {
                    c = (u64)((*s));
                    if (((i64)((*s)) == (i64)0)) {
                        goto L76 ;
                    };
                    if ((((u64)(c) >= '0') && ((u64)(c) <= '9'))) {
                        ++s;
                        n = (((n * (i64)10) + (i64)(c)) - (i64)48);
                    } else {
                        goto L76 ;
                    };
                }L76 :;
                ;
                /*gotwidth:*/
L74 :;
;
                if (!(!!((u64)(wset)))) {
                    (*fmt).minwidth = (u64)(n);
                    wset = (u64)((i64)1);
                } else {
                    (*fmt).precision = n;
                };
            };
        }
        } /* SW */
;
L72 :;
    }L73 :;
    ;
}

static i64 msysnewc_domultichar(byte * p,i64 n,byte * dest,struct msysnewc_fmtrec * fmt) {
    byte str[20];
    byte *  q;
    i64 nchars;
    i64 av_1;
    q = str;
    nchars = n;
    av_1 = n;
    while (av_1-- > 0) {
L77 :;
        if (((i64)((*p)) == (i64)0)) {
            goto L79 ;
        };
        (*q) = (u64)((*p));
        ++q;
        ++p;
L78 :;
    }L79 :;
    ;
    (*q) = (u64)0u;
    return msysnewc_expandstr(str,dest,(i64)(strlen((i8 *)(str))),fmt);
}

static i64 msysnewc_expandstr(byte * s,byte * t,i64 n,struct msysnewc_fmtrec * fmt) {
    i64 i;
    i64 w;
    i64 m;
    i64 av_1;
    i64 av_2;
    i64 av_3;
    i64 av_4;
    i64 av_5;
    w = (i64)((*fmt).minwidth);
    if (((w == (i64)0) || (w <= n))) {
        strncpy((i8 *)(t),(i8 *)(s),(u32)(n));
        (*(t + n)) = (u64)0u;
        return n;
    };
    if (((u64)((*fmt).justify) == 'L')) {
        strncpy((i8 *)(t),(i8 *)(s),(u32)(n));
        t += n;
        L80 :;
        for (i=(i64)1;i<=(w - n);i+=(i64)1) {
L81 :;
            (*t) = (u64)((*fmt).padchar);
            ++t;
L82 :;
        }L83 :;
        ;
        (*t) = (u64)0u;
    } else if (((u64)((*fmt).justify) == 'R')) {
        if (((((u64)((*fmt).padchar) == '0') && !!((u64)((*fmt).base))) && (((u64)((*s)) == '-') || ((u64)((*s)) == '+')))) {
            (*t) = (u64)((*s));
            ++t;
            av_2 = (w - n);
            while (av_2-- > 0) {
L84 :;
                (*t) = (u64)((*fmt).padchar);
                ++t;
L85 :;
            }L86 :;
            ;
            strncpy((i8 *)(t),(i8 *)((s + (i64)1)),(u32)((n - (i64)1)));
            (*((t + n) - (i64)1)) = (u64)0u;
        } else {
            av_3 = (w - n);
            while (av_3-- > 0) {
L87 :;
                (*t) = (u64)((*fmt).padchar);
                ++t;
L88 :;
            }L89 :;
            ;
            strncpy((i8 *)(t),(i8 *)(s),(u32)(n));
            (*(t + n)) = (u64)0u;
        };
    } else {
        m = (((w - n) + (i64)1) / (i64)2);
        av_4 = m;
        while (av_4-- > 0) {
L90 :;
            (*t) = (u64)((*fmt).padchar);
            ++t;
L91 :;
        }L92 :;
        ;
        strncpy((i8 *)(t),(i8 *)(s),(u32)(n));
        t += n;
        av_5 = ((w - n) - m);
        while (av_5-- > 0) {
L93 :;
            (*t) = (u64)((*fmt).padchar);
            ++t;
L94 :;
        }L95 :;
        ;
        (*t) = (u64)0u;
    };
    return w;
}

static u64 msysnewc_xdivrem(u64 a,u64 b,u64 * remainder) {
    u64 q;
    mlib_abortprogram((byte*)"XDIVREM");
    return q;
}

static i64 msysnewc_u64tostr(u64 aa,byte * s,u64 base,i64 sep) {
    byte t[360];
    i64 i;
    i64 j;
    i64 k;
    i64 g;
    byte *  s0;
    i = (i64)0;
    k = (i64)0;
    g = (((i64)(base) == (i64)10)?(i64)3:(i64)4);
    L96 :;
    do {
        t[(++i)] = (u64)(msysnewc_digits[((i64)((aa % base)))]);
        aa = (aa / base);
        ++k;
        if (((!!(sep) && ((i64)(aa) != (i64)0)) && (k == g))) {
            t[(++i)] = (u64)(sep);
            k = (i64)0;
        };
L97 :;
    } while (!((i64)(aa) == (i64)0));L98 :;
    ;
    j = i;
    s0 = s;
    L99 :;
    while (!!(i)) {
        (*s) = (u64)(t[(i--)]);
        ++s;
L100 :;
    }L101 :;
    ;
    (*s) = (u64)0u;
    return j;
}

static i64 msysnewc_i64tostrfmt(i64 aa,byte * s,struct msysnewc_fmtrec * fmt) {
    byte str[360];
    i64 n;
    i64 usigned;
    static u64 mindint = (u64)9223372036854775808u;
    usigned = (i64)0;
    if (!!((u64)((*fmt).usigned))) {
        usigned = (i64)1;
    };
    if (((aa == (i64)(mindint)) && !(!!(usigned)))) {
        str[((i64)0)] = '-';
        n = (msysnewc_i64mintostr(&str[((i64)1)],(i64)((*fmt).base),(i64)((*fmt).sepchar)) + (i64)1);
    } else {
        if (((!(!!(usigned)) && (aa < (i64)0)) || !!((u64)((*fmt).plus)))) {
            if ((aa < (i64)0)) {
                aa = -(aa);
                str[((i64)0)] = '-';
            } else {
                str[((i64)0)] = '+';
            };
            n = (msysnewc_u64tostr((u64)(aa),&str[((i64)1)],(u64)((*fmt).base),(i64)((*fmt).sepchar)) + (i64)1);
        } else {
            n = msysnewc_u64tostr((u64)(aa),str,(u64)((*fmt).base),(i64)((*fmt).sepchar));
        };
    };
    if (!!((u64)((*fmt).suffix))) {
        str[(n)] = (u64)((*fmt).suffix);
        str[(++n)] = (u64)0u;
    };
    if (((((i64)((u64)((*fmt).base)) > (i64)10) || !!((u64)((*fmt).suffix))) && ((u64)((*fmt).lettercase) == 'a'))) {
        msysnewc_convlcstring(str);
    };
    return msysnewc_expandstr(str,s,n,fmt);
}

static i64 msysnewc_u64tostrfmt(i64 aa,byte * s,struct msysnewc_fmtrec * fmt) {
    byte str[360];
    i64 n;
    n = msysnewc_u64tostr((u64)(aa),str,(u64)((*fmt).base),(i64)((*fmt).sepchar));
    if (!!((u64)((*fmt).suffix))) {
        str[(n)] = (u64)((*fmt).suffix);
        str[(++n)] = (u64)0u;
    };
    if ((((i64)((u64)((*fmt).base)) > (i64)10) || (!!((u64)((*fmt).suffix)) && ((u64)((*fmt).lettercase) == 'a')))) {
        msysnewc_convlcstring(str);
    };
    return msysnewc_expandstr(str,s,n,fmt);
}

static i64 msysnewc_i64mintostr(byte * s,i64 base,i64 sep) {
    byte t[360];
    i64 i;
    i64 j;
    i64 k;
    i64 g;
    switch ((int)base) {
    case 10:;
    {
        strcpy((i8 *)(&t[((i64)0)]),(i8 *)((byte*)"9223372036854775808"));
        j = (i64)3;
    }break;
    case 16:;
    {
        strcpy((i8 *)(&t[((i64)0)]),(i8 *)((byte*)"8000000000000000"));
        j = (i64)1;
    }break;
    case 2:;
    {
        strcpy((i8 *)(&t[((i64)0)]),(i8 *)((byte*)"1000000000000000000000000000000000000000000000000000000000000000"));
        j = (i64)7;
    }break;
    default: {
        strcpy((i8 *)(&t[((i64)0)]),(i8 *)((byte*)"<mindint>"));
    }
    } /* SW */
;
    i = (i64)(strlen((i8 *)(&t[((i64)0)])));
    s += i;
    if (!!(sep)) {
        s += j;
    };
    (*s) = (u64)0u;
    k = (i64)0;
    g = ((base == (i64)10)?(i64)3:(i64)4);
    L102 :;
    while (!!(i)) {
        --s;
        (*s) = (u64)(t[((i-- - (i64)1))]);
        if (((!!(sep) && !!(i)) && (++k == g))) {
            --s;
            (*s) = (u64)(sep);
            k = (i64)0;
        };
L103 :;
    }L104 :;
    ;
    return (i64)(strlen((i8 *)(s)));
}

static i64 msysnewc_strtostrfmt(byte * s,byte * t,i64 n,struct msysnewc_fmtrec * fmt) {
    byte *  u;
    byte *  v;
    byte str[256];
    i64 w;
    i64 nheap;
    nheap = (i64)0;
    if ((!!((u64)((*fmt).quotechar)) || !!((u64)((*fmt).lettercase)))) {
        if ((n < (i64)256)) {
            u = str;
        } else {
            nheap = (n + (i64)3);
            u = (byte *)(mlib_pcm_alloc(nheap));
        };
        if (!!((u64)((*fmt).quotechar))) {
            v = u;
            (*v) = (u64)((*fmt).quotechar);
            ++v;
            if (!!(n)) {
                strcpy((i8 *)(v),(i8 *)(s));
                v += n;
            };
            (*v) = (u64)((*fmt).quotechar);
            ++v;
            (*v) = (u64)0u;
            n += (i64)2;
        } else {
            memcpy((void *)(u),(void *)(s),(u32)(n));
        };
        switch ((int)((*fmt).lettercase)) {
        case 97:;
        {
            msysnewc_convlcstring(u);
        }break;
        case 65:;
        {
            msysnewc_convucstring(u);
        }break;
        default: {
        }
        } /* SW */
;
        s = u;
    };
    w = (i64)((*fmt).minwidth);
    if ((w > n)) {
        n = msysnewc_expandstr(s,t,n,fmt);
    } else {
        memcpy((void *)(t),(void *)(s),(u32)(n));
    };
    if (!!(nheap)) {
        mlib_pcm_free((void *)(u),nheap);
    };
    return n;
}

static void msysnewc_tostr_i64(i64 a,struct msysnewc_fmtrec * fmt) {
    byte str[360];
    i64 n;
    if (((i64)((*fmt).charmode)==(i64)0)) {
        n = msysnewc_i64tostrfmt(a,str,fmt);
    }else if (((i64)((*fmt).charmode)==(i64)68) || ((i64)((*fmt).charmode)==(i64)100)) {
        n = msysnewc_domultichar((byte *)(&a),(i64)8,str,fmt);
    } else {
        msysnewc_printchar(a);
        return;
    };
    msysnewc_printstr_n(str,n);
}

static void msysnewc_tostr_u64(u64 a,struct msysnewc_fmtrec * fmt) {
    byte str[360];
    i64 n;
    if (((i64)((*fmt).charmode)==(i64)68) || ((i64)((*fmt).charmode)==(i64)100)) {
        n = msysnewc_domultichar((byte *)(&a),(i64)8,str,fmt);
    }else if (((i64)((*fmt).charmode)==(i64)67) || ((i64)((*fmt).charmode)==(i64)99)) {
        msysnewc_printchar((i64)(a));
        return;
    } else {
        n = msysnewc_u64tostrfmt((i64)(a),str,fmt);
    };
    msysnewc_printstr_n(str,n);
}

static void msysnewc_tostr_r64(double x,struct msysnewc_fmtrec * fmt) {
    byte str[360];
    byte str2[360];
    byte cfmt[10];
    i64 n;
    cfmt[((i64)0)] = '%';
    if (!!((i64)((*fmt).precision))) {
        cfmt[((i64)1)] = '.';
        cfmt[((i64)2)] = '*';
        cfmt[((i64)3)] = (u64)((*fmt).realfmt);
        cfmt[((i64)4)] = (u64)0u;
        sprintf((i8 *)(str),(i8 *)(cfmt),(*fmt).precision,x);
    } else {
        cfmt[((i64)1)] = (u64)((*fmt).realfmt);
        cfmt[((i64)2)] = (u64)0u;
        sprintf((i8 *)(str),(i8 *)(cfmt),x);
    };
    n = (i64)(strlen((i8 *)(str)));
    if ((n < (i64)((u64)((*fmt).minwidth)))) {
        n = msysnewc_expandstr(str,str2,n,fmt);
        strcpy((i8 *)(str),(i8 *)(str2));
    };
    msysnewc_printstr_n(str,n);
}

static void msysnewc_tostr_str(byte * s,struct msysnewc_fmtrec * fmt) {
    i64 oldlen;
    i64 newlen;
    i64 n;
    byte *  t;
    oldlen = (i64)(strlen((i8 *)(s)));
    newlen = oldlen;
    if (((!!((u64)((*fmt).quotechar)) || ((i64)((u64)((*fmt).minwidth)) > newlen)) || !!((u64)((*fmt).lettercase)))) {
        if (!!((u64)((*fmt).quotechar))) {
            newlen += (i64)2;
        };
        if (((i64)((u64)((*fmt).minwidth)) > newlen)) {
            newlen = (i64)((*fmt).minwidth);
        };
        t = (byte *)(mlib_pcm_alloc((newlen + (i64)1)));
        n = msysnewc_strtostrfmt(s,t,oldlen,fmt);
        msysnewc_printstr_n(t,n);
        mlib_pcm_free((void *)(t),(newlen + (i64)1));
    } else {
        msysnewc_printstr_n(s,oldlen);
    };
}

static struct msysnewc_fmtrec * msysnewc_getfmt(byte * fmtstyle) {
    static struct msysnewc_fmtrec fmt;
    if (!!(fmtstyle)) {
        msysnewc_strtofmt(fmtstyle,(i64)-1,&fmt);
        return &fmt;
    } else {
        return &msysnewc_defaultfmt;
    };
}

byte * msysnewc_strint(i64 a,byte * fmtstyle) {
    static byte str[100];
    struct msysnewc_fmtrec *  fmt;
    msysnewc_m_print_startstr(str);
    msysnewc_tostr_i64(a,(fmt = msysnewc_getfmt(fmtstyle)));
    msysnewc_m_print_end();
    return msysnewc_getstr(str,fmt);
}

void msysnewc_getstrint(i64 a,byte * dest) {
    msysnewc_m_print_startstr(dest);
    msysnewc_tostr_i64(a,msysnewc_getfmt((byte *)(0)));
    msysnewc_m_print_end();
}

byte * msysnewc_strword(u64 a,byte * fmtstyle) {
    static byte str[100];
    struct msysnewc_fmtrec *  fmt;
    msysnewc_m_print_startstr(str);
    msysnewc_tostr_u64(a,(fmt = msysnewc_getfmt(fmtstyle)));
    msysnewc_m_print_end();
    return msysnewc_getstr(str,fmt);
}

byte * msysnewc_strreal(double a,byte * fmtstyle) {
    static byte str[320];
    struct msysnewc_fmtrec *  fmt;
    msysnewc_m_print_startstr(str);
    msysnewc_tostr_r64(a,(fmt = msysnewc_getfmt(fmtstyle)));
    msysnewc_m_print_end();
    return msysnewc_getstr(str,fmt);
}

static byte * msysnewc_getstr(byte * s,struct msysnewc_fmtrec * fmt) {
    if (!!((u64)((*fmt).heapmode))) {
        return mlib_pcm_copyheapstring(s);
    } else {
        return s;
    };
}

static void msysnewc_initreadbuffer(void) {
    if (!!(msysnewc_rd_buffer)) {
        return;
    };
    msysnewc_rd_buffer = (byte *)(mlib_pcm_alloc((i64)16384));
    (*msysnewc_rd_buffer) = (u64)0u;
    msysnewc_rd_pos = (msysnewc_rd_lastpos = msysnewc_rd_buffer);
}

void msysnewc_m_read_conline(void) {
    msysnewc_initreadbuffer();
    mlib_readlinen(0,msysnewc_rd_buffer,(i64)16384);
    msysnewc_rd_length = (i64)(strlen((i8 *)(msysnewc_rd_buffer)));
    msysnewc_rd_pos = msysnewc_rd_buffer;
    msysnewc_rd_lastpos = (byte *)(0);
}

void msysnewc_m_read_fileline(void * f) {
    msysnewc_initreadbuffer();
    mlib_readlinen(f,msysnewc_rd_buffer,(i64)16384);
    msysnewc_rd_length = (i64)(strlen((i8 *)(msysnewc_rd_buffer)));
    msysnewc_rd_pos = msysnewc_rd_buffer;
    msysnewc_rd_lastpos = (byte *)(0);
}

void msysnewc_m_read_strline(byte * s) {
    i64 n;
    msysnewc_initreadbuffer();
    n = (i64)(strlen((i8 *)(s)));
    if ((n < (i64)16384)) {
        strcpy((i8 *)(msysnewc_rd_buffer),(i8 *)(s));
    } else {
        memcpy((void *)(msysnewc_rd_buffer),(void *)(s),(u32)16383u);
        (*((msysnewc_rd_buffer + (i64)16384) - (i64)1)) = (u64)0u;
    };
    msysnewc_rd_length = n;
    msysnewc_rd_pos = msysnewc_rd_buffer;
    msysnewc_rd_lastpos = (byte *)(0);
}

static byte * msysnewc_readitem(i64 * itemlength) {
    byte *  p;
    byte *  s;
    byte *  itemstr;
    byte quotechar;
    byte c;
    if (!(!!(msysnewc_rd_buffer))) {
        msysnewc_initreadbuffer();
    };
    s = msysnewc_rd_pos;
    L105 :;
    while ((((u64)((*s)) == ' ') || ((i64)((*s)) == (i64)9))) {
        ++s;
L106 :;
    }L107 :;
    ;
    itemstr = s;
    msysnewc_rd_lastpos = (msysnewc_rd_pos = s);
    if (((i64)((*s)) == (i64)0)) {
        msysnewc_termchar = (i64)0;
        (*itemlength) = (i64)0;
        return s;
    };
    quotechar = (u64)0u;
    if (((u64)((*s)) == '"')) {
        quotechar = '"';
        ++s;
    } else if (((u64)((*s)) == (u64)39u)) {
        quotechar = (u64)39u;
        ++s;
    };
    p = (itemstr = s);
    L108 :;
    while (!!((u64)((*s)))) {
        c = (u64)((*s++));
        switch ((int)(c)) {
        case 32:;
        case 9:;
        case 44:;
        case 61:;
        {
            if ((!!((u64)(quotechar)) || (p == s))) {
                goto L111 ;
;
            };
            msysnewc_termchar = (i64)(c);
            goto L110 ;
        }break;
        default: {
            /*normalchar:*/
L111 :;
;
            if (((u64)(c) == (u64)(quotechar))) {
                if (((u64)((*s)) == (u64)(quotechar))) {
                    (*p) = (u64)(c);
                    ++s;
                    ++p;
                } else {
                    msysnewc_termchar = (i64)((*s));
                    if (((msysnewc_termchar == (i64)44) || (msysnewc_termchar == (i64)61))) {
                        ++s;
                        msysnewc_termchar = (i64)((*s));
                    };
                    goto L110 ;
                };
            } else {
                (*p) = (u64)(c);
                ++p;
            };
        }
        } /* SW */
;
L109 :;
    }L110 :;
    ;
    if (((i64)((*s)) == (i64)0)) {
        msysnewc_termchar = (i64)0;
    };
    (*itemlength) = (p - itemstr);
    msysnewc_rd_pos = s;
    return itemstr;
}

i64 msysnewc_strtoint(byte * s,i64 length,i64 base) {
    byte signd;
    u64 aa;
    byte c;
    byte d;
    msysnewc_itemerror = (i64)0;
    if ((length == (i64)-1)) {
        length = (i64)(strlen((i8 *)(s)));
    };
    signd = (u64)((i64)0);
    if ((!!(length) && ((u64)((*s)) == '-'))) {
        signd = (u64)((i64)1);
        ++s;
        --length;
    } else if ((!!(length) && ((u64)((*s)) == '+'))) {
        ++s;
        --length;
    };
    aa = (u64)((i64)0);
    L112 :;
    while (!!(length)) {
        c = (u64)((*s++));
        --length;
        switch ((int)(c)) {
        case 65:;
        case 66:;
        case 67:;
        case 68:;
        case 69:;
        case 70:;
        {
            d = (u64)((((u64)(c) - 'A') + (i64)10));
        }break;
        case 97:;
        case 98:;
        case 99:;
        case 100:;
        case 101:;
        case 102:;
        {
            d = (u64)((((u64)(c) - 'a') + (i64)10));
        }break;
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
        {
            d = ((u64)(c) - '0');
        }break;
        case 95:;
        case 39:;
        {
            goto L113 ;
        }break;
        default: {
            msysnewc_itemerror = (i64)1;
            goto L114 ;
        }
        } /* SW */
;
        if (((i64)(d) >= base)) {
            msysnewc_itemerror = (i64)1;
            goto L114 ;
        };
        aa = (u64)((((i64)(aa) * base) + (i64)(d)));
L113 :;
    }L114 :;
    ;
    if (!!((u64)(signd))) {
        return (i64)(-(aa));
    } else {
        return (i64)(aa);
    };
}

i64 msysnewc_m_read_i64(i64 fmt) {
    byte *  s;
    i64 length;
    if ((fmt==(i64)67) || (fmt==(i64)99)) {
        msysnewc_rd_lastpos = msysnewc_rd_pos;
        if (!!((u64)((*msysnewc_rd_pos)))) {
            return (i64)((*msysnewc_rd_pos++));
        } else {
            return (i64)0;
        };
    }else if ((fmt==(i64)84) || (fmt==(i64)116)) {
        return msysnewc_termchar;
    }else if ((fmt==(i64)69) || (fmt==(i64)101)) {
        return msysnewc_itemerror;
    };
    s = msysnewc_readitem(&length);
    if ((fmt==(i64)0) || (fmt==(i64)73) || (fmt==(i64)105)) {
        return msysnewc_strtoint(s,length,(i64)10);
    }else if ((fmt==(i64)66) || (fmt==(i64)98)) {
        return msysnewc_strtoint(s,length,(i64)2);
    }else if ((fmt==(i64)72) || (fmt==(i64)104)) {
        return msysnewc_strtoint(s,length,(i64)16);
    };
    return (i64)0;
}

double msysnewc_m_read_r64(i64 fmt) {
    byte str[512];
    byte *  s;
    i64 length;
    i32 numlength;
    double x;
    s = msysnewc_readitem(&length);
    if (((length == (i64)0) || (length >= (i64)512))) {
        return (double)0.;
    };
    memcpy((void *)(str),(void *)(s),(u32)(length));
    str[((length + (i64)1))-1] = (u64)0u;
    msysnewc_itemerror = (i64)0;
    if ((((i64)(sscanf((i8 *)(str),(i8 *)((byte*)"%lf%n"),&x,&numlength)) == (i64)0) || ((i64)(numlength) != length))) {
        x = (double)0.;
        msysnewc_itemerror = (i64)1;
    };
    return x;
}

void msysnewc_m_read_str(byte * dest,i64 destlen,i64 fmt) {
    byte *  s;
    i64 length;
    msysnewc_itemerror = (i64)0;
    if (((fmt == (i64)76) || (fmt == (i64)108))) {
        s = msysnewc_rd_pos;
        length = ((msysnewc_rd_buffer + msysnewc_rd_length) - msysnewc_rd_pos);
    } else {
        s = msysnewc_readitem(&length);
        if (((fmt == (i64)78) || (fmt == (i64)110))) {
            msysnewc_iconvlcn(s,length);
        };
    };
    if ((destlen > (i64)0)) {
        if ((length >= destlen)) {
            length = (destlen - (i64)1);
            msysnewc_itemerror = (i64)1;
        };
    };
    memcpy((void *)(dest),(void *)(s),(u32)(length));
    (*(dest + length)) = (u64)0u;
}

void msysnewc_readstr(byte * dest,i64 fmt,i64 destlen) {
    msysnewc_m_read_str(dest,destlen,fmt);
}

void msysnewc_rereadln(void) {
    msysnewc_rd_pos = msysnewc_rd_buffer;
    msysnewc_rd_lastpos = msysnewc_rd_pos;
}

void msysnewc_reread(void) {
    msysnewc_rd_pos = msysnewc_rd_lastpos;
}

i64 msysnewc_valint(byte * s,i64 fmt) {
    byte *  old_pos;
    byte *  old_lastpos;
    i64 aa;
    msysnewc_initreadbuffer();
    old_pos = msysnewc_rd_pos;
    old_lastpos = msysnewc_rd_lastpos;
    msysnewc_rd_pos = s;
    aa = msysnewc_m_read_i64(fmt);
    msysnewc_rd_pos = old_pos;
    msysnewc_rd_lastpos = old_lastpos;
    return aa;
}

double msysnewc_valreal(byte * s) {
    byte *  old_pos;
    byte *  old_lastpos;
    double x;
    msysnewc_initreadbuffer();
    old_pos = msysnewc_rd_pos;
    old_lastpos = msysnewc_rd_lastpos;
    msysnewc_rd_pos = s;
    x = msysnewc_m_read_r64((i64)0);
    msysnewc_rd_pos = old_pos;
    msysnewc_rd_lastpos = old_lastpos;
    return x;
}

static void msysnewc_iconvlcn(byte * s,i64 n) {
    i64 av_1;
    av_1 = n;
    while (av_1-- > 0) {
L115 :;
        (*s) = (u64)(tolower((i32)((*s))));
        ++s;
L116 :;
    }L117 :;
    ;
}

static void msysnewc_iconvucn(byte * s,i64 n) {
    i64 av_1;
    av_1 = n;
    while (av_1-- > 0) {
L118 :;
        (*s) = (u64)(toupper((i32)((*s))));
        ++s;
L119 :;
    }L120 :;
    ;
}

static void msysnewc_convlcstring(byte * s) {
    L121 :;
    while (!!((u64)((*s)))) {
        (*s) = (u64)(tolower((i32)((*s))));
        ++s;
L122 :;
    }L123 :;
    ;
}

static void msysnewc_convucstring(byte * s) {
    L124 :;
    while (!!((u64)((*s)))) {
        (*s) = (u64)(toupper((i32)((*s))));
        ++s;
L125 :;
    }L126 :;
    ;
}

i64 msysnewc_m_power_i64(i64 n,i64 a) {
    if ((n < (i64)0)) {
        return (i64)0;
    } else if ((n == (i64)0)) {
        return (i64)1;
    } else if ((n == (i64)1)) {
        return a;
    } else if (((n & (i64)1) == (i64)0)) {
        return msysnewc_m_power_i64((n / (i64)2),(a * a));
    } else {
        return (msysnewc_m_power_i64(((n - (i64)1) / (i64)2),(a * a)) * a);
    };
}

void msysnewc_m_intoverflow(void) {
    mlib_abortprogram((byte*)"Integer overflow detected");
}

void msysnewc_m_dotindex(u64 i,u64 a) {
    mlib_abortprogram((byte*)"DOT INDEX");
}

void msysnewc_m_dotslice(u64 j,u64 i,u64 a) {
    mlib_abortprogram((byte*)"DOT SLICE");
}

void msysnewc_m_popdotindex(u64 i,u64 * p,u64 x) {
    mlib_abortprogram((byte*)"POP DOT INDEX");
}

void msysnewc_m_popdotslice(u64 j,u64 i,u64 * p,u64 x) {
    mlib_abortprogram((byte*)"POP DOT SLICE");
}

i64 msysnewc_m_imin(i64 a,i64 b) {
    return (a<b?a:b);
}

i64 msysnewc_m_imax(i64 a,i64 b) {
    return (a>b?a:b);
}

double msysnewc_m_sign(double x) {
    if ((x > (double)0.)) {
        return (double)1.;
    } else if ((x < (double)0.)) {
        return (double)-1.;
    } else {
        return (double)0.;
    };
}

void * mlib_pcm_alloc(i64 n) {
    byte *  p;
    if (!(!!((u64)(mlib_pcm_setup)))) {
        mlib_pcm_init();
    };
    if ((n > (i64)2048)) {
        mlib_alloccode = mlib_pcm_getac(n);
        mlib_allocbytes = (i64)(mlib_allocupper[(mlib_alloccode)]);
        p = (byte *)(mlib_allocmem(mlib_allocbytes));
        if (!(!!(p))) {
            mlib_abortprogram((byte*)"pcm_alloc failure");
        };
        if (!!((i64)0)) {
            mlib_addtomemalloc((i32 *)(p),mlib_allocbytes);
        };
        return (void *)(p);
    };
    mlib_alloccode = (i64)(mlib_sizeindextable[(n)]);
    if ((mlib_alloccode == (i64)0)) {
        mlib_alloccode = (i64)1;
    };
    mlib_allocbytes = (i64)(mlib_allocupper[(mlib_alloccode)]);
    mlib_smallmemtotal += mlib_allocbytes;
    if (!!((p = (byte *)(mlib_freelist[(mlib_alloccode)])))) {
        if (!!((i64)0)) {
            mlib_addtomemalloc((i32 *)(p),mlib_allocbytes);
        };
        mlib_freelist[(mlib_alloccode)] = (u32 *)(u32)((i64)((*mlib_freelist[(mlib_alloccode)])));
        return (void *)(p);
    };
    p = mlib_pcheapptr;
    mlib_pcheapptr += mlib_allocbytes;
    if ((mlib_pcheapptr >= mlib_pcheapend)) {
        p = (byte *)(mlib_pcm_newblock(mlib_allocbytes));
        return (void *)(p);
    };
    if (!!((i64)0)) {
        mlib_addtomemalloc((i32 *)(p),mlib_allocbytes);
    };
    return (void *)(p);
}

void mlib_pcm_freestr(byte * s) {
    mlib_pcm_free((void *)(s),((i64)((u64)(strlen((i8 *)(s)))) + (i64)1));
}

void mlib_pcm_free(void * p,i64 n) {
    i64 acode;
    if ((n == (i64)0)) {
        return;
    };
    if ((n > (i64)2048)) {
        if (!!((i64)0)) {
            mlib_removefrommemalloc((i32 *)(p),n);
        };
        free(p);
        return;
    };
    if (!!(p)) {
        acode = (i64)(mlib_sizeindextable[(n)]);
        mlib_smallmemtotal -= (i64)(mlib_allocupper[(acode)]);
        if (!!((i64)0)) {
            mlib_removefrommemalloc((i32 *)(p),(i64)(mlib_allocupper[(acode)]));
        };
        (*(u32 *)(p)) = (u64)((u32)((i64)(u32)(mlib_freelist[(acode)])));
        mlib_freelist[(acode)] = (u32 *)(p);
    };
}

void mlib_pcm_freeac(void * p,i64 alloc) {
    mlib_pcm_free(p,(i64)(mlib_allocupper[(alloc)]));
}

void mlib_pcm_copymem4(void * p,void * q,i64 n) {
    memcpy(p,q,(u32)(n));
}

void mlib_pcm_clearmem(void * p,i64 n) {
    memset(p,(i32)0,(u32)(n));
}

void mlib_pcm_init(void) {
    i64 j;
    i64 k;
    i64 size;
    i64 av_1;
    i64 i;
    if (!!((u64)(mlib_pcm_setup))) {
        return;
    };
    mlib_pcm_newblock((i64)0);
    L127 :;
    for (i=(i64)1;i<=(i64)2048;i+=(i64)1) {
L128 :;
        j = (i64)1;
        k = (i64)16;
        L131 :;
        while ((i > k)) {
            k = (k << (i64)1);
            ++j;
L132 :;
        }L133 :;
        ;
        mlib_sizeindextable[(i)] = (u64)(j);
L129 :;
    }L130 :;
    ;
    mlib_allocupper[((i64)1)] = (u64)((i64)16);
    size = (i64)16;
    L134 :;
    for (i=(i64)2;i<=(i64)27;i+=(i64)1) {
L135 :;
        size *= (i64)2;
        mlib_allocupper[(i)] = (u64)(size);
        if ((size >= (i64)33554432)) {
            k = i;
            goto L137 ;
        };
L136 :;
    }L137 :;
    ;
    L138 :;
    for (i=(k + (i64)1);i<=(i64)300;i+=(i64)1) {
L139 :;
        size += (i64)33554432;
        if ((size < (i64)8589934592)) {
            mlib_allocupper[(i)] = (u64)(size);
            mlib_maxmemory = (u64)(size);
        } else {
            mlib_maxalloccode = (i - (i64)1);
            goto L141 ;
        };
L140 :;
    }L141 :;
    ;
    mlib_pcm_setup = (u64)((i64)1);
}

i64 mlib_pcm_getac(i64 size) {
    if ((size <= (i64)2048)) {
        return (i64)(mlib_sizeindextable[(size)]);
    };
    size = ((size + (i64)255) >> (i64)8);
    if ((size <= (i64)2048)) {
        return ((i64)((u64)(mlib_sizeindextable[(size)])) + (i64)8);
    };
    size = ((size + (i64)63) >> (i64)6);
    if ((size <= (i64)2048)) {
        return ((i64)((u64)(mlib_sizeindextable[(size)])) + (i64)14);
    };
    size = ((((size - (i64)2048) + (i64)2047) / (i64)2048) + (i64)22);
    return size;
}

void * mlib_pcm_newblock(i64 itemsize) {
    static i64 totalheapsize;
    byte *  p;
    totalheapsize += (i64)2097152;
    mlib_alloccode = (i64)0;
    p = (byte *)(mlib_allocmem((i64)2097152));
    if ((p == 0)) {
        mlib_abortprogram((byte*)"Can't alloc pc heap");
    };
    mlib_pcheapptr = p;
    mlib_pcheapend = (p + (i64)2097152);
    if ((mlib_pcheapstart == 0)) {
        mlib_pcheapstart = p;
    };
    mlib_pcheapptr += itemsize;
    return (void *)((u32 *)(p));
}

i64 mlib_pcm_round(i64 n) {
    static i32 allocbytes[9] = {(i32)0,(i32)16,(i32)32,(i32)64,(i32)128,(i32)256,(i32)512,(i32)1024,(i32)2048};
    if ((n > (i64)2048)) {
        return n;
    } else {
        return (i64)(allocbytes[((i64)(mlib_sizeindextable[(n)]))]);
    };
}

i64 mlib_pcm_array(i64 n) {
    i64 m;
    if ((n <= (i64)2048)) {
        return mlib_pcm_round(n);
    } else {
        m = (i64)2048;
        L142 :;
        while ((n > m)) {
            m <<= (i64)1;
L143 :;
        }L144 :;
        ;
        return m;
    };
}

void mlib_pcm_printfreelist(i64 size,u32 * p) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"Size: ",NULL);
    msysnewc_m_print_i64(size,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    L145 :;
    while (!!(p)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)" ",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_ptr(p,(byte*)"h");
        msysnewc_m_print_end();
        ;
        p = (u32 *)(u32)((i64)((*p)));
L146 :;
    }L147 :;
    ;
    puts((i8 *)((byte*)""));
}

void mlib_pcm_diags(byte * caption) {
    i64 m;
    i64 i;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"HEAP FREELISTS:",NULL);
    msysnewc_m_print_str(caption,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    m = (i64)16;
    L148 :;
    for (i=(i64)1;i<=(i64)8;i+=(i64)1) {
L149 :;
        mlib_pcm_printfreelist(m,mlib_freelist[(i)]);
        m <<= (i64)1;
L150 :;
    }L151 :;
    ;
}

void * mlib_pcm_allocz(i64 n) {
    void *  p;
    p = mlib_pcm_alloc(n);
    memset(p,(i32)0,(u32)(n));
    return p;
}

byte * mlib_pcm_copyheapstring(byte * s) {
    byte *  q;
    i64 n;
    if ((s == 0)) {
        return (byte *)(0);
    };
    n = ((i64)((u64)(strlen((i8 *)(s)))) + (i64)1);
    q = (byte *)(mlib_pcm_alloc(n));
    memcpy((void *)(q),(void *)(s),(u32)(n));
    return q;
}

byte * mlib_pcm_copyheapstringn(byte * s,i64 n) {
    byte *  q;
    if ((s == 0)) {
        return (byte *)(0);
    };
    q = (byte *)(mlib_pcm_alloc((n + (i64)1)));
    memcpy((void *)(q),(void *)(s),(u32)(n));
    (*(q + n)) = (u64)0u;
    return q;
}

byte * mlib_pcm_copyheapblock(byte * s,i64 length) {
    byte *  q;
    if ((length == (i64)0)) {
        return (byte *)(0);
    };
    q = (byte *)(mlib_pcm_alloc(length));
    memcpy((void *)(q),(void *)(s),(u32)(length));
    return q;
}

static void mlib_addtomemalloc(i32 * ptr,i64 size) {
    i64 i;
    L152 :;
    for (i=(i64)1;i<=(i64)500000;i+=(i64)1) {
L153 :;
        if ((mlib_memalloctable[(i)-1] == ptr)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)"ALLOC ERROR:",NULL);
            msysnewc_m_print_ptr(ptr,NULL);
            msysnewc_m_print_str((byte*)"ALREADY ALLOCATED\n\n\n",NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            msysnewc_m_print_startcon();
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            msysnewc_m_print_startcon();
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            exit((i64)2);
        };
        if ((mlib_memalloctable[(i)-1] == 0)) {
            mlib_memalloctable[(i)-1] = ptr;
            mlib_memallocsize[(i)-1] = size;
            return;
        };
L154 :;
    }L155 :;
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"MEMALLOCTABLE FULL\n\n\n\n",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    osnos_os_getch();
    exit((i64)3);
}

static void mlib_removefrommemalloc(i32 * ptr,i64 size) {
    i64 i;
    L156 :;
    for (i=(i64)1;i<=(i64)500000;i+=(i64)1) {
L157 :;
        if ((mlib_memalloctable[(i)-1] == ptr)) {
            if (((i64)(mlib_memallocsize[(i)-1]) != size)) {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((byte*)"REMOVE:FOUND",NULL);
                msysnewc_m_print_ptr(ptr,NULL);
                msysnewc_m_print_str((byte*)"IN MEMALLOCTABLE, FREESIZE=",NULL);
                msysnewc_m_print_i64(size,NULL);
                msysnewc_m_print_str((byte*)", BUT STORED AS BLOCK SIZE:",NULL);
                msysnewc_m_print_i64(mlib_memallocsize[(i)-1],NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                msysnewc_m_print_startcon();
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                msysnewc_m_print_startcon();
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                mlib_abortprogram((byte*)"MEMSIZE");
            };
            mlib_memalloctable[(i)-1] = (i32 *)(0);
            return;
        };
L158 :;
    }L159 :;
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"CAN'T FIND",NULL);
    msysnewc_m_print_ptr(ptr,NULL);
    msysnewc_m_print_str((byte*)"IN MEMALLOCTABLE",NULL);
    msysnewc_m_print_i64(size,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    mlib_abortprogram((byte*)"MEM");
    exit((i64)4);
}

void * mlib_allocmem(i64 n) {
    void *  p;
    p = malloc((u64)(n));
    if (!!(p)) {
        return p;
    };
    msysnewc_m_print_startcon();
    msysnewc_m_print_i64(n,NULL);
    msysnewc_m_print_i64(mlib_memtotal,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    mlib_abortprogram((byte*)"Alloc mem failure");
    return 0;
}

void * mlib_reallocmem(void * p,i64 n) {
    p = realloc(p,(u32)(n));
    if (!!(p)) {
        return p;
    };
    msysnewc_m_print_startcon();
    msysnewc_m_print_i64(n,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    mlib_abortprogram((byte*)"Realloc mem failure");
    return 0;
}

void mlib_abortprogram(byte * s) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(s,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"ABORTING: Press key...",NULL);
    msysnewc_m_print_end();
    ;
    osnos_os_getch();
    exit((i64)5);
}

i64 mlib_getfilesize(void * handlex) {
    u32 p;
    u32 size;
    p = (u64)(ftell(handlex));
    fseek(handlex,(i32)0,(i32)2);
    size = (u64)(ftell(handlex));
    fseek(handlex,(i32)(p),(i32)0);
    return (i64)(size);
}

void mlib_readrandom(void * handlex,byte * mem,i64 offset,i64 size) {
    i64 a;
    fseek(handlex,(i32)(offset),(i32)0);
    a = (i64)(fread((void *)(mem),(u32)1u,(u32)(size),handlex));
}

i64 mlib_writerandom(void * handlex,byte * mem,i64 offset,i64 size) {
    fseek(handlex,(i32)(offset),(i32)0);
    return (i64)(fwrite((void *)(mem),(u32)1u,(u32)(size),handlex));
}

i64 mlib_setfilepos(void * file,i64 offset) {
    return (i64)(fseek(file,(i32)(offset),(i32)0));
}

i64 mlib_getfilepos(void * file) {
    return (i64)(ftell(file));
}

byte * mlib_readfile(byte * filename) {
    void *  f;
    i64 size;
    byte *  m;
    byte *  p;
    f = fopen((i8 *)(filename),(i8 *)((byte*)"rb"));
    if ((f == 0)) {
        return (byte *)(0);
    };
    mlib_rfsize = (size = mlib_getfilesize(f));
    m = (byte *)(malloc((u64)((size + (i64)4))));
    if ((m == 0)) {
        return (byte *)(0);
    };
    mlib_readrandom(f,m,(i64)0,size);
    p = (m + size);
    (*p) = (u64)((i64)0);
    (*(p + (i64)1)) = (u64)((i64)26);
    (*(p + (i64)2)) = (u64)((i64)0);
    fclose(f);
    return m;
}

i64 mlib_writefile(byte * filename,byte * data,i64 size) {
    void *  f;
    i64 n;
    f = fopen((i8 *)(filename),(i8 *)((byte*)"wb"));
    if ((f == 0)) {
        return (i64)0;
    };
    n = mlib_writerandom(f,data,(i64)0,size);
    fclose(f);
    return n;
}

i64 mlib_checkfile(byte * file) {
    void *  f;
    if (!!((f = fopen((i8 *)(file),(i8 *)((byte*)"rb"))))) {
        fclose(f);
        return (i64)1;
    };
    return (i64)0;
}

void mlib_readlinen(void * handlex,byte * buffer,i64 size) {
    i64 ch;
    byte *  p;
    i64 n;
    byte crseen;
    if ((handlex == 0)) {
        handlex = osnos_os_getstdin();
    };
    if ((handlex == 0)) {
        n = (i64)0;
        p = buffer;
        L160 :;
        while (1) {
            ch = (i64)(getchar());
            if ((((ch == (i64)13) || (ch == (i64)10)) || (ch == (i64)-1))) {
                (*p) = (u64)0u;
                return;
            };
            (*p++) = (u64)(ch);
            ++n;
            if ((n >= (size - (i64)2))) {
                (*p) = (u64)0u;
                return;
            };
        }L161 :;
        ;
    };
    (*buffer) = (u64)0u;
    if ((fgets((i8 *)(buffer),(size - (i64)2),handlex) == 0)) {
        return;
    };
    n = (i64)(strlen((i8 *)(buffer)));
    if ((n == (i64)0)) {
        return;
    };
    p = ((buffer + n) - (i64)1);
    crseen = (u64)((i64)0);
    L162 :;
    while (((p >= buffer) && (((i64)((*p)) == (i64)13) || ((i64)((*p)) == (i64)10)))) {
        if ((((i64)((*p)) == (i64)13) || ((i64)((*p)) == (i64)10))) {
            crseen = (u64)((i64)1);
        };
        (*p--) = (u64)0u;
L163 :;
    }L164 :;
    ;
    if ((!(!!((u64)(crseen))) && ((n + (i64)4) > size))) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_i64(size,NULL);
        msysnewc_m_print_i64(n,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        mlib_abortprogram((byte*)"line too long");
    };
}

void mlib_iconvlcn(byte * s,i64 n) {
    i64 av_1;
    av_1 = n;
    while (av_1-- > 0) {
L165 :;
        (*s) = (u64)(tolower((i32)((*s))));
        ++s;
L166 :;
    }L167 :;
    ;
}

void mlib_iconvucn(byte * s,i64 n) {
    i64 av_1;
    av_1 = n;
    while (av_1-- > 0) {
L168 :;
        (*s) = (u64)(toupper((i32)((*s))));
        ++s;
L169 :;
    }L170 :;
    ;
}

void mlib_convlcstring(byte * s) {
    L171 :;
    while (!!((u64)((*s)))) {
        (*s) = (u64)(tolower((i32)((*s))));
        ++s;
L172 :;
    }L173 :;
    ;
}

void mlib_convucstring(byte * s) {
    L174 :;
    while (!!((u64)((*s)))) {
        (*s) = (u64)(toupper((i32)((*s))));
        ++s;
L175 :;
    }L176 :;
    ;
}

byte * mlib_changeext(byte * s,byte * newext) {
    static byte newfile[260];
    byte newext2[32];
    byte *  sext;
    i64 n;
    strcpy((i8 *)(&newfile[((i64)1)-1]),(i8 *)(s));
    if (((i64)((*newext))==(i64)0)) {
        newext2[((i64)1)-1] = (u64)0u;
        newext2[((i64)2)-1] = (u64)0u;
    }else if (((i64)((*newext))==(i64)46)) {
        strcpy((i8 *)(&newext2[((i64)1)-1]),(i8 *)(newext));
    } else {
        strcpy((i8 *)(&newext2[((i64)1)-1]),(i8 *)((byte*)"."));
        strcat((i8 *)(&newext2[((i64)1)-1]),(i8 *)(newext));
    };
    sext = mlib_extractext(s,(i64)1);
    if (((i64)((*sext))==(i64)0)) {
        strcat((i8 *)(&newfile[((i64)1)-1]),(i8 *)(&newext2[((i64)1)-1]));
    }else if (((i64)((*sext))==(i64)46)) {
        strcat((i8 *)(&newfile[((i64)1)-1]),(i8 *)(&newext2[((i64)2)-1]));
    } else {
        n = ((sext - s) - (i64)2);
        strcpy((i8 *)(((&newfile[((i64)1)-1] + n) + (i64)1)),(i8 *)(&newext2[((i64)1)-1]));
    };
    return &newfile[((i64)1)-1];
}

byte * mlib_extractext(byte * s,i64 period) {
    byte *  t;
    byte *  u;
    t = mlib_extractfile(s);
    if (((i64)((*t)) == (i64)0)) {
        return (byte*)"";
    };
    u = ((t + (i64)(strlen((i8 *)(t)))) - (i64)1);
    L177 :;
    while ((u >= t)) {
        if (((u64)((*u)) == '.')) {
            if (((i64)((*(u + (i64)1))) == (i64)0)) {
                return (!!(period)?(byte*)".":(byte*)"");
            };
            return (u + (i64)1);
        };
        --u;
L178 :;
    }L179 :;
    ;
    return (byte*)"";
}

byte * mlib_extractpath(byte * s) {
    static byte str[260];
    byte *  t;
    i64 n;
    t = ((s + (i64)(strlen((i8 *)(s)))) - (i64)1);
    L180 :;
    while ((t >= s)) {
        switch ((int)((*t))) {
        case 92:;
        case 47:;
        case 58:;
        {
            n = ((t - s) + (i64)1);
            memcpy((void *)(str),(void *)(s),(u32)(n));
            str[(n)] = (u64)0u;
            return str;
        }break;
        default: {
        }
        } /* SW */
;
        --t;
L181 :;
    }L182 :;
    ;
    return (byte*)"";
}

byte * mlib_extractfile(byte * s) {
    byte *  t;
    t = mlib_extractpath(s);
    if (((i64)((*t)) == (i64)0)) {
        return s;
    };
    return (s + (i64)(strlen((i8 *)(t))));
}

byte * mlib_extractbasefile(byte * s) {
    static byte str[100];
    byte *  f;
    byte *  e;
    i64 n;
    i64 flen;
    f = mlib_extractfile(s);
    flen = (i64)(strlen((i8 *)(f)));
    if ((flen == (i64)0)) {
        return (byte*)"";
    };
    e = mlib_extractext(f,(i64)0);
    if (!!((u64)((*e)))) {
        n = ((flen - (i64)((u64)(strlen((i8 *)(e))))) - (i64)1);
        memcpy((void *)(&str),(void *)(f),(u32)(n));
        str[(n)] = (u64)0u;
        return str;
    };
    if (((u64)((*((f + flen) - (i64)1))) == '.')) {
        memcpy((void *)(&str),(void *)(f),(u32)((flen - (i64)1)));
        str[((flen - (i64)1))] = (u64)0u;
        return str;
    };
    return f;
}

byte * mlib_addext(byte * s,byte * newext) {
    byte *  sext;
    sext = mlib_extractext(s,(i64)1);
    if (((i64)((*sext)) == (i64)0)) {
        return mlib_changeext(s,newext);
    };
    return s;
}

void * mlib_alloctable(i64 n,i64 size) {
    void *  p;
    p = malloc((u64)(((n + (i64)1) * size)));
    if (!(!!(p))) {
        mlib_abortprogram((byte*)"Alloctable failure");
    };
    return p;
}

void * mlib_zalloctable(i64 n,i64 size) {
    i64 *  p;
    p = (i64 *)(mlib_alloctable(n,size));
    mlib_pcm_clearmem((void *)(p),((n + (i64)1) * size));
    return (void *)(p);
}

void mlib_checkfreelists(byte * s) {
    u32 *  p;
    u32 *  q;
    i64 aa;
    i64 i;
    L183 :;
    for (i=(i64)2;i<=(i64)2;i+=(i64)1) {
L184 :;
        p = mlib_freelist[(i)];
        L187 :;
        while (!!(p)) {
            aa = (i64)(u32)(p);
            if (((aa > (i64)4294967295LL) || (aa < (i64)100))) {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str(s,NULL);
                msysnewc_m_print_str((byte*)"FREE LIST ERROR",NULL);
                msysnewc_m_print_i64(i,NULL);
                msysnewc_m_print_ptr(p,NULL);
                msysnewc_m_print_ptr(q,NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
            };
            q = p;
            p = (u32 *)(u32)((i64)((*p)));
L188 :;
        }L189 :;
        ;
L185 :;
    }L186 :;
    ;
}

void * mlib_pcm_alloc32(void) {
    mlib_allocbytes = (i64)32;
    return mlib_pcm_alloc((i64)32);
}

void mlib_pcm_free32(void * p) {
    mlib_smallmemtotal -= (i64)32;
    if (!!((i64)0)) {
        mlib_removefrommemalloc((i32 *)(p),(i64)32);
    };
    (*(u32 *)(p)) = (u64)((u32)((i64)(u32)(mlib_freelist[((i64)2)])));
    mlib_freelist[((i64)2)] = (u32 *)(p);
}

void mlib_outbyte(void * f,i64 x) {
    fwrite((void *)(&x),(u32)1u,(u32)1u,f);
}

void mlib_outword16(void * f,u64 x) {
    fwrite((void *)(&x),(u32)2u,(u32)1u,f);
}

void mlib_outword(void * f,u64 x) {
    fwrite((void *)(&x),(u32)4u,(u32)1u,f);
}

void mlib_outword64(void * f,u64 x) {
    fwrite((void *)(&x),(u32)8u,(u32)1u,f);
}

i64 mlib_myeof(void * f) {
    i64 c;
    c = (i64)(fgetc(f));
    if ((c == (i64)-1)) {
        return (i64)1;
    };
    ungetc((i32)(c),f);
    return (i64)0;
}

void * mlib_pcm_smallallocz(i64 n) {
    byte *  p;
    if (((mlib_alloccode = (i64)(mlib_sizeindextable[(n)])) == (i64)0)) {
        mlib_alloccode = (i64)1;
    };
    mlib_allocbytes = (i64)(mlib_allocupper[(mlib_alloccode)]);
    p = mlib_pcheapptr;
    mlib_pcheapptr += mlib_allocbytes;
    if ((mlib_pcheapptr >= mlib_pcheapend)) {
        p = (byte *)(mlib_pcm_newblock(mlib_allocbytes));
        memset((void *)(p),(i32)0,(u32)(n));
        return (void *)(p);
    };
    memset((void *)(p),(i32)0,(u32)(n));
    return (void *)(p);
}

void * mlib_pcm_smallalloc(i64 n) {
    byte *  p;
    if (((mlib_alloccode = (i64)(mlib_sizeindextable[(n)])) == (i64)0)) {
        mlib_alloccode = (i64)1;
    };
    mlib_allocbytes = (i64)(mlib_allocupper[(mlib_alloccode)]);
    p = mlib_pcheapptr;
    mlib_pcheapptr += mlib_allocbytes;
    if ((mlib_pcheapptr >= mlib_pcheapend)) {
        p = (byte *)(mlib_pcm_newblock(mlib_allocbytes));
        return (void *)(p);
    };
    return (void *)(p);
}

void mlib_strbuffer_add(struct mlib_strbuffer * dest,byte * s,i64 n) {
    i64 newlen;
    i64 oldlen;
    byte *  newptr;
    if ((n == (i64)0)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"N=0",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    if ((n == (i64)-1)) {
        n = (i64)(strlen((i8 *)(s)));
    };
    oldlen = (i64)((*dest).length);
    if ((oldlen == (i64)0)) {
        (*dest).strptr = (byte *)(mlib_pcm_alloc((n + (i64)1)));
        (*dest).allocated = mlib_allocbytes;
        (*dest).length = n;
        memcpy((void *)((*dest).strptr),(void *)(s),(u32)(n));
        (*((*dest).strptr + n)) = (u64)0u;
        return;
    };
    newlen = (oldlen + n);
    if (((newlen + (i64)1) > (i64)((*dest).allocated))) {
        newptr = (byte *)(mlib_pcm_alloc((newlen + (i64)1)));
        memcpy((void *)(newptr),(void *)((*dest).strptr),(u32)(oldlen));
        (*dest).strptr = newptr;
        (*dest).allocated = mlib_allocbytes;
    };
    memcpy((void *)(((*dest).strptr + oldlen)),(void *)(s),(u32)(n));
    (*((*dest).strptr + newlen)) = (u64)0u;
    (*dest).length = newlen;
}

void mlib_gs_init(struct mlib_strbuffer * dest) {
    mlib_pcm_clearmem((void *)(dest),(i64)12);
}

void mlib_gs_free(struct mlib_strbuffer * dest) {
    if (!!((i64)((*dest).allocated))) {
        mlib_pcm_free((void *)((*dest).strptr),(i64)((*dest).allocated));
    };
}

void mlib_gs_str(struct mlib_strbuffer * dest,byte * s) {
    mlib_strbuffer_add(dest,s,(i64)-1);
}

void mlib_gs_char(struct mlib_strbuffer * dest,i64 c) {
    byte s[16];
    s[((i64)1)-1] = (u64)(c);
    s[((i64)2)-1] = (u64)0u;
    mlib_strbuffer_add(dest,s,(i64)1);
}

void mlib_gs_strn(struct mlib_strbuffer * dest,byte * s,i64 length) {
    mlib_strbuffer_add(dest,s,length);
}

void mlib_gs_strvar(struct mlib_strbuffer * dest,struct mlib_strbuffer * s) {
    mlib_strbuffer_add(dest,(*s).strptr,(i64)-1);
}

void mlib_gs_strint(struct mlib_strbuffer * dest,i64 a) {
    mlib_strbuffer_add(dest,msysnewc_strint(a,(byte *)(0)),(i64)-1);
}

void mlib_gs_strln(struct mlib_strbuffer * dest,byte * s) {
    mlib_gs_str(dest,s);
    mlib_gs_line(dest);
}

void mlib_gs_strsp(struct mlib_strbuffer * dest,byte * s) {
    mlib_gs_str(dest,s);
    mlib_gs_str(dest,(byte*)" ");
}

void mlib_gs_line(struct mlib_strbuffer * dest) {
    mlib_strbuffer_add(dest,(byte*)"\r\n",(i64)-1);
}

i64 mlib_gs_getcol(struct mlib_strbuffer * dest) {
    return (i64)((*dest).length);
}

void mlib_gs_leftstr(struct mlib_strbuffer * dest,byte * s,i64 w,i64 padch) {
    i64 col;
    i64 i;
    i64 n;
    i64 slen;
    byte str[2560];
    col = (i64)((*dest).length);
    strcpy((i8 *)(str),(i8 *)(s));
    slen = (i64)(strlen((i8 *)(s)));
    n = (w - slen);
    if ((n > (i64)0)) {
        L190 :;
        for (i=(i64)1;i<=n;i+=(i64)1) {
L191 :;
            str[((slen + i))-1] = (u64)(padch);
L192 :;
        }L193 :;
        ;
        str[(((slen + n) + (i64)1))-1] = (u64)0u;
    };
    mlib_gs_str(dest,str);
}

void mlib_gs_leftint(struct mlib_strbuffer * dest,i64 a,i64 w,i64 padch) {
    mlib_gs_leftstr(dest,msysnewc_strint(a,(byte *)(0)),w,padch);
}

void mlib_gs_padto(struct mlib_strbuffer * dest,i64 col,i64 ch) {
    i64 n;
    byte str[2560];
    i64 i;
    n = (col - (i64)((*dest).length));
    if ((n <= (i64)0)) {
        return;
    };
    L194 :;
    for (i=(i64)1;i<=n;i+=(i64)1) {
L195 :;
        str[(i)-1] = (u64)(ch);
L196 :;
    }L197 :;
    ;
    str[((n + (i64)1))-1] = (u64)0u;
    mlib_gs_str(dest,str);
}

void mlib_gs_println(struct mlib_strbuffer * dest,void * f) {
    (*((*dest).strptr + (i64)((*dest).length))) = (u64)0u;
    if ((f == 0)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((*dest).strptr,NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((byte*)"\r",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    } else {
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_str((*dest).strptr,NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((byte*)"\r",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
}

i64 mlib_nextcmdparam(i64 * paramno,byte * * name,byte * * value,byte * defext) {
    static i64 infile = (i64)0;
    static byte *  filestart = 0;
    static byte *  fileptr = 0;
    static byte colonseen = (u8)0u;
    byte *  q;
    byte *  item;
    byte *  fileext;
    i64 length;
    static byte str[300];
    /*reenter:*/
L198 :;
;
    (*value) = (byte *)(0);
    (*name) = (byte *)(0);
    if (!!(infile)) {
        if ((mlib_readnextfileitem(&fileptr,&item) == (i64)0)) {
            free((void *)(filestart));
            infile = (i64)0;
            goto L198 ;
;
        };
    } else {
        if (((*paramno) > msysnewc_nsysparams)) {
            return (i64)0;
        };
        item = msysnewc_sysparams[((*paramno))-1];
        ++(*paramno);
        length = (i64)(strlen((i8 *)(item)));
        if (((u64)((*item)) == '@')) {
            filestart = (fileptr = (byte *)(mlib_readfile((item + (i64)1))));
            if ((filestart == 0)) {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((byte*)"Can't open",NULL);
                msysnewc_m_print_str(item,NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                exit((i64)7);
            };
            infile = (i64)1;
            goto L198 ;
;
        };
        if (((u64)((*item)) == ':')) {
            colonseen = (u64)((i64)1);
            return (i64)4;
        };
    };
    (*value) = (byte *)(0);
    if (((u64)((*item)) == '-')) {
        (*name) = (item + (!!((u64)(colonseen))?(i64)0:(i64)1));
        q = (byte *)(strchr((i8 *)(item),(i32)58));
        if (!(!!(q))) {
            q = (byte *)(strchr((i8 *)(item),(i32)61));
        };
        if (!!(q)) {
            (*value) = (q + (i64)1);
            (*q) = (u64)0u;
        };
        return (!!((u64)(colonseen))?(i64)5:(i64)1);
    };
    fileext = mlib_extractext(item,(i64)0);
    (*name) = item;
    if (((i64)((*fileext)) == (i64)0)) {
        strcpy((i8 *)(str),(i8 *)((*name)));
        if ((!!(defext) && !(!!((u64)(colonseen))))) {
            (*name) = mlib_addext(str,defext);
        };
    } else if (!!(mlib_eqstring(fileext,(byte*)"dll"))) {
        return (!!((u64)(colonseen))?(i64)5:(i64)3);
    };
    return (!!((u64)(colonseen))?(i64)5:(i64)2);
}

static i64 mlib_readnextfileitem(byte * * fileptr,byte * * item) {
    byte *  p;
    byte *  pstart;
    byte *  pend;
    i64 n;
    static byte str[256];
    p = (*fileptr);
    /*reenter:*/
L199 :;
;
    L200 :;
    while (1) {
        if (((i64)((*p))==(i64)32) || ((i64)((*p))==(i64)9) || ((i64)((*p))==(i64)13) || ((i64)((*p))==(i64)10)) {
            ++p;
        }else if (((i64)((*p))==(i64)26) || ((i64)((*p))==(i64)0)) {
            return (i64)0;
        } else {
            goto L201 ;
        };
    }L201 :;
    ;
    if (((i64)((*p))==(i64)33) || ((i64)((*p))==(i64)35)) {
        ++p;
        L202 :;
        if (((i64)((*p++))==(i64)10)) {
            goto L199 ;
;
        }else if (((i64)((*p++))==(i64)26) || ((i64)((*p++))==(i64)0)) {
            (*fileptr) = (p - (i64)1);
            return (i64)0;
        } else {
        }goto L202 ;
L203 :;
        ;
    };
    if (((i64)((*p))==(i64)34)) {
        pstart = ++p;
        L204 :;
        while (1) {
            if (((i64)((*p))==(i64)0) || ((i64)((*p))==(i64)26)) {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((byte*)"Unexpected EOF in @file",NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                exit((i64)8);
            }else if (((i64)((*p))==(i64)34)) {
                pend = p++;
                if (((u64)((*p)) == ',')) {
                    ++p;
                };
                goto L205 ;
            };
            ++p;
        }L205 :;
        ;
    } else {
        pstart = p;
        L206 :;
        while (1) {
            if (((i64)((*p))==(i64)0) || ((i64)((*p))==(i64)26)) {
                pend = p;
                goto L207 ;
            }else if (((i64)((*p))==(i64)32) || ((i64)((*p))==(i64)9) || ((i64)((*p))==(i64)44) || ((i64)((*p))==(i64)13) || ((i64)((*p))==(i64)10)) {
                pend = p++;
                goto L207 ;
            };
            ++p;
        }L207 :;
        ;
    };
    n = (pend - pstart);
    if ((n >= (i64)256)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"@file item too long",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        exit((i64)9);
    };
    memcpy((void *)(str),(void *)(pstart),(u32)(n));
    str[((n + (i64)1))-1] = (u64)0u;
    (*item) = str;
    (*fileptr) = p;
    return (i64)1;
}

void mlib_ipadstr(byte * s,i64 width,byte * padchar) {
    i64 n;
    i64 av_1;
    n = (i64)(strlen((i8 *)(s)));
    av_1 = (width - n);
    while (av_1-- > 0) {
L208 :;
        strcat((i8 *)(s),(i8 *)(padchar));
L209 :;
    }L210 :;
    ;
}

byte * mlib_padstr(byte * s,i64 width,byte * padchar) {
    static byte str[256];
    strcpy((i8 *)(str),(i8 *)(s));
    mlib_ipadstr(str,width,padchar);
    return str;
}

byte * mlib_chr(i64 c) {
    static byte str[8];
    str[((i64)1)-1] = (u64)(c);
    str[((i64)2)-1] = (u64)0u;
    return str;
}

i64 mlib_cmpstring(byte * s,byte * t) {
    i64 res;
    if (((res = (i64)(strcmp((i8 *)(s),(i8 *)(t)))) < (i64)0)) {
        return (i64)-1;
    } else if ((res > (i64)0)) {
        return (i64)1;
    } else {
        return (i64)0;
    };
}

i64 mlib_cmpstringn(byte * s,byte * t,i64 n) {
    i64 res;
    if (((res = (i64)(strncmp((i8 *)(s),(i8 *)(t),(u32)(n)))) < (i64)0)) {
        return (i64)-1;
    } else if ((res > (i64)0)) {
        return (i64)1;
    } else {
        return (i64)0;
    };
}

i64 mlib_eqstring(byte * s,byte * t) {
    return ((i64)(strcmp((i8 *)(s),(i8 *)(t))) == (i64)0);
}

i64 mlib_cmpbytes(void * p,void * q,i64 n) {
    i64 res;
    if (((res = (i64)(memcmp(p,q,(u32)(n)))) < (i64)0)) {
        return (i64)-1;
    } else if ((res > (i64)0)) {
        return (i64)1;
    } else {
        return (i64)0;
    };
}

i64 mlib_eqbytes(void * p,void * q,i64 n) {
    return ((i64)(memcmp(p,q,(u32)(n))) == (i64)0);
}

void mlib_mseed(u64 a,u64 b) {
    mlib_seed[((i64)1)-1] = (i64)(a);
    if (!!(b)) {
        mlib_seed[((i64)2)-1] = (i64)(b);
    } else {
        mlib_seed[((i64)2)-1] ^= (i64)(a);
    };
}

u64 mlib_mrandom(void) {
    u64 x;
    u64 y;
    x = (u64)(mlib_seed[((i64)1)-1]);
    y = (u64)(mlib_seed[((i64)2)-1]);
    mlib_seed[((i64)1)-1] = (i64)(y);
    x ^= (x << (i64)23);
    mlib_seed[((i64)2)-1] = (i64)((((x ^ y) ^ (x >> (i64)17)) ^ (y >> (i64)26)));
    return (u64)((mlib_seed[((i64)2)-1] + (i64)(y)));
}

i64 mlib_mrandomp(void) {
    return (i64)((mlib_mrandom() & (u64)9223372036854775807u));
}

i64 mlib_mrandomint(i64 n) {
    return (mlib_mrandomp() % n);
}

i64 mlib_mrandomrange(i64 a,i64 b) {
    i64 span;
    span = ((b - a) + (i64)1);
    if ((span <= (i64)0)) {
        return (i64)0;
    };
    return ((mlib_mrandomp() % span) + a);
}

double mlib_mrandomreal(void) {
    double x;
    L211 :;
    do {
        x = ((double)(mlib_mrandomp()) / (double)9223372036854775800.);
L212 :;
    } while (!(x != (double)1.));L213 :;
    ;
    return x;
}

double mlib_mrandomreal1(void) {
    return (double)((mlib_mrandomp() / (i64)((u64)9223372036854775807u)));
}

byte * mlib_checkpackfile(void) {
    i64 a;
    i64 offset;
    byte exefile[300];
    byte *  packexeptr;
    i64 packexesize;
    byte *  packfilename;
    i64 packfilesize;
    byte *  packfileptr;
    strcpy((i8 *)(&exefile[((i64)1)-1]),(i8 *)(osnos_os_gethostname()));
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"Attempting to open",NULL);
    msysnewc_m_print_ptr(&exefile,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    packexeptr = mlib_readfile(&exefile[((i64)1)-1]);
    if (!(!!(packexeptr))) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"Can't open",NULL);
        msysnewc_m_print_ptr(&exefile,NULL);
        msysnewc_m_print_ptr(&packexeptr,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        exit(0);
    };
    packexesize = mlib_rfsize;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"File read OK. Size",NULL);
    msysnewc_m_print_i64(packexesize,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    a = (i64)((*(i32 *)((packexeptr + (packexesize - (i64)4)))));
    if ((a != (i64)1262568272)) {
        free((void *)(packexeptr));
        packfileptr = (byte *)(0);
        return (byte *)(0);
    };
    offset = (i64)((*(i32 *)((packexeptr + (packexesize - (i64)8)))));
    packfilename = (byte *)((packexeptr + offset));
    offset += ((i64)((u64)(strlen((i8 *)(packfilename)))) + (i64)1);
    packfilesize = (i64)((*(i32 *)((packexeptr + offset))));
    packfileptr = ((packexeptr + offset) + (i64)4);
    return packfileptr;
}

void osnos_os_init(void) {
    osnos_init_flag = (i64)1;
}

i64 osnos_os_execwait(byte * cmdline,i64 newconsole,byte * workdir) {
    return (i64)(system((i8 *)(cmdline)));
}

i64 osnos_os_execcmd(byte * cmdline,i64 newconsole) {
    return (i64)(system((i8 *)(cmdline)));
}

i64 osnos_os_getch(void) {
    return (i64)0;
}

i64 osnos_os_kbhit(void) {
    mlib_abortprogram((byte*)"kbhit");
    return (i64)0;
}

void osnos_os_flushkeys(void) {
    mlib_abortprogram((byte*)"flushkeys");
}

void * osnos_os_getconsolein(void) {
    return 0;
}

void * osnos_os_getconsoleout(void) {
    return 0;
}

void * osnos_os_proginstance(void) {
    mlib_abortprogram((byte*)"PROGINST");
    return 0;
}

u64 osnos_os_getdllinst(byte * name) {
    return (u64)((i64)0);
}

void (*osnos_os_getdllprocaddr(i32 hinst,byte * name))(void) {
    static struct osnos_os_getdllprocaddr_rec table[23] = {
    {(byte*)"malloc",(void *)(&malloc)},
    {(byte*)"realloc",(void *)(&realloc)},
    {(byte*)"free",(void *)(&free)},
    {(byte*)"printf",(void *)(&printf)},
    {(byte*)"puts",(void *)(&puts)},
    {(byte*)"fgetc",(void *)(&fgetc)},
    {(byte*)"fputc",(void *)(&fputc)},
    {(byte*)"getchar",(void *)(&getchar)},
    {(byte*)"fopen",(void *)(&fopen)},
    {(byte*)"fclose",(void *)(&fclose)},
    {(byte*)"fseek",(void *)(&fseek)},
    {(byte*)"ftell",(void *)(&ftell)},
    {(byte*)"fread",(void *)(&fread)},
    {(byte*)"fwrite",(void *)(&fwrite)},
    {(byte*)"clock",(void *)(&clock)},
    {(byte*)"isalpha",(void *)(&isalpha)},
    {(byte*)"tolower",(void *)(&tolower)},
    {(byte*)"feof",(void *)(&feof)},
    {(byte*)"memset",(void *)(&memset)},
    {(byte*)"memcpy",(void *)(&memcpy)},
    {(byte*)"ungetc",(void *)(&ungetc)},
    {(byte*)"remove",(void *)(&remove)},
    {(byte*)"system",(void *)(&system)}
};
    i64 av_1;
    i64 i;
    L214 :;
    for (i=(i64)1;i<=(i64)23;i+=(i64)1) {
L215 :;
        if (((i64)(strcmp((i8 *)(table[(i)-1].name),(i8 *)(name))) == (i64)0)) {
            return (void (*)(void))(table[(i)-1].addr);
        };
L216 :;
    }L217 :;
    ;
    return (void (*)(void))(0);
}

void osnos_os_initwindows(void) {
}

i64 osnos_os_getchx(void) {
    mlib_abortprogram((byte*)"getchx");
    return (i64)0;
}

byte * osnos_os_getos(void) {
    return (byte*)"NO-OS";
}

i64 osnos_os_getoscode(void) {
    return (i64)78;
}

i64 osnos_os_iswindows(void) {
    static i64 iswindows = (i64)-1;
    void *  f;
    if ((iswindows == (i64)-1)) {
        f = fopen((i8 *)((byte*)"c:/windows/notepad.exe"),(i8 *)((byte*)"rb"));
        if (!!(f)) {
            fclose(f);
            iswindows = (i64)1;
        } else {
            iswindows = (i64)0;
        };
    };
    return iswindows;
}

i64 osnos_os_shellexec(byte * opc,byte * file) {
    mlib_abortprogram((byte*)"SHELL EXEC");
    return (i64)0;
}

void osnos_os_sleep(i64 a) {
    mlib_abortprogram((byte*)"sleep");
}

void * osnos_os_getstdin(void) {
    return 0;
}

void * osnos_os_getstdout(void) {
    return 0;
}

byte * osnos_os_gethostname(void) {
    return (byte*)"";
}

i64 osnos_os_gethostsize(void) {
    return (i64)32;
}

byte * osnos_os_getmpath(void) {
    return (byte*)"";
}

void osnos_os_exitprocess(i64 x) {
    exit(0);
}

i64 osnos_os_gettimestamp(void) {
    return (i64)(clock());
}

i64 osnos_os_gettickcount(void) {
    return (i64)(clock());
}

i64 osnos_os_clock(void) {
    if (!!(osnos_os_iswindows())) {
        return (i64)(clock());
    } else {
        return ((i64)(clock()) / (i64)1000);
    };
}

i64 osnos_os_getclockspersec(void) {
    return (!!(osnos_os_iswindows())?(i64)1000:(i64)1000000);
}

void osnos_os_setmesshandler(void * addr) {
    mlib_abortprogram((byte*)"SETMESSHANDLER");
}

i64 osnos_os_filelastwritetime(byte * filename) {
    return (i64)0;
}

i64 osnos_os_hpcounter(void) {
    return (i64)1;
}

i64 osnos_os_hpfrequency(void) {
    return (i64)1;
}

void osnos_os_getsystime(void * tm) {
}

void osnos_os_peek(void) {
}

static void cc_support_stopcompiler(byte * filename,i64 lineno) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    exit((i64)1);
}

void cc_support_mcerror(byte * mess) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"MC Error:",NULL);
    msysnewc_m_print_str(mess,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    osnos_os_getch();
    exit((i64)40);
}

void cc_support_serror(byte * mess) {
    cc_support_serror_gen(mess);
}

void cc_support_serror_gen(byte * mess) {
    if (!!(cc_decls_currproc)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"In function",NULL);
        msysnewc_m_print_str((*cc_decls_currproc).name,NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((byte*)" ",NULL);
        msysnewc_m_print_end();
        ;
    };
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"On line",NULL);
    msysnewc_m_print_u64(cc_decls_lx.lineno,NULL);
    msysnewc_m_print_str((byte*)"in file",NULL);
    msysnewc_m_print_str(cc_decls_sourcefilepaths[((i64)(cc_decls_lx.fileno))],NULL);
    msysnewc_m_print_str(cc_decls_sourcefilenames[((i64)(cc_decls_lx.fileno))],NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    cc_support_showmacrolineno();
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"**** Syntax Error:",NULL);
    msysnewc_m_print_str(mess,NULL);
    msysnewc_m_print_str((byte*)"****",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    cc_support_stopcompiler(cc_decls_sourcefilepaths[((i64)(cc_decls_lx.fileno))],(i64)(cc_decls_lx.lineno));
}

void cc_support_serror_ss(byte * mess,byte * a,byte * b) {
    byte str[256];
    sprintf((i8 *)(str),(i8 *)(mess),a,b);
    cc_support_serror_gen(str);
}

void cc_support_serror_s(byte * mess,byte * a) {
    byte str[256];
    sprintf((i8 *)(str),(i8 *)(mess),a);
    cc_support_serror_gen(str);
}

void cc_support_terror_gen(byte * mess) {
    if (!!(cc_decls_currproc)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"In function",NULL);
        msysnewc_m_print_str((*cc_decls_currproc).name,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"Type error:",NULL);
    msysnewc_m_print_str(mess,NULL);
    msysnewc_m_print_str((byte*)"on line",NULL);
    msysnewc_m_print_u64(cc_decls_lx.lineno,NULL);
    msysnewc_m_print_str(cc_decls_sourcefilepaths[((i64)(cc_decls_lx.fileno))],NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    cc_support_showmacrolineno();
    cc_support_stopcompiler(cc_decls_sourcefilepaths[((i64)(cc_decls_lx.fileno))],(i64)(cc_decls_lx.lineno));
}

void cc_support_terror(byte * mess) {
    cc_support_terror_gen(mess);
}

void cc_support_terror_s(byte * mess,byte * a) {
    byte str[256];
    sprintf((i8 *)(str),(i8 *)(mess),a);
    cc_support_terror_gen(str);
}

void cc_support_terror_ss(byte * mess,byte * a,byte * b) {
    byte str[256];
    sprintf((i8 *)(str),(i8 *)(mess),a,b);
    cc_support_terror_gen(str);
}

void cc_support_gerror_gen(byte * mess,struct cc_decls_unitrec * p) {
    i64 lineno;
    if (!!(p)) {
        lineno = (i64)((*p).lineno);
    } else {
        lineno = cc_decls_clineno;
    };
    if (!!(cc_decls_currproc)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"In function",NULL);
        msysnewc_m_print_str((*cc_decls_currproc).name,NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((byte*)" ",NULL);
        msysnewc_m_print_end();
        ;
    };
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"On line",NULL);
    msysnewc_m_print_i64((lineno & (i64)16777215),NULL);
    msysnewc_m_print_str((byte*)"in file",NULL);
    msysnewc_m_print_str(cc_decls_sourcefilepaths[((lineno >> (i64)24))],NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"**** Code Gen Error:",NULL);
    msysnewc_m_print_str(mess,NULL);
    msysnewc_m_print_str((byte*)"****",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    cc_support_stopcompiler(cc_decls_sourcefilepaths[((lineno >> (i64)24))],lineno);
}

void cc_support_gerror(byte * mess,struct cc_decls_unitrec * p) {
    cc_support_gerror_gen(mess,p);
}

void cc_support_gerror_s(byte * mess,byte * s,struct cc_decls_unitrec * p) {
    byte str[256];
    sprintf((i8 *)(str),(i8 *)(mess),s);
    cc_support_gerror_gen(str,p);
}

void cc_support_nxerror(byte * mess,struct cc_decls_unitrec * p) {
    i64 lineno;
    if (!!(p)) {
        lineno = (i64)((*p).lineno);
    } else {
        lineno = (i64)0;
    };
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"NX error:",NULL);
    msysnewc_m_print_str(mess,NULL);
    msysnewc_m_print_str((byte*)"on line",NULL);
    msysnewc_m_print_i64(lineno,NULL);
    msysnewc_m_print_str((*cc_decls_stmodule).name,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    osnos_os_getch();
    cc_support_stopcompiler((*cc_decls_stmodule).name,lineno);
}

i64 cc_support_testelem(byte (*p)[],i64 n) {
    return (!!(((u64)((*p)[((n >> (i64)3))]) & (u64)(cc_support_bytemasks[((n & (i64)7))])))?(i64)1:(i64)0);
}

void cc_support_setelem(byte (*p)[],i64 n) {
    (*p)[((n >> (i64)3))] |= cc_support_bytemasks[((n & (i64)7))];
}

i64 cc_support_nextpoweroftwo(i64 x) {
    i64 a;
    if ((x == (i64)0)) {
        return (i64)0;
    };
    a = (i64)1;
    L218 :;
    while ((a < x)) {
        a <<= (i64)1;
L219 :;
    }L220 :;
    ;
    return a;
}

void cc_support_loaderror(byte * mess,byte * mess2) {
    byte str[512];
    sprintf((i8 *)(str),(i8 *)(mess),mess2);
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"Load Error:",NULL);
    msysnewc_m_print_str(str,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"Stopping",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    exit((i64)45);
}

i64 cc_support_loadfromstdin(byte * file) {
    byte src[30000];
    byte *  p;
    i64 n;
    i64 c;
    if ((cc_decls_nsourcefiles > (i64)600)) {
        cc_support_loaderror((byte*)"Too many source files",(byte*)"");
    };
    ++cc_decls_nsourcefiles;
    cc_decls_sourcefilepaths[(cc_decls_nsourcefiles)] = mlib_pcm_copyheapstring(file);
    cc_decls_sourcefilenames[(cc_decls_nsourcefiles)] = mlib_pcm_copyheapstring(file);
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"Reading from stdin. Finish with Ctrl-Z:",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    p = src;
    n = (i64)0;
    L221 :;
    while (((c = (i64)(getchar())) != (i64)-1)) {
        (*p++) = (u64)(c);
        if ((++n >= (i64)30000)) {
            cc_support_loaderror((byte*)"stdin overflow",(byte*)"");
        };
L222 :;
    }L223 :;
    ;
    (*p) = (u64)0u;
    cc_decls_sourcefiletext[(cc_decls_nsourcefiles)] = mlib_pcm_copyheapstring(src);
    cc_decls_sourcefilesizes[(cc_decls_nsourcefiles)] = (i64)(strlen((i8 *)(src)));
    return cc_decls_nsourcefiles;
}

i64 cc_support_loadsourcefile(byte * file,byte * shortfile) {
    byte *  s;
    if ((cc_decls_nsourcefiles > (i64)600)) {
        cc_support_loaderror((byte*)"Too many source files",(byte*)"");
    };
    ++cc_decls_nsourcefiles;
    cc_decls_sourcefilepaths[(cc_decls_nsourcefiles)] = mlib_pcm_copyheapstring(file);
    cc_decls_sourcefilenames[(cc_decls_nsourcefiles)] = mlib_pcm_copyheapstring(shortfile);
    s = (byte *)(mlib_readfile(file));
    if (!(!!(s))) {
        cc_support_loaderror((byte*)"LSF can't load ",file);
    };
    if (!!((i64)0)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"SPLICELINES",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        s = cc_support_splicelines(s);
    };
    cc_decls_sourcefiletext[(cc_decls_nsourcefiles)] = s;
    cc_decls_sourcefilesizes[(cc_decls_nsourcefiles)] = mlib_rfsize;
    (*(s + mlib_rfsize)) = (u64)0u;
    return cc_decls_nsourcefiles;
}

static byte * cc_support_splicelines(byte * s) {
    byte *  t;
    byte *  u;
    t = (u = (byte *)(mlib_pcm_alloc(((i64)((u64)(strlen((i8 *)(s)))) + (i64)1))));
    L224 :;
    while (!!((u64)((*s)))) {
        if ((((u64)((*s)) == (u64)92u) && ((i64)((*(s + (i64)1))) == (i64)10))) {
            s += (i64)2;
        } else if (((((u64)((*s)) == (u64)92u) && ((i64)((*(s + (i64)1))) == (i64)13)) && ((i64)((*(s + (i64)2))) == (i64)10))) {
            s += (i64)3;
        } else {
            (*t++) = (u64)((*s++));
        };
        (*t) = (u64)0u;
L225 :;
    }L226 :;
    ;
    return u;
}

i64 cc_support_loadbuiltin(byte * shortfile,byte * hdrtext) {
    if ((cc_decls_nsourcefiles > (i64)600)) {
        cc_support_loaderror((byte*)"Too many source files",(byte*)"");
    };
    ++cc_decls_nsourcefiles;
    cc_decls_sourcefilepaths[(cc_decls_nsourcefiles)] = (byte*)"<builtin>";
    cc_decls_sourcefilenames[(cc_decls_nsourcefiles)] = mlib_pcm_copyheapstring(shortfile);
    cc_decls_sourcefiletext[(cc_decls_nsourcefiles)] = mlib_pcm_copyheapstring(hdrtext);
    cc_decls_sourcefilesizes[(cc_decls_nsourcefiles)] = (i64)(strlen((i8 *)(hdrtext)));
    return cc_decls_nsourcefiles;
}

static void cc_support_gs_copytostr(struct mlib_strbuffer * source,byte * s) {
    if (!!((i64)((*source).length))) {
        memcpy((void *)(s),(void *)((*source).strptr),(u32)((*source).length));
        (*(s + (i64)((*source).length))) = (u64)0u;
    } else {
        (*s) = (u64)0u;
    };
}

void cc_support_gs_additem(struct mlib_strbuffer * dest,byte * s) {
    byte *  d;
    i64 lastchar;
    i64 nextchar;
    d = (*dest).strptr;
    if (!!((i64)((*dest).length))) {
        lastchar = (i64)((*((d + (i64)((*dest).length)) - (i64)1)));
        nextchar = (i64)((*s));
        if ((!!(cc_support_isalphanum(lastchar)) && !!(cc_support_isalphanum(nextchar)))) {
            mlib_strbuffer_add(dest,(byte*)" ",(i64)-1);
        };
    };
    mlib_strbuffer_add(dest,s,(i64)-1);
}

static i64 cc_support_isalphanum(i64 c) {
    if (((((c >= (i64)65) && (c <= (i64)90)) || ((c >= (i64)97) && (c <= (i64)122))) || ((c >= (i64)48) && (c <= (i64)57)))) {
        return (i64)1;
    };
    return (i64)0;
}

static void cc_support_showmacrolineno(void) {
    if (!!(cc_decls_slineno)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"\t(Last macro invoked near line",NULL);
        msysnewc_m_print_i64(cc_decls_slineno,NULL);
        msysnewc_m_print_str((byte*)"in file",NULL);
        msysnewc_m_print_str(cc_decls_sourcefilenames[(cc_decls_sfileno)],NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((byte*)")",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
}

void cc_lex_lex_preprocess_only(byte * infile,i64 showtokens,i64 nn,i64 toconsole) {
    byte *  psource;
    i64 ntokens;
    i64 nlines;
    i64 fileno;
    i64 size;
    i64 t;
    i64 hashtot;
    i64 symtot;
    static struct mlib_strbuffer sbuffer;
    static struct mlib_strbuffer *  dest = &sbuffer;
    void *  f;
    byte outfile[300];
    cc_lex_dowhitespace = (i64)1;
    fileno = cc_support_loadsourcefile(infile,infile);
    strcpy((i8 *)(outfile),(i8 *)(mlib_changeext(infile,(byte*)"i")));
    psource = cc_decls_sourcefiletext[(fileno)];
    size = (i64)(cc_decls_sourcefilesizes[(fileno)]);
    nlines = (ntokens = (i64)0);
    hashtot = (symtot = (i64)0);
    t = osnos_os_clock();
    cc_lex_destcopy = dest;
    mlib_gs_init(dest);
    cc_decls_nalllines = (i64)0;
    cc_lex_lxsptr = psource;
    cc_lex_lxstart = cc_lex_lxsptr;
    cc_decls_nextlx.lineno = (u64)((i64)1);
    cc_lex_setfileno((i64)1);
    cc_lex_ifcondlevel = (i64)0;
    cc_lex_stacksourcefile((byte*)"bcc.h",(i64)1);
    cc_decls_nextlx.symbol = (u64)((i64)56);
    L227 :;
    do {
        cc_lex_lexm();
        ++ntokens;
        if (!!(showtokens)) {
            cc_lex_emittoken(&cc_decls_nextlx,dest,(i64)0);
        };
L228 :;
    } while (!((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)57));L229 :;
    ;
    if (!!(cc_lex_ifcondlevel)) {
        cc_lex_lxerror((byte*)"#endif missing");
    };
    nlines += cc_decls_nalllines;
    if (!!(showtokens)) {
        if (!!(toconsole)) {
            mlib_gs_println(dest,0);
        } else {
            f = fopen((i8 *)(outfile),(i8 *)((byte*)"wb"));
            mlib_gs_println(dest,f);
            fclose(f);
        };
    };
}

void cc_lex_lexreadtoken(void) {
    u64 c;
    u64 hsum;
    byte *  ss;
    cc_decls_nextlx.subcodex = (u64)((i64)0);
    L230 :;
    switch ((int)((*cc_lex_lxsptr++))) {
    case 65:;
    case 66:;
    case 67:;
    case 68:;
    case 69:;
    case 70:;
    case 71:;
    case 72:;
    case 73:;
    case 74:;
    case 75:;
    case 76:;
    case 77:;
    case 78:;
    case 79:;
    case 80:;
    case 81:;
    case 82:;
    case 83:;
    case 84:;
    case 85:;
    case 86:;
    case 87:;
    case 88:;
    case 89:;
    case 90:;
    case 97:;
    case 98:;
    case 99:;
    case 100:;
    case 101:;
    case 102:;
    case 103:;
    case 104:;
    case 105:;
    case 106:;
    case 107:;
    case 108:;
    case 109:;
    case 110:;
    case 111:;
    case 112:;
    case 113:;
    case 114:;
    case 115:;
    case 116:;
    case 117:;
    case 118:;
    case 119:;
    case 120:;
    case 121:;
    case 122:;
    case 36:;
    case 95:;
    {
        /*doname:*/
L232 :;
;
        cc_lex_lxsvalue = (cc_lex_lxsptr - (i64)1);
        hsum = (u64)((*cc_lex_lxsvalue));
        L233 :;
        while (!!((u64)(cc_lex_alphamap[((i64)((c = (u64)((*cc_lex_lxsptr++)))))]))) {
            hsum = (((hsum << (i64)4) - hsum) + c);
L234 :;
        }L235 :;
        ;
        --cc_lex_lxsptr;
        cc_decls_nextlx.symbol = (u64)((i64)68);
        cc_decls_nextlx.length = (cc_lex_lxsptr - cc_lex_lxsvalue);
        if ((c==(u64)39u) || (c==(u64)34u)) {
            if (((i64)(cc_decls_nextlx.length) == (i64)1)) {
                if (((i64)((*cc_lex_lxsvalue))==(i64)108) || ((i64)((*cc_lex_lxsvalue))==(i64)76) || ((i64)((*cc_lex_lxsvalue))==(i64)117) || ((i64)((*cc_lex_lxsvalue))==(i64)85)) {
                    ++cc_lex_lxsptr;
                    cc_lex_lxreadstring((i64)(c),(i64)1);
                    return;
                };
            };
        };
        cc_lex_lxhashvalue = (i64)(((hsum << (i64)5) - hsum));
        ss = (byte *)(mlib_pcm_alloc(((i64)(cc_decls_nextlx.length) + (i64)1)));
        memcpy((void *)(ss),(void *)(cc_lex_lxsvalue),(u32)(cc_decls_nextlx.length));
        (*(ss + (i64)(cc_decls_nextlx.length))) = (u64)0u;
        cc_lex_lxsvalue = ss;
        cc_lex_lookup();
        return;
    }break;
    case 49:;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
    {
        if (((i64)((*cc_lex_lxsptr))==(i64)32) || ((i64)((*cc_lex_lxsptr))==(i64)41) || ((i64)((*cc_lex_lxsptr))==(i64)13) || ((i64)((*cc_lex_lxsptr))==(i64)44) || ((i64)((*cc_lex_lxsptr))==(i64)59)) {
            cc_decls_nextlx.symbol = (u64)((i64)59);
            cc_decls_nextlx.subcode = (u64)((i64)4);
            cc_decls_nextlx.value = ((u64)((*(cc_lex_lxsptr - (i64)1))) - '0');
            cc_decls_nextlx.length = (i64)1;
            cc_lex_setnumberoffset(((cc_lex_lxsptr - (i64)1) - cc_lex_lxstart));
        } else {
            cc_lex_readdecimal((cc_lex_lxsptr - (i64)1));
        };
        return;
    }break;
    case 48:;
    {
        switch ((int)((*cc_lex_lxsptr))) {
        case 120:;
        case 88:;
        {
            ++cc_lex_lxsptr;
            cc_lex_readhex((cc_lex_lxsptr - (i64)2));
            return;
        }break;
        case 98:;
        case 66:;
        {
            ++cc_lex_lxsptr;
            cc_lex_readbinary((cc_lex_lxsptr - (i64)2));
            return;
        }break;
        case 46:;
        {
            cc_lex_readrealnumber((cc_lex_lxsptr - (i64)1),(cc_lex_lxsptr - (i64)1),(i64)1,(i64)10);
            return;
        }break;
        case 117:;
        case 85:;
        case 108:;
        case 76:;
        {
            cc_lex_readdecimal((cc_lex_lxsptr - (i64)1));
            return;
        }break;
        case 44:;
        case 41:;
        case 93:;
        case 125:;
        case 59:;
        case 32:;
        case 58:;
        case 13:;
        case 10:;
        case 38:;
        case 61:;
        case 63:;
        {
            cc_decls_nextlx.symbol = (u64)((i64)59);
            cc_decls_nextlx.subcode = (u64)((i64)4);
            cc_decls_nextlx.value = (i64)0;
            cc_decls_nextlx.length = (i64)1;
            cc_lex_setnumberoffset(((cc_lex_lxsptr - (i64)1) - cc_lex_lxstart));
            return;
        }break;
        default: {
            cc_lex_readoctal((cc_lex_lxsptr - (i64)1));
            return;
        }
        } /* SW */
;
    }break;
    case 35:;
    {
        if (((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)56)) {
            cc_decls_nextlx.symbol = (u64)((i64)4);
            return;
        } else if (((u64)((*cc_lex_lxsptr)) == '#')) {
            ++cc_lex_lxsptr;
            cc_decls_nextlx.symbol = (u64)((i64)7);
            return;
        } else {
            cc_decls_nextlx.symbol = (u64)((i64)5);
            return;
        };
    }break;
    case 92:;
    {
        L236 :;
        if (((i64)((*cc_lex_lxsptr))==(i64)13) || ((i64)((*cc_lex_lxsptr))==(i64)10)) {
            goto L237 ;
        }else if (((i64)((*cc_lex_lxsptr))==(i64)32) || ((i64)((*cc_lex_lxsptr))==(i64)9)) {
            ++cc_lex_lxsptr;
        } else {
            cc_decls_nextlx.symbol = (u64)((i64)21);
            return;
        }goto L236 ;
L237 :;
        ;
        (*(cc_lex_lxsptr - (i64)1)) = ' ';
        ++cc_decls_nextlx.lineno;
        ++cc_decls_nalllines;
        if (((i64)((*cc_lex_lxsptr))==(i64)13)) {
            ++cc_lex_lxsptr;
            (*cc_lex_lxsptr++) = ' ';
        }else if (((i64)((*cc_lex_lxsptr))==(i64)10)) {
            (*cc_lex_lxsptr++) = ' ';
        } else {
        };
    }break;
    case 123:;
    {
        cc_decls_nextlx.symbol = (u64)((i64)16);
        return;
    }break;
    case 125:;
    {
        cc_decls_nextlx.symbol = (u64)((i64)17);
        return;
    }break;
    case 46:;
    {
        switch ((int)((*cc_lex_lxsptr))) {
        case 46:;
        {
            ++cc_lex_lxsptr;
            if (((u64)((*cc_lex_lxsptr)) == '.')) {
                ++cc_lex_lxsptr;
                cc_decls_nextlx.symbol = (u64)((i64)20);
            } else {
                --cc_lex_lxsptr;
                cc_decls_nextlx.symbol = (u64)((i64)2);
                return;
            };
            return;
        }break;
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
        {
            --cc_lex_lxsptr;
            cc_lex_readrealnumber(cc_lex_lxsptr,cc_lex_lxsptr,(i64)0,(i64)10);
            return;
        }break;
        default: {
            cc_decls_nextlx.symbol = (u64)((i64)2);
            return;
        }
        } /* SW */
;
    }break;
    case 44:;
    {
        cc_decls_nextlx.symbol = (u64)((i64)8);
        return;
    }break;
    case 59:;
    {
        cc_decls_nextlx.symbol = (u64)((i64)9);
        return;
    }break;
    case 58:;
    {
        cc_decls_nextlx.symbol = (u64)((i64)10);
        return;
    }break;
    case 40:;
    {
        cc_decls_nextlx.symbol = (u64)((i64)12);
        return;
    }break;
    case 41:;
    {
        cc_decls_nextlx.symbol = (u64)((i64)13);
        return;
    }break;
    case 91:;
    {
        cc_decls_nextlx.symbol = (u64)((i64)14);
        return;
    }break;
    case 93:;
    {
        cc_decls_nextlx.symbol = (u64)((i64)15);
        return;
    }break;
    case 124:;
    {
        if (((i64)((*cc_lex_lxsptr))==(i64)124)) {
            ++cc_lex_lxsptr;
            cc_decls_nextlx.symbol = (u64)((i64)30);
        }else if (((i64)((*cc_lex_lxsptr))==(i64)61)) {
            ++cc_lex_lxsptr;
            cc_decls_nextlx.symbol = (u64)((i64)50);
        } else {
            cc_decls_nextlx.symbol = (u64)((i64)27);
        };
        return;
    }break;
    case 94:;
    {
        if (((u64)((*cc_lex_lxsptr)) == '=')) {
            ++cc_lex_lxsptr;
            cc_decls_nextlx.symbol = (u64)((i64)52);
        } else {
            cc_decls_nextlx.symbol = (u64)((i64)29);
        };
        return;
    }break;
    case 63:;
    {
        cc_decls_nextlx.symbol = (u64)((i64)18);
        return;
    }break;
    case 126:;
    {
        cc_decls_nextlx.symbol = (u64)((i64)34);
        return;
    }break;
    case 43:;
    {
        if (((i64)((*cc_lex_lxsptr))==(i64)43)) {
            ++cc_lex_lxsptr;
            cc_decls_nextlx.symbol = (u64)((i64)36);
        }else if (((i64)((*cc_lex_lxsptr))==(i64)61)) {
            ++cc_lex_lxsptr;
            cc_decls_nextlx.symbol = (u64)((i64)45);
        } else {
            cc_decls_nextlx.symbol = (u64)((i64)22);
        };
        return;
    }break;
    case 45:;
    {
        if (((i64)((*cc_lex_lxsptr))==(i64)45)) {
            ++cc_lex_lxsptr;
            cc_decls_nextlx.symbol = (u64)((i64)37);
        }else if (((i64)((*cc_lex_lxsptr))==(i64)62)) {
            ++cc_lex_lxsptr;
            cc_decls_nextlx.symbol = (u64)((i64)3);
        }else if (((i64)((*cc_lex_lxsptr))==(i64)61)) {
            ++cc_lex_lxsptr;
            cc_decls_nextlx.symbol = (u64)((i64)46);
        } else {
            cc_decls_nextlx.symbol = (u64)((i64)23);
        };
        return;
    }break;
    case 42:;
    {
        if (((u64)((*cc_lex_lxsptr)) == '=')) {
            ++cc_lex_lxsptr;
            cc_decls_nextlx.symbol = (u64)((i64)47);
        } else {
            cc_decls_nextlx.symbol = (u64)((i64)24);
        };
        return;
    }break;
    case 47:;
    {
        if (((i64)((*cc_lex_lxsptr))==(i64)47)) {
            cc_lex_readlinecomment();
            cc_decls_nextlx.symbol = (u64)((i64)56);
            cc_decls_nextlx.length = (i64)0;
            return;
        }else if (((i64)((*cc_lex_lxsptr))==(i64)42)) {
            cc_lex_readblockcomment();
        }else if (((i64)((*cc_lex_lxsptr))==(i64)61)) {
            ++cc_lex_lxsptr;
            cc_decls_nextlx.symbol = (u64)((i64)48);
            return;
        } else {
            cc_decls_nextlx.symbol = (u64)((i64)25);
            return;
        };
    }break;
    case 37:;
    {
        if (((u64)((*cc_lex_lxsptr)) == '=')) {
            ++cc_lex_lxsptr;
            cc_decls_nextlx.symbol = (u64)((i64)49);
        } else {
            cc_decls_nextlx.symbol = (u64)((i64)26);
        };
        return;
    }break;
    case 61:;
    {
        if (((i64)((*cc_lex_lxsptr))==(i64)61)) {
            cc_decls_nextlx.symbol = (u64)((i64)39);
            ++cc_lex_lxsptr;
        } else {
            cc_decls_nextlx.symbol = (u64)((i64)11);
        };
        return;
    }break;
    case 60:;
    {
        switch ((int)((*cc_lex_lxsptr))) {
        case 61:;
        {
            ++cc_lex_lxsptr;
            cc_decls_nextlx.symbol = (u64)((i64)42);
        }break;
        case 60:;
        {
            if (((u64)((*++cc_lex_lxsptr)) == '=')) {
                ++cc_lex_lxsptr;
                cc_decls_nextlx.symbol = (u64)((i64)53);
            } else {
                cc_decls_nextlx.symbol = (u64)((i64)32);
            };
        }break;
        default: {
            cc_decls_nextlx.symbol = (u64)((i64)41);
        }
        } /* SW */
;
        return;
    }break;
    case 62:;
    {
        switch ((int)((*cc_lex_lxsptr))) {
        case 61:;
        {
            ++cc_lex_lxsptr;
            cc_decls_nextlx.symbol = (u64)((i64)43);
        }break;
        case 62:;
        {
            if (((u64)((*++cc_lex_lxsptr)) == '=')) {
                ++cc_lex_lxsptr;
                cc_decls_nextlx.symbol = (u64)((i64)54);
            } else {
                cc_decls_nextlx.symbol = (u64)((i64)33);
            };
        }break;
        default: {
            cc_decls_nextlx.symbol = (u64)((i64)44);
        }
        } /* SW */
;
        return;
    }break;
    case 38:;
    {
        if (((i64)((*cc_lex_lxsptr))==(i64)38)) {
            ++cc_lex_lxsptr;
            cc_decls_nextlx.symbol = (u64)((i64)31);
        }else if (((i64)((*cc_lex_lxsptr))==(i64)61)) {
            ++cc_lex_lxsptr;
            cc_decls_nextlx.symbol = (u64)((i64)51);
        } else {
            cc_decls_nextlx.symbol = (u64)((i64)28);
        };
        return;
    }break;
    case 39:;
    {
        cc_lex_lxreadstring((i64)39,(i64)0);
        return;
    }break;
    case 34:;
    {
        cc_lex_lxreadstring((i64)34,(i64)0);
        return;
    }break;
    case 32:;
    case 9:;
    {
    }break;
    case 10:;
    {
        ++cc_decls_nalllines;
        ++cc_decls_nextlx.lineno;
        cc_decls_nextlx.symbol = (u64)((i64)56);
        cc_decls_nextlx.length = (i64)0;
        if (!!(cc_lex_dowhitespace)) {
            cc_decls_nextlx.svalue = cc_lex_lxsptr;
            L238 :;
            switch ((int)((*cc_lex_lxsptr++))) {
            case 32:;
            case 9:;
            {
            }break;
            default: {
                --cc_lex_lxsptr;
                goto L239 ;
            }
            } /* SW */
goto L238 ;
L239 :;
            ;
            cc_decls_nextlx.length = (cc_lex_lxsptr - cc_decls_nextlx.svalue);
        };
        return;
    }break;
    case 13:;
    {
    }break;
    case 33:;
    {
        if (((i64)((*cc_lex_lxsptr))==(i64)61)) {
            cc_decls_nextlx.symbol = (u64)((i64)40);
            ++cc_lex_lxsptr;
        } else {
            cc_decls_nextlx.symbol = (u64)((i64)35);
        };
        return;
    }break;
    case 64:;
    {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"@ SEEN",NULL);
        msysnewc_m_print_u64(cc_decls_nextlx.lineno,NULL);
        msysnewc_m_print_str(cc_decls_sourcefilenames[((i64)(cc_decls_nextlx.fileno))],NULL);
        msysnewc_m_print_i64(cc_lex_lx_stackindex,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    }break;
    case 0:;
    {
        /*doeof:*/
L240 :;
;
        --cc_lex_lxsptr;
        if (!!(cc_lex_lx_stackindex)) {
            cc_lex_unstacksourcefile();
            cc_decls_nextlx.symbol = (u64)((i64)56);
        } else {
            cc_decls_nextlx.symbol = (u64)((i64)57);
        };
        return;
    }break;
    case 12:;
    {
    }break;
    case 239:;
    {
        cc_lex_lxsptr += (i64)2;
    }break;
    default: {
        if ((((i64)128 <= (i64)((*(cc_lex_lxsptr - (i64)1)))) && ((i64)((*(cc_lex_lxsptr - (i64)1))) <= (i64)255))) {
            goto L232 ;
;
        };
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"ERROR CHAR",NULL);
        msysnewc_m_print_c8((*(cc_lex_lxsptr - (i64)1)),NULL);
        msysnewc_m_print_i64((i64)((*(cc_lex_lxsptr - (i64)1))),NULL);
        msysnewc_m_print_i64(cc_lex_lx_stackindex,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        cc_lex_lxerror((byte*)"ERROR CHAR");
        cc_decls_nextlx.symbol = (u64)((i64)1);
        return;
    }
    } /* SW */
goto L230 ;
L231 :;
    ;
}

static void cc_lex_readrealnumber(byte * pstart,byte * intstart,i64 intlen,i64 base) {
    byte *  fractstart;
    i64 fractlen;
    i64 expon;
    i64 badexpon;
    double basex;
    double x;
    double expbase;
    i64 pref;
    byte realstr[512];
    byte *  rs;
    byte expstr[32];
    if ((base != (i64)10)) {
        cc_lex_old_readrealnumber(pstart,intstart,intlen,base);
        return;
    };
    fractstart = (byte *)(0);
    fractlen = (i64)0;
    expon = (i64)0;
    if (((u64)((*cc_lex_lxsptr)) == '.')) {
        fractstart = ++cc_lex_lxsptr;
        fractlen = (cc_lex_scannumber(base) - fractstart);
    };
    badexpon = (i64)0;
    if (((i64)((*cc_lex_lxsptr))==(i64)101) || ((i64)((*cc_lex_lxsptr))==(i64)69)) {
        if ((base != (i64)16)) {
            ++cc_lex_lxsptr;
            expon = cc_lex_readexponent(&badexpon);
        };
    }else if (((i64)((*cc_lex_lxsptr))==(i64)112) || ((i64)((*cc_lex_lxsptr))==(i64)80)) {
        if ((base == (i64)16)) {
            ++cc_lex_lxsptr;
            expon = cc_lex_readexponent(&badexpon);
        };
    };
    if (!!(badexpon)) {
        --cc_lex_lxsptr;
        cc_lex_readalphanumeric(pstart);
        return;
    };
    if (((i64)((*cc_lex_lxsptr))==(i64)102) || ((i64)((*cc_lex_lxsptr))==(i64)70) || ((i64)((*cc_lex_lxsptr))==(i64)108) || ((i64)((*cc_lex_lxsptr))==(i64)76)) {
        ++cc_lex_lxsptr;
    } else {
        if (!!((u64)(cc_lex_alphamap[((i64)((*cc_lex_lxsptr)))]))) {
            cc_lex_readalphanumeric(pstart);
            return;
        };
    };
    if ((base == (i64)16)) {
        realstr[((i64)1)-1] = '0';
        realstr[((i64)2)-1] = 'x';
        rs = &realstr[((i64)3)-1];
        pref = (i64)2;
    } else {
        rs = &realstr[((i64)1)-1];
        pref = (i64)0;
    };
    if (((intlen + fractlen) > (i64)500)) {
        cc_lex_lxerror((byte*)"Real too long");
    };
    if (!!(intlen)) {
        memcpy((void *)(rs),(void *)(intstart),(u32)(intlen));
    };
    if (!!(fractlen)) {
        memcpy((void *)((rs + intlen)),(void *)(fractstart),(u32)(fractlen));
    };
    expbase = (basex = (double)(base));
    if ((base == (i64)10)) {
        expon -= fractlen;
    } else {
        expon -= (fractlen * (i64)4);
        expbase = (double)2.;
    };
    realstr[((((pref + intlen) + fractlen) + (i64)1))-1] = (u64)0u;
    msysnewc_m_print_startstr(expstr);
    msysnewc_m_print_str(((base == (i64)10)?(byte*)"e":(byte*)"p"),NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_i64(expon,NULL);
    msysnewc_m_print_end();
    ;
    strcat((i8 *)(realstr),(i8 *)(expstr));
    if ((base != (i64)10)) {
        cc_lex_lxerror((byte*)"Non-base-10 floats temporarily unavailable");
    };
    x = strtod((i8 *)(realstr),0);
    cc_decls_nextlx.symbol = (u64)((i64)60);
    cc_decls_nextlx.subcode = (u64)((i64)12);
    cc_decls_nextlx.xvalue = x;
    cc_lex_setnumberoffset((intstart - cc_lex_lxstart));
    cc_decls_nextlx.length = (cc_lex_lxsptr - intstart);
}

static i64 cc_lex_readexponent(i64 * badexpon) {
    byte *  numstart;
    i64 length;
    i64 neg;
    i64 c;
    i64 a;
    i64 av_1;
    neg = (i64)0;
    if (((i64)((*cc_lex_lxsptr))==(i64)43)) {
        ++cc_lex_lxsptr;
    }else if (((i64)((*cc_lex_lxsptr))==(i64)45)) {
        ++cc_lex_lxsptr;
        neg = (i64)1;
    };
    numstart = cc_lex_lxsptr;
    length = (cc_lex_scannumber((i64)10) - numstart);
    if ((length == (i64)0)) {
        (*badexpon) = (i64)1;
        return (i64)0;
    };
    a = (i64)0;
    av_1 = length;
    while (av_1-- > 0) {
L241 :;
        c = (i64)((*numstart++));
        a = (((a * (i64)10) + c) - (i64)48);
L242 :;
    }L243 :;
    ;
    return (!!(neg)?-(a):a);
}

static void cc_lex_lxerror(byte * mess) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"Lex error",NULL);
    msysnewc_m_print_str(mess,NULL);
    msysnewc_m_print_str((byte*)"in:",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str(cc_decls_sourcefilepaths[(cc_lex_getfileno())],NULL);
    msysnewc_m_print_str((byte*)"Line:",NULL);
    msysnewc_m_print_u64(cc_decls_nextlx.lineno,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    osnos_os_getch();
    exit((i64)11);
}

void cc_lex_printsymbol(struct cc_decls_tokenrec * lp) {
    struct cc_decls_tokenrec l;
    l = (*lp);
    printf((i8 *)((byte*)"%-18s"),cc_tables_symbolnames[((i64)(l.symbol))-1]);
    if (((i64)(l.symbol)==(i64)68)) {
        cc_lex_printstrn((*l.symptr).name,(i64)((*l.symptr).namelen),0);
    }else if (((i64)(l.symbol)==(i64)59)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_i64(l.value,NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((byte*)" ",NULL);
        msysnewc_m_print_end();
        ;
        cc_lex_shownumberstr(lp,0);
    }else if (((i64)(l.symbol)==(i64)60)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_r64(l.xvalue,NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((byte*)" ",NULL);
        msysnewc_m_print_end();
        ;
        cc_lex_shownumberstr(lp,0);
    }else if (((i64)(l.symbol)==(i64)63)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"\"",NULL);
        msysnewc_m_print_end();
        ;
        cc_lex_printstrn(l.svalue,(i64)(l.length),0);
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"\"",NULL);
        msysnewc_m_print_end();
        ;
    }else if (((i64)(l.symbol)==(i64)61)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"'",NULL);
        msysnewc_m_print_end();
        ;
        cc_lex_printstrn(l.svalue,(i64)(l.length),0);
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"'",NULL);
        msysnewc_m_print_end();
        ;
    } else {
        if (!!((u64)(l.subcode))) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)"#",NULL);
            msysnewc_m_print_u64(l.subcode,NULL);
            msysnewc_m_print_end();
            ;
        };
    };
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

void cc_lex_lexsetup(void) {
    i64 i;
    cc_lex_inithashtable();
    cc_lex_fillhashtable();
    L244 :;
    for (i=(i64)0;i<=(i64)255;i+=(i64)1) {
L245 :;
        switch ((int)i) {
        case 65:;
        case 66:;
        case 67:;
        case 68:;
        case 69:;
        case 70:;
        case 71:;
        case 72:;
        case 73:;
        case 74:;
        case 75:;
        case 76:;
        case 77:;
        case 78:;
        case 79:;
        case 80:;
        case 81:;
        case 82:;
        case 83:;
        case 84:;
        case 85:;
        case 86:;
        case 87:;
        case 88:;
        case 89:;
        case 90:;
        case 97:;
        case 98:;
        case 99:;
        case 100:;
        case 101:;
        case 102:;
        case 103:;
        case 104:;
        case 105:;
        case 106:;
        case 107:;
        case 108:;
        case 109:;
        case 110:;
        case 111:;
        case 112:;
        case 113:;
        case 114:;
        case 115:;
        case 116:;
        case 117:;
        case 118:;
        case 119:;
        case 120:;
        case 121:;
        case 122:;
        case 36:;
        case 95:;
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
        case 128:;
        case 129:;
        case 130:;
        case 131:;
        case 132:;
        case 133:;
        case 134:;
        case 135:;
        case 136:;
        case 137:;
        case 138:;
        case 139:;
        case 140:;
        case 141:;
        case 142:;
        case 143:;
        case 144:;
        case 145:;
        case 146:;
        case 147:;
        case 148:;
        case 149:;
        case 150:;
        case 151:;
        case 152:;
        case 153:;
        case 154:;
        case 155:;
        case 156:;
        case 157:;
        case 158:;
        case 159:;
        case 160:;
        case 161:;
        case 162:;
        case 163:;
        case 164:;
        case 165:;
        case 166:;
        case 167:;
        case 168:;
        case 169:;
        case 170:;
        case 171:;
        case 172:;
        case 173:;
        case 174:;
        case 175:;
        case 176:;
        case 177:;
        case 178:;
        case 179:;
        case 180:;
        case 181:;
        case 182:;
        case 183:;
        case 184:;
        case 185:;
        case 186:;
        case 187:;
        case 188:;
        case 189:;
        case 190:;
        case 191:;
        case 192:;
        case 193:;
        case 194:;
        case 195:;
        case 196:;
        case 197:;
        case 198:;
        case 199:;
        case 200:;
        case 201:;
        case 202:;
        case 203:;
        case 204:;
        case 205:;
        case 206:;
        case 207:;
        case 208:;
        case 209:;
        case 210:;
        case 211:;
        case 212:;
        case 213:;
        case 214:;
        case 215:;
        case 216:;
        case 217:;
        case 218:;
        case 219:;
        case 220:;
        case 221:;
        case 222:;
        case 223:;
        case 224:;
        case 225:;
        case 226:;
        case 227:;
        case 228:;
        case 229:;
        case 230:;
        case 231:;
        case 232:;
        case 233:;
        case 234:;
        case 235:;
        case 236:;
        case 237:;
        case 238:;
        case 239:;
        case 240:;
        case 241:;
        case 242:;
        case 243:;
        case 244:;
        case 245:;
        case 246:;
        case 247:;
        case 248:;
        case 249:;
        case 250:;
        case 251:;
        case 252:;
        case 253:;
        case 254:;
        case 255:;
        {
            cc_lex_alphamap[(i)] = (u64)1u;
        }break;
        default: {
        }
        } /* SW */
;
        switch ((int)i) {
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
        {
            cc_lex_digitmap[(i)] = (u64)1u;
        }break;
        default: {
        }
        } /* SW */
;
        cc_lex_commentmap[(i)] = (u64)1u;
        cc_lex_linecommentmap[(i)] = (u64)1u;
        cc_lex_spacemap[(i)] = (u64)0u;
L246 :;
    }L247 :;
    ;
    cc_lex_commentmap[((i64)42)] = (u64)0u;
    cc_lex_commentmap[((i64)0)] = (u64)0u;
    cc_lex_commentmap[((i64)10)] = (u64)0u;
    cc_lex_linecommentmap[((i64)0)] = (u64)0u;
    cc_lex_linecommentmap[((i64)92)] = (u64)0u;
    cc_lex_linecommentmap[((i64)10)] = (u64)0u;
    cc_lex_spacemap[((i64)32)] = (u64)1u;
    cc_lex_spacemap[((i64)9)] = (u64)1u;
    cc_lex_normaltkx.symbol = (u64)((i64)56);
    cc_lex_npastedtokens = (i64)0;
}

void cc_lex_printstrn(byte * s,i64 length,void * f) {
    if (!!(length)) {
        if ((f == 0)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_i64(length,(byte*)"v");
            msysnewc_m_print_nogap();
            msysnewc_m_print_str(s,(byte*)".*");
            msysnewc_m_print_end();
            ;
        } else {
            msysnewc_m_print_startfile(f);
            msysnewc_m_print_i64(length,(byte*)"v");
            msysnewc_m_print_nogap();
            msysnewc_m_print_str(s,(byte*)".*");
            msysnewc_m_print_end();
            ;
        };
    };
}

static byte * cc_lex_scannumber(i64 base) {
    byte *  dest;
    i64 c;
    dest = cc_lex_lxsptr;
    L248 :;
    switch ((int)(c = (i64)((*cc_lex_lxsptr++)))) {
    case 48:;
    case 49:;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
    {
        (*dest++) = (u64)(c);
        if ((c >= ((i64)48 + base))) {
            cc_lex_lxerror((byte*)"Digit out of range");
        };
    }break;
    case 65:;
    case 66:;
    case 67:;
    case 68:;
    case 69:;
    case 70:;
    case 97:;
    case 98:;
    case 99:;
    case 100:;
    case 101:;
    case 102:;
    {
        if ((base == (i64)16)) {
            (*dest++) = (u64)(c);
        } else {
            --cc_lex_lxsptr;
            goto L249 ;
        };
    }break;
    case 95:;
    case 39:;
    case 96:;
    {
    }break;
    default: {
        --cc_lex_lxsptr;
        goto L249 ;
    }
    } /* SW */
goto L248 ;
L249 :;
    ;
    return dest;
}

static i64 cc_lex_lookup(void) {
    i64 j;
    i64 wrapped;
    i64 length;
    /*retry:*/
L250 :;
;
    j = (cc_lex_lxhashvalue & cc_decls_hstmask);
    wrapped = (i64)0;
    L251 :;
    while (1) {
        cc_decls_nextlx.symptr = (*cc_decls_hashtable)[(j)];
        length = (i64)((*cc_decls_nextlx.symptr).namelen);
        if (!(!!(length))) {
            goto L252 ;
        };
        if ((length == (i64)(cc_decls_nextlx.length))) {
            if (((i64)(memcmp((void *)((*cc_decls_nextlx.symptr).name),(void *)(cc_lex_lxsvalue),(u32)(length))) == (i64)0)) {
                return (i64)1;
            };
        };
        if ((++j >= cc_decls_hstsize)) {
            if (!!(wrapped)) {
                mlib_abortprogram((byte*)"HASHTABLE FULL");
            };
            wrapped = (i64)1;
            j = (i64)0;
        };
    }L252 :;
    ;
    if ((cc_lex_nhstsymbols >= cc_lex_hstthreshold)) {
        cc_lex_newhashtable();
        cc_lex_lxhashvalue = (i64)(cc_lex_gethashvalue(cc_lex_lxsvalue,(i64)(cc_decls_nextlx.length)));
        goto L250 ;
;
    };
    (*cc_decls_nextlx.symptr).name = cc_lex_lxsvalue;
    (*cc_decls_nextlx.symptr).namelen = (u64)(cc_decls_nextlx.length);
    (*cc_decls_nextlx.symptr).symbol = (u64)((i64)68);
    ++cc_lex_nhstsymbols;
    return (i64)0;
}

u64 cc_lex_gethashvalue(byte * s,i64 length) {
    u64 hsum;
    i64 av_1;
    if ((length == (i64)-1)) {
        length = (i64)(strlen((i8 *)(s)));
    };
    hsum = (u64)((i64)0);
    av_1 = length;
    while (av_1-- > 0) {
L253 :;
        hsum = (((hsum << (i64)4) - hsum) + (u64)((*s++)));
L254 :;
    }L255 :;
    ;
    return ((hsum << (i64)5) - hsum);
}

static void cc_lex_inithashtable(void) {
    i64 i;
    cc_decls_hashtable = (struct cc_decls_strec * (*)[])(mlib_pcm_alloc((cc_decls_hstsize * (i64)4)));
    cc_decls_hstmask = (cc_decls_hstsize - (i64)1);
    L256 :;
    for (i=(i64)0;i<=cc_decls_hstmask;i+=(i64)1) {
L257 :;
        (*cc_decls_hashtable)[(i)] = (struct cc_decls_strec *)(mlib_pcm_allocz((i64)84));
L258 :;
    }L259 :;
    ;
    cc_lex_nhstsymbols = (i64)0;
    cc_lex_hstthreshold = (((i64)6 * cc_decls_hstsize) / (i64)10);
}

static void cc_lex_fillhashtable(void) {
    i64 i;
    i64 av_1;
    L260 :;
    for (i=(i64)1;i<=(i64)77;i+=(i64)1) {
L261 :;
        cc_lex_lxsvalue = cc_tables_stnames[(i)-1];
        if (((i64)(cc_tables_stsymbols[(i)-1]) == (i64)69)) {
            cc_lex_lxsvalue = mlib_pcm_copyheapstring(cc_lex_lxsvalue);
        };
        cc_decls_nextlx.length = (i64)(strlen((i8 *)(cc_lex_lxsvalue)));
        cc_lex_lxhashvalue = (i64)(cc_lex_gethashvalue(cc_lex_lxsvalue,(i64)(cc_decls_nextlx.length)));
        if (!!(cc_lex_lookup())) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(cc_tables_stnames[(i)-1],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            mlib_abortprogram((byte*)"Duplicate symbol table entry");
        };
        (*cc_decls_nextlx.symptr).symbol = (u64)(cc_tables_stsymbols[(i)-1]);
        (*cc_decls_nextlx.symptr).subcode = (i64)(cc_tables_stsubcodes[(i)-1]);
L262 :;
    }L263 :;
    ;
}

static i64 cc_lex_dolexdirective(void) {
    struct cc_decls_strec *  d;
    byte *  p;
    byte *  pstart;
    byte *  s;
    i64 cond;
    i64 c;
    i64 syshdr;
    i64 dir;
    i64 length;
    i64 allowmacros;
    byte filename[300];
    pstart = cc_lex_lxsptr;
    dir = cc_lex_getlexdirective();
    if ((dir == (i64)0)) {
        cc_lex_printstrn(pstart,(cc_lex_lxsptr - pstart),0);
        msysnewc_m_print_startcon();
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        cc_lex_lxerror((byte*)"Invalid # directive");
    };
    if ((dir==(i64)7)) {
        cc_lex_isincludefile = (i64)1;
        L264 :;
        while ((((u64)((*cc_lex_lxsptr)) == ' ') || ((i64)((*cc_lex_lxsptr)) == (i64)9))) {
            ++cc_lex_lxsptr;
L265 :;
        }L266 :;
        ;
        allowmacros = ((u64)((*cc_lex_lxsptr)) != '<');
        cc_lex_lexm();
        cc_lex_isincludefile = (i64)0;
        if (((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)41)) {
            syshdr = (i64)1;
            p = filename;
            if (!!(allowmacros)) {
                L267 :;
                while (1) {
                    cc_lex_lexm();
                    if (((i64)(cc_decls_nextlx.symbol)==(i64)57) || ((i64)(cc_decls_nextlx.symbol)==(i64)56)) {
                        cc_lex_lxerror((byte*)"Bad include file");
                    }else if (((i64)(cc_decls_nextlx.symbol)==(i64)44)) {
                        goto L268 ;
                    } else {
                        s = cc_lex_strtoken(&cc_decls_nextlx,&length);
                        memcpy((void *)(p),(void *)(s),(u32)(length));
                        p += length;
                    };
                }L268 :;
                ;
            } else {
                L269 :;
                while (1) {
                    c = (i64)((*cc_lex_lxsptr++));
                    if ((c==(i64)62)) {
                        goto L270 ;
                    }else if ((c==(i64)10) || (c==(i64)0)) {
                        cc_lex_lxerror((byte*)"include: > expected");
                    } else {
                        (*p++) = (u64)(c);
                    };
                }L270 :;
                ;
            };
            (*p) = (u64)0u;
        } else if (((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)63)) {
            syshdr = (i64)0;
            strcpy((i8 *)(filename),(i8 *)(cc_decls_nextlx.svalue));
        } else {
            cc_lex_lxerror((byte*)"include?");
        };
        cc_lex_lexm();
        if (!!(cc_decls_fshowincludes)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)"INCLUDE",NULL);
            msysnewc_m_print_str(filename,NULL);
            msysnewc_m_print_str((byte*)"FROM",NULL);
            msysnewc_m_print_str(cc_decls_sourcefilepaths[(cc_lex_getfileno())],NULL);
            msysnewc_m_print_u64(cc_decls_nextlx.lineno,NULL);
            msysnewc_m_print_str((byte*)"NSOURCEFILES=",NULL);
            msysnewc_m_print_i64(cc_decls_nsourcefiles,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        };
        ++cc_lex_nincludes;
        cc_lex_stacksourcefile(filename,syshdr);
        if (!(!!(syshdr))) {
            cc_lex_addautomodule(filename,cc_lex_getfileno());
        };
    }else if ((dir==(i64)1)) {
        cc_lex_dodefine();
    }else if ((dir==(i64)10)) {
        cc_lex_lexreadtoken();
        if (((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)68)) {
            cc_lex_lxerror((byte*)"undef: name expected");
        };
        d = cc_decls_nextlx.symptr;
        if (((i64)((u64)((*d).nameid)) != (i64)1)) {
        } else {
            (*d).nameid = (u64)((i64)0);
            (*d).symbol = (u64)((*cc_decls_nextlx.symptr).oldsymbol);
            (*d).mparamlist = (struct cc_decls_mparamrec *)(0);
            (*d).attribs.ax_flmacro = (u64)((i64)0);
        };
    }else if ((dir==(i64)8)) {
        cond = cc_lex_getifdef();
        goto L271 ;
;
    }else if ((dir==(i64)9)) {
        cond = !(cc_lex_getifdef());
        goto L271 ;
;
    }else if ((dir==(i64)3)) {
        cond = cc_lex_getifexpr();
        /*doif:*/
L271 :;
;
        ++cc_lex_ifcondlevel;
        if (!!(cond)) {
            return (i64)0;
        } else {
            /*doskipcode:*/
L272 :;
;
            dir = cc_lex_skipcode();
            if ((dir==(i64)4)) {
                cond = cc_lex_getifexpr();
                if (!!(cond)) {
                    return (i64)0;
                };
                goto L272 ;
;
            }else if ((dir==(i64)5)) {
            }else if ((dir==(i64)6)) {
                --cc_lex_ifcondlevel;
            };
        };
    }else if ((dir==(i64)4) || (dir==(i64)5)) {
        if (!(!!(cc_lex_ifcondlevel))) {
            cc_lex_lxerror((byte*)"#if missing/elif/else");
        };
        L273 :;
        do {
            dir = cc_lex_skipcode();
L274 :;
        } while (!(dir == (i64)6));L275 :;
        ;
        --cc_lex_ifcondlevel;
    }else if ((dir==(i64)6)) {
        if (!(!!(cc_lex_ifcondlevel))) {
            cc_lex_lxerror((byte*)"#if missing/endif");
        };
        --cc_lex_ifcondlevel;
    }else if ((dir==(i64)18)) {
    }else if ((dir==(i64)19)) {
        L276 :;
        do {
            cc_lex_lexreadtoken();
L277 :;
        } while (!((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)56));L278 :;
        ;
    }else if ((dir==(i64)11)) {
        cc_lex_lexm();
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"#ERROR:",NULL);
        msysnewc_m_print_end();
        ;
        cc_lex_showtoken(&cc_decls_nextlx);
        msysnewc_m_print_startcon();
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        cc_lex_lxerror((byte*)"ABORTING");
        goto L279 ;
;
    }else if ((dir==(i64)13)) {
        cc_lex_lexm();
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"#MESSAGE",NULL);
        msysnewc_m_print_end();
        ;
        if (((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)56)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)" Line",NULL);
            msysnewc_m_print_i64(((i64)((u64)(cc_decls_nextlx.lineno)) + (i64)1),NULL);
            msysnewc_m_print_str(cc_decls_sourcefilenames[(cc_lex_getfileno())],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        } else {
            cc_lex_showtoken(&cc_decls_nextlx);
            msysnewc_m_print_startcon();
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        };
        goto L279 ;
;
    }else if ((dir==(i64)12) || (dir==(i64)14)) {
        cc_lex_lexm();
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"#WARNING:",NULL);
        msysnewc_m_print_end();
        ;
        cc_lex_showtoken(&cc_decls_nextlx);
        msysnewc_m_print_startcon();
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        /*dowarning2:*/
L279 :;
;
        L280 :;
        while ((((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)56) && ((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)57))) {
            cc_lex_lexm();
L281 :;
        }L282 :;
        ;
        if ((dir == (i64)14)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)"Press key...",NULL);
            msysnewc_m_print_end();
            ;
            osnos_os_getch();
            msysnewc_m_print_startcon();
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        };
    }else if ((dir==(i64)20)) {
        cc_lex_dopragmadir();
    }else if ((dir==(i64)15)) {
        cc_decls_debug = (i64)1;
    }else if ((dir==(i64)16)) {
        cc_decls_debug = (i64)0;
    }else if ((dir==(i64)17)) {
        cc_lex_lexreadtoken();
        if (((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)68)) {
            d = cc_decls_nextlx.symptr;
            msysnewc_m_print_startcon();
            msysnewc_m_print_u64(cc_decls_nextlx.lineno,NULL);
            msysnewc_m_print_str(cc_decls_sourcefilenames[(cc_lex_getfileno())],NULL);
            msysnewc_m_print_str((byte*)":",NULL);
            msysnewc_m_print_end();
            ;
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)"SHOW MACRO",NULL);
            msysnewc_m_print_str(cc_lib_getstname(d),NULL);
            msysnewc_m_print_str((byte*)":",NULL);
            msysnewc_m_print_end();
            ;
            if (((i64)((u64)((*d).nameid)) == (i64)1)) {
                cc_lex_showtokens((byte*)"tokens:",(*d).tokenlist);
                msysnewc_m_print_startcon();
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
            } else {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((byte*)"not a macro",NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
            };
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)"Not a name",NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        };
    } else {
        /*skip:*/
L283 :;
;
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"DIRECTIVE NOT IMPL:",NULL);
        msysnewc_m_print_str(cc_tables_sourcedirnames[(dir)-1],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        cc_lex_lxsptr = pstart;
        cc_decls_nextlx.symbol = (u64)((i64)4);
        return (i64)1;
        cc_lex_lxerror((byte*)"Directive not implemented");
    };
    return (i64)0;
}

static i64 cc_lex_getlexdirective(void) {
    struct cc_decls_strec *  d;
    cc_lex_lexreadtoken();
    if (((i64)(cc_decls_nextlx.symbol)==(i64)68)) {
    }else if (((i64)(cc_decls_nextlx.symbol)==(i64)56)) {
        return (i64)18;
    }else if (((i64)(cc_decls_nextlx.symbol)==(i64)59)) {
        L284 :;
        do {
            cc_lex_lexreadtoken();
L285 :;
        } while (!(((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)56) || ((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)57)));L286 :;
        ;
        return (i64)18;
    } else {
        return (i64)0;
    };
    if (((i64)((*cc_decls_nextlx.symptr).symbol)==(i64)69)) {
        return (i64)((*cc_decls_nextlx.symptr).subcode);
    }else if (((i64)((*cc_decls_nextlx.symptr).symbol)==(i64)72)) {
        return (i64)3;
    }else if (((i64)((*cc_decls_nextlx.symptr).symbol)==(i64)73)) {
        return (i64)5;
    }else if (((i64)((*cc_decls_nextlx.symptr).symbol)==(i64)56)) {
        return (i64)18;
    };
    d = cc_decls_nextlx.symptr;
    if (((i64)((u64)((*d).nameid)) == (i64)1)) {
        if (((i64)((u64)((*d).oldsymbol)) == (i64)69)) {
            return (i64)((*d).subcode);
        };
    };
    return (i64)0;
}

void cc_lex_startlex(byte * caption,i64 fileno) {
    cc_lex_ifcondlevel = (i64)0;
    cc_lex_lx_stackindex = (i64)0;
    cc_lex_noexpand = (i64)0;
    cc_lex_normaltk = &cc_lex_normaltkx;
    cc_lex_lx_stackindex = (i64)0;
    cc_lex_ifcondlevel = (i64)0;
    cc_lex_firstsymbol = (i64)1;
    cc_lex_npastedtokens = (i64)0;
    cc_lex_isincludefile = (i64)0;
    cc_lex_tkptr = (struct cc_decls_tokenrec *)(0);
    cc_lex_lxstart = (cc_lex_lxsptr = cc_decls_sourcefiletext[(fileno)]);
    cc_lex_setfileno(fileno);
    cc_decls_nextlx.lineno = (u64)((i64)1);
    cc_decls_nextlx.numberoffset = (i64)0;
    cc_decls_nextlx.symbol = (u64)((i64)56);
    cc_decls_nextlx.subcode = (u64)((i64)0);
    cc_lex_lex();
}

void cc_lex_endlex(void) {
    if (!!(cc_lex_ifcondlevel)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_i64(cc_lex_ifcondlevel,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        cc_lex_lxerror((byte*)"#endif missing");
    };
}

void cc_lex_ps(byte * caption) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(caption,NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str((byte*)":::",NULL);
    msysnewc_m_print_end();
    ;
    cc_lex_printsymbol(&cc_decls_lx);
}

void cc_lex_psnext(byte * caption) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(caption,NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str((byte*)":##",NULL);
    msysnewc_m_print_end();
    ;
    cc_lex_printsymbol(&cc_decls_nextlx);
}

i64 cc_lex_gethashtablesize(void) {
    i64 i;
    i64 n;
    n = (i64)0;
    L287 :;
    for (i=(i64)0;i<=cc_decls_hstmask;i+=(i64)1) {
L288 :;
        if (!!((*(*cc_decls_hashtable)[(i)]).name)) {
            ++n;
        };
L289 :;
    }L290 :;
    ;
    return n;
}

static void cc_lex_readlinecomment(void) {
    L291 :;
    while (1) {
        L293 :;
        while (!!((u64)(cc_lex_linecommentmap[((i64)((*++cc_lex_lxsptr)))]))) {
L294 :;
        }L295 :;
        ;
        if (((i64)((*cc_lex_lxsptr))==(i64)10)) {
            ++cc_lex_lxsptr;
            goto L292 ;
        }else if (((i64)((*cc_lex_lxsptr))==(i64)0)) {
            goto L292 ;
        }else if (((i64)((*cc_lex_lxsptr))==(i64)92)) {
            ++cc_lex_lxsptr;
            if (((i64)((*cc_lex_lxsptr))==(i64)13)) {
                ++cc_decls_nalllines;
                cc_lex_lxsptr += (i64)2;
                ++cc_decls_nextlx.lineno;
            }else if (((i64)((*cc_lex_lxsptr))==(i64)10)) {
                ++cc_lex_lxsptr;
                ++cc_decls_nalllines;
                ++cc_decls_nextlx.lineno;
            };
        };
    }L292 :;
    ;
    ++cc_decls_nalllines;
    ++cc_decls_nextlx.lineno;
}

static void cc_lex_readblockcomment(void) {
    L296 :;
    while (1) {
        L298 :;
        while (!!((u64)(cc_lex_commentmap[((i64)((*++cc_lex_lxsptr)))]))) {
L299 :;
        }L300 :;
        ;
        if (((i64)((*cc_lex_lxsptr))==(i64)10)) {
            ++cc_decls_nalllines;
            ++cc_decls_nextlx.lineno;
        }else if (((i64)((*cc_lex_lxsptr))==(i64)0)) {
            cc_lex_lxerror((byte*)"block comment eof");
        }else if (((i64)((*cc_lex_lxsptr))==(i64)42)) {
            if (((u64)((*(cc_lex_lxsptr + (i64)1))) == '/')) {
                cc_lex_lxsptr += (i64)2;
                goto L297 ;
            };
        };
    }L297 :;
    ;
}

static void cc_lex_readhex(byte * pstart) {
    u64 aa;
    i64 c;
    i64 length;
    i64 leading;
    i64 ll;
    i64 usigned;
    byte *  p;
    aa = (u64)((i64)0);
    p = cc_lex_lxsptr;
    leading = (i64)1;
    ll = (usigned = (i64)0);
    length = (i64)0;
    L301 :;
    switch ((int)(c = (i64)((*cc_lex_lxsptr++)))) {
    case 49:;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
    {
        leading = (i64)0;
        aa = (u64)((((i64)(aa) * (i64)16) + (c - (i64)48)));
        ++length;
    }break;
    case 48:;
    {
        if (!!(leading)) {
            ++p;
        } else {
            ++length;
            aa = (u64)(((i64)(aa) * (i64)16));
        };
    }break;
    case 65:;
    case 66:;
    case 67:;
    case 68:;
    case 69:;
    case 70:;
    {
        leading = (i64)0;
        ++length;
        aa = (u64)(((i64)((aa * (u64)((i64)16))) + ((c - (i64)65) + (i64)10)));
    }break;
    case 97:;
    case 98:;
    case 99:;
    case 100:;
    case 101:;
    case 102:;
    {
        leading = (i64)0;
        ++length;
        aa = (u64)(((i64)((aa * (u64)((i64)16))) + ((c - (i64)97) + (i64)10)));
    }break;
    case 46:;
    case 80:;
    case 112:;
    {
        --cc_lex_lxsptr;
        cc_lex_readrealnumber(pstart,p,(cc_lex_lxsptr - p),(i64)16);
        return;
    }break;
    case 76:;
    case 108:;
    {
        ++ll;
        if ((ll > (i64)2)) {
            cc_lex_lxerror((byte*)"-LL?");
        };
    }break;
    case 85:;
    case 117:;
    {
        if (!!(usigned)) {
            cc_lex_lxerror((byte*)"-U?");
        };
        usigned = (i64)1;
    }break;
    default: {
        --cc_lex_lxsptr;
        goto L302 ;
    }
    } /* SW */
goto L301 ;
L302 :;
    ;
    cc_lex_setnumberoffset((pstart - cc_lex_lxstart));
    cc_decls_nextlx.length = (cc_lex_lxsptr - pstart);
    if ((length > (i64)16)) {
        cc_lex_lxerror((byte*)"Overflow in hex number");
    };
    cc_decls_nextlx.symbol = (u64)((i64)59);
    if ((aa > (u64)9223372036854775807u)) {
        cc_decls_nextlx.subcode = (u64)((i64)10);
    } else if (((i64)(aa) > (i64)4294967295LL)) {
        cc_decls_nextlx.subcode = (u64)((i64)5);
    } else if (((i64)(aa) > (i64)2147483647)) {
        cc_decls_nextlx.subcode = (u64)((i64)9);
    } else {
        cc_decls_nextlx.subcode = (u64)((i64)4);
    };
    cc_decls_nextlx.value = (i64)(aa);
    cc_lex_checknumbersuffix();
}

static void cc_lex_readbinary(byte * pstart) {
    u64 aa;
    i64 c;
    i64 length;
    i64 leading;
    byte *  p;
    i64 av_1;
    aa = (u64)((i64)0);
    p = cc_lex_lxsptr;
    leading = (i64)1;
    L303 :;
    switch ((int)(c = (i64)((*cc_lex_lxsptr++)))) {
    case 49:;
    {
        leading = (i64)0;
    }break;
    case 48:;
    {
        if (!!(leading)) {
            ++p;
        };
    }break;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
    {
        cc_lex_lxerror((byte*)"Binary bad digit");
    }break;
    case 46:;
    {
        cc_lex_lxerror((byte*)"Binary fp");
    }break;
    default: {
        --cc_lex_lxsptr;
        goto L304 ;
    }
    } /* SW */
goto L303 ;
L304 :;
    ;
    length = (cc_lex_lxsptr - p);
    cc_lex_setnumberoffset((pstart - cc_lex_lxstart));
    cc_decls_nextlx.length = (cc_lex_lxsptr - pstart);
    if ((length > (i64)64)) {
        cc_lex_lxerror((byte*)"Overflow in binary number");
    };
    av_1 = length;
    while (av_1-- > 0) {
L305 :;
        aa = (u64)(((((i64)(aa) * (i64)2) + (i64)((*p++))) - (i64)48));
L306 :;
    }L307 :;
    ;
    cc_decls_nextlx.symbol = (u64)((i64)59);
    cc_decls_nextlx.subcode = (u64)((i64)4);
    if (((i64)(aa) >= (i64)2147483647)) {
        cc_decls_nextlx.subcode = (u64)((i64)5);
    };
    cc_decls_nextlx.value = (i64)(aa);
    cc_lex_checknumbersuffix();
}

static void cc_lex_readoctal(byte * pstart) {
    u64 aa;
    i64 c;
    i64 length;
    i64 res;
    i64 leading;
    i64 ll;
    i64 usigned;
    byte *  p;
    i64 av_1;
    aa = (u64)((i64)0);
    p = cc_lex_lxsptr;
    leading = (i64)1;
    ll = (usigned = (i64)0);
    length = (i64)0;
    L308 :;
    switch ((int)(c = (i64)((*cc_lex_lxsptr++)))) {
    case 49:;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    {
        leading = (i64)0;
        ++length;
    }break;
    case 48:;
    {
        if (!!(leading)) {
            ++p;
        } else {
            ++length;
        };
    }break;
    case 46:;
    {
        --cc_lex_lxsptr;
        cc_lex_readrealnumber(pstart,p,(cc_lex_lxsptr - p),(i64)10);
        return;
    }break;
    case 76:;
    case 108:;
    {
        ++ll;
        if ((ll > (i64)2)) {
            cc_lex_lxerror((byte*)"-LL?");
        };
    }break;
    case 85:;
    case 117:;
    {
        if (!!(usigned)) {
            cc_lex_lxerror((byte*)"-U?");
        };
        usigned = (i64)1;
    }break;
    default: {
        if (!!((u64)(cc_lex_alphamap[(c)]))) {
            /*doalpha:*/
L310 :;
;
            cc_lex_readalphanumeric(pstart);
            return;
        };
        --cc_lex_lxsptr;
        goto L309 ;
    }
    } /* SW */
goto L308 ;
L309 :;
    ;
    cc_lex_setnumberoffset((pstart - cc_lex_lxstart));
    cc_decls_nextlx.length = (cc_lex_lxsptr - pstart);
    if (((length > (i64)22) || ((length == (i64)22) && ((res = mlib_cmpstringn(p,(byte*)"1777777777777777777777",(i64)22)) > (i64)0)))) {
        cc_lex_lxerror((byte*)"Overflow in octal number");
    };
    av_1 = length;
    while (av_1-- > 0) {
L311 :;
        aa = (u64)(((((i64)(aa) * (i64)8) + (i64)((*p++))) - (i64)48));
L312 :;
    }L313 :;
    ;
    cc_decls_nextlx.symbol = (u64)((i64)59);
    cc_decls_nextlx.subcode = (u64)((i64)4);
    if (((i64)(aa) >= (i64)2147483647)) {
        cc_decls_nextlx.subcode = (u64)((i64)5);
    };
    cc_decls_nextlx.value = (i64)(aa);
    cc_lex_checknumbersuffix();
}

static void cc_lex_readdecimal(byte * pstart) {
    u64 aa;
    i64 c;
    i64 length;
    i64 res;
    byte ll;
    byte usigned;
    byte *  p;
    i64 av_1;
    aa = (u64)((i64)0);
    ll = (u64)((usigned = (u64)((i64)0)));
    p = --cc_lex_lxsptr;
    L314 :;
    while (!!((u64)(cc_lex_digitmap[((i64)((*++cc_lex_lxsptr)))]))) {
L315 :;
    }L316 :;
    ;
    L317 :;
    while (((u64)((*p)) == '0')) {
        ++p;
L318 :;
    }L319 :;
    ;
    length = (cc_lex_lxsptr - p);
    L320 :;
    switch ((int)(c = (i64)((*cc_lex_lxsptr++)))) {
    case 46:;
    case 69:;
    case 101:;
    {
        --cc_lex_lxsptr;
        cc_lex_readrealnumber(pstart,p,(cc_lex_lxsptr - p),(i64)10);
        return;
    }break;
    case 76:;
    case 108:;
    {
        ++ll;
        if (((i64)((u64)(ll)) > (i64)2)) {
            cc_lex_lxerror((byte*)"-LL?");
        };
    }break;
    case 85:;
    case 117:;
    {
        if (!!((u64)(usigned))) {
            cc_lex_lxerror((byte*)"-U?");
        };
        usigned = (u64)((i64)1);
    }break;
    default: {
        if (!!((u64)(cc_lex_alphamap[(c)]))) {
            cc_lex_readalphanumeric(pstart);
            return;
        };
        --cc_lex_lxsptr;
        goto L321 ;
    }
    } /* SW */
goto L320 ;
L321 :;
    ;
    cc_lex_setnumberoffset((pstart - cc_lex_lxstart));
    cc_decls_nextlx.length = (cc_lex_lxsptr - pstart);
    if (((length > (i64)20) || ((length == (i64)20) && ((res = mlib_cmpstringn(p,(byte*)"18446744073709551615",(i64)20)) > (i64)0)))) {
        cc_lex_lxerror((byte*)"Overflow in decimal number");
    };
    av_1 = length;
    while (av_1-- > 0) {
L322 :;
        aa = ((aa * (u64)((i64)10)) + ((u64)((*p++)) - '0'));
L323 :;
    }L324 :;
    ;
    cc_decls_nextlx.symbol = (u64)((i64)59);
    cc_decls_nextlx.subcode = (u64)((i64)4);
    if (((i64)(ll)==(i64)0) || ((i64)(ll)==(i64)1)) {
        if (!!((u64)(usigned))) {
            if (((i64)(aa) >= (i64)4294967295LL)) {
                cc_decls_nextlx.subcode = (u64)((i64)10);
            } else {
                cc_decls_nextlx.subcode = (u64)((i64)9);
            };
        } else {
            if (((i64)(aa) >= (i64)2147483647)) {
                cc_decls_nextlx.subcode = (u64)((i64)5);
            };
        };
    } else {
        if (!!((u64)(usigned))) {
            cc_decls_nextlx.subcode = (u64)((i64)10);
        } else {
            cc_decls_nextlx.subcode = (u64)((i64)5);
        };
    };
    cc_decls_nextlx.value = (i64)(aa);
}

static i64 cc_lex_checknumbersuffix(void) {
    byte c;
    L325 :;
    switch ((int)((c = (u64)((*cc_lex_lxsptr++))))) {
    case 76:;
    case 108:;
    case 117:;
    case 85:;
    {
    }break;
    default: {
        if (!!((u64)(cc_lex_alphamap[((i64)(c))]))) {
        };
        --cc_lex_lxsptr;
        goto L326 ;
    }
    } /* SW */
goto L325 ;
L326 :;
    ;
    return (i64)4;
}

static void cc_lex_stacksourcefile(byte * file,i64 syshdr) {
    i64 fileno;
    struct cc_lex_stackinforec info;
    byte fullpath[500];
    fileno = cc_lex_getsourcefile(file,syshdr);
    if ((fileno == (i64)0)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(file,NULL);
        msysnewc_m_print_u64(strlen((i8 *)(file)),NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        cc_lex_lxerror((byte*)"Can't find include file");
    };
    if ((cc_lex_lx_stackindex >= (i64)20)) {
        cc_lex_lxerror((byte*)"Too many nested includes");
    };
    ++cc_lex_lx_stackindex;
    fullpath[((i64)1)-1] = (u64)0u;
    if ((cc_lex_lx_stackindex > (i64)1)) {
        strcpy((i8 *)(fullpath),(i8 *)(cc_lex_headerpathlist[((cc_lex_lx_stackindex - (i64)1))-1]));
    };
    if (!!((u64)(cc_lex_headerpath[((i64)1)-1]))) {
        strcat((i8 *)(fullpath),(i8 *)(mlib_pcm_copyheapstring(cc_lex_headerpath)));
    };
    cc_lex_headerpathlist[(cc_lex_lx_stackindex)-1] = mlib_pcm_copyheapstring(fullpath);
    info.startptr = cc_lex_lxstart;
    info.sptr = cc_lex_lxsptr;
    info.lineno = (i64)(cc_decls_nextlx.lineno);
    info.fileno = cc_lex_getfileno();
    cc_lex_lx_stack[(cc_lex_lx_stackindex)-1] = info;
    cc_lex_lxstart = (cc_lex_lxsptr = cc_decls_sourcefiletext[(fileno)]);
    cc_lex_setfileno(fileno);
    cc_decls_nextlx.lineno = (u64)((i64)1);
}

static void cc_lex_unstacksourcefile(void) {
    byte *  path;
    struct cc_lex_stackinforec info;
    path = cc_lex_headerpathlist[(cc_lex_lx_stackindex)-1];
    mlib_pcm_free((void *)(path),(i64)(strlen((i8 *)(path))));
    info = cc_lex_lx_stack[(cc_lex_lx_stackindex--)-1];
    cc_lex_lxstart = info.startptr;
    cc_lex_lxsptr = info.sptr;
    cc_decls_nextlx.lineno = (u64)(info.lineno);
    cc_lex_setfileno((i64)(info.fileno));
}

static i64 cc_lex_getsourcefile(byte * file,i64 syshdr) {
    static byte filespec[300];
    byte *  hdrtext;
    i64 i;
    cc_lex_headerpath[((i64)1)-1] = (u64)0u;
    strcpy((i8 *)(filespec),(i8 *)(file));
    mlib_convlcstring(filespec);
    L327 :;
    for (i=(i64)1;i<=cc_decls_nsourcefiles;i+=(i64)1) {
L328 :;
        if (!!(mlib_eqstring(filespec,cc_decls_sourcefilenames[(i)]))) {
            return i;
        };
L329 :;
    }L330 :;
    ;
    if (!!(cc_decls_dointheaders)) {
        hdrtext = cc_headers_findheader(filespec);
        if (!!(hdrtext)) {
            return cc_support_loadbuiltin(filespec,hdrtext);
        };
    };
    strcpy((i8 *)(cc_lex_headerpath),(i8 *)(mlib_extractpath(file)));
    if ((((u64)(cc_lex_headerpath[((i64)1)-1]) == '/') || (((u64)(cc_lex_headerpath[((i64)2)-1]) == ':') && ((u64)(cc_lex_headerpath[((i64)3)-1]) == '/')))) {
        if (!!(mlib_checkfile(file))) {
            return cc_support_loadsourcefile(file,file);
        };
        return (i64)0;
    };
    L331 :;
    for (i=cc_lex_lx_stackindex;i>=(i64)1;i-=(i64)1) {
L332 :;
        strcpy((i8 *)(filespec),(i8 *)(cc_lex_headerpathlist[(i)-1]));
        strcat((i8 *)(filespec),(i8 *)(file));
        if (!!(mlib_checkfile(filespec))) {
            return cc_support_loadsourcefile(filespec,file);
        };
L333 :;
    }L334 :;
    ;
    L335 :;
    for (i=(i64)1;i<=cc_decls_nsearchdirs;i+=(i64)1) {
L336 :;
        strcpy((i8 *)(filespec),(i8 *)(cc_decls_searchdirs[(i)-1]));
        strcat((i8 *)(filespec),(i8 *)(file));
        if (!!(mlib_checkfile(filespec))) {
            strcpy((i8 *)(cc_lex_headerpath),(i8 *)(mlib_extractpath(filespec)));
            return cc_support_loadsourcefile(filespec,file);
        };
L337 :;
    }L338 :;
    ;
    return (i64)0;
}

void cc_lex_lex(void) {
    /*reenter:*/
L339 :;
;
    cc_decls_lx = cc_decls_nextlx;
    cc_lex_lexm();
    if ((((i64)((u64)(cc_decls_lx.symbol)) == (i64)68) && (cc_lex_lx_stackindex == (i64)0))) {
        (*((*cc_decls_lx.symptr).name + (i64)(cc_decls_lx.length))) = (u64)0u;
    };
    L340 :;
    if (((i64)(cc_decls_nextlx.symbol)==(i64)68)) {
        cc_decls_nextlx.symbol = (u64)((*cc_decls_nextlx.symptr).symbol);
        if (((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)69)) {
            cc_decls_nextlx.symbol = (u64)((i64)68);
        };
        cc_decls_nextlx.subcode = (u64)((*cc_decls_nextlx.symptr).subcode);
        return;
    }else if (((i64)(cc_decls_nextlx.symbol)==(i64)56)) {
        cc_lex_lexm();
    } else {
        return;
    }goto L340 ;
L341 :;
    ;
}

static void cc_lex_shownumberstr(struct cc_decls_tokenrec * l,void * f) {
    byte *  s;
    if (!!(cc_lex_getfilenox(l))) {
        s = (cc_decls_sourcefiletext[(cc_lex_getfilenox(l))] + cc_lex_getnumberoffsetx(l));
    } else {
        s = cc_lex_pastedtokenlist[((i64)((*l).pasteno))-1];
    };
    cc_lex_printstrn(s,(i64)((*l).length),f);
}

struct cc_decls_strec * cc_lex_addnamestr(byte * name) {
    struct cc_decls_tokenrec oldlx;
    struct cc_decls_strec *  symptr;
    oldlx = cc_decls_nextlx;
    cc_decls_nextlx.length = (i64)(strlen((i8 *)(name)));
    cc_lex_lxhashvalue = (i64)(cc_lex_gethashvalue(name,(i64)(cc_decls_nextlx.length)));
    cc_lex_lxsvalue = (byte *)(mlib_pcm_alloc(((i64)(cc_decls_nextlx.length) + (i64)1)));
    memcpy((void *)(cc_lex_lxsvalue),(void *)(name),(u32)(((i64)(cc_decls_nextlx.length) + (i64)1)));
    cc_lex_lookup();
    symptr = cc_decls_nextlx.symptr;
    cc_decls_nextlx = oldlx;
    return symptr;
}

static void cc_lex_lxreadstring(i64 termchar,i64 fwide) {
    byte str[2048];
    byte *  dest;
    byte *  ws;
    u16 *  wd;
    u16 *  wd0;
    i64 c;
    i64 d;
    i64 length;
    i64 av_1;
    i64 av_2;
    if ((termchar == (i64)34)) {
        cc_decls_nextlx.symbol = (!!(fwide)?(u64)((i64)64):(u64)((i64)63));
    } else {
        cc_decls_nextlx.symbol = (u64)((i64)61);
    };
    cc_decls_nextlx.svalue = cc_lex_lxsptr;
    if (((cc_lex_lx_stackindex == (i64)0) || !!(fwide))) {
        dest = cc_lex_lxsptr;
        ws = dest;
    } else {
        dest = str;
    };
    length = (i64)0;
    L342 :;
    while (1) {
        switch ((int)(c = (i64)((*cc_lex_lxsptr++)))) {
        case 92:;
        {
            if (!!(cc_lex_isincludefile)) {
                c = (i64)47;
                goto L344 ;
;
            };
            c = (i64)((*cc_lex_lxsptr++));
            /*reenter:*/
L345 :;
;
            switch ((int)c) {
            case 97:;
            {
                c = (i64)7;
            }break;
            case 98:;
            {
                c = (i64)8;
            }break;
            case 102:;
            {
                c = (i64)12;
            }break;
            case 110:;
            {
                c = (i64)10;
            }break;
            case 114:;
            {
                c = (i64)13;
            }break;
            case 116:;
            {
                c = (i64)9;
            }break;
            case 118:;
            {
                c = (i64)11;
            }break;
            case 120:;
            {
                c = (i64)0;
                L346 :;
                while (1) {
                    switch ((int)(d = (i64)((*cc_lex_lxsptr++)))) {
                    case 65:;
                    case 66:;
                    case 67:;
                    case 68:;
                    case 69:;
                    case 70:;
                    {
                        c = ((((c * (i64)16) + d) - (i64)65) + (i64)10);
                    }break;
                    case 97:;
                    case 98:;
                    case 99:;
                    case 100:;
                    case 101:;
                    case 102:;
                    {
                        c = ((((c * (i64)16) + d) - (i64)97) + (i64)10);
                    }break;
                    case 48:;
                    case 49:;
                    case 50:;
                    case 51:;
                    case 52:;
                    case 53:;
                    case 54:;
                    case 55:;
                    case 56:;
                    case 57:;
                    {
                        c = (((c * (i64)16) + d) - (i64)48);
                    }break;
                    default: {
                        --cc_lex_lxsptr;
                        goto L347 ;
                    }
                    } /* SW */
;
                }L347 :;
                ;
            }break;
            case 48:;
            case 49:;
            case 50:;
            case 51:;
            case 52:;
            case 53:;
            case 54:;
            case 55:;
            {
                c -= (i64)48;
                av_1 = (i64)2;
                while (av_1-- > 0) {
L348 :;
                    switch ((int)(d = (i64)((*cc_lex_lxsptr++)))) {
                    case 48:;
                    case 49:;
                    case 50:;
                    case 51:;
                    case 52:;
                    case 53:;
                    case 54:;
                    case 55:;
                    {
                        c = (((c * (i64)8) + d) - (i64)48);
                    }break;
                    default: {
                        --cc_lex_lxsptr;
                        goto L350 ;
                    }
                    } /* SW */
;
L349 :;
                }L350 :;
                ;
            }break;
            case 34:;
            {
                c = (i64)34;
            }break;
            case 92:;
            {
                c = (i64)92;
            }break;
            case 39:;
            {
                c = (i64)39;
            }break;
            case 13:;
            {
                ++cc_decls_nalllines;
                ++cc_decls_nextlx.lineno;
                if (((i64)((*cc_lex_lxsptr)) == (i64)10)) {
                    ++cc_lex_lxsptr;
                };
                goto L342 ;
            }break;
            case 10:;
            {
                goto L342 ;
            }break;
            default: {
            }
            } /* SW */
;
        }break;
        case 34:;
        case 39:;
        {
            if ((c == termchar)) {
                goto L343 ;
            };
        }break;
        case 10:;
        case 0:;
        {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)"NEXTLX.LINENO=",NULL);
            msysnewc_m_print_u64(cc_decls_nextlx.lineno,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            cc_lex_lxerror((byte*)"String not terminated");
        }break;
        default: {
        }
        } /* SW */
;
        /*normalchar:*/
L344 :;
;
        if ((cc_lex_lx_stackindex == (i64)0)) {
            (*dest++) = (u64)(c);
        } else if ((++length < (i64)2048)) {
            (*dest++) = (u64)(c);
        } else {
            cc_lex_lxerror((byte*)"Local str too long");
        };
    }L343 :;
    ;
    (*dest) = (u64)0u;
    if (!!(fwide)) {
        length = (i64)((cc_decls_nextlx.length = (dest - cc_decls_nextlx.svalue)));
        wd0 = (wd = (u16 *)(mlib_pcm_alloc(((length * (i64)2) + (i64)2))));
        av_2 = length;
        while (av_2-- > 0) {
L351 :;
            (*wd++) = (u64)((*ws++));
L352 :;
        }L353 :;
        ;
        (*wd) = (u64)((i64)0);
        cc_decls_nextlx.svalue = (byte *)(wd0);
    } else {
        if ((cc_lex_lx_stackindex == (i64)0)) {
            cc_decls_nextlx.length = (dest - cc_decls_nextlx.svalue);
        } else {
            cc_decls_nextlx.length = length;
            cc_decls_nextlx.svalue = (byte *)(mlib_pcm_alloc((length + (i64)1)));
            memcpy((void *)(cc_decls_nextlx.svalue),(void *)(str),(u32)((length + (i64)1)));
        };
    };
}

static void cc_lex_addlisttoken(struct cc_decls_tokenrec * * ulist,struct cc_decls_tokenrec * * ulistx,struct cc_decls_tokenrec * p) {
    if (((*ulist) == 0)) {
        (*ulist) = ((*ulistx) = p);
    } else {
        (*(*ulistx)).nexttoken = p;
    };
    (*p).nexttoken = (struct cc_decls_tokenrec *)(0);
    (*ulistx) = p;
}

static void cc_lex_addlisttoken_copy(struct cc_decls_tokenrec * * ulist,struct cc_decls_tokenrec * * ulistx,struct cc_decls_tokenrec * q) {
    struct cc_decls_tokenrec *  p;
    p = cc_lex_alloctoken();
    (*p) = (*q);
    (*p).nexttoken = (struct cc_decls_tokenrec *)(0);
    if (((*ulist) == 0)) {
        (*ulist) = ((*ulistx) = p);
    } else {
        (*(*ulistx)).nexttoken = p;
    };
    (*p).nexttoken = (struct cc_decls_tokenrec *)(0);
    (*ulistx) = p;
}

static void cc_lex_addlist_nextlx(struct cc_decls_tokenrec * * ulist,struct cc_decls_tokenrec * * ulistx) {
    struct cc_decls_tokenrec *  p;
    p = cc_lex_alloctoken();
    (*p) = cc_decls_nextlx;
    (*p).nexttoken = (struct cc_decls_tokenrec *)(0);
    if (((*ulist) == 0)) {
        (*ulist) = ((*ulistx) = p);
    } else {
        (*(*ulistx)).nexttoken = p;
    };
    (*p).nexttoken = (struct cc_decls_tokenrec *)(0);
    (*ulistx) = p;
}

static void cc_lex_addlisttoken_seq(struct cc_decls_tokenrec * * ulist,struct cc_decls_tokenrec * * ulistx,struct cc_decls_tokenrec * seq) {
    struct cc_decls_tokenrec *  tk;
    L354 :;
    while (!!(seq)) {
        tk = cc_lex_alloctoken();
        (*tk) = (*seq);
        if (((*ulist) == 0)) {
            (*ulist) = ((*ulistx) = tk);
        } else {
            (*(*ulistx)).nexttoken = tk;
        };
        (*tk).nexttoken = (struct cc_decls_tokenrec *)(0);
        (*ulistx) = tk;
        seq = (*seq).nexttoken;
L355 :;
    }L356 :;
    ;
}

static void cc_lex_addlistmparam(struct cc_decls_mparamrec * * ulist,struct cc_decls_mparamrec * * ulistx,struct cc_decls_mparamrec * p) {
    if (((*ulist) == 0)) {
        (*ulist) = ((*ulistx) = p);
    } else {
        (*(*ulistx)).nextmparam = p;
    };
    (*ulistx) = p;
}

static void cc_lex_dodefine(void) {
    struct cc_decls_mparamrec *  stlist;
    struct cc_decls_mparamrec *  stlistx;
    struct cc_decls_mparamrec *  p;
    struct cc_decls_mparamrec *  q;
    struct cc_decls_strec *  stname;
    struct cc_decls_strec *  d;
    struct cc_decls_tokenrec *  tklist;
    struct cc_decls_tokenrec *  tklistx;
    struct cc_decls_tokenrec *  tk;
    i64 nparams;
    i64 ntokens;
    i64 paramno;
    cc_lex_lexreadtoken();
    if (((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)68)) {
        cc_lex_lxerror((byte*)"define: name expected");
    };
    stname = cc_decls_nextlx.symptr;
    (*stname).lineno = (u64)(((i64)((u64)(cc_decls_nextlx.lineno)) + (cc_lex_getfileno() << (i64)24)));
    (*stname).oldsymbol = (u64)((*stname).symbol);
    (*stname).symbol = (u64)((i64)68);
    (*stname).nameid = (u64)((i64)1);
    nparams = (i64)0;
    if (((u64)((*cc_lex_lxsptr)) == '(')) {
        ++cc_lex_lxsptr;
        stlist = (stlistx = (struct cc_decls_mparamrec *)(0));
        (*stname).attribs.ax_flmacro = (u64)((i64)1);
        cc_lex_lexreadtoken();
        L357 :;
        while (1) {
            if (((i64)(cc_decls_nextlx.symbol)==(i64)68)) {
                d = cc_decls_nextlx.symptr;
                p = stlist;
                L359 :;
                while (!!(p)) {
                    if (((*p).def == d)) {
                        cc_lex_lxerror((byte*)"Dupl macro param");
                    };
                    p = (*p).nextmparam;
L360 :;
                }L361 :;
                ;
                q = (struct cc_decls_mparamrec *)(mlib_pcm_alloc((i64)8));
                (*q).def = d;
                (*q).nextmparam = (struct cc_decls_mparamrec *)(0);
                cc_lex_addlistmparam(&stlist,&stlistx,q);
                ++nparams;
                cc_lex_lexreadtoken();
                if (((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)8)) {
                    cc_lex_lexreadtoken();
                };
            }else if (((i64)(cc_decls_nextlx.symbol)==(i64)13)) {
                goto L358 ;
            }else if (((i64)(cc_decls_nextlx.symbol)==(i64)20)) {
                d = cc_lex_addnamestr((byte*)"__VA_ARGS__");
                (*stname).attribs.ax_varparams = (u64)((i64)1);
                cc_lex_lexreadtoken();
                if (((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)13)) {
                    cc_lex_lxerror((byte*)"')' expected");
                };
                q = (struct cc_decls_mparamrec *)(mlib_pcm_alloc((i64)8));
                (*q).def = d;
                (*q).nextmparam = (struct cc_decls_mparamrec *)(0);
                cc_lex_addlistmparam(&stlist,&stlistx,q);
                ++nparams;
                goto L358 ;
            } else {
                cc_lex_lxerror((byte*)"macro params?");
            };
        }L358 :;
        ;
        (*stname).mparamlist = stlist;
    };
    tklist = (tklistx = (struct cc_decls_tokenrec *)(0));
    ntokens = (i64)0;
    L362 :;
    while (1) {
        cc_lex_lexreadtoken();
        if (((i64)(cc_decls_nextlx.symbol)==(i64)56) || ((i64)(cc_decls_nextlx.symbol)==(i64)57)) {
            goto L363 ;
        }else if (((i64)(cc_decls_nextlx.symbol)==(i64)68)) {
            p = (*stname).mparamlist;
            paramno = (i64)1;
            L364 :;
            while (!!(p)) {
                if (((*p).def == cc_decls_nextlx.symptr)) {
                    cc_decls_nextlx.flags |= (u8)2u;
                    cc_decls_nextlx.paramno = paramno;
                    goto L366 ;
                };
                p = (*p).nextmparam;
                ++paramno;
L365 :;
            }L366 :;
            ;
            if ((cc_decls_nextlx.symptr == stname)) {
                cc_decls_nextlx.flags |= (u8)1u;
            };
        };
        ++ntokens;
        tk = cc_lex_alloctoken();
        (*tk) = cc_decls_nextlx;
        cc_lex_addlisttoken(&tklist,&tklistx,tk);
    }L363 :;
    ;
    (*stname).tokenlist = tklist;
    (*stname).attribs.ax_nparams = (u64)(nparams);
}

static void cc_lex_readalphanumeric(byte * pstart) {
    L367 :;
    while (!!((u64)(cc_lex_alphamap[((i64)((*cc_lex_lxsptr++)))]))) {
L368 :;
    }L369 :;
    ;
    --cc_lex_lxsptr;
    cc_decls_nextlx.svalue = pstart;
    cc_decls_nextlx.symbol = (u64)((i64)58);
    cc_decls_nextlx.length = (cc_lex_lxsptr - pstart);
}

static i64 cc_lex_inmacrostack(struct cc_decls_strec * d,struct cc_decls_tokenrec * macrostack) {
    L370 :;
    while (!!(macrostack)) {
        if (((*macrostack).symptr == d)) {
            return (i64)1;
        };
        macrostack = (*macrostack).nexttoken;
L371 :;
    }L372 :;
    ;
    return (i64)0;
}

static void cc_lex_showtokens(byte * caption,struct cc_decls_tokenrec * tk) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(caption,NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str((byte*)"<",NULL);
    msysnewc_m_print_end();
    ;
    L373 :;
    while (!!(tk)) {
        cc_lex_showtoken(tk);
        tk = (*tk).nexttoken;
L374 :;
    }L375 :;
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)">",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

static void cc_lex_lexa(struct cc_decls_tokenrec * * tk) {
    if (((*tk) == cc_lex_normaltk)) {
        cc_lex_lexreadtoken();
        return;
    };
    if (((*tk) == 0)) {
        cc_decls_nextlx.symbol = (u64)((i64)57);
        return;
    };
    cc_decls_nextlx = (*(*tk));
    (*tk) = (*(*tk)).nexttoken;
}

static void cc_lex_lexm(void) {
    struct cc_decls_strec *  d;
    static i64 doreset = (i64)0;
    i64 newlineno;
    L376 :;
    while (1) {
        if (!!(cc_lex_tkptr)) {
            cc_decls_nextlx = (*cc_lex_tkptr);
            cc_lex_tkptr = (*cc_lex_tkptr).nexttoken;
            if ((cc_lex_tkptr == 0)) {
                if (((((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)68) && ((i64)((u64)((*cc_decls_nextlx.symptr).nameid)) == (i64)1)) && !!(cc_lex_peeklb()))) {
                    cc_lex_setfileno(cc_decls_sfileno);
                    cc_decls_nextlx.lineno = (u64)(cc_decls_slineno);
                    doreset = (i64)0;
                    goto L378 ;
;
                };
                doreset = (i64)1;
            };
            return;
        };
        if (!!(doreset)) {
            cc_lex_setfileno(cc_decls_sfileno);
            cc_decls_nextlx.lineno = (u64)(cc_decls_slineno);
            doreset = (i64)0;
        };
        if (!!(cc_lex_firstsymbol)) {
            cc_lex_firstsymbol = (i64)0;
            cc_lex_dospecialinclude();
        };
        cc_lex_lexreadtoken();
        /*test1:*/
L378 :;
;
        if (((i64)(cc_decls_nextlx.symbol)==(i64)4)) {
            if (!!(cc_lex_dolexdirective())) {
                return;
            };
            goto L376 ;
        }else if (((i64)(cc_decls_nextlx.symbol)==(i64)68)) {
            d = cc_decls_nextlx.symptr;
            if (((i64)((*d).symbol)==(i64)70)) {
                cc_decls_sfileno = cc_lex_getfileno();
                cc_decls_slineno = (i64)(cc_decls_nextlx.lineno);
                cc_lex_expandpredefmacro((i64)((*d).subcode),&cc_decls_nextlx,cc_decls_slineno);
                doreset = (i64)1;
                return;
            } else {
                if ((((i64)((u64)((*d).nameid)) != (i64)1) || !!(cc_lex_noexpand))) {
                    return;
                };
            };
        } else {
            return;
        };
        cc_decls_sfileno = cc_lex_getfileno();
        cc_decls_slineno = (i64)(cc_decls_nextlx.lineno);
        if (!!((u64)((*d).attribs.ax_flmacro))) {
            if (!(!!(cc_lex_peeklb()))) {
                return;
            };
            cc_lex_tkptr = cc_lex_expandfnmacro(d,(struct cc_decls_tokenrec *)(0),&cc_lex_normaltk,(i64)1,&newlineno);
            cc_decls_slineno = newlineno;
        } else {
            cc_lex_tkptr = cc_lex_expandobjmacro(d,(struct cc_decls_tokenrec *)(0),&cc_lex_normaltk,(i64)1);
        };
        if ((cc_lex_tkptr == 0)) {
            doreset = (i64)1;
        };
    }L377 :;
    ;
}

static i64 cc_lex_peeklb(void) {
    if ((((u64)((*cc_lex_lxsptr)) == '(') || (((u64)((*cc_lex_lxsptr)) == ' ') && ((u64)((*(cc_lex_lxsptr + (i64)1))) == '(')))) {
        return (i64)1;
    };
    return (i64)0;
}

static i64 cc_lex_peektk(struct cc_decls_tokenrec * tk) {
    tk = (*tk).nexttoken;
    if ((tk == 0)) {
        return (i64)0;
    };
    if (((i64)((u64)((*tk).symbol)) == (i64)12)) {
        return (i64)1;
    };
    return (i64)0;
}

static struct cc_decls_tokenrec * cc_lex_expandobjmacro(struct cc_decls_strec * m,struct cc_decls_tokenrec * macrostack,struct cc_decls_tokenrec * * tksource,i64 frombaselevel) {
    struct cc_decls_tokenrec *  tk;
    struct cc_decls_tokenrec *  p;
    struct cc_decls_tokenrec *  repl;
    struct cc_decls_tokenrec newmacro;
    i64 iscomplex;
    i64 useshh;
    i64 expanded;
    struct cc_decls_strec *  d;
    p = (tk = (*m).tokenlist);
    iscomplex = (useshh = (i64)0);
    L379 :;
    while (!!(p)) {
        if (((i64)((u64)((*p).symbol)) == (i64)68)) {
            d = (*p).symptr;
            if ((((i64)((u64)((*d).nameid)) == (i64)1) || ((i64)((u64)((*d).symbol)) == (i64)70))) {
                iscomplex = (i64)1;
                goto L381 ;
            };
        } else if (((i64)((u64)((*p).symbol)) == (i64)7)) {
            iscomplex = (useshh = (i64)1);
            goto L381 ;
        };
        p = (*p).nexttoken;
L380 :;
    }L381 :;
    ;
    if (!(!!(iscomplex))) {
        return tk;
    };
    newmacro.symptr = m;
    newmacro.nexttoken = macrostack;
    if (!!(useshh)) {
        repl = cc_lex_substituteargs(m,(struct cc_decls_tokenrec * (*)[])(0),(struct cc_decls_tokenrec * (*)[])(0),(i64)0,(struct cc_decls_tokenrec *)(0));
    } else {
        repl = (*m).tokenlist;
    };
    tk = cc_lex_scantokenseq(repl,&newmacro,&expanded);
    return tk;
}

static struct cc_decls_tokenrec * cc_lex_expandfnmacro(struct cc_decls_strec * m,struct cc_decls_tokenrec * macrostack,struct cc_decls_tokenrec * * tksource,i64 frombaselevel,i64 * endlineno) {
    struct cc_decls_tokenrec *  args[200];
    struct cc_decls_tokenrec *  expargs[200];
    struct cc_decls_tokenrec *  repl;
    struct cc_decls_tokenrec newmacro;
    i64 nargs;
    i64 i;
    i64 expanded;
    nargs = cc_lex_readmacrocall(m,&args,tksource);
    if (!!(frombaselevel)) {
        (*endlineno) = (i64)(cc_decls_nextlx.lineno);
    };
    L382 :;
    for (i=(i64)1;i<=nargs;i+=(i64)1) {
L383 :;
        expargs[(i)-1] = (struct cc_decls_tokenrec *)(0);
L384 :;
    }L385 :;
    ;
    repl = cc_lex_substituteargs(m,&args,&expargs,nargs,macrostack);
    newmacro.symptr = m;
    newmacro.nexttoken = macrostack;
    repl = cc_lex_scantokenseq(repl,&newmacro,&expanded);
    return repl;
}

static struct cc_decls_tokenrec * cc_lex_scantokenseq(struct cc_decls_tokenrec * tk,struct cc_decls_tokenrec * macrostack,i64 * expanded) {
    struct cc_decls_tokenrec *  newtk;
    struct cc_decls_tokenrec *  newtkx;
    struct cc_decls_tokenrec *  expandtk;
    struct cc_decls_tokenrec *  oldtk;
    struct cc_decls_strec *  m;
    i64 noexpandflag;
    i64 simple;
    i64 dummy;
    /*reenter:*/
L386 :;
;
    (*expanded) = (i64)0;
    newtk = (newtkx = (struct cc_decls_tokenrec *)(0));
    noexpandflag = (i64)0;
    simple = (i64)1;
    oldtk = tk;
    L387 :;
    while (!!(tk)) {
        if (((i64)((*tk).symbol)==(i64)68)) {
            if ((((i64)((u64)((*(*tk).symptr).nameid)) == (i64)1) || ((i64)((u64)((*(*tk).symptr).symbol)) == (i64)70))) {
                simple = (i64)0;
                goto L389 ;
            };
        };
        if ((tk == 0)) {
            goto L389 ;
        };
        tk = (*tk).nexttoken;
L388 :;
    }L389 :;
    ;
    if (!!(simple)) {
        return oldtk;
    };
    tk = oldtk;
    L390 :;
    while (!!(tk)) {
        if (((i64)((*tk).symbol)==(i64)68)) {
            m = (*tk).symptr;
            if ((((i64)((u64)((*m).nameid)) == (i64)1) && !(!!(noexpandflag)))) {
                if ((!!(((i64)((u64)((*tk).flags)) & (i64)4)) || !!(cc_lex_noexpand))) {
                    goto L393 ;
;
                };
                if (!!(cc_lex_inmacrostack(m,macrostack))) {
                    cc_lex_addlisttoken_copy(&newtk,&newtkx,tk);
                    (*newtkx).flags |= (u8)4u;
                    goto L394 ;
;
                };
                simple = (i64)0;
                if (!!((u64)((*m).attribs.ax_flmacro))) {
                    if (!(!!(cc_lex_peektk(tk)))) {
                        goto L393 ;
;
                    };
                    cc_lex_lexa(&tk);
                    expandtk = cc_lex_expandfnmacro(m,macrostack,&tk,(i64)1,&dummy);
                    cc_lex_addlisttoken_seq(&newtk,&newtkx,expandtk);
                    (*expanded) = (i64)1;
                    goto L391 ;
                } else {
                    expandtk = cc_lex_expandobjmacro(m,macrostack,&tk,(i64)0);
                    (*expanded) = (i64)1;
                    cc_lex_addlisttoken_seq(&newtk,&newtkx,expandtk);
                };
            } else if (((i64)((u64)((*m).symbol)) == (i64)93)) {
                noexpandflag = (i64)1;
                goto L393 ;
;
            } else if (((i64)((u64)((*m).symbol)) == (i64)70)) {
                expandtk = cc_lex_alloctokenz();
                cc_lex_expandpredefmacro((i64)((*m).subcode),expandtk,cc_decls_slineno);
                cc_lex_addlisttoken_copy(&newtk,&newtkx,expandtk);
                goto L395 ;
;
            } else {
                noexpandflag = (i64)0;
                goto L393 ;
;
            };
        } else {
            /*simpletoken:*/
L393 :;
;
            cc_lex_addlisttoken_copy(&newtk,&newtkx,tk);
        };
        /*skip:*/
L394 :;
;
        if ((tk == 0)) {
            goto L392 ;
        };
        /*skip2:*/
L395 :;
;
        tk = (*tk).nexttoken;
L391 :;
    }L392 :;
    ;
    if (!!((*expanded))) {
        tk = newtk;
        goto L386 ;
;
    };
    return newtk;
}

static i64 cc_lex_readmacrocall(struct cc_decls_strec * d,struct cc_decls_tokenrec * (*args)[],struct cc_decls_tokenrec * * tksource) {
    i64 nparams;
    i64 lbcount;
    i64 paramno;
    i64 nargs;
    i64 usesvargs;
    i64 varg;
    struct cc_decls_tokenrec *  tklist;
    struct cc_decls_tokenrec *  tklistx;
    cc_lex_lexa(tksource);
    if (((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)12)) {
        cc_lex_lxerror((byte*)"rmc: no '('");
    };
    nparams = (i64)((*d).attribs.ax_nparams);
    nargs = (i64)0;
    if ((nparams == (i64)0)) {
        cc_lex_lexa(tksource);
        if (((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)13)) {
            cc_lex_lxerror((byte*)"rmc: ')' expected");
        };
        return (i64)0;
    };
    paramno = (i64)1;
    lbcount = (i64)1;
    tklist = (tklistx = (struct cc_decls_tokenrec *)(0));
    usesvargs = (i64)((*d).attribs.ax_varparams);
    varg = (i64)0;
    L396 :;
    while (1) {
        if (((paramno == nparams) && !!(usesvargs))) {
            varg = (i64)1;
        };
        cc_lex_lexa(tksource);
        if (((i64)(cc_decls_nextlx.symbol)==(i64)8)) {
            if (((lbcount == (i64)1) && !(!!(varg)))) {
                if ((tklist == 0)) {
                    tklist = cc_lex_alloctokenz();
                    cc_lex_setfilenox(tklist,cc_lex_getfileno());
                    (*tklist).symbol = (u64)((i64)66);
                };
                (*args)[(paramno)-1] = tklist;
                tklist = (tklistx = (struct cc_decls_tokenrec *)(0));
                ++paramno;
            } else {
                goto L398 ;
;
            };
        }else if (((i64)(cc_decls_nextlx.symbol)==(i64)57)) {
            cc_lex_lxerror((byte*)"EOS in macro call");
        }else if (((i64)(cc_decls_nextlx.symbol)==(i64)12)) {
            ++lbcount;
            goto L398 ;
;
        }else if (((i64)(cc_decls_nextlx.symbol)==(i64)13)) {
            if ((lbcount > (i64)1)) {
                --lbcount;
                cc_lex_addlist_nextlx(&tklist,&tklistx);
            } else {
                if ((tklist == 0)) {
                    tklist = cc_lex_alloctokenz();
                    cc_lex_setfilenox(tklist,cc_lex_getfileno());
                    (*tklist).symbol = (u64)((i64)66);
                };
                (*args)[(paramno)-1] = tklist;
                goto L397 ;
            };
        } else {
            /*addtoken:*/
L398 :;
;
            cc_lex_addlist_nextlx(&tklist,&tklistx);
        };
    }L397 :;
    ;
    if ((paramno != nparams)) {
        if ((((paramno + (i64)1) == nparams) && !!(usesvargs))) {
            (*args)[(nparams)-1] = (struct cc_decls_tokenrec *)(0);
        } else {
            cc_lex_lxerror((byte*)"Wrong # macro params");
        };
    };
    return nparams;
}

static struct cc_decls_tokenrec * cc_lex_substituteargs(struct cc_decls_strec * m,struct cc_decls_tokenrec * (*args)[],struct cc_decls_tokenrec * (*expargs)[],i64 nargs,struct cc_decls_tokenrec * macrostack) {
    struct cc_decls_mparamrec *  params;
    struct cc_decls_tokenrec *  seq;
    struct cc_decls_tokenrec *  seqstart;
    struct cc_decls_tokenrec *  lasttoken;
    struct cc_decls_tokenrec *  newtk;
    struct cc_decls_tokenrec *  newtkx;
    struct cc_decls_tokenrec *  niltk;
    struct cc_decls_tokenrec *  tkexp;
    struct cc_decls_tokenrec tk;
    i64 n;
    i64 i;
    i64 expanded;
    struct cc_decls_tokenrec *  hhpoints[100];
    i64 nhashhash;
    params = (*m).mparamlist;
    seq = (seqstart = (*m).tokenlist);
    newtk = (newtkx = (struct cc_decls_tokenrec *)(0));
    nhashhash = (i64)0;
    lasttoken = (struct cc_decls_tokenrec *)(0);
    L399 :;
    while (!!(seq)) {
        if (((i64)((*seq).symbol)==(i64)5)) {
            if (!!(nargs)) {
                seq = (*seq).nexttoken;
                if ((seq == 0)) {
                    cc_lex_lxerror((byte*)"# at end");
                };
                if (!(!!(((i64)((u64)((*seq).flags)) & (i64)2)))) {
                    cc_lex_lxerror((byte*)"# not followed by param");
                };
                n = (i64)((*seq).paramno);
                cc_lex_stringify((*args)[(n)-1],&tk);
                cc_lex_addlisttoken_copy(&newtk,&newtkx,&tk);
            } else {
                cc_lex_addlisttoken(&newtk,&newtkx,seq);
                (*newtkx).symbol = (u64)((i64)6);
            };
        }else if (((i64)((*seq).symbol)==(i64)7)) {
            if ((seq == seqstart)) {
                cc_lex_lxerror((byte*)"## at start");
            };
            if ((nhashhash >= (i64)100)) {
                cc_lex_lxerror((byte*)"Too many ##");
            };
            hhpoints[(++nhashhash)-1] = newtkx;
        } else {
            if (((((i64)((u64)((*seq).symbol)) == (i64)68) && !!(((i64)((u64)((*seq).flags)) & (i64)2))) && !!(nargs))) {
                n = (i64)((*seq).paramno);
                if (((!!((*seq).nexttoken) && ((i64)((u64)((*(*seq).nexttoken).symbol)) == (i64)7)) || (!!(lasttoken) && ((i64)((u64)((*lasttoken).symbol)) == (i64)7)))) {
                    cc_lex_addlisttoken_seq(&newtk,&newtkx,(*args)[(n)-1]);
                } else {
                    tkexp = (*expargs)[(n)-1];
                    if ((tkexp == 0)) {
                        tkexp = ((*expargs)[(n)-1] = cc_lex_scantokenseq((*args)[(n)-1],macrostack,&expanded));
                    };
                    cc_lex_addlisttoken_seq(&newtk,&newtkx,tkexp);
                };
            } else {
                /*doother:*/
L402 :;
;
                cc_lex_addlisttoken_copy(&newtk,&newtkx,seq);
            };
        };
        lasttoken = seq;
        seq = (*seq).nexttoken;
L400 :;
    }L401 :;
    ;
    if (!!(nhashhash)) {
        niltk = (struct cc_decls_tokenrec *)(0);
        L403 :;
        for (i=(i64)1;i<=nhashhash;i+=(i64)1) {
L404 :;
            cc_lex_pastetokens(hhpoints[(i)-1],((i < nhashhash)?&hhpoints[((i + (i64)1))-1]:&niltk));
L405 :;
        }L406 :;
        ;
    };
    return newtk;
}

static byte * cc_lex_strtoken(struct cc_decls_tokenrec * lp,i64 * length) {
    byte *  name;
    byte *  s;
    struct cc_decls_tokenrec l;
    l = (*lp);
    if (((i64)(l.symbol)==(i64)68)) {
        /*doname:*/
L407 :;
;
        (*length) = (i64)((*l.symptr).namelen);
        return (*l.symptr).name;
    }else if (((i64)(l.symbol)==(i64)59) || ((i64)(l.symbol)==(i64)60)) {
        (*length) = (i64)(l.length);
        if (!!(cc_lex_getfilenox(&l))) {
            return (cc_decls_sourcefiletext[(cc_lex_getfilenox(&l))] + cc_lex_getnumberoffsetx(&l));
        } else {
            return cc_lex_pastedtokenlist[((i64)(l.pasteno))-1];
        };
    }else if (((i64)(l.symbol)==(i64)58)) {
        (*length) = (i64)(l.length);
        return l.svalue;
    }else if (((i64)(l.symbol)==(i64)63) || ((i64)(l.symbol)==(i64)64)) {
        s = cc_lex_strstring(l.svalue,(i64)(l.length),length,(i64)34);
        return s;
    }else if (((i64)(l.symbol)==(i64)61)) {
        s = cc_lex_strstring(l.svalue,(i64)(l.length),length,(i64)39);
        return s;
    }else if (((i64)(l.symbol)==(i64)56)) {
        if (!!(cc_lex_dowhitespace)) {
            (*length) = ((i64)(l.length) + (i64)1);
            s = (byte *)(mlib_pcm_alloc((*length)));
            (*s) = (u64)10u;
            memcpy((void *)((s + (i64)1)),(void *)(l.svalue),(u32)(l.length));
        } else {
            (*length) = (i64)1;
            return (byte*)"\n";
        };
        return s;
    }else if (((i64)(l.symbol)==(i64)57)) {
        (*length) = (i64)0;
        return (byte*)"";
    }else if (((i64)(l.symbol)==(i64)71) || ((i64)(l.symbol)==(i64)87) || ((i64)(l.symbol)==(i64)86) || ((i64)(l.symbol)==(i64)88)) {
        goto L407 ;
;
    } else {
        name = cc_tables_shortsymbolnames[((i64)(l.symbol))-1];
        if (!!(((*length) = (i64)(strlen((i8 *)(name)))))) {
            if (((u64)((*name)) != 'k')) {
                return name;
            } else {
                (*length) = (i64)(strlen((i8 *)((cc_tables_symbolnames[((i64)(l.symbol))-1] + (i64)1))));
                return (cc_tables_symbolnames[((i64)(l.symbol))-1] + (i64)1);
            };
        } else {
            return (byte*)"";
        };
    };
    return (byte*)"";
}

static byte * cc_lex_strstring(byte * s,i64 length,i64 * newlength,i64 quotechar) {
    byte *  t;
    byte *  u;
    t = (u = (byte *)(mlib_pcm_alloc(((length * (i64)2) + (i64)4))));
    if (!!(quotechar)) {
        (*u) = (u64)(quotechar);
        ++u;
    };
    cc_lib_convertstring(s,u,length);
    (*newlength) = (i64)(strlen((i8 *)(t)));
    if (!!(quotechar)) {
        (*(t + (*newlength))) = (u64)(quotechar);
        ++(*newlength);
    };
    return t;
}

void cc_lex_emittoken(struct cc_decls_tokenrec * lp,struct mlib_strbuffer * dest,i64 forcespace) {
    i64 length;
    byte *  s;
    if ((((i64)((u64)((*lp).symbol)) == (i64)56) && (cc_lex_lasttoken == (i64)56))) {
        return;
    };
    s = cc_lex_strtoken(lp,&length);
    if ((!!(forcespace) || !!(cc_lex_needspace(cc_lex_lasttoken,(i64)((*lp).symbol))))) {
        mlib_gs_char(dest,(i64)32);
    };
    mlib_gs_strn(dest,s,length);
    cc_lex_lasttoken = (i64)((*lp).symbol);
}

void cc_lex_showtoken(struct cc_decls_tokenrec * lp) {
    static struct mlib_strbuffer buffer;
    static struct mlib_strbuffer *  dest = &buffer;
    mlib_gs_init(dest);
    cc_lex_emittoken(lp,dest,(i64)0);
    msysnewc_m_print_startcon();
    msysnewc_m_print_i64((*dest).length,(byte*)"v");
    msysnewc_m_print_nogap();
    msysnewc_m_print_str((*dest).strptr,(byte*)".*");
    msysnewc_m_print_end();
    ;
}

static void cc_lex_stringify(struct cc_decls_tokenrec * seq,struct cc_decls_tokenrec * dest) {
    byte *  s;
    i64 length;
    i64 addspace;
    static struct mlib_strbuffer buffer;
    static struct mlib_strbuffer *  deststr = &buffer;
    (*dest).symbol = (u64)((i64)63);
    (*dest).nexttoken = (struct cc_decls_tokenrec *)(0);
    if (((*seq).nexttoken == 0)) {
        s = cc_lex_strtoken(seq,&length);
        (*dest).length = length;
        (*dest).svalue = s;
        return;
    };
    mlib_gs_init(deststr);
    cc_lex_lasttoken = (i64)0;
    addspace = (i64)0;
    L408 :;
    while (!!(seq)) {
        cc_lex_emittoken(seq,deststr,addspace);
        addspace = (i64)1;
        seq = (*seq).nexttoken;
L409 :;
    }L410 :;
    ;
    (*dest).length = length;
    (*dest).svalue = (*deststr).strptr;
    (*dest).length = (i64)((*deststr).length);
}

static void cc_lex_pastetokens(struct cc_decls_tokenrec * tk,struct cc_decls_tokenrec * * tknext) {
    struct cc_decls_tokenrec *  tk2;
    i64 length1;
    i64 length2;
    byte *  s;
    byte *  t;
    byte *  u;
    struct cc_decls_tokenrec oldtoken;
    struct cc_decls_tokenrec token;
    byte *  oldlxsptr;
    i64 oldlx_stackindex;
    tk2 = (*tk).nexttoken;
    if ((tk2 == (*tknext))) {
        (*tknext) = tk;
    };
    (*tk).nexttoken = (*tk2).nexttoken;
    if (((i64)((u64)((*tk).symbol)) == (i64)66)) {
        if (((i64)((u64)((*tk2).symbol)) == (i64)66)) {
        } else {
            (*tk) = (*tk2);
        };
    } else if (((i64)((u64)((*tk2).symbol)) == (i64)66)) {
    } else {
        s = cc_lex_strtoken(tk,&length1);
        t = cc_lex_strtoken(tk2,&length2);
        u = (byte *)(mlib_pcm_alloc((length1 + length2)));
        memcpy((void *)(u),(void *)(s),(u32)(length1));
        memcpy((void *)((u + length1)),(void *)(t),(u32)(length2));
        (*((u + length1) + length2)) = (u64)0u;
        if ((cc_lex_npastedtokens >= (i64)87000)) {
            cc_lex_lxerror((byte*)"Too many pasted tokens");
        };
        cc_lex_pastedtokenlist[(++cc_lex_npastedtokens)-1] = u;
        oldtoken = cc_decls_nextlx;
        oldlxsptr = cc_lex_lxsptr;
        oldlx_stackindex = cc_lex_lx_stackindex;
        cc_lex_lxsptr = u;
        cc_lex_lx_stackindex = (i64)0;
        cc_lex_setfileno((i64)0);
        cc_decls_nextlx.lineno = (u64)((i64)0);
        cc_lex_lexreadtoken();
        token = cc_decls_nextlx;
        cc_lex_lexreadtoken();
        if (((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)57)) {
        };
        cc_decls_nextlx = oldtoken;
        cc_lex_lxsptr = oldlxsptr;
        cc_lex_lx_stackindex = oldlx_stackindex;
        token.nexttoken = (*tk).nexttoken;
        cc_lex_setfilenox(&token,(i64)0);
        token.pasteno = cc_lex_npastedtokens;
        token.flags |= (u8)8u;
        (*tk) = token;
    };
}

static i64 cc_lex_getifexpr(void) {
    i64 sx;
    i64 x;
    cc_lex_lexm();
    x = cc_lex_evalcondexpr(&sx);
    if (((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)56)) {
        cc_lex_lxerror((byte*)"#if:eol expected");
    };
    return (x != (i64)0);
}

static i64 cc_lex_evalcondexpr(i64 * sx) {
    i64 x;
    i64 y;
    i64 z;
    i64 sy;
    i64 sz;
    x = cc_lex_evalorexpr(sx);
    if (((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)18)) {
        cc_lex_lexm();
        y = cc_lex_evalcondexpr(&sy);
        if (((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)10)) {
            cc_lex_lxerror((byte*)": expected");
        };
        cc_lex_lexm();
        z = cc_lex_evalcondexpr(&sz);
        if (!!(x)) {
            (*sx) = sy;
            x = y;
        } else {
            (*sx) = sz;
            x = z;
        };
    };
    return x;
}

static i64 cc_lex_evalorexpr(i64 * sx) {
    i64 x;
    i64 y;
    i64 sy;
    x = cc_lex_evalandexpr(sx);
    L411 :;
    while (((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)30)) {
        cc_lex_lexm();
        y = cc_lex_evalandexpr(&sy);
        x = ((!!(x) || !!(y))?(i64)1:(i64)0);
L412 :;
    }L413 :;
    ;
    return x;
}

static i64 cc_lex_evalandexpr(i64 * sx) {
    i64 x;
    i64 y;
    i64 sy;
    x = cc_lex_evaliorexpr(sx);
    L414 :;
    while (((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)31)) {
        cc_lex_lexm();
        y = cc_lex_evaliorexpr(&sy);
        x = ((!!(x) && !!(y))?(i64)1:(i64)0);
L415 :;
    }L416 :;
    ;
    return x;
}

static i64 cc_lex_evaliorexpr(i64 * sx) {
    i64 x;
    i64 sy;
    x = cc_lex_evalixorexpr(sx);
    L417 :;
    while (((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)27)) {
        cc_lex_lexm();
        x |= cc_lex_evalixorexpr(&sy);
L418 :;
    }L419 :;
    ;
    return x;
}

static i64 cc_lex_evalixorexpr(i64 * sx) {
    i64 x;
    i64 sy;
    x = cc_lex_evaliandexpr(sx);
    L420 :;
    while (((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)29)) {
        cc_lex_lexm();
        x ^= cc_lex_evaliandexpr(&sy);
L421 :;
    }L422 :;
    ;
    return x;
}

static i64 cc_lex_evaliandexpr(i64 * sx) {
    i64 x;
    i64 sy;
    x = cc_lex_evaleqexpr(sx);
    L423 :;
    while (((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)28)) {
        cc_lex_lexm();
        x &= cc_lex_evaleqexpr(&sy);
L424 :;
    }L425 :;
    ;
    return x;
}

static i64 cc_lex_evaleqexpr(i64 * sx) {
    i64 x;
    i64 y;
    i64 sy;
    i64 opc;
    x = cc_lex_evalcmpexpr(sx);
    L426 :;
    while ((((opc = (i64)(cc_decls_nextlx.symbol)) == (i64)39) || (opc == (i64)40))) {
        cc_lex_lexm();
        y = cc_lex_evalcmpexpr(&sy);
        if ((opc==(i64)39)) {
            x = (x == y);
        }else if ((opc==(i64)40)) {
            x = (x != y);
        };
L427 :;
    }L428 :;
    ;
    return x;
}

static i64 cc_lex_evalcmpexpr(i64 * sx) {
    i64 x;
    i64 y;
    i64 sy;
    i64 opc;
    x = cc_lex_evalshiftexpr(sx);
    L429 :;
    while ((((((opc = (i64)(cc_decls_nextlx.symbol)) == (i64)41) || (opc == (i64)42)) || (opc == (i64)43)) || (opc == (i64)44))) {
        cc_lex_lexm();
        y = cc_lex_evalshiftexpr(&sy);
        if ((opc==(i64)41)) {
            x = (x < y);
        }else if ((opc==(i64)42)) {
            x = (x <= y);
        }else if ((opc==(i64)43)) {
            x = (x >= y);
        }else if ((opc==(i64)44)) {
            x = (x > y);
        };
L430 :;
    }L431 :;
    ;
    return x;
}

static i64 cc_lex_evalshiftexpr(i64 * sx) {
    i64 x;
    i64 y;
    i64 sy;
    i64 opc;
    x = cc_lex_evaladdexpr(sx);
    L432 :;
    while ((((opc = (i64)(cc_decls_nextlx.symbol)) == (i64)32) || (opc == (i64)33))) {
        cc_lex_lexm();
        y = cc_lex_evaladdexpr(&sy);
        if ((opc==(i64)33)) {
            x = (x >> y);
        }else if ((opc==(i64)32)) {
            x = (x << y);
        };
L433 :;
    }L434 :;
    ;
    return x;
}

static i64 cc_lex_evaladdexpr(i64 * sx) {
    i64 x;
    i64 y;
    i64 sy;
    i64 opc;
    x = cc_lex_evalmulexpr(sx);
    L435 :;
    while ((((opc = (i64)(cc_decls_nextlx.symbol)) == (i64)22) || (opc == (i64)23))) {
        cc_lex_lexm();
        y = cc_lex_evalmulexpr(&sy);
        if ((opc==(i64)22)) {
            x += y;
        }else if ((opc==(i64)23)) {
            x -= y;
        };
L436 :;
    }L437 :;
    ;
    return x;
}

static i64 cc_lex_evalmulexpr(i64 * sx) {
    i64 x;
    i64 y;
    i64 sy;
    i64 opc;
    x = cc_lex_evalunaryexpr(sx);
    L438 :;
    while (((((opc = (i64)(cc_decls_nextlx.symbol)) == (i64)24) || (opc == (i64)25)) || (opc == (i64)26))) {
        cc_lex_lexm();
        y = cc_lex_evalunaryexpr(&sy);
        if (((y == (i64)0) && (opc != (i64)24))) {
            cc_lex_lxerror((byte*)"#if:div by zero");
        };
        if ((opc==(i64)24)) {
            x *= y;
        }else if ((opc==(i64)25)) {
            x = (x / y);
        }else if ((opc==(i64)26)) {
            x = (x % y);
        };
L439 :;
    }L440 :;
    ;
    return x;
}

static i64 cc_lex_evalunaryexpr(i64 * sx) {
    i64 x;
    i64 opc;
    if (((i64)(cc_decls_nextlx.symbol)==(i64)22) || ((i64)(cc_decls_nextlx.symbol)==(i64)23) || ((i64)(cc_decls_nextlx.symbol)==(i64)35) || ((i64)(cc_decls_nextlx.symbol)==(i64)34)) {
        opc = (i64)(cc_decls_nextlx.symbol);
        cc_lex_lexm();
        x = cc_lex_evalunaryexpr(sx);
        if ((opc==(i64)22)) {
            return x;
        }else if ((opc==(i64)23)) {
            return -(x);
        }else if ((opc==(i64)35)) {
            return !(x);
        }else if ((opc==(i64)34)) {
            return ~(x);
        };
    };
    return cc_lex_evalterm(sx);
}

static i64 cc_lex_evalterm(i64 * sx) {
    i64 res;
    i64 lb;
    (*sx) = (i64)1;
    if (((i64)(cc_decls_nextlx.symbol)==(i64)68)) {
        if (((i64)((*cc_decls_nextlx.symptr).symbol)==(i64)93)) {
            cc_lex_noexpand = (i64)1;
            lb = (i64)0;
            cc_lex_lexm();
            if (((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)12)) {
                lb = (i64)1;
                cc_lex_lexm();
            };
            if (((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)68)) {
                cc_lex_lxerror((byte*)"defined?");
            };
            res = ((i64)((u64)((*cc_decls_nextlx.symptr).nameid)) == (i64)1);
            cc_lex_lexm();
            if (!!(lb)) {
                if (((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)13)) {
                    cc_lex_lxerror((byte*)"')' expected");
                };
                cc_lex_lexm();
            };
            cc_lex_noexpand = (i64)0;
        }else if (((i64)((*cc_decls_nextlx.symptr).symbol)==(i64)91)) {
            cc_lex_lexm();
            if (((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)12)) {
                cc_lex_lxerror((byte*)"'(' expected");
            };
            cc_lex_lexm();
            if (((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)68)) {
                cc_lex_lxerror((byte*)"name expected");
            };
            if (((i64)((*cc_decls_nextlx.symptr).symbol)==(i64)71)) {
                res = (i64)(cc_tables_typespecsizes[((i64)((*cc_decls_nextlx.symptr).subcode))-1]);
            } else {
                cc_lex_lxerror((byte*)"sizeof2");
            };
            cc_lex_lexm();
            if (((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)13)) {
                cc_lex_lxerror((byte*)"')' expected");
            };
            cc_lex_lexm();
        } else {
            cc_lex_lexm();
            return (i64)0;
        };
    }else if (((i64)(cc_decls_nextlx.symbol)==(i64)59)) {
        res = cc_decls_nextlx.value;
        cc_lex_lexm();
    }else if (((i64)(cc_decls_nextlx.symbol)==(i64)61)) {
        if (((i64)(cc_decls_nextlx.length) == (i64)0)) {
            res = (i64)0;
        } else {
            res = (i64)((*cc_decls_nextlx.svalue));
        };
        cc_lex_lexm();
    }else if (((i64)(cc_decls_nextlx.symbol)==(i64)12)) {
        cc_lex_lexm();
        res = cc_lex_evalcondexpr(sx);
        if (((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)13)) {
            cc_lex_lxerror((byte*)") expected");
        };
        cc_lex_lexm();
    } else {
        cc_lex_printsymbol(&cc_decls_nextlx);
        cc_lex_printstrn(cc_decls_nextlx.svalue,(i64)(cc_decls_nextlx.length),0);
        msysnewc_m_print_startcon();
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        cc_lex_lxerror((byte*)"evalterm?");
    };
    return res;
}

static i64 cc_lex_getifdef(void) {
    i64 res;
    struct cc_decls_strec *  d;
    cc_lex_noexpand = (i64)1;
    cc_lex_lexreadtoken();
    cc_lex_noexpand = (i64)0;
    if (((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)68)) {
        cc_lex_lxerror((byte*)"Name expected");
    };
    d = cc_decls_nextlx.symptr;
    res = (i64)0;
    if (((i64)((u64)((*d).nameid)) == (i64)1)) {
        res = (i64)1;
    } else if (((i64)((u64)((*d).symbol)) == (i64)70)) {
        res = (i64)1;
    };
    cc_lex_lexreadtoken();
    if (((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)56)) {
        cc_lex_lxerror((byte*)"EOL expected");
    };
    return res;
}

static i64 cc_lex_skipcode(void) {
    i64 level;
    i64 dir;
    level = (i64)0;
    L441 :;
    while (1) {
        cc_lex_fastreadtoken();
        if (((i64)(cc_decls_nextlx.symbol)==(i64)4)) {
            dir = cc_lex_getlexdirective();
            if ((dir==(i64)3) || (dir==(i64)8) || (dir==(i64)9)) {
                ++level;
            }else if ((dir==(i64)4) || (dir==(i64)5)) {
                if ((level == (i64)0)) {
                    return dir;
                };
            }else if ((dir==(i64)6)) {
                if ((level == (i64)0)) {
                    return dir;
                };
                --level;
            };
        }else if (((i64)(cc_decls_nextlx.symbol)==(i64)57)) {
            cc_lex_lxerror((byte*)"#if:Unexpected eof");
        };
    }L442 :;
    ;
    return (i64)0;
}

static void cc_lex_freetokens(struct cc_decls_tokenrec * tk) {
    struct cc_decls_tokenrec *  nexttk;
    L443 :;
    while (!!(tk)) {
        nexttk = (*tk).nexttoken;
        tk = nexttk;
L444 :;
    }L445 :;
    ;
}

void cc_lex_fastreadtoken(void) {
    i64 dodir;
    byte *  p;
    cc_decls_nextlx.subcodex = (u64)((i64)0);
    L446 :;
    switch ((int)((*cc_lex_lxsptr++))) {
    case 35:;
    {
        p = (cc_lex_lxsptr - (i64)2);
        dodir = (i64)0;
        L448 :;
        while ((p >= cc_lex_lxstart)) {
            if (((i64)((*p))==(i64)10)) {
                dodir = (i64)1;
                goto L450 ;
            }else if (((i64)((*p))==(i64)9) || ((i64)((*p))==(i64)32)) {
            } else {
                goto L450 ;
            };
            --p;
L449 :;
        }L450 :;
        ;
        if ((!!(dodir) || (p < cc_lex_lxstart))) {
            cc_decls_nextlx.symbol = (u64)((i64)4);
            return;
        } else if (((u64)((*cc_lex_lxsptr)) == '#')) {
            ++cc_lex_lxsptr;
        };
    }break;
    case 47:;
    {
        if (((i64)((*cc_lex_lxsptr))==(i64)47)) {
            cc_lex_readlinecomment();
        }else if (((i64)((*cc_lex_lxsptr))==(i64)42)) {
            cc_lex_readblockcomment();
        };
    }break;
    case 39:;
    {
        cc_lex_lxreadstring((i64)39,(i64)0);
    }break;
    case 34:;
    {
        cc_lex_lxreadstring((i64)34,(i64)0);
    }break;
    case 13:;
    {
        ++cc_decls_nalllines;
        ++cc_decls_nextlx.lineno;
        cc_decls_nextlx.symbol = (u64)((i64)56);
        cc_decls_nextlx.length = (i64)0;
        ++cc_lex_lxsptr;
    }break;
    case 10:;
    {
        ++cc_decls_nextlx.lineno;
        ++cc_decls_nalllines;
        cc_decls_nextlx.symbol = (u64)((i64)56);
        cc_decls_nextlx.length = (i64)0;
    }break;
    case 0:;
    {
        --cc_lex_lxsptr;
        if (!!(cc_lex_lx_stackindex)) {
            cc_lex_unstacksourcefile();
        } else {
            cc_decls_nextlx.symbol = (u64)((i64)57);
            return;
        };
    }break;
    case 12:;
    {
    }break;
    default: {
    }
    } /* SW */
goto L446 ;
L447 :;
    ;
}

static struct cc_decls_tokenrec * cc_lex_alloctoken(void) {
    struct cc_decls_tokenrec *  tk;
    tk = (struct cc_decls_tokenrec *)(mlib_pcm_alloc((i64)28));
    return tk;
}

static struct cc_decls_tokenrec * cc_lex_alloctokenz(void) {
    struct cc_decls_tokenrec *  tk;
    tk = (struct cc_decls_tokenrec *)(mlib_pcm_alloc((i64)28));
    (*tk).nexttoken = (struct cc_decls_tokenrec *)(0);
    return tk;
}

static void cc_lex_expandpredefmacro(i64 pdmcode,struct cc_decls_tokenrec * tk,i64 lineno) {
    byte str[256];
    static byte *  monthnames[12] = {
    (byte*)"Jan",
    (byte*)"Feb",
    (byte*)"Mar",
    (byte*)"Apr",
    (byte*)"May",
    (byte*)"Jun",
    (byte*)"Jul",
    (byte*)"Aug",
    (byte*)"Sep",
    (byte*)"Oct",
    (byte*)"Nov",
    (byte*)"Dec"
};
    struct osnos_rsystemtime tm;
    byte *  s;
    i64 fileno;
    if (!!(cc_lex_noexpand)) {
        return;
    };
    if ((pdmcode==(i64)1)) {
        osnos_os_getsystime((void *)(&tm));
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((byte*)"#-#-#");
        msysnewc_m_print_i64(tm.day,NULL);
        msysnewc_m_print_str(monthnames[(tm.month)-1],NULL);
        msysnewc_m_print_i64(tm.year,(byte*)"4");
        msysnewc_m_print_end();
        ;
        (*tk).symbol = (u64)((i64)63);
        (*tk).svalue = mlib_pcm_copyheapstring(str);
    }else if ((pdmcode==(i64)2)) {
        osnos_os_getsystime((void *)(&tm));
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((byte*)"#:#:#");
        msysnewc_m_print_i64(tm.hour,(byte*)"2");
        msysnewc_m_print_i64(tm.minute,(byte*)"z2");
        msysnewc_m_print_i64(tm.second,(byte*)"z2");
        msysnewc_m_print_end();
        ;
        (*tk).symbol = (u64)((i64)63);
        (*tk).svalue = mlib_pcm_copyheapstring(str);
    }else if ((pdmcode==(i64)3)) {
        (*tk).symbol = (u64)((i64)63);
        fileno = cc_lex_getfilenox(tk);
        if ((fileno == (i64)0)) {
            fileno = cc_decls_sfileno;
        };
        if (!!(cc_decls_sfileno)) {
            (*tk).svalue = cc_decls_sourcefilenames[(cc_decls_sfileno)];
        } else {
            (*tk).svalue = (byte*)"(File not available)";
        };
    }else if ((pdmcode==(i64)5)) {
        (*tk).symbol = (u64)((i64)63);
        if (!!(cc_decls_currproc)) {
            (*tk).svalue = (*cc_decls_currproc).name;
        } else {
            (*tk).svalue = (byte*)"???";
        };
    }else if ((pdmcode==(i64)4)) {
        (*tk).symbol = (u64)((i64)59);
        (*tk).value = lineno;
    }else if ((pdmcode==(i64)8)) {
        (*tk).symbol = (u64)((i64)59);
        (*tk).value = (i64)1;
    }else if ((pdmcode==(i64)7)) {
        (*tk).symbol = (u64)((i64)59);
        (*tk).value = (i64)1;
    } else {
        msysnewc_m_print_startcon();
        msysnewc_m_print_i64(pdmcode,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        cc_lex_lxerror((byte*)"PDM");
    };
    if (((i64)((u64)((*tk).symbol)) == (i64)63)) {
        (*tk).length = (i64)(strlen((i8 *)((*tk).svalue)));
        (*tk).subcode = (u64)(cc_decls_trefchar);
    } else {
        (*tk).subcode = (u64)((i64)4);
        s = (byte *)(mlib_pcm_alloc((i64)16));
        msysnewc_getstrint((*tk).value,s);
        (*tk).length = (i64)(strlen((i8 *)(s)));
        if ((cc_lex_npastedtokens >= (i64)87000)) {
            cc_lex_lxerror((byte*)"2:Too many pasted tokens");
        };
        cc_lex_pastedtokenlist[(++cc_lex_npastedtokens)-1] = s;
        cc_lex_setfilenox(tk,(i64)0);
        (*tk).pasteno = cc_lex_npastedtokens;
    };
}

static void cc_lex_dopragmadir(void) {
    cc_lex_lexm();
    if (((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)68)) {
        if (((i64)(memcmp((void *)((*cc_decls_nextlx.symptr).name),(void *)((byte*)"pack"),(u32)4u)) == (i64)0)) {
            cc_lex_lexm();
            if (((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)12)) {
                cc_lex_lxerror((byte*)"'(' expected");
            };
            cc_lex_lexm();
            if (((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)59)) {
                if ((cc_decls_nextlx.value==(i64)1)) {
                    cc_decls_structpadding = (i64)0;
                } else {
                    goto L451 ;
;
                    cc_lex_lxerror((byte*)"Only pack(1) or () allowed");
                };
                cc_lex_lexm();
            } else if (((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)13)) {
                cc_decls_structpadding = (i64)1;
            };
        } else if (((i64)(memcmp((void *)((*cc_decls_nextlx.symptr).name),(void *)((byte*)"$callback"),(u32)9u)) == (i64)0)) {
            cc_decls_callbackflag = (i64)1;
        };
    };
    /*finish:*/
L451 :;
;
    L452 :;
    while ((((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)56) && ((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)57))) {
        cc_lex_lexm();
L453 :;
    }L454 :;
    ;
}

static i64 cc_lex_needspace(i64 a,i64 b) {
    byte *  aname;
    byte *  bname;
    if ((a == (i64)0)) {
        return (i64)0;
    };
    aname = cc_tables_shortsymbolnames[(a)-1];
    bname = cc_tables_shortsymbolnames[(b)-1];
    if (((i64)((*bname))==(i64)110) || ((i64)((*bname))==(i64)107)) {
        if (((i64)((*aname))==(i64)110) || ((i64)((*aname))==(i64)107)) {
            return (i64)1;
        };
    }else if (((i64)((*bname))==(i64)45) || ((i64)((*bname))==(i64)43)) {
        if (((i64)((*aname))==(i64)45) || ((i64)((*aname))==(i64)43)) {
            return (i64)1;
        };
    };
    return (i64)0;
}

void cc_lex_dospecialinclude(void) {
    ++cc_lex_nincludes;
    cc_lex_stacksourcefile((byte*)"bcc.h",(i64)1);
    if (!!(cc_decls_dheaderfile)) {
        cc_lex_stacksourcefile(cc_decls_dheaderfile,(i64)1);
    };
}

static void cc_lex_addautomodule(byte * headername,i64 fileno) {
    byte *  cfilename;
    byte *  headerfile;
    i64 present;
    i64 i;
    headerfile = cc_decls_sourcefilepaths[(fileno)];
    if (!(!!(cc_decls_fautomodules))) {
        return;
    };
    if (!!(mlib_eqstring(mlib_extractext(headerfile,(i64)0),(byte*)"c"))) {
        return;
    };
    cfilename = mlib_changeext(headerfile,(byte*)"c");
    if (!!(mlib_checkfile(cfilename))) {
        present = (i64)1;
        L455 :;
        for (i=(i64)1;i<=cc_decls_nautomodules;i+=(i64)1) {
L456 :;
            if (!!(mlib_eqstring(cc_decls_automodulenames[(i)],cfilename))) {
                present = (i64)0;
                goto L458 ;
            };
L457 :;
        }L458 :;
        ;
        if (!!(present)) {
            cc_decls_automodulenames[(++cc_decls_nautomodules)] = mlib_pcm_copyheapstring(cfilename);
        };
    };
}

static void cc_lex_setnumberoffset(i64 offset) {
    cc_decls_nextlx.numberoffset = (((i64)(cc_decls_nextlx.numberoffset) & (i64)4278190080LL) | (offset & (i64)16777215));
}

static void cc_lex_setfileno(i64 fileno) {
    cc_decls_nextlx.fileno = (u64)((fileno & (i64)255));
    cc_decls_nextlx.numberoffset = (((i64)(cc_decls_nextlx.numberoffset) & (i64)16777215) | ((fileno & (i64)65280) << (i64)16));
}

static void cc_lex_setfilenox(struct cc_decls_tokenrec * tk,i64 fileno) {
    (*tk).fileno = (u64)((fileno & (i64)255));
    (*tk).numberoffset = (((i64)((*tk).numberoffset) & (i64)16777215) | ((fileno & (i64)65280) << (i64)16));
}

static i64 cc_lex_getfileno(void) {
    return ((((i64)(cc_decls_nextlx.numberoffset) >> (i64)24) << (i64)8) | (i64)((u64)(cc_decls_nextlx.fileno)));
}

static i64 cc_lex_getfilenox(struct cc_decls_tokenrec * tk) {
    return ((((i64)((*tk).numberoffset) >> (i64)24) << (i64)8) | (i64)((u64)((*tk).fileno)));
}

static i64 cc_lex_getnumberoffsetx(struct cc_decls_tokenrec * tk) {
    return ((i64)((*tk).numberoffset) & (i64)16777215);
}

void cc_lex_freehashtable(void) {
    struct cc_decls_strec *  d;
    struct cc_decls_strec *  e;
    struct cc_decls_strec *  f;
    i64 i;
    L459 :;
    for (i=(i64)0;i<=cc_decls_hstmask;i+=(i64)1) {
L460 :;
        d = (*cc_decls_hashtable)[(i)];
        if ((!!((*d).name) && ((i64)((u64)((*d).symbol)) == (i64)68))) {
            if (((i64)((u64)((*d).nameid)) == (i64)1)) {
                cc_lex_freetokens((*d).tokenlist);
            };
            f = (*d).nextdupl;
            L463 :;
            while (!!(f)) {
                cc_lex_freestentry(f);
                e = (*f).nextdupl;
                mlib_pcm_free((void *)(f),(i64)84);
                f = e;
L464 :;
            }L465 :;
            ;
            mlib_pcm_clearmem((void *)((*cc_decls_hashtable)[(i)]),(i64)84);
        } else if (!!((*d).name)) {
            (*d).nextdupl = (struct cc_decls_strec *)(0);
        };
L461 :;
    }L462 :;
    ;
}

static void cc_lex_freestentry(struct cc_decls_strec * d) {
}

static void cc_lex_regenlookup(struct cc_decls_strec * d) {
    i64 j;
    i64 wrapped;
    i64 length;
    struct cc_decls_strec *  e;
    j = ((i64)(cc_lex_gethashvalue((*d).name,(i64)((*d).namelen))) & cc_decls_hstmask);
    wrapped = (i64)0;
    L466 :;
    while (1) {
        e = (*cc_decls_hashtable)[(j)];
        length = (i64)((*e).namelen);
        if (!(!!(length))) {
            mlib_pcm_free((void *)((*cc_decls_hashtable)[(j)]),(i64)84);
            (*cc_decls_hashtable)[(j)] = d;
            ++cc_lex_nhstsymbols;
            return;
        };
        if ((length == (i64)((u64)((*d).namelen)))) {
            if (((i64)(memcmp((void *)((*e).name),(void *)((*d).name),(u32)(length))) == (i64)0)) {
                cc_lex_lxerror((byte*)"regenhst dupl?");
            };
        };
        if ((++j >= cc_decls_hstsize)) {
            if (!!(wrapped)) {
                mlib_abortprogram((byte*)"REGENHST FULL?");
            };
            wrapped = (i64)1;
            j = (i64)0;
        };
    }L467 :;
    ;
}

static void cc_lex_printhashtable(byte * caption) {
    struct cc_decls_strec *  d;
    i64 av_1;
    i64 i;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(caption,NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str((byte*)":",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    L468 :;
    for (i=(i64)0;i<=(cc_decls_hstsize - (i64)1);i+=(i64)1) {
L469 :;
        d = (*cc_decls_hashtable)[(i)];
        if (!!((*d).name)) {
            if (!!(mlib_eqstring((*d).name,(byte*)"char"))) {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((byte*)"********************** CHAR",NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
            };
            msysnewc_m_print_startcon();
            msysnewc_m_print_i64(i,NULL);
            msysnewc_m_print_str((byte*)":",NULL);
            msysnewc_m_print_str((*d).name,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_i64(i,NULL);
            msysnewc_m_print_str((byte*)": ----",NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        };
        if (((i % (i64)30) == (i64)0)) {
            osnos_os_getch();
        };
L470 :;
    }L471 :;
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

static void cc_lex_newhashtable(void) {
    struct cc_decls_strec * (*oldhashtable)[];
    i64 oldhstsize;
    struct cc_decls_strec *  d;
    i64 av_1;
    i64 i;
    oldhashtable = cc_decls_hashtable;
    oldhstsize = cc_decls_hstsize;
    cc_decls_hstsize *= (i64)2;
    cc_decls_hstmask = (cc_decls_hstsize - (i64)1);
    cc_lex_nhstsymbols = (i64)0;
    cc_lex_hstthreshold = (((i64)6 * cc_decls_hstsize) / (i64)10);
    cc_decls_hashtable = (struct cc_decls_strec * (*)[])(mlib_pcm_alloc((cc_decls_hstsize * (i64)4)));
    L472 :;
    for (i=(i64)0;i<=cc_decls_hstmask;i+=(i64)1) {
L473 :;
        (*cc_decls_hashtable)[(i)] = (struct cc_decls_strec *)(mlib_pcm_allocz((i64)84));
L474 :;
    }L475 :;
    ;
    L476 :;
    for (i=(i64)0;i<=(oldhstsize - (i64)1);i+=(i64)1) {
L477 :;
        d = (*oldhashtable)[(i)];
        if (!!((*d).name)) {
            cc_lex_regenlookup(d);
        };
L478 :;
    }L479 :;
    ;
    mlib_pcm_free((void *)(oldhashtable),(oldhstsize * (i64)4));
}

static void cc_lex_old_readrealnumber(byte * pstart,byte * intstart,i64 intlen,i64 base) {
    byte *  fractstart;
    i64 fractlen;
    i64 expon;
    i64 i;
    i64 c;
    i64 badexpon;
    double basex;
    double x;
    double expbase;
    byte realstr[500];
    i64 av_1;
    i64 av_2;
    i64 av_3;
    fractstart = (byte *)(0);
    fractlen = (i64)0;
    expon = (i64)0;
    if (((u64)((*cc_lex_lxsptr)) == '.')) {
        fractstart = ++cc_lex_lxsptr;
        fractlen = (cc_lex_scannumber(base) - fractstart);
    };
    badexpon = (i64)0;
    if (((i64)((*cc_lex_lxsptr))==(i64)101) || ((i64)((*cc_lex_lxsptr))==(i64)69)) {
        if ((base != (i64)16)) {
            ++cc_lex_lxsptr;
            expon = cc_lex_readexponent(&badexpon);
        };
    }else if (((i64)((*cc_lex_lxsptr))==(i64)112) || ((i64)((*cc_lex_lxsptr))==(i64)80)) {
        if ((base == (i64)16)) {
            ++cc_lex_lxsptr;
            expon = cc_lex_readexponent(&badexpon);
        };
    };
    if (!!(badexpon)) {
        --cc_lex_lxsptr;
        cc_lex_readalphanumeric(pstart);
        return;
    };
    if (((i64)((*cc_lex_lxsptr))==(i64)102) || ((i64)((*cc_lex_lxsptr))==(i64)70)) {
        ++cc_lex_lxsptr;
    } else {
        if (!!((u64)(cc_lex_alphamap[((i64)((*cc_lex_lxsptr)))]))) {
            cc_lex_readalphanumeric(pstart);
            return;
        };
    };
    if (((intlen + fractlen) > (i64)500)) {
        cc_lex_lxerror((byte*)"Real too long");
    };
    if (!!(intlen)) {
        memcpy((void *)(&realstr),(void *)(intstart),(u32)(intlen));
    };
    if (!!(fractlen)) {
        memcpy((void *)((&realstr[((i64)1)-1] + intlen)),(void *)(fractstart),(u32)(fractlen));
    };
    expbase = (basex = (double)(base));
    if ((base == (i64)10)) {
        expon -= fractlen;
    } else {
        expon -= (fractlen * (i64)4);
        expbase = (double)2.;
    };
    x = (double)0.;
    L480 :;
    for (i=(i64)1;i<=(intlen + fractlen);i+=(i64)1) {
L481 :;
        c = (i64)(realstr[(i)-1]);
        if (((c >= (i64)48) && (c <= (i64)57))) {
            x = ((x * basex) + (double)((c - (i64)48)));
        } else if ((c > (i64)97)) {
            x = ((((x * basex) + (double)(c)) - (double)97.) + (double)10.);
        } else {
            x = ((((x * basex) + (double)(c)) - (double)65.) + (double)10.);
        };
L482 :;
    }L483 :;
    ;
    if ((expon >= (i64)0)) {
        av_2 = expon;
        while (av_2-- > 0) {
L484 :;
            x *= expbase;
L485 :;
        }L486 :;
        ;
    } else {
        av_3 = -(expon);
        while (av_3-- > 0) {
L487 :;
            x /= expbase;
L488 :;
        }L489 :;
        ;
    };
    cc_decls_nextlx.symbol = (u64)((i64)60);
    cc_decls_nextlx.subcode = (u64)((i64)12);
    cc_decls_nextlx.xvalue = x;
    cc_lex_setnumberoffset((intstart - cc_lex_lxstart));
    cc_decls_nextlx.length = (cc_lex_lxsptr - intstart);
}

byte * cc_headers_findheader(byte * name) {
    i64 i;
    byte newname[256];
    byte *  s;
    byte *  t;
    i64 av_1;
    if (!!(strchr((i8 *)(name),(i32)92))) {
        s = name;
        t = newname;
        L490 :;
        while (!!((u64)((*s)))) {
            if (((u64)((*s)) == (u64)92u)) {
                (*t++) = '/';
            } else {
                (*t++) = (u64)((*s));
            };
            ++s;
L491 :;
        }L492 :;
        ;
        (*t) = (u64)0u;
        name = newname;
    };
    L493 :;
    for (i=(i64)1;i<=(i64)42;i+=(i64)1) {
L494 :;
        if (!!(mlib_eqstring(name,cc_headers_stdhdrnames[(i)-1]))) {
            return (*cc_headers_stdhdrtext[(i)-1]);
        };
L495 :;
    }L496 :;
    ;
    return (byte *)(0);
}

void cc_headers_writeheaders(void) {
    void *  f;
    byte *  ifile;
    i64 i;
    i64 av_1;
    L497 :;
    for (i=(i64)1;i<=(i64)42;i+=(i64)1) {
L498 :;
        ifile = mlib_changeext(cc_headers_stdhdrnames[(i)-1],(byte*)"hdr");
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"Writing internal",NULL);
        msysnewc_m_print_str(cc_headers_stdhdrnames[(i)-1],NULL);
        msysnewc_m_print_str((byte*)"as",NULL);
        msysnewc_m_print_str(ifile,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        f = fopen((i8 *)(ifile),(i8 *)((byte*)"wb"));
        fwrite((void *)((*cc_headers_stdhdrtext[(i)-1])),(u32)1u,strlen((i8 *)((*cc_headers_stdhdrtext[(i)-1]))),f);
        fclose(f);
L499 :;
    }L500 :;
    ;
}

void cc_headers_checkbcclib(void) {
    void *  f;
    if (!(!!(mlib_checkfile((byte*)"bcclib.asm")))) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"Writing",NULL);
        msysnewc_m_print_str((byte*)"bcclib.asm",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        f = fopen((i8 *)((byte*)"bcclib.asm"),(i8 *)((byte*)"wb"));
        fwrite((void *)(cc_headers_bcclibstr),(u32)1u,strlen((i8 *)(cc_headers_bcclibstr)),f);
        fclose(f);
    };
}

byte * cc_headers_getbcclib(void) {
    byte *  s;
    i64 slen;
    slen = (i64)(strlen((i8 *)(cc_headers_bcclibstr)));
    s = (byte *)(malloc((u64)((slen + (i64)1))));
    memcpy((void *)(s),(void *)(cc_headers_bcclibstr),(u32)((slen + (i64)1)));
    return s;
}

i64 cc_headers_isheaderfile(byte * file) {
    i64 av_1;
    i64 i;
    L501 :;
    for (i=(i64)1;i<=(i64)42;i+=(i64)1) {
L502 :;
        if (!!(mlib_eqstring(cc_headers_stdhdrnames[(i)-1],file))) {
            return (i64)1;
        };
L503 :;
    }L504 :;
    ;
    return (i64)0;
}

static struct cc_decls_strec * cc_lib_newstrec(void) {
    struct cc_decls_strec *  p;
    p = (struct cc_decls_strec *)(mlib_pcm_alloc((i64)84));
    memset((void *)(p),(i32)0,(u32)84u);
    (*p).lineno = (u64)(((i64)((u64)(cc_decls_lx.lineno)) + ((i64)(cc_decls_lx.fileno) << (i64)24)));
    (*p).attribs.ax_moduleno = (u64)(cc_decls_currmoduleno);
    return p;
}

void cc_lib_initcclib(void) {
}

void cc_lib_printst(void * f,struct cc_decls_strec * p,i64 level) {
    struct cc_decls_strec *  q;
    if (((i64)((u64)((*p).symbol)) != (i64)68)) {
        cc_support_mcerror((byte*)"PRINTST not name");
    };
    cc_lib_printstrec(f,p,level);
    q = (*p).deflist;
    L505 :;
    while ((q != 0)) {
        cc_lib_printst(f,q,(level + (i64)1));
        q = (*q).nextdef;
L506 :;
    }L507 :;
    ;
}

static void cc_lib_printstrec(void * f,struct cc_decls_strec * p,i64 level) {
    struct cc_decls_attribrec attrs;
    struct mlib_strbuffer v;
    struct mlib_strbuffer *  d;
    i64 col;
    i64 offset;
    byte str[256];
    struct cc_decls_paramrec *  pm;
    i64 av_1;
    d = &v;
    mlib_gs_init(d);
    offset = (i64)0;
    av_1 = level;
    while (av_1-- > 0) {
L508 :;
        mlib_gs_str(d,(byte*)"    ");
        offset += (i64)4;
L509 :;
    }L510 :;
    ;
    mlib_gs_str(d,(byte*)":");
    if (!!((u64)((*p).blockno))) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_str((*p).name,NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((byte*)".",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_u64((*p).blockno,NULL);
        msysnewc_m_print_end();
        ;
        mlib_gs_leftstr(d,str,((i64)28 - offset),(i64)45);
    } else {
        mlib_gs_leftstr(d,(*p).name,((i64)28 - offset),(i64)45);
    };
    mlib_gs_leftstr(d,cc_tables_namenames[((i64)((*p).nameid))],(i64)12,(i64)46);
    col = mlib_gs_getcol(d);
    attrs = (*p).attribs;
    mlib_gs_str(d,(byte*)"[");
    mlib_gs_str(d,cc_tables_scopenames[((i64)((*p).scope))]);
    mlib_gs_str(d,(byte*)" ");
    if (!!((u64)(attrs.ax_static))) {
        mlib_gs_str(d,(byte*)"Stat");
    };
    if (!!((u64)(attrs.ax_align))) {
        mlib_gs_str(d,(byte*)"@@");
        mlib_gs_strint(d,(i64)(attrs.ax_align));
        mlib_gs_str(d,(byte*)" ");
    };
    if (!!((u64)(attrs.ax_varparams))) {
        mlib_gs_str(d,(byte*)"Var ");
    };
    if (!!((u64)(attrs.ax_used))) {
        mlib_gs_str(d,(byte*)"Used ");
    };
    if (!!((u64)(attrs.ax_forward))) {
        mlib_gs_str(d,(byte*)"Fwd ");
    };
    if (!!((u64)(attrs.ax_frame))) {
        mlib_gs_str(d,(byte*)"Frm ");
    };
    if (!!((u64)(attrs.ax_autovar))) {
        mlib_gs_str(d,(byte*)"AV ");
    };
    if (!!((u64)(attrs.ax_nparams))) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((byte*)"Pm:# ");
        msysnewc_m_print_u64(attrs.ax_nparams,NULL);
        msysnewc_m_print_end();
        ;
        mlib_gs_str(d,str);
    };
    if (!!((u64)(attrs.ax_moduleno))) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((byte*)"M# ");
        msysnewc_m_print_u64(attrs.ax_moduleno,NULL);
        msysnewc_m_print_end();
        ;
        mlib_gs_str(d,str);
    };
    if (!!((u64)(attrs.ax_equals))) {
        mlib_gs_str(d,(byte*)"= ");
    };
    mlib_gs_str(d,(byte*)"]");
    mlib_gs_padto(d,(col + (i64)10),(i64)61);
    if (!!((*p).owner)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((byte*)"(#)");
        msysnewc_m_print_str((*(*p).owner).name,NULL);
        msysnewc_m_print_end();
        ;
        mlib_gs_leftstr(d,str,(i64)18,(i64)32);
    } else {
        mlib_gs_leftstr(d,(byte*)"()",(i64)18,(i64)32);
    };
    if (((i64)((*p).mode)==(i64)1)) {
        mlib_gs_str(d,(byte*)"Void ");
    } else {
        mlib_gs_strsp(d,cc_lib_strmode((i64)((*p).mode),(i64)1));
    };
    if (((i64)((*p).nameid)==(i64)10)) {
        mlib_gs_str(d,(byte*)"Offset:");
        mlib_gs_strint(d,(*p).offset);
    }else if (((i64)((*p).nameid)==(i64)8) || ((i64)((*p).nameid)==(i64)9)) {
        if (!!((*p).code)) {
            mlib_gs_str(d,(byte*)"=");
            mlib_gs_strvar(d,cc_lib_strexpr((*p).code));
        };
        mlib_gs_str(d,(byte*)" Offset: ");
        mlib_gs_strint(d,(*p).offset);
    }else if (((i64)((*p).nameid)==(i64)6)) {
        mlib_gs_str(d,(byte*)"Index:");
        mlib_gs_strint(d,(i64)((*p).index));
        mlib_gs_str(d,(byte*)" Address:");
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_ptr((*p).address,NULL);
        msysnewc_m_print_end();
        ;
        mlib_gs_str(d,str);
        if (!!((u64)((*p).attribs.ax_callback))) {
            mlib_gs_str(d,(byte*)"<callback fn>");
        };
    }else if (((i64)((*p).nameid)==(i64)11)) {
        mlib_gs_str(d,(byte*)"Enum:");
        mlib_gs_strint(d,(i64)((*p).index));
    }else if (((i64)((*p).nameid)==(i64)7)) {
        if (!!((*p).code)) {
            mlib_gs_str(d,(byte*)"=");
            mlib_gs_strvar(d,cc_lib_strexpr((*p).code));
        };
        mlib_gs_str(d,(byte*)"STATIC********");
    };
    mlib_gs_str(d,(byte*)" ");
    mlib_gs_str(d,(byte*)"Lineno:");
    mlib_gs_strint(d,((i64)((u64)((*p).lineno)) & (i64)16777215));
    mlib_gs_str(d,(byte*)" ");
    mlib_gs_str(d,cc_decls_sourcefilenames[((i64)(((u64)((*p).lineno) >> (i64)24)))]);
    if (((i64)((u64)((*p).nameid)) == (i64)6)) {
        mlib_gs_line(d);
        pm = (*p).paramlist;
        L511 :;
        while (!!(pm)) {
            mlib_gs_str(d,(byte*)"\t\tParam: ");
            mlib_gs_leftstr(d,(!!((*pm).def)?(*(*pm).def).name:(byte*)"Anon"),(i64)10,(i64)45);
            mlib_gs_str(d,cc_tables_pmflagnames[((i64)((*pm).flags))]);
            mlib_gs_line(d);
            pm = (*pm).nextparam;
L512 :;
        }L513 :;
        ;
    };
    mlib_gs_println(d,f);
    if (!!((*p).code)) {
        if (((i64)((*p).nameid)==(i64)8) || ((i64)((*p).nameid)==(i64)7)) {
            cc_lib_printunit(f,(*p).code,(i64)-3,(byte*)"*");
        };
    };
}

void cc_lib_printstflat(void * f) {
    i64 i;
    struct cc_decls_strec *  p;
    i64 av_1;
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_str((byte*)"GLOBAL SYMBOL TABLE:",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    L514 :;
    for (i=(i64)0;i<=(cc_decls_hstsize - (i64)1);i+=(i64)1) {
L515 :;
        p = (*cc_decls_hashtable)[(i)];
        if (!!((*p).name)) {
            if (((i64)((*p).symbol)==(i64)68)) {
                msysnewc_m_print_startfile(f);
                msysnewc_m_print_i64(i,NULL);
                msysnewc_m_print_ptr(p,NULL);
                msysnewc_m_print_str((byte*)":",NULL);
                msysnewc_m_print_str(cc_lib_getstname(p),NULL);
                msysnewc_m_print_str(cc_tables_symbolnames[((i64)((*p).symbol))-1],NULL);
                msysnewc_m_print_str(cc_tables_namenames[((i64)((*p).nameid))],NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                p = (*p).nextdupl;
                L518 :;
                while (!!(p)) {
                    msysnewc_m_print_startfile(f);
                    msysnewc_m_print_str((byte*)"\t",NULL);
                    msysnewc_m_print_ptr(p,NULL);
                    msysnewc_m_print_str(cc_lib_getstname(p),NULL);
                    msysnewc_m_print_str(cc_tables_symbolnames[((i64)((*p).symbol))-1],NULL);
                    msysnewc_m_print_str(cc_tables_namenames[((i64)((*p).nameid))],NULL);
                    msysnewc_m_print_ptr((*p).prevdupl,NULL);
                    msysnewc_m_print_end();
                    ;
                    msysnewc_m_print_startfile(f);
                    msysnewc_m_print_str((byte*)"(From",NULL);
                    msysnewc_m_print_str((!!((*p).owner)?cc_lib_getstname((*p).owner):(byte*)"-"),NULL);
                    msysnewc_m_print_nogap();
                    msysnewc_m_print_str((byte*)")",NULL);
                    msysnewc_m_print_newline();
                    msysnewc_m_print_end();
                    ;
                    p = (*p).nextdupl;
L519 :;
                }L520 :;
                ;
            };
        };
L516 :;
    }L517 :;
    ;
}

struct cc_decls_unitrec * cc_lib_createname(struct cc_decls_strec * p) {
    struct cc_decls_unitrec *  u;
    u = cc_lib_allocunitrec();
    (*u).tag = (i64)3;
    (*u).def = p;
    (*u).simple = (u64)((i64)1);
    return u;
}

struct cc_decls_unitrec * cc_lib_createunit0(i64 tag) {
    struct cc_decls_unitrec *  u;
    u = cc_lib_allocunitrec();
    (*u).tag = tag;
    return u;
}

struct cc_decls_unitrec * cc_lib_createunit1(i64 tag,struct cc_decls_unitrec * p) {
    struct cc_decls_unitrec *  u;
    u = cc_lib_allocunitrec();
    (*u).tag = tag;
    (*u).a = p;
    return u;
}

struct cc_decls_unitrec * cc_lib_createunit2(i64 tag,struct cc_decls_unitrec * p,struct cc_decls_unitrec * q) {
    struct cc_decls_unitrec *  u;
    u = cc_lib_allocunitrec();
    (*u).tag = tag;
    (*u).a = p;
    (*u).b = q;
    return u;
}

struct cc_decls_unitrec * cc_lib_createunit3(i64 tag,struct cc_decls_unitrec * p,struct cc_decls_unitrec * q,struct cc_decls_unitrec * r) {
    struct cc_decls_unitrec *  u;
    u = cc_lib_allocunitrec();
    (*u).tag = tag;
    (*u).a = p;
    (*u).b = q;
    (*u).c = r;
    return u;
}

struct cc_decls_unitrec * cc_lib_createconstunit(u64 a,i64 t) {
    struct cc_decls_unitrec *  u;
    u = cc_lib_allocunitrec();
    (*u).tag = (i64)1;
    (*u).value = (i64)(a);
    (*u).mode = t;
    (*u).simple = (u64)((i64)1);
    return u;
}

struct cc_decls_unitrec * cc_lib_createstringconstunit(byte * s,i64 length) {
    struct cc_decls_unitrec *  u;
    u = cc_lib_allocunitrec();
    (*u).tag = (i64)1;
    (*u).svalue = s;
    (*u).mode = cc_decls_trefchar;
    if ((length == (i64)-1)) {
        (*u).slength = (i64)(strlen((i8 *)(s)));
    } else {
        (*u).slength = length;
    };
    (*u).isstrconst = (u64)((i64)1);
    (*u).simple = (u64)((i64)1);
    return u;
}

struct cc_decls_unitrec * cc_lib_createwstringconstunit(u16 * s,i64 length) {
    struct cc_decls_unitrec *  u;
    u = cc_lib_allocunitrec();
    (*u).tag = (i64)1;
    (*u).wsvalue = s;
    (*u).mode = cc_decls_trefwchar;
    (*u).wslength = length;
    (*u).iswstrconst = (u64)((i64)1);
    (*u).simple = (u64)((i64)1);
    return u;
}

i64 cc_lib_getoptocode(i64 opc) {
    static i16 opctotable[79];
    i64 opcto;
    i64 i;
    byte str[20];
    i64 av_1;
    opcto = (i64)(opctotable[(opc)]);
    if (!!(opcto)) {
        return opcto;
    };
    strcpy((i8 *)(str),(i8 *)(cc_tables_jtagnames[(opc)]));
    strcat((i8 *)(str),(i8 *)((byte*)"to"));
    L521 :;
    for (i=(i64)0;i<=(i64)78;i+=(i64)1) {
L522 :;
        if (!!(mlib_eqstring(cc_tables_jtagnames[(i)],str))) {
            opctotable[(opc)] = i;
            return i;
        };
L523 :;
    }L524 :;
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(cc_tables_jtagnames[(opc)],NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    cc_support_serror((byte*)"Can't find -to version");
    return (i64)0;
}

i64 cc_lib_getconstvalue(struct cc_decls_unitrec * p,i64 id) {
    if ((!!(p) && ((i64)((*p).tag) == (i64)1))) {
        return (*p).value;
    };
    cc_support_serror((byte*)"GCV Not constant");
    return (i64)0;
}

byte * cc_lib_nextautotype(void) {
    static byte str[32];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str((byte*)"$T",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_i64(++cc_lib_autotypeno,NULL);
    msysnewc_m_print_end();
    ;
    return str;
}

i64 cc_lib_createconstmode(i64 m) {
    i64 newm;
    if (!!((u64)(cc_decls_ttconst[(m)]))) {
        return m;
    };
    if (!!(cc_decls_ttconsttype[(m)])) {
        return cc_decls_ttconsttype[(m)];
    };
    newm = cc_lib_copymode(m);
    cc_decls_ttconsttype[(m)] = newm;
    cc_decls_ttconst[(newm)] = (u64)((i64)1);
    cc_decls_ttconsttype[(newm)] = m;
    return newm;
}

i64 cc_lib_createrefmode(i64 m) {
    i64 newm;
    if (!!(cc_decls_ttreftype[(m)])) {
        return cc_decls_ttreftype[(m)];
    };
    newm = cc_lib_createnewmode((i64)16);
    cc_decls_ttreftype[(m)] = newm;
    cc_decls_tttarget[(newm)] = m;
    cc_decls_ttisref[(newm)] = (u64)((i64)1);
    return newm;
}

i64 cc_lib_createprocmode(i64 m,struct cc_decls_paramrec * pm) {
    i64 newm;
    newm = cc_lib_createnewmode((i64)17);
    cc_decls_ttparams[(newm)] = pm;
    cc_decls_tttarget[(newm)] = m;
    return newm;
}

i64 cc_lib_createarraymode(i64 m,i64 length) {
    i64 newm;
    newm = cc_lib_createnewmode((i64)19);
    cc_decls_tttarget[(newm)] = m;
    cc_decls_ttlength[(newm)] = length;
    cc_decls_ttsize[(newm)] = (length * cc_decls_ttsize[(m)]);
    return newm;
}

i64 cc_lib_createenummode(struct cc_decls_strec * e) {
    i64 newm;
    newm = cc_lib_createnewmode((i64)15);
    cc_decls_ttnamedef[(newm)] = e;
    return newm;
}

i64 cc_lib_createstructmode(struct cc_decls_strec * s,i64 smode) {
    i64 newm;
    newm = cc_lib_createnewmode(smode);
    cc_decls_ttnamedef[(newm)] = s;
    return newm;
}

void cc_lib_setnameptr(struct cc_decls_unitrec * p) {
    (*(*p).def).code = p;
}

void cc_lib_printcode_all(void * f,byte * caption) {
    i64 i;
    L525 :;
    for (i=(i64)1;i<=cc_decls_nmodules;i+=(i64)1) {
L526 :;
        cc_lib_printcode(f,caption,i);
L527 :;
    }L528 :;
    ;
}

void cc_lib_printcode(void * f,byte * caption,i64 n) {
    struct cc_decls_strec *  p;
    p = (*cc_decls_moduletable[(n)].stmodule).deflist;
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_str(caption,NULL);
    msysnewc_m_print_str((byte*)"MODULE:",NULL);
    msysnewc_m_print_str(cc_decls_moduletable[(n)].name,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    L529 :;
    while (!!(p)) {
        if (((i64)((*p).nameid)==(i64)6)) {
            if (!!((*p).code)) {
                msysnewc_m_print_startfile(f);
                msysnewc_m_print_str((*p).name,NULL);
                msysnewc_m_print_nogap();
                msysnewc_m_print_str((byte*)"=",NULL);
                msysnewc_m_print_str(cc_tables_scopenames[((i64)((*p).scope))],NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                cc_lib_printunit(f,(*p).code,(i64)0,(byte*)"1");
                msysnewc_m_print_startfile(f);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
            };
        };
        p = (*p).nextdef;
L530 :;
    }L531 :;
    ;
}

void cc_lib_printunit(void * dev,struct cc_decls_unitrec * p,i64 level,byte * prefix) {
    struct cc_decls_strec *  d;
    i64 t;
    i64 n;
    i64 lincr;
    byte *  idname;
    struct cc_decls_caserec *  pc;
    if ((p == 0)) {
        return;
    };
    if (((i64)((*p).tag) >= (i64)78)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"print unit: bad tag",NULL);
        msysnewc_m_print_i64((*p).tag,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        osnos_os_getch();
        exit((i64)30);
    };
    if (!!((u64)((*p).lineno))) {
        cc_lib_currlineno = (i64)((*p).lineno);
    };
    lincr = (i64)1;
    if ((level < (i64)0)) {
        lincr = (i64)-1;
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((byte*)"             ",NULL);
        msysnewc_m_print_end();
        ;
    };
    msysnewc_m_print_startfile(dev);
    msysnewc_m_print_str(cc_lib_getprefix(labs(level),prefix,p),NULL);
    msysnewc_m_print_end();
    ;
    idname = cc_tables_jtagnames[((i64)((*p).tag))];
    if (((u64)((*idname)) == 'j')) {
        idname += (i64)2;
    };
    msysnewc_m_print_startfile(dev);
    msysnewc_m_print_str(idname,NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str((byte*)": ",NULL);
    msysnewc_m_print_end();
    ;
    if (((i64)((*p).tag)==(i64)3) || ((i64)((*p).tag)==(i64)5)) {
        d = (*p).def;
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((*d).name,NULL);
        msysnewc_m_print_str(cc_tables_namenames[((i64)((*d).nameid))],NULL);
        msysnewc_m_print_end();
        ;
        if (!!((*d).code)) {
            msysnewc_m_print_startfile(dev);
            msysnewc_m_print_str((byte*)" {",NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str(cc_tables_jtagnames[((i64)((*(*d).code).tag))],NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str((byte*)"}",NULL);
            msysnewc_m_print_end();
            ;
        };
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((byte*)" ",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(cc_lib_getdottedname(d),NULL);
        msysnewc_m_print_end();
        ;
        if (!!((*p).c)) {
            msysnewc_m_print_startfile(dev);
            msysnewc_m_print_str((byte*)" Lastcall:",NULL);
            msysnewc_m_print_ptr((*p).c,NULL);
            msysnewc_m_print_end();
            ;
        };
    }else if (((i64)((*p).tag)==(i64)7) || ((i64)((*p).tag)==(i64)8) || ((i64)((*p).tag)==(i64)17)) {
        d = (*p).def;
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((*d).name,NULL);
        msysnewc_m_print_str(cc_tables_namenames[((i64)((*d).nameid))],NULL);
        msysnewc_m_print_end();
        ;
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        cc_lib_printunit(dev,(*d).code,(level + lincr),(byte*)"1");
        return;
    }else if (((i64)((*p).tag)==(i64)17)) {
        d = (*p).def;
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((*d).name,NULL);
        msysnewc_m_print_str(cc_tables_namenames[((i64)((*d).nameid))],NULL);
        msysnewc_m_print_end();
        ;
    }else if (((i64)((*p).tag)==(i64)18)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((*(*p).def).name,NULL);
        msysnewc_m_print_end();
        ;
    }else if (((i64)((*p).tag)==(i64)19)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((byte*)"Index:",NULL);
        msysnewc_m_print_i64((*p).index,NULL);
        msysnewc_m_print_end();
        ;
    }else if (((i64)((*p).tag)==(i64)1)) {
        t = (i64)((*p).mode);
        if ((t == cc_decls_trefchar)) {
            if (!(!!((u64)((*p).isstrconst)))) {
                goto L532 ;
;
            };
            /*dostring:*/
L533 :;
;
            if (((i64)((*p).slength) > (i64)256)) {
                msysnewc_m_print_startfile(dev);
                msysnewc_m_print_str((byte*)"\"",NULL);
                msysnewc_m_print_nogap();
                msysnewc_m_print_str((byte*)"(LONGSTR)",NULL);
                msysnewc_m_print_str((byte*)"\" *",NULL);
                msysnewc_m_print_nogap();
                msysnewc_m_print_i64((*p).slength,NULL);
                msysnewc_m_print_end();
                ;
            } else {
                msysnewc_m_print_startfile(dev);
                msysnewc_m_print_str((byte*)"\"",NULL);
                msysnewc_m_print_nogap();
                msysnewc_m_print_str((*p).svalue,NULL);
                msysnewc_m_print_nogap();
                msysnewc_m_print_str((byte*)"\" *",NULL);
                msysnewc_m_print_nogap();
                msysnewc_m_print_i64((*p).slength,NULL);
                msysnewc_m_print_end();
                ;
            };
        } else if ((t == cc_decls_trefwchar)) {
            if (!(!!((u64)((*p).iswstrconst)))) {
                goto L532 ;
;
            };
            msysnewc_m_print_startfile(dev);
            msysnewc_m_print_str((byte*)"\"",NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str((byte*)"(WSTRING)",NULL);
            msysnewc_m_print_str((byte*)"\" *",NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_i64((*p).wslength,NULL);
            msysnewc_m_print_end();
            ;
        } else if (((t >= (i64)2) && (t <= (i64)5))) {
            msysnewc_m_print_startfile(dev);
            msysnewc_m_print_i64((*p).value,NULL);
            msysnewc_m_print_end();
            ;
        } else if (((t >= (i64)7) && (t <= (i64)10))) {
            msysnewc_m_print_startfile(dev);
            msysnewc_m_print_u64((*p).uvalue,NULL);
            msysnewc_m_print_end();
            ;
        } else if (!!(cc_lib_isrealcc(t))) {
            msysnewc_m_print_startfile(dev);
            msysnewc_m_print_r64((*p).xvalue,NULL);
            msysnewc_m_print_end();
            ;
        } else if ((cc_decls_ttbasetype[(t)] == (i64)16)) {
            if (!!((u64)((*p).isstrconst))) {
                goto L533 ;
;
            };
            /*doref:*/
L532 :;
;
            msysnewc_m_print_startfile(dev);
            msysnewc_m_print_ptr((void *)(u32)((*p).value),NULL);
            msysnewc_m_print_end();
            ;
        } else if ((cc_decls_ttbasetype[(t)] == (i64)19)) {
            if (!!((u64)((*p).isstrconst))) {
                goto L533 ;
;
            };
            cc_support_serror((byte*)"PRINTUNIT/CONST/aRRAY");
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(cc_lib_typename(t),NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            cc_support_serror((byte*)"PRINTUNIT BAD CONST");
        };
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((byte*)" ",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(cc_lib_strmode(t,(i64)1),NULL);
        msysnewc_m_print_end();
        ;
        if (!!((u64)((*p).isstrconst))) {
            msysnewc_m_print_startfile(dev);
            msysnewc_m_print_str((byte*)"<STRCONST>",NULL);
            msysnewc_m_print_end();
            ;
        };
        if (!!((u64)((*p).iswstrconst))) {
            msysnewc_m_print_startfile(dev);
            msysnewc_m_print_str((byte*)"<WSTRCONST>",NULL);
            msysnewc_m_print_end();
            ;
        };
    }else if (((i64)((*p).tag)==(i64)57)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str(cc_tables_convnames[((i64)((*p).opcode))],NULL);
        msysnewc_m_print_end();
        ;
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((byte*)" ",NULL);
        msysnewc_m_print_end();
        ;
        if (!!((u64)((*p).convmem))) {
            msysnewc_m_print_startfile(dev);
            msysnewc_m_print_str((byte*)"Mem:",NULL);
            msysnewc_m_print_end();
            ;
        };
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str(cc_lib_typename((i64)((*(*p).a).mode)),NULL);
        msysnewc_m_print_end();
        ;
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((byte*)" => ",NULL);
        msysnewc_m_print_end();
        ;
        if (!!((u64)((*p).convtomem))) {
            msysnewc_m_print_startfile(dev);
            msysnewc_m_print_str((byte*)"Mem:",NULL);
            msysnewc_m_print_end();
            ;
        };
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str(cc_lib_typename((i64)((*p).mode)),NULL);
        msysnewc_m_print_end();
        ;
    }else if (((i64)((*p).tag)==(i64)58)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((byte*)"Scale:",NULL);
        msysnewc_m_print_i64((*p).scale,NULL);
        msysnewc_m_print_end();
        ;
    }else if (((i64)((*p).tag)==(i64)54) || ((i64)((*p).tag)==(i64)55)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((byte*)"Ptrscale:",NULL);
        msysnewc_m_print_i64((*p).ptrscale,NULL);
        msysnewc_m_print_end();
        ;
    }else if (((i64)((*p).tag)==(i64)23)) {
        pc = (*p).nextcase;
        n = (i64)0;
        L534 :;
        while (!!(pc)) {
            ++n;
            pc = (*pc).nextcase;
L535 :;
        }L536 :;
        ;
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_ptr((*p).nextcase,NULL);
        msysnewc_m_print_i64(n,NULL);
        msysnewc_m_print_end();
        ;
    }else if (((i64)((*p).tag)==(i64)31)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((byte*)" Aparams:",NULL);
        msysnewc_m_print_i64((*p).aparams,NULL);
        msysnewc_m_print_end();
        ;
    }else if (((i64)((*p).tag)==(i64)53)) {
    }else if (((i64)((*p).tag)==(i64)50)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((byte*)" Offset:",NULL);
        msysnewc_m_print_i64((*p).offset,NULL);
        msysnewc_m_print_end();
        ;
    };
    if (!!((i64)((*p).alength))) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((byte*)" ALENGTH=",NULL);
        msysnewc_m_print_i64((*p).alength,NULL);
        msysnewc_m_print_end();
        ;
    };
    msysnewc_m_print_startfile(dev);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    cc_lib_printunitlist(dev,(*p).a,(level + lincr),(byte*)"1");
    cc_lib_printunitlist(dev,(*p).b,(level + lincr),(byte*)"2");
    if (((i64)((*p).tag) != (i64)6)) {
        cc_lib_printunitlist(dev,(*p).c,(level + lincr),(byte*)"3");
    };
}

static void cc_lib_printunitlist(void * dev,struct cc_decls_unitrec * p,i64 level,byte * prefix) {
    if ((p == 0)) {
        return;
    };
    L537 :;
    while (!!(p)) {
        cc_lib_printunit(dev,p,level,prefix);
        p = (*p).nextunit;
L538 :;
    }L539 :;
    ;
}

static byte * cc_lib_getprefix(i64 level,byte * prefix,struct cc_decls_unitrec * p) {
    static byte str[512];
    byte indentstr[512];
    byte *  modestr;
    i64 length;
    i64 av_1;
    indentstr[((i64)1)-1] = (u64)0u;
    if ((level > (i64)10)) {
        level = (i64)10;
    };
    strcpy((i8 *)(indentstr),(i8 *)((byte*)"-----------------------"));
    modestr = cc_lib_strmode((i64)((*p).mode),(i64)0);
    length = (i64)(strlen((i8 *)(modestr)));
    if ((length < (i64)((u64)(strlen((i8 *)(indentstr)))))) {
        memcpy((void *)(indentstr),(void *)(modestr),(u32)(length));
    } else {
        strcpy((i8 *)(indentstr),(i8 *)(modestr));
    };
    av_1 = level;
    while (av_1-- > 0) {
L540 :;
        strcat((i8 *)(indentstr),(i8 *)((byte*)"|---"));
L541 :;
    }L542 :;
    ;
    strcpy((i8 *)(str),(i8 *)(cc_lib_getlineinfok()));
    strcat((i8 *)(str),(i8 *)(indentstr));
    strcat((i8 *)(str),(i8 *)(prefix));
    if (!!((u64)((*prefix)))) {
        strcat((i8 *)(str),(i8 *)((byte*)" "));
    };
    return str;
}

byte * cc_lib_getdottedname(struct cc_decls_strec * p) {
    static byte str[256];
    byte str2[256];
    struct cc_decls_strec *  owner;
    strcpy((i8 *)(str),(i8 *)((*p).name));
    owner = (*p).owner;
    L543 :;
    while ((!!(owner) && ((i64)((u64)((*owner).nameid)) != (i64)2))) {
        strcpy((i8 *)(str2),(i8 *)(str));
        strcpy((i8 *)(str),(i8 *)((*owner).name));
        strcat((i8 *)(str),(i8 *)((byte*)"."));
        strcat((i8 *)(str),(i8 *)(str2));
        owner = (*owner).owner;
L544 :;
    }L545 :;
    ;
    if (!!((u64)((*p).blockno))) {
        msysnewc_m_print_startstr(str2);
        msysnewc_m_print_str((byte*)".",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_u64((*p).blockno,NULL);
        msysnewc_m_print_end();
        ;
        strcat((i8 *)(str),(i8 *)(str2));
    };
    return str;
}

static byte * cc_lib_getlineinfok(void) {
    static byte str[40];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_setfmt((byte*)"# ");
    msysnewc_m_print_i64(cc_lib_currlineno,(byte*)"z5");
    msysnewc_m_print_end();
    ;
    return str;
}

struct cc_decls_strec * cc_lib_getautofieldname(void) {
    byte str[32];
    byte *  name;
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str((byte*)"$F",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_i64(++cc_lib_nextafindex,NULL);
    msysnewc_m_print_end();
    ;
    name = mlib_pcm_copyheapstring(str);
    return cc_lex_addnamestr(name);
}

void cc_lib_convertstring(byte * s,byte * t,i64 length) {
    i64 c;
    byte str[20];
    byte *  t0;
    i64 av_1;
    if ((length == (i64)-1)) {
        length = (i64)(strlen((i8 *)(s)));
    };
    t0 = t;
    av_1 = length;
    while (av_1-- > 0) {
L546 :;
        c = (i64)((*s++));
        switch ((int)c) {
        case 34:;
        {
            (*t++) = (u64)92u;
            (*t++) = '"';
        }break;
        case 39:;
        {
            (*t++) = (u64)92u;
            (*t++) = (u64)39u;
        }break;
        case 10:;
        {
            (*t++) = (u64)92u;
            (*t++) = 'n';
        }break;
        case 13:;
        {
            (*t++) = (u64)92u;
            (*t++) = 'r';
        }break;
        case 9:;
        {
            (*t++) = (u64)92u;
            (*t++) = 't';
        }break;
        case 92:;
        {
            (*t++) = (u64)92u;
            (*t++) = (u64)92u;
        }break;
        case 7:;
        {
            (*t++) = (u64)92u;
            (*t++) = 'a';
        }break;
        case 8:;
        {
            (*t++) = (u64)92u;
            (*t++) = 'b';
        }break;
        case 12:;
        {
            (*t++) = (u64)92u;
            (*t++) = 'f';
        }break;
        case 11:;
        {
            (*t++) = (u64)92u;
            (*t++) = 'v';
        }break;
        default: {
            if (((c < (i64)32) || (c >= (i64)127))) {
                msysnewc_m_print_startstr(str);
                msysnewc_m_print_setfmt((byte*)"\\#o");
                msysnewc_m_print_i64(c,(byte*)"z3");
                msysnewc_m_print_end();
                ;
                (*t++) = (u64)(str[((i64)1)-1]);
                (*t++) = (u64)(str[((i64)2)-1]);
                (*t++) = (u64)(str[((i64)3)-1]);
                (*t++) = (u64)(str[((i64)4)-1]);
            } else {
                (*t++) = (u64)(c);
            };
        }
        } /* SW */
;
L547 :;
    }L548 :;
    ;
    (*t) = (u64)0u;
}

struct mlib_strbuffer * cc_lib_strexpr(struct cc_decls_unitrec * p) {
    mlib_gs_init(cc_lib_exprstr);
    cc_lib_jeval(cc_lib_exprstr,p);
    return cc_lib_exprstr;
}

static void cc_lib_jeval(struct mlib_strbuffer * dest,struct cc_decls_unitrec * p) {
    struct cc_decls_unitrec *  q;
    byte str[16000];
    i64 lb;
    i64 t;
    if (((i64)((*p).tag)==(i64)1)) {
        if (((t = (i64)((*p).mode)) == cc_decls_trefchar)) {
            if (((i64)((*p).slength) == (i64)0)) {
                goto L549 ;
;
            };
            if (!(!!((u64)((*p).isstrconst)))) {
                goto L549 ;
;
            };
            if (((i64)((*p).slength) > (i64)8000)) {
                strcpy((i8 *)(str),(i8 *)((byte*)"LONGSTR)"));
            } else {
                cc_lib_convertstring((*p).svalue,str,(i64)-1);
            };
            cc_support_gs_additem(dest,(byte*)"\"");
            cc_support_gs_additem(dest,str);
            cc_support_gs_additem(dest,(byte*)"\"");
            return;
        } else if (((t >= (i64)2) && (t <= (i64)5))) {
            msysnewc_getstrint((*p).value,str);
        } else if (((t >= (i64)7) && (t <= (i64)10))) {
            strcpy((i8 *)(str),(i8 *)(msysnewc_strword((*p).uvalue,(byte *)(0))));
        } else if (((t == (i64)12) || (t == (i64)11))) {
            strcpy((i8 *)(str),(i8 *)(msysnewc_strreal((*p).xvalue,(byte *)(0))));
        } else {
            if ((cc_decls_ttbasetype[((i64)((*p).mode))]==(i64)16)) {
                /*doref:*/
L549 :;
;
                msysnewc_m_print_startstr(str);
                msysnewc_m_print_ptr((void *)((*p).svalue),NULL);
                msysnewc_m_print_end();
                ;
            }else if ((cc_decls_ttbasetype[((i64)((*p).mode))]==(i64)19)) {
                strcpy((i8 *)(str),(i8 *)((byte*)"ARRAY"));
            } else {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str(cc_lib_typename((i64)((*p).mode)),NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                cc_support_nxerror((byte*)"EVAL/CONST",p);
            };
        };
        cc_support_gs_additem(dest,str);
    }else if (((i64)((*p).tag)==(i64)3)) {
        cc_support_gs_additem(dest,(*(*p).def).name);
    }else if (((i64)((*p).tag)==(i64)5)) {
        mlib_gs_str(dest,(byte*)"&");
        cc_support_gs_additem(dest,(*(*p).def).name);
    }else if (((i64)((*p).tag)==(i64)25) || ((i64)((*p).tag)==(i64)26) || ((i64)((*p).tag)==(i64)33) || ((i64)((*p).tag)==(i64)34) || ((i64)((*p).tag)==(i64)35) || ((i64)((*p).tag)==(i64)36) || ((i64)((*p).tag)==(i64)37) || ((i64)((*p).tag)==(i64)38) || ((i64)((*p).tag)==(i64)39) || ((i64)((*p).tag)==(i64)40) || ((i64)((*p).tag)==(i64)41) || ((i64)((*p).tag)==(i64)42) || ((i64)((*p).tag)==(i64)43) || ((i64)((*p).tag)==(i64)44) || ((i64)((*p).tag)==(i64)45) || ((i64)((*p).tag)==(i64)46) || ((i64)((*p).tag)==(i64)47) || ((i64)((*p).tag)==(i64)48) || ((i64)((*p).tag)==(i64)49) || ((i64)((*p).tag)==(i64)62) || ((i64)((*p).tag)==(i64)63) || ((i64)((*p).tag)==(i64)64) || ((i64)((*p).tag)==(i64)65) || ((i64)((*p).tag)==(i64)66) || ((i64)((*p).tag)==(i64)67) || ((i64)((*p).tag)==(i64)68) || ((i64)((*p).tag)==(i64)69) || ((i64)((*p).tag)==(i64)70) || ((i64)((*p).tag)==(i64)71)) {
        strcpy((i8 *)(str),(i8 *)(cc_lib_getopcjname((i64)((*p).tag))));
        cc_support_gs_additem(dest,(byte*)"(");
        cc_lib_jeval(dest,(*p).a);
        cc_support_gs_additem(dest,str);
        cc_lib_jeval(dest,(*p).b);
        cc_support_gs_additem(dest,(byte*)")");
    }else if (((i64)((*p).tag)==(i64)59) || ((i64)((*p).tag)==(i64)60) || ((i64)((*p).tag)==(i64)61) || ((i64)((*p).tag)==(i64)27) || ((i64)((*p).tag)==(i64)28)) {
        strcpy((i8 *)(str),(i8 *)(cc_lib_getopcjname((i64)((*p).tag))));
        cc_support_gs_additem(dest,str);
        cc_support_gs_additem(dest,(byte*)"(");
        cc_lib_jeval(dest,(*p).a);
        cc_support_gs_additem(dest,(byte*)")");
    }else if (((i64)((*p).tag)==(i64)31)) {
        cc_lib_jeval(dest,(*p).a);
        cc_support_gs_additem(dest,(byte*)"(");
        q = (*p).b;
        L550 :;
        while (!!(q)) {
            cc_lib_jeval(dest,q);
            q = (*q).nextunit;
            if (!!(q)) {
                cc_support_gs_additem(dest,(byte*)",");
            };
L551 :;
        }L552 :;
        ;
        cc_support_gs_additem(dest,(byte*)")");
    }else if (((i64)((*p).tag)==(i64)50)) {
        cc_lib_jeval(dest,(*p).a);
        cc_support_gs_additem(dest,(byte*)".");
        mlib_gs_str(dest,(byte*)"???");
    }else if (((i64)((*p).tag)==(i64)51)) {
        cc_lib_jeval(dest,(*p).a);
        cc_support_gs_additem(dest,(byte*)"->");
        cc_lib_jeval(dest,(*p).b);
    }else if (((i64)((*p).tag)==(i64)29) || ((i64)((*p).tag)==(i64)30)) {
        lb = ((i64)((*p).tag) == (i64)30);
        cc_support_gs_additem(dest,(!!(lb)?(byte*)"(":(byte*)"{"));
        q = (*p).a;
        L553 :;
        while (!!(q)) {
            cc_lib_jeval(dest,q);
            q = (*q).nextunit;
            if (!!(q)) {
                cc_support_gs_additem(dest,(byte*)",");
            };
L554 :;
        }L555 :;
        ;
        cc_support_gs_additem(dest,(!!(lb)?(byte*)")":(byte*)"}"));
    }else if (((i64)((*p).tag)==(i64)12)) {
        cc_lib_jeval(dest,(*p).a);
        cc_support_gs_additem(dest,(byte*)"=");
        cc_lib_jeval(dest,(*p).b);
    }else if (((i64)((*p).tag)==(i64)32)) {
        cc_lib_jeval(dest,(*p).a);
        cc_support_gs_additem(dest,(byte*)"?");
        cc_lib_jeval(dest,(*p).b);
        cc_support_gs_additem(dest,(byte*)":");
        cc_lib_jeval(dest,(*p).c);
    }else if (((i64)((*p).tag)==(i64)57)) {
        cc_support_gs_additem(dest,cc_lib_strmode((i64)((*p).mode),(i64)1));
        cc_support_gs_additem(dest,(byte*)"(");
        cc_lib_jeval(dest,(*p).a);
        cc_support_gs_additem(dest,(byte*)")");
    }else if (((i64)((*p).tag)==(i64)53)) {
        cc_support_gs_additem(dest,(byte*)"*(");
        cc_lib_jeval(dest,(*p).a);
        if (!!((*p).b)) {
            cc_support_gs_additem(dest,(byte*)"+");
            cc_lib_jeval(dest,(*p).b);
        };
        cc_support_gs_additem(dest,(byte*)")");
    }else if (((i64)((*p).tag)==(i64)6)) {
        cc_support_gs_additem(dest,(byte*)"<JBLOCK>");
    }else if (((i64)((*p).tag)==(i64)73)) {
        cc_support_gs_additem(dest,(byte*)"++");
        cc_lib_jeval(dest,(*p).a);
    }else if (((i64)((*p).tag)==(i64)74)) {
        cc_support_gs_additem(dest,(byte*)"--");
        cc_lib_jeval(dest,(*p).a);
    }else if (((i64)((*p).tag)==(i64)75)) {
        cc_lib_jeval(dest,(*p).a);
        cc_support_gs_additem(dest,(byte*)"++");
    }else if (((i64)((*p).tag)==(i64)76)) {
        cc_lib_jeval(dest,(*p).a);
        cc_support_gs_additem(dest,(byte*)"--");
    }else if (((i64)((*p).tag)==(i64)2)) {
        mlib_gs_str(dest,(byte*)"<nullunit>");
    }else if (((i64)((*p).tag)==(i64)58)) {
        mlib_gs_str(dest,(byte*)"scale((");
        cc_lib_jeval(dest,(*p).a);
        if (((i64)((*p).scale) > (i64)0)) {
            mlib_gs_str(dest,(byte*)")*");
            mlib_gs_strint(dest,(i64)((*p).scale));
        } else {
            mlib_gs_str(dest,(byte*)")/");
            mlib_gs_strint(dest,-((i64)((*p).scale)));
        };
        mlib_gs_str(dest,(byte*)")");
    } else {
        mlib_gs_str(dest,(byte*)"<CAN'T DO JEVAL>");
    };
}

byte * cc_lib_getopcjname(i64 opc) {
    static byte str[20];
    byte *  name;
    byte *  s;
    name = cc_tables_jtagnames[(opc)];
    s = (byte *)(strchr((i8 *)(name),(i32)32));
    if (!!(s)) {
        memcpy((void *)(str),(void *)(name),(u32)((s - name)));
        str[(((s - name) + (i64)1))-1] = (u64)0u;
        return str;
    } else {
        return name;
    };
}

byte * cc_lib_strmode(i64 m,i64 expand) {
    static byte str[16384];
    cc_lib_istrmode(m,expand,str);
    return str;
}

byte * cc_lib_strmode2(i64 m,i64 expand) {
    static byte str[16384];
    cc_lib_istrmode(m,expand,str);
    return str;
}

void cc_lib_istrmode(i64 m,i64 expand,byte * dest) {
    struct cc_decls_strec *  d;
    struct cc_decls_strec *  q;
    i64 needcomma;
    i64 i;
    i64 target;
    i64 t;
    i64 n;
    struct mlib_strbuffer sxx;
    struct mlib_strbuffer *  xx;
    struct cc_decls_paramrec *  pm;
    xx = &sxx;
    if ((m < (i64)22)) {
        strcpy((i8 *)(dest),(i8 *)(cc_lib_typename(m)));
        return;
    };
    t = cc_decls_ttbasetype[(m)];
    if ((t==(i64)16)) {
        if (!!((u64)(cc_decls_ttconst[(m)]))) {
            strcpy((i8 *)(dest),(i8 *)((byte*)"const ref "));
        } else {
            strcpy((i8 *)(dest),(i8 *)((byte*)"ref "));
        };
        target = cc_decls_tttarget[(m)];
        if (((target >= (i64)0) && (cc_decls_ttbasetype[(cc_decls_tttarget[(m)])] == (i64)20))) {
            strcat((i8 *)(dest),(i8 *)(cc_lib_typename(cc_decls_tttarget[(m)])));
        } else {
            cc_lib_istrmode(cc_decls_tttarget[(m)],(i64)0,(dest + (i64)(strlen((i8 *)(dest)))));
        };
    }else if ((t==(i64)19)) {
        if (!!(cc_decls_ttlength[(m)])) {
            msysnewc_m_print_startstr(dest);
            msysnewc_m_print_setfmt((byte*)"[#]");
            msysnewc_m_print_i64(cc_decls_ttlength[(m)],NULL);
            msysnewc_m_print_end();
            ;
        } else {
            strcpy((i8 *)(dest),(i8 *)((byte*)"[]"));
        };
        cc_lib_istrmode(cc_decls_tttarget[(m)],(i64)0,(dest + (i64)(strlen((i8 *)(dest)))));
    }else if ((t==(i64)15)) {
        strcpy((i8 *)(dest),(i8 *)((byte*)"enum "));
        strcat((i8 *)(dest),(i8 *)(cc_lib_typename(m)));
    }else if ((t==(i64)20) || (t==(i64)21)) {
        if (!(!!(expand))) {
            strcpy((i8 *)(dest),(i8 *)(cc_lib_typename(m)));
            return;
        };
        strcpy((i8 *)(dest),(i8 *)(cc_lib_typename(cc_decls_ttbasetype[(m)])));
        strcat((i8 *)(dest),(i8 *)((byte*)"("));
        d = cc_decls_ttnamedef[(m)];
        needcomma = (i64)0;
        q = (*d).deflist;
        L556 :;
        while (!!(q)) {
            if (!!(needcomma)) {
                strcat((i8 *)(dest),(i8 *)((byte*)","));
            };
            needcomma = (i64)1;
            cc_lib_istrmode((i64)((*q).mode),(i64)0,(dest + (i64)(strlen((i8 *)(dest)))));
            strcat((i8 *)(dest),(i8 *)((byte*)" "));
            strcat((i8 *)(dest),(i8 *)((*q).name));
            q = (*q).nextdef;
L557 :;
        }L558 :;
        ;
        strcat((i8 *)(dest),(i8 *)((byte*)")"));
    }else if ((t==(i64)1)) {
        strcpy((i8 *)(dest),(i8 *)(cc_lib_typename(m)));
    }else if ((t==(i64)17)) {
        strcpy((i8 *)(dest),(i8 *)((byte*)"proc[PM]("));
        pm = cc_decls_ttparams[(m)];
        n = (i64)((*pm).nparams);
        L559 :;
        for (i=(i64)1;i<=n;i+=(i64)1) {
L560 :;
            cc_lib_istrmode((i64)((*pm).mode),(i64)0,(dest + (i64)(strlen((i8 *)(dest)))));
            if ((i != n)) {
                strcat((i8 *)(dest),(i8 *)((byte*)","));
            };
            pm = (*pm).nextparam;
L561 :;
        }L562 :;
        ;
        strcat((i8 *)(dest),(i8 *)((byte*)")"));
        cc_lib_istrmode(cc_decls_tttarget[(m)],(i64)0,(dest + (i64)(strlen((i8 *)(dest)))));
    } else {
        if ((t < (i64)22)) {
            strcpy((i8 *)(dest),(i8 *)(cc_lib_typename(m)));
            return;
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(cc_lib_typename(m),NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            cc_support_mcerror((byte*)"NEWSTRMODE");
        };
    };
}

i64 cc_lib_countunits(struct cc_decls_unitrec * p) {
    i64 n;
    n = (i64)0;
    L563 :;
    while (!!(p)) {
        ++n;
        p = (*p).nextunit;
L564 :;
    }L565 :;
    ;
    return n;
}

static void cc_lib_purgesymbol(struct cc_decls_strec * p,struct cc_decls_strec * prev,i64 del) {
    struct cc_decls_strec *  q;
    if (((i64)((*p).nameid)==(i64)10)) {
        return;
    };
    cc_lib_purgesymbollist((*p).deflist,(i64)0,del);
    if (!!(prev)) {
        (*prev).nextdef = (*p).nextdef;
    } else {
        (*(*p).owner).deflist = (*p).nextdef;
    };
    q = (*p).prevdupl;
    (*q).nextdupl = (*p).nextdupl;
    if (!!(del)) {
        mlib_pcm_free((void *)(p),(i64)84);
    };
}

void cc_lib_purgesymbollist(struct cc_decls_strec * p,i64 ismodule,i64 del) {
    cc_support_serror((byte*)"PURGESYMBOL");
}

void cc_lib_purgeprocs(struct cc_decls_strec * p,i64 del) {
    L566 :;
    while (!!(p)) {
        if (((i64)((u64)((*p).nameid)) == (i64)6)) {
            cc_lib_purgeproc(p,del);
        };
        p = (*p).nextdef;
L567 :;
    }L568 :;
    ;
}

void cc_lib_purgeproc(struct cc_decls_strec * p,i64 del) {
    struct cc_decls_strec *  q;
    struct cc_decls_strec *  prev;
    struct cc_decls_strec *  r;
    q = (*p).deflist;
    prev = (struct cc_decls_strec *)(0);
    L569 :;
    while (!!(q)) {
        r = (*q).nextdef;
        if (((i64)((u64)((*q).nameid)) == (i64)8)) {
            cc_lib_purgesymbol(q,prev,del);
        } else {
            prev = q;
        };
        q = r;
L570 :;
    }L571 :;
    ;
}

void cc_lib_printmodelist(void * f) {
    byte *  mstr;
    struct mlib_strbuffer destv;
    struct mlib_strbuffer *  dest;
    i64 m;
    dest = &destv;
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_str((byte*)"MODELIST",NULL);
    msysnewc_m_print_i64(cc_decls_ntypes,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    mlib_gs_init(dest);
    mlib_gs_leftstr(dest,(byte*)"#",(i64)4,(i64)32);
    mlib_gs_leftstr(dest,(byte*)"Name",(i64)13,(i64)32);
    mlib_gs_leftstr(dest,(byte*)"Base",(i64)13,(i64)32);
    mlib_gs_leftstr(dest,(byte*)"Bit",(i64)3,(i64)32);
    mlib_gs_leftstr(dest,(byte*)"Target",(i64)14,(i64)32);
    mlib_gs_leftstr(dest,(byte*)"Len",(i64)4,(i64)32);
    mlib_gs_leftstr(dest,(byte*)"Size",(i64)5,(i64)32);
    mlib_gs_leftstr(dest,(byte*)"C",(i64)3,(i64)32);
    mlib_gs_leftstr(dest,(byte*)"R",(i64)3,(i64)32);
    mlib_gs_leftstr(dest,(byte*)"V",(i64)3,(i64)32);
    mlib_gs_leftstr(dest,(byte*)"@Cnst",(i64)5,(i64)32);
    mlib_gs_leftstr(dest,(byte*)"@Ref",(i64)5,(i64)32);
    mlib_gs_leftstr(dest,(byte*)"Tag",(i64)8,(i64)32);
    mlib_gs_leftstr(dest,(byte*)"Mode",(i64)32,(i64)32);
    mlib_gs_println(dest,f);
    L572 :;
    for (m=(i64)0;m<=cc_decls_ntypes;m+=(i64)1) {
L573 :;
        mlib_gs_init(dest);
        mlib_gs_leftint(dest,m,(i64)4,(i64)32);
        mlib_gs_leftstr(dest,cc_lib_typename(m),(i64)13,(i64)32);
        mlib_gs_leftstr(dest,cc_lib_typename(cc_decls_ttbasetype[(m)]),(i64)13,(i64)32);
        mlib_gs_leftint(dest,cc_decls_ttbitwidth[(m)],(i64)3,(i64)32);
        if (!!(cc_decls_tttarget[(m)])) {
            mlib_gs_leftint(dest,cc_decls_tttarget[(m)],(i64)3,(i64)32);
            mlib_gs_leftstr(dest,cc_lib_typename(cc_decls_tttarget[(m)]),(i64)11,(i64)32);
        } else {
            mlib_gs_leftstr(dest,(byte*)"-",(i64)14,(i64)32);
        };
        if ((cc_decls_ttbasetype[(m)]==(i64)19) || (cc_decls_ttbasetype[(m)]==(i64)20) || (cc_decls_ttbasetype[(m)]==(i64)21)) {
            mlib_gs_leftint(dest,cc_decls_ttlength[(m)],(i64)4,(i64)32);
        } else {
            mlib_gs_leftstr(dest,(byte*)"",(i64)4,(i64)32);
        };
        mlib_gs_leftint(dest,cc_decls_ttsize[(m)],(i64)5,(i64)32);
        mlib_gs_leftint(dest,(i64)(cc_decls_ttconst[(m)]),(i64)3,(i64)32);
        mlib_gs_leftint(dest,(i64)(cc_decls_ttrestrict[(m)]),(i64)3,(i64)32);
        mlib_gs_leftint(dest,(i64)(cc_decls_ttvolatile[(m)]),(i64)3,(i64)32);
        mlib_gs_leftint(dest,cc_decls_ttconsttype[(m)],(i64)5,(i64)32);
        mlib_gs_leftint(dest,cc_decls_ttreftype[(m)],(i64)5,(i64)32);
        if (!!(cc_decls_ttnamedef[(m)])) {
            mlib_gs_leftstr(dest,(*cc_decls_ttnamedef[(m)]).name,(i64)8,(i64)32);
        } else {
            mlib_gs_leftstr(dest,(byte*)"-",(i64)8,(i64)32);
        };
        mstr = cc_lib_strmode(m,(i64)1);
        if (((i64)((u64)(strlen((i8 *)(mstr)))) < (i64)16)) {
            mlib_gs_str(dest,mstr);
        } else {
            mlib_gs_println(dest,f);
            mlib_gs_init(dest);
            mlib_gs_str(dest,(byte*)"\t\t");
            mlib_gs_str(dest,mstr);
        };
        mlib_gs_println(dest,f);
L574 :;
    }L575 :;
    ;
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

byte * cc_lib_typename(i64 m) {
    i64 basem;
    static byte str[300];
    basem = cc_decls_ttbasetype[(m)];
    if ((basem==(i64)20) || (basem==(i64)21)) {
        strcpy((i8 *)(str),((basem == (i64)20)?(i8 *)((byte*)"struct "):(i8 *)((byte*)"union ")));
        if (!!(cc_decls_ttnamedef[(m)])) {
            strcat((i8 *)(str),(i8 *)((*cc_decls_ttnamedef[(m)]).name));
        };
        return str;
    }else if ((basem==(i64)19)) {
        return (byte*)"<array>";
    }else if ((basem==(i64)15)) {
        if (!!(cc_decls_ttnamedef[(m)])) {
            return (*cc_decls_ttnamedef[(m)]).name;
        };
        return (byte*)"<enum>";
    } else {
        if (!!((u64)(cc_decls_ttconst[(m)]))) {
            strcpy((i8 *)(str),(i8 *)((byte*)"const "));
            strcat((i8 *)(str),(i8 *)(cc_tables_stdtypenames[(basem)]));
            return str;
        };
        return cc_tables_stdtypenames[(basem)];
    };
    return (byte*)"";
}

struct cc_decls_unitrec * cc_lib_allocunitrec(void) {
    struct cc_decls_unitrec *  p;
    if (!!(cc_lib_remainingunits--)) {
        p = cc_lib_unitheapptr;
        ++cc_lib_unitheapptr;
        (*p).lineno = (u64)(cc_decls_lx.lineno);
        if (((i64)((u64)(cc_decls_lx.fileno)) <= (i64)255)) {
            (*p).fileno = (u64)(cc_decls_lx.fileno);
        };
        return p;
    };
    p = (cc_lib_unitheapptr = (struct cc_decls_unitrec *)(mlib_pcm_alloc((i64)2400000)));
    memset((void *)(p),(i32)0,(u32)2400000u);
    cc_lib_remainingunits = (i64)49999;
    ++cc_lib_unitheapptr;
    (*p).lineno = (u64)(cc_decls_lx.lineno);
    if (((i64)((u64)(cc_decls_lx.fileno)) <= (i64)255)) {
        (*p).fileno = (u64)(cc_decls_lx.fileno);
    };
    return p;
}

static i64 cc_lib_copymode(i64 m) {
    if ((cc_decls_ntypes >= (i64)20000)) {
        cc_support_serror((byte*)"Too many types");
    };
    ++cc_decls_ntypes;
    cc_decls_ttnamedef[(cc_decls_ntypes)] = cc_decls_ttnamedef[(m)];
    cc_decls_ttbasetype[(cc_decls_ntypes)] = cc_decls_ttbasetype[(m)];
    cc_decls_ttlength[(cc_decls_ntypes)] = cc_decls_ttlength[(m)];
    cc_decls_ttconst[(cc_decls_ntypes)] = (u64)(cc_decls_ttconst[(m)]);
    cc_decls_ttrestrict[(cc_decls_ntypes)] = (u64)(cc_decls_ttrestrict[(m)]);
    cc_decls_ttvolatile[(cc_decls_ntypes)] = (u64)(cc_decls_ttvolatile[(m)]);
    cc_decls_ttusertype[(cc_decls_ntypes)] = cc_decls_ttusertype[(m)];
    cc_decls_ttsize[(cc_decls_ntypes)] = cc_decls_ttsize[(m)];
    cc_decls_ttbitwidth[(cc_decls_ntypes)] = cc_decls_ttbitwidth[(m)];
    cc_decls_tttarget[(cc_decls_ntypes)] = cc_decls_tttarget[(m)];
    cc_decls_ttparams[(cc_decls_ntypes)] = cc_decls_ttparams[(m)];
    cc_decls_ttisref[(cc_decls_ntypes)] = (u64)(cc_decls_ttisref[(m)]);
    return cc_decls_ntypes;
}

static i64 cc_lib_createnewmode(i64 m) {
    if ((cc_decls_ntypes >= (i64)20000)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"MAXTYPE=",NULL);
        msysnewc_m_print_i64((i64)20000,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        cc_support_serror((byte*)"Too many types/cnm");
    };
    ++cc_decls_ntypes;
    cc_decls_ttbasetype[(cc_decls_ntypes)] = m;
    cc_decls_ttsize[(cc_decls_ntypes)] = cc_decls_ttsize[(m)];
    cc_decls_ttbitwidth[(cc_decls_ntypes)] = cc_decls_ttbitwidth[(m)];
    return cc_decls_ntypes;
}

void cc_lib_addlistunit(struct cc_decls_unitrec * * ulist,struct cc_decls_unitrec * * ulistx,struct cc_decls_unitrec * p) {
    if (((*ulist) == 0)) {
        (*ulist) = ((*ulistx) = p);
    } else {
        (*(*ulistx)).nextunit = p;
    };
    (*p).nextunit = (struct cc_decls_unitrec *)(0);
    (*ulistx) = p;
}

void cc_lib_addlistdef(struct cc_decls_strec * * ulist,struct cc_decls_strec * * ulistx,struct cc_decls_strec * p) {
    if (((*ulist) == 0)) {
        (*ulist) = ((*ulistx) = p);
    } else {
        (*(*ulistx)).nextdef = p;
    };
    (*p).nextdef = (struct cc_decls_strec *)(0);
    (*ulistx) = p;
}

void cc_lib_addlistparam(struct cc_decls_paramrec * * ulist,struct cc_decls_paramrec * * ulistx,struct cc_decls_paramrec * p) {
    if (((*ulist) == 0)) {
        (*ulist) = ((*ulistx) = p);
    } else {
        (*(*ulistx)).nextparam = p;
    };
    (*p).nextparam = (struct cc_decls_paramrec *)(0);
    (*ulistx) = p;
}

void cc_lib_checksymbol(i64 symbol) {
    byte str[256];
    if (((i64)((u64)(cc_decls_lx.symbol)) != symbol)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((byte*)"# expected, not #");
        msysnewc_m_print_str(cc_tables_symbolnames[(symbol)-1],NULL);
        msysnewc_m_print_str(cc_tables_symbolnames[((i64)(cc_decls_lx.symbol))-1],NULL);
        msysnewc_m_print_end();
        ;
        if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)68)) {
            strcat((i8 *)(str),(i8 *)((byte*)" \""));
            strcat((i8 *)(str),(i8 *)(cc_lib_getstname(cc_decls_lx.symptr)));
            strcat((i8 *)(str),(i8 *)((byte*)"\""));
        };
        cc_support_serror(str);
    };
}

void cc_lib_skipsymbol(i64 symbol) {
    if (((i64)((u64)(cc_decls_lx.symbol)) != symbol)) {
        cc_lib_checksymbol(symbol);
    };
    cc_lex_lex();
}

void cc_lib_inittypetables(void) {
    i64 i;
    i64 size;
    i64 bitsize;
    i64 s;
    i64 t;
    i64 u;
    i64 av_1;
    i64 av_2;
    i64 av_3;
    L576 :;
    for (i=(i64)0;i<=(i64)21;i+=(i64)1) {
L577 :;
        cc_decls_ttbasetype[(i)] = i;
        bitsize = (i64)(cc_tables_stdtypewidths[(i)]);
        size = (bitsize / (i64)8);
        cc_decls_ttsize[(i)] = size;
        cc_decls_ttbitwidth[(i)] = bitsize;
L578 :;
    }L579 :;
    ;
    cc_decls_ntypes = (i64)21;
    cc_decls_trefchar = cc_lib_createrefmode((i64)2);
    cc_decls_trefwchar = cc_lib_createrefmode((i64)3);
    L580 :;
    for (i=(i64)1;i<=(i64)144;i+=(i64)1) {
L581 :;
        s = (i64)(cc_tables_dominantsetuptable[(i)-1][((i64)1)-1]);
        t = (i64)(cc_tables_dominantsetuptable[(i)-1][((i64)2)-1]);
        u = (i64)(cc_tables_dominantsetuptable[(i)-1][((i64)3)-1]);
        cc_tables_dominantmode[(s)][(t)] = (u64)(u);
L582 :;
    }L583 :;
    ;
    L584 :;
    for (i=(i64)1;i<=(i64)144;i+=(i64)1) {
L585 :;
        s = (i64)(cc_tables_convsetuptable[(i)-1][((i64)1)-1]);
        t = (i64)(cc_tables_convsetuptable[(i)-1][((i64)2)-1]);
        u = (i64)(cc_tables_convsetuptable[(i)-1][((i64)3)-1]);
        cc_tables_conversionops[(s)][(t)] = (u64)(u);
L586 :;
    }L587 :;
    ;
    cc_decls_ntypesreset = cc_decls_ntypes;
}

struct cc_decls_strec * cc_lib_createdupldef(struct cc_decls_strec * owner,struct cc_decls_strec * symptr,i64 id) {
    struct cc_decls_strec *  p;
    struct cc_decls_strec *  q;
    p = cc_lib_newstrec();
    (*p).name = (*symptr).name;
    (*p).namelen = (u64)((*symptr).namelen);
    (*p).symbol = (u64)((i64)68);
    (*p).owner = owner;
    (*p).nameid = (u64)(id);
    (*p).namespace = (u64)(cc_tables_namespaces[(id)]);
    if (!!((q = (*symptr).nextdupl))) {
        (*q).prevdupl = p;
    };
    (*p).nextdupl = q;
    (*p).prevdupl = symptr;
    (*symptr).nextdupl = p;
    if (!!(owner)) {
        if (((*owner).deflist == 0)) {
            (*owner).deflist = ((*owner).deflistx = p);
        } else {
            (*(*owner).deflistx).nextdef = p;
            (*owner).deflistx = p;
        };
    };
    return p;
}

struct cc_decls_strec * cc_lib_createnewmoduledef(struct cc_decls_strec * owner,struct cc_decls_strec * symptr) {
    struct cc_decls_strec *  p;
    p = cc_lib_createdupldef(owner,symptr,(i64)3);
    return p;
}

struct cc_decls_strec * cc_lib_createnewproc(struct cc_decls_strec * owner,struct cc_decls_strec * symptr) {
    struct cc_decls_strec *  p;
    struct cc_decls_strec *  q;
    p = cc_lib_createdupldef(owner,symptr,(i64)6);
    q = p;
    L588 :;
    while (!!((q = (*q).nextdupl))) {
        if (((*q).owner == owner)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((*q).name,NULL);
            msysnewc_m_print_str((byte*)"in",NULL);
            msysnewc_m_print_str((*owner).name,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            cc_support_serror((byte*)"Dupl proc name");
        };
L589 :;
    }L590 :;
    ;
    return p;
}

struct cc_decls_strec * cc_lib_resolvename(struct cc_decls_strec * owner,struct cc_decls_strec * symptr,i64 ns,i64 blockno) {
    static i64 nnn = (i64)0;
    i64 nsblock;
    struct cc_decls_strec *  d;
    if (((i64)((u64)((*symptr).nameid)) > (i64)1)) {
        return symptr;
    };
    if ((!!(blockno) && ((i64)(cc_decls_blockcounts[(blockno)]) == (i64)0))) {
        blockno = (i64)(cc_decls_blockowner[(blockno)]);
    };
    L591 :;
    while (1) {
        nsblock = ((ns << (i64)16) | blockno);
        d = symptr;
        L593 :;
        while (!!((d = (*d).nextdupl))) {
            if ((((*d).owner == owner) && ((i64)((u64)((*d).nsblock)) == nsblock))) {
                return d;
            };
L594 :;
        }L595 :;
        ;
        if ((blockno == (i64)0)) {
            if (((i64)((*owner).nameid)==(i64)6)) {
                owner = cc_decls_stmodule;
                goto L591 ;
            }else if (((i64)((*owner).nameid)==(i64)13)) {
                owner = (*owner).owner;
                if ((owner == 0)) {
                    return (struct cc_decls_strec *)(0);
                };
            } else {
                return (struct cc_decls_strec *)(0);
            };
        } else if (((blockno = (i64)(cc_decls_blockowner[(blockno)])) == (i64)0)) {
            owner = cc_decls_stmodule;
        };
    }L592 :;
    ;
    return (struct cc_decls_strec *)(0);
}

struct cc_decls_strec * cc_lib_checkdupl(struct cc_decls_strec * owner,struct cc_decls_strec * symptr,i64 ns,i64 blockno) {
    i64 nsblock;
    struct cc_decls_strec *  d;
    d = symptr;
    nsblock = ((ns << (i64)16) | blockno);
    L596 :;
    while (!!((d = (*d).nextdupl))) {
        if ((((*d).owner == owner) && ((i64)((u64)((*d).nsblock)) == nsblock))) {
            return d;
        };
L597 :;
    }L598 :;
    ;
    return (struct cc_decls_strec *)(0);
}

struct cc_decls_strec * cc_lib_checkdupl_inproc(struct cc_decls_strec * owner,struct cc_decls_strec * symptr,i64 ns,i64 blockno) {
    i64 nsblock;
    struct cc_decls_strec *  d;
    d = symptr;
    nsblock = ((ns << (i64)16) | blockno);
    L599 :;
    while ((!!((d = (*d).nextdupl)) && ((*d).owner == owner))) {
        if (((i64)((u64)((*d).nsblock)) == nsblock)) {
            return d;
        };
L600 :;
    }L601 :;
    ;
    return (struct cc_decls_strec *)(0);
}

i64 cc_lib_getalignment(i64 m) {
    i64 a;
    if ((cc_decls_ttbasetype[(m)]==(i64)19)) {
        return cc_lib_getalignment(cc_decls_tttarget[(m)]);
    }else if ((cc_decls_ttbasetype[(m)]==(i64)20) || (cc_decls_ttbasetype[(m)]==(i64)21)) {
        a = (i64)((*cc_decls_ttnamedef[(m)]).attribs.ax_align);
        if ((a == (i64)0)) {
            return (i64)16;
        };
        return a;
    };
    a = cc_decls_ttsize[(m)];
    if ((a==(i64)1) || (a==(i64)2) || (a==(i64)4) || (a==(i64)8)) {
        return a;
    };
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(cc_lib_strmode(m,(i64)1),NULL);
    msysnewc_m_print_i64(a,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    cc_support_serror((byte*)"GETALIGN SIZE NOT 1248");
    return (i64)0;
}

i64 cc_lib_isexported(struct cc_decls_strec * d) {
    if (((i64)((u64)((*d).nameid)) == (i64)6)) {
        if ((!!((*d).code) && (((i64)((u64)((*d).scope)) == (i64)3) || ((i64)((u64)((*d).scope)) == (i64)4)))) {
            return (i64)1;
        };
    } else {
        if (((i64)((u64)((*d).scope)) == (i64)4)) {
            return (i64)1;
        };
    };
    return (i64)0;
}

i64 cc_lib_isimported(struct cc_decls_strec * d) {
    if (((i64)((u64)((*d).nameid)) == (i64)6)) {
        if ((((*d).code == 0) && (((i64)((u64)((*d).scope)) == (i64)3) || ((i64)((u64)((*d).scope)) == (i64)4)))) {
            return (i64)1;
        };
    } else {
        if (((i64)((u64)((*d).scope)) == (i64)3)) {
            return (i64)1;
        };
    };
    return (i64)0;
}

i64 cc_lib_isstructunion(i64 m) {
    if ((cc_decls_ttbasetype[(m)]==(i64)20) || (cc_decls_ttbasetype[(m)]==(i64)21)) {
        if ((cc_decls_ttsize[(m)]==(i64)1) || (cc_decls_ttsize[(m)]==(i64)2) || (cc_decls_ttsize[(m)]==(i64)4) || (cc_decls_ttsize[(m)]==(i64)8)) {
        } else {
            return (i64)1;
        };
    };
    return (i64)0;
}

byte * cc_lib_getstname(struct cc_decls_strec * d) {
    static byte name[256];
    memcpy((void *)(name),(void *)((*d).name),(u32)((*d).namelen));
    name[(((i64)((u64)((*d).namelen)) + (i64)1))-1] = (u64)0u;
    return name;
}

i64 cc_lib_isrealcc(i64 m) {
    m = cc_decls_ttbasetype[(m)];
    return (((i64)11 <= m) && (m <= (i64)13));
}

i64 cc_lib_isintcc(i64 m) {
    m = cc_decls_ttbasetype[(m)];
    return (((i64)2 <= m) && (m <= (i64)10));
}

static void cc_parse_readmodule(void) {
    i64 linkage;
    i64 m;
    i64 mbase;
    i64 commaseen;
    i64 wasdef;
    struct cc_decls_strec *  d;
    struct cc_decls_paramrec *  pm;
    i64 t;
    i64 nitems;
    i64 wasenum;
    L602 :;
    while (((i64)((u64)(cc_decls_lx.symbol)) != (i64)57)) {
        nitems = (i64)0;
        if (((i64)(cc_decls_lx.symbol)==(i64)97)) {
            cc_lex_lex();
            t = cc_parse_readcasttype(&d,(i64)0,&pm);
            cc_lib_skipsymbol((i64)9);
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)"Type is:",NULL);
            msysnewc_m_print_str(cc_lib_strmode(t,(i64)1),NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            goto L603 ;
        }else if (((i64)(cc_decls_lx.symbol)==(i64)100)) {
            nitems = (i64)1;
        }else if (((i64)(cc_decls_lx.symbol)==(i64)9)) {
            cc_support_serror((byte*)"Extra semicolon 2");
        };
        wasenum = (i64)(cc_decls_lx.symbol);
        if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)100)) {
            nitems = (i64)1;
        };
        mbase = cc_parse_readdeclspec(cc_decls_stmodule,&linkage);
        commaseen = (i64)0;
        L605 :;
        if (((i64)(cc_decls_lx.symbol)==(i64)68) || ((i64)(cc_decls_lx.symbol)==(i64)24) || ((i64)(cc_decls_lx.symbol)==(i64)12)) {
            ++nitems;
            m = cc_parse_readtype(cc_decls_stmodule,&d,mbase,&pm);
            if ((d == 0)) {
                cc_support_serror((byte*)"Var name expected");
            };
            if ((linkage == (i64)5)) {
                if (!!(pm)) {
                    m = cc_lib_createprocmode(m,pm);
                };
                d = cc_parse_createtypedef(cc_decls_stmodule,d,m);
                cc_parse_constantseen = (u64)((i64)0);
            } else if (!!(pm)) {
                /*readfn:*/
L607 :;
;
                if ((((i64)((u64)(cc_decls_lx.symbol)) == (i64)16) && !!(commaseen))) {
                    cc_support_serror((byte*)"fn def after comma");
                };
                d = cc_parse_readfunction(d,m,linkage,pm,&wasdef);
                if (!!(wasdef)) {
                    goto L606 ;
                };
            } else if ((cc_decls_ttbasetype[(m)] == (i64)17)) {
                pm = cc_decls_ttparams[(m)];
                m = cc_decls_tttarget[(m)];
                cc_parse_constantseen = (u64)((i64)0);
                goto L607 ;
;
            } else {
                d = cc_parse_readmodulevar(d,m,linkage);
                cc_parse_constantseen = (u64)((i64)0);
            };
            if (((i64)(cc_decls_lx.symbol)==(i64)8)) {
                commaseen = (i64)1;
                cc_lex_lex();
            } else {
                cc_lib_skipsymbol((i64)9);
                goto L606 ;
            };
        }else if (((i64)(cc_decls_lx.symbol)==(i64)102)) {
            cc_parse_constantseen = (u64)((i64)1);
            cc_lex_lex();
            goto L603 ;
        }else if (((i64)(cc_decls_lx.symbol)==(i64)103)) {
            cc_parse_readstructinfosym();
        } else {
            if ((cc_decls_ttbasetype[(mbase)]==(i64)15) || (cc_decls_ttbasetype[(mbase)]==(i64)20) || (cc_decls_ttbasetype[(mbase)]==(i64)21)) {
                cc_lib_skipsymbol((i64)9);
                goto L606 ;
            }else if ((cc_decls_ttbasetype[(mbase)]==(i64)4)) {
                cc_lib_skipsymbol((i64)9);
                goto L606 ;
            } else {
                cc_support_serror_s((byte*)"Decl error %s",cc_lib_typename(mbase));
            };
        }goto L605 ;
L606 :;
        ;
        if (((nitems == (i64)0) && !!(cc_decls_fmodern))) {
            if ((cc_decls_ttbasetype[(mbase)]==(i64)20) || (cc_decls_ttbasetype[(mbase)]==(i64)21) || (cc_decls_ttbasetype[(mbase)]==(i64)15)) {
            } else {
                if ((wasenum != (i64)90)) {
                    msysnewc_m_print_startcon();
                    msysnewc_m_print_str((byte*)"STRMODE(MBASE)=",NULL);
                    msysnewc_m_print_str(cc_lib_strmode(mbase,(i64)1),NULL);
                    msysnewc_m_print_newline();
                    msysnewc_m_print_end();
                    ;
                    cc_support_serror((byte*)"Empty declaration");
                };
            };
        };
L603 :;
    }L604 :;
    ;
}

i64 cc_parse_parsemodule(i64 n) {
    struct cc_decls_strec *  owner;
    cc_parse_loopindex = (i64)((u64)((cc_parse_iscallbackfnx = (u64)((cc_parse_constantseen = (u64)((cc_parse_ingeneric = (u64)((i64)0))))))));
    cc_parse_ist_symptr = (struct cc_decls_strec *)(0);
    memset((void *)(&cc_parse_casevaluestack),(i32)0,(u32)400u);
    cc_lex_startlex((byte*)"PARSETEST",cc_decls_moduletable[(n)].fileno);
    owner = cc_decls_stmodule;
    cc_decls_currproc = (struct cc_decls_strec *)(0);
    cc_parse_loopindex = (i64)0;
    cc_lex_lex();
    cc_parse_readmodule();
    cc_lex_endlex();
    return (i64)1;
}

static i64 cc_parse_readdeclspec(struct cc_decls_strec * owner,i64 * linkage) {
    struct cc_parse_readdeclspec_declrec d;
    struct cc_decls_unitrec *  p;
    i64 t;
    i64 mod;
    i64 m;
    i64 fstruct;
    memset((void *)(&d),(i32)0,(u32)15u);
    fstruct = (mod = (i64)0);
    L608 :;
    switch ((int)(cc_decls_lx.symbol)) {
    case 71:;
    {
        switch ((int)(cc_decls_lx.subcode)) {
        case 5:;
        case 2:;
        case 6:;
        case 7:;
        case 10:;
        case 1:;
        {
            if (!!((i64)(d.typeno))) {
                if (!!(fstruct)) {
                    cc_lib_checksymbol((i64)9);
                } else {
                    goto L610 ;
;
                };
            };
            d.typeno = (i64)(cc_tables_typespectypes[((i64)(cc_decls_lx.subcode))-1]);
        }break;
        case 3:;
        {
            if (((!!((u64)(d.isshort)) || !!((u64)(d.islong))) || !!((u64)(d.isllong)))) {
                goto L610 ;
;
            };
            d.isshort = (u64)((mod = (i64)1));
        }break;
        case 4:;
        {
            if ((!!((u64)(d.isllong)) || !!((u64)(d.isshort)))) {
                goto L610 ;
;
            } else if (!!((u64)(d.islong))) {
                d.islong = (u64)((i64)0);
                d.isllong = (u64)((i64)1);
            } else {
                d.islong = (u64)((i64)1);
            };
            mod = (i64)1;
        }break;
        case 8:;
        {
            if ((!!((u64)(d.issigned)) || !!((u64)(d.isunsigned)))) {
                goto L610 ;
;
            };
            d.issigned = (u64)((mod = (i64)1));
        }break;
        case 9:;
        {
            if ((!!((u64)(d.issigned)) || !!((u64)(d.isunsigned)))) {
                goto L610 ;
;
            };
            d.isunsigned = (u64)((mod = (i64)1));
        }break;
        case 11:;
        {
            if (((!!((i64)(d.typeno)) && ((i64)(d.typeno) != (i64)11)) && ((i64)(d.typeno) != (i64)12))) {
                goto L610 ;
;
            };
            d.typeno = (i64)14;
        }break;
        default: {
            /*tserror:*/
L610 :;
;
            cc_support_serror_s((byte*)"declspec/ts %s",cc_tables_typespecnames[((i64)(cc_decls_lx.subcode))-1]);
        }
        } /* SW */
;
        cc_lex_lex();
    }break;
    case 87:;
    {
        if (((i64)(cc_decls_lx.subcode)==(i64)1)) {
            d.isconst = (u64)((i64)1);
        }else if (((i64)(cc_decls_lx.subcode)==(i64)2)) {
            d.isvolatile = (u64)((i64)1);
        }else if (((i64)(cc_decls_lx.subcode)==(i64)3)) {
            d.isrestrict = (u64)((i64)1);
        };
        cc_lex_lex();
    }break;
    case 86:;
    {
        if (!!((u64)(d.linkage))) {
            cc_support_serror((byte*)"Dual storage spec");
        };
        d.linkage = (u64)(cc_decls_lx.subcode);
        cc_lex_lex();
    }break;
    case 88:;
    {
        if (((i64)(cc_decls_lx.subcode)==(i64)1)) {
            d.isinline = (u64)((i64)1);
        }else if (((i64)(cc_decls_lx.subcode)==(i64)3)) {
            cc_decls_callbackflag = (i64)1;
        };
        cc_lex_lex();
    }break;
    case 84:;
    case 85:;
    {
        if (!!((i64)(d.typeno))) {
            cc_support_serror((byte*)"struct?");
        };
        d.typeno = cc_parse_readstructdecl(owner);
        d.isusertype = (u64)((i64)1);
        fstruct = (i64)1;
    }break;
    case 90:;
    {
        if (!!((i64)(d.typeno))) {
            cc_support_serror((byte*)"enum?");
        };
        cc_parse_readenumdecl(owner);
        d.typeno = (i64)4;
        d.isusertype = (u64)((i64)1);
    }break;
    case 68:;
    {
        if ((!(!!((i64)(d.typeno))) && !!((m = cc_parse_isusertype(owner))))) {
            if (!!(mod)) {
                d.typeno = (i64)4;
                goto L609 ;
            };
            d.typeno = m;
            d.isusertype = (u64)((i64)1);
            cc_lex_lex();
        } else {
            if ((((i64)(d.typeno) == (i64)0) && !(!!(mod)))) {
                cc_support_serror_s((byte*)"Implicit decls not allowed: %s",(*cc_decls_lx.symptr).name);
            };
            if (((i64)(d.typeno) == (i64)0)) {
                d.typeno = (i64)4;
            };
            goto L609 ;
        };
    }break;
    case 98:;
    {
        cc_lex_lex();
        cc_lib_skipsymbol((i64)12);
        p = cc_parse_readexpression();
        cc_lib_skipsymbol((i64)13);
        if ((!!((i64)(d.typeno)) || !!(mod))) {
            cc_support_serror((byte*)"typeof");
        };
        d.typeno = (i64)((*p).mode);
    }break;
    case 100:;
    {
        cc_parse_dostaticassert();
    }break;
    default: {
        goto L609 ;
    }
    } /* SW */
goto L608 ;
L609 :;
    ;
    t = (!!((i64)(d.typeno))?(i64)(d.typeno):(i64)4);
    if (!(!!((u64)(d.isusertype)))) {
        if ((t==(i64)4)) {
            if (!!((u64)(d.isshort))) {
                t = (!!((u64)(d.isunsigned))?(i64)8:(i64)3);
            } else if (!!((u64)(d.islong))) {
                if (!!(cc_decls_wintarget)) {
                    t = (!!((u64)(d.isunsigned))?(i64)9:(i64)4);
                } else {
                    t = (!!((u64)(d.isunsigned))?(i64)10:(i64)5);
                };
            } else if (!!((u64)(d.isllong))) {
                t = (!!((u64)(d.isunsigned))?(i64)10:(i64)5);
            } else if (!!((u64)(d.isunsigned))) {
                t = (i64)9;
            };
        }else if ((t==(i64)2)) {
            if (((!!((u64)(d.isshort)) || !!((u64)(d.islong))) || !!((u64)(d.isllong)))) {
                cc_support_serror((byte*)"char decl?");
            };
            t = (!!((u64)(d.isunsigned))?(i64)7:(i64)2);
        }else if ((t==(i64)12)) {
            if ((((!!((u64)(d.isshort)) || !!((u64)(d.isllong))) || !!((u64)(d.issigned))) || !!((u64)(d.isunsigned)))) {
                cc_support_serror((byte*)"dbl decl?");
            };
        }else if ((t==(i64)14)) {
            if ((((!!((u64)(d.isshort)) || !!((u64)(d.isllong))) || !!((u64)(d.issigned))) || !!((u64)(d.isunsigned)))) {
                cc_support_serror((byte*)"Complex?");
            };
        } else {
            if (!!(mod)) {
                cc_support_serror((byte*)"declspec/float");
            };
        };
    };
    if (!!((u64)(d.isconst))) {
        t = cc_lib_createconstmode(t);
    };
    (*linkage) = (i64)(d.linkage);
    return t;
}

static i64 cc_parse_istypestarter(void) {
    struct cc_decls_strec *  d;
    switch ((int)(cc_decls_lx.symbol)) {
    case 71:;
    {
        return (i64)1;
    }break;
    case 87:;
    {
        return (i64)1;
    }break;
    case 68:;
    {
        d = cc_lib_resolvename((!!(cc_decls_currproc)?cc_decls_currproc:cc_decls_stmodule),cc_decls_lx.symptr,(i64)2,cc_decls_currblockno);
        if (!!(d)) {
            cc_decls_lx.symptr = d;
            return ((i64)((u64)((*d).nameid)) == (i64)5);
        };
    }break;
    case 84:;
    case 85:;
    case 90:;
    {
        return (i64)1;
    }break;
    default: {
    }
    } /* SW */
;
    return (i64)0;
}

static struct cc_decls_unitrec * cc_parse_readexpression(void) {
    struct cc_decls_unitrec *  p;
    struct cc_decls_unitrec *  ulist;
    struct cc_decls_unitrec *  ulistx;
    if (((i64)(cc_decls_nextlx.symbol)==(i64)9) || ((i64)(cc_decls_nextlx.symbol)==(i64)13)) {
        return cc_parse_readterm();
    };
    p = cc_parse_readassignexpr();
    if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)8)) {
        ulist = (ulistx = (struct cc_decls_unitrec *)(0));
        L611 :;
        while (1) {
            cc_lib_addlistunit(&ulist,&ulistx,p);
            if (((i64)((u64)(cc_decls_lx.symbol)) != (i64)8)) {
                goto L612 ;
            };
            cc_lex_lex();
            p = cc_parse_readassignexpr();
        }L612 :;
        ;
        p = cc_lib_createunit1((i64)30,ulist);
        if (!!(ulistx)) {
            (*p).mode = (i64)((*ulistx).mode);
        };
        return p;
    };
    return p;
}

static struct cc_decls_unitrec * cc_parse_readassignexpr(void) {
    struct cc_decls_unitrec *  p;
    struct cc_decls_unitrec *  q;
    struct cc_decls_unitrec *  r;
    i64 opc;
    i64 oldpmode;
    if (((i64)(cc_decls_nextlx.symbol)==(i64)8) || ((i64)(cc_decls_nextlx.symbol)==(i64)9) || ((i64)(cc_decls_nextlx.symbol)==(i64)13)) {
        return cc_parse_readterm();
    }else if (((i64)(cc_decls_nextlx.symbol)==(i64)11)) {
        p = cc_parse_readterm();
        opc = (i64)(cc_decls_lx.symbol);
        goto L613 ;
;
    };
    p = cc_parse_readcondexpr();
    switch ((int)(opc = (i64)(cc_decls_lx.symbol))) {
    case 11:;
    case 47:;
    case 48:;
    case 49:;
    case 45:;
    case 46:;
    case 53:;
    case 54:;
    case 51:;
    case 52:;
    case 50:;
    {
        /*gotp:*/
L613 :;
;
        cc_lex_lex();
        oldpmode = (i64)((*p).mode);
        cc_parse_checklvalue(p);
        q = cc_parse_readassignexpr();
        if (!!((u64)(cc_decls_ttisref[((i64)((*p).mode))]))) {
            return cc_parse_createassignopref(opc,p,q);
        };
        q = cc_parse_coercemode(q,oldpmode);
        if (!!((u64)(cc_decls_ttconst[(oldpmode)]))) {
            cc_support_terror((byte*)"Modifying read-only var");
        };
        if ((((i64)((*q).tag) == (i64)57) && (opc == (i64)11))) {
            (*q).convtomem = (u64)((i64)1);
        };
        if ((((i64)((*p).tag) == (i64)53) && ((i64)((*(*p).a).tag) == (i64)1))) {
            cc_support_terror((byte*)"Modifying constant?");
        };
        r = cc_lib_createunit2((i64)(cc_tables_symboltojtag[(opc)-1]),p,q);
        (*r).mode = oldpmode;
        return r;
    }break;
    default: {
    }
    } /* SW */
;
    return p;
}

static struct cc_decls_unitrec * cc_parse_readcondexpr(void) {
    struct cc_decls_unitrec *  x;
    struct cc_decls_unitrec *  y;
    struct cc_decls_unitrec *  pcond;
    i64 s;
    i64 t;
    i64 u;
    pcond = cc_parse_readorlexpr();
    if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)18)) {
        cc_parse_coercecond(pcond);
        cc_lex_lex();
        x = cc_parse_readexpression();
        cc_lib_skipsymbol((i64)10);
        y = cc_parse_readcondexpr();
        if (!!((u = (i64)(cc_tables_dominantmode[((s = cc_decls_ttbasetype[((i64)((*x).mode))]))][((t = cc_decls_ttbasetype[((i64)((*y).mode))]))])))) {
            x = cc_parse_coercemode(x,u);
            y = cc_parse_coercemode(y,u);
            if (((((i64)((*pcond).tag) == (i64)1) && ((i64)((*x).tag) == (i64)1)) && ((i64)((*y).tag) == (i64)1))) {
                return (!!((*pcond).value)?x:y);
            };
        } else if (((s == (i64)16) && (t == (i64)16))) {
            u = (i64)((*x).mode);
        } else if (((((s == (i64)16) && (t == (i64)4)) && ((i64)((*y).tag) == (i64)1)) && ((*y).value == (i64)0))) {
            u = (i64)((*x).mode);
            cc_parse_coercemode(y,u);
        } else if (((((s == (i64)4) && (t == (i64)16)) && ((i64)((*x).tag) == (i64)1)) && ((*x).value == (i64)0))) {
            u = (i64)((*y).mode);
            cc_parse_coercemode(x,u);
        } else if (((s == (i64)20) && (t == (i64)20))) {
            u = (i64)((*x).mode);
        } else if (((s == t) && (t == (i64)1))) {
            u = (i64)1;
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(cc_lib_strmode((i64)((*x).mode),(i64)1),NULL);
            msysnewc_m_print_str(cc_lib_strmode((i64)((*y).mode),(i64)1),NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            cc_support_terror((byte*)"?: incompatible types");
        };
        pcond = cc_lib_createunit3((i64)32,pcond,x,y);
        (*pcond).mode = u;
    };
    return pcond;
}

static struct cc_decls_unitrec * cc_parse_readorlexpr(void) {
    struct cc_decls_unitrec *  x;
    struct cc_decls_unitrec *  y;
    x = cc_parse_readandlexpr();
    L614 :;
    while (((i64)((u64)(cc_decls_lx.symbol)) == (i64)30)) {
        cc_lex_lex();
        y = cc_parse_readandlexpr();
        cc_parse_coercecond(x);
        cc_parse_coercecond(y);
        if ((((i64)((*x).tag) == (i64)1) && ((i64)((*y).tag) == (i64)1))) {
            (*x).value = ((!!((*x).value) || !!((*y).value))?(i64)1:(i64)0);
            goto L615 ;
        };
        x = cc_lib_createunit2((i64)26,x,y);
        (*x).mode = (i64)4;
L615 :;
    }L616 :;
    ;
    return x;
}

static struct cc_decls_unitrec * cc_parse_readandlexpr(void) {
    struct cc_decls_unitrec *  x;
    struct cc_decls_unitrec *  y;
    x = cc_parse_readiorexpr();
    L617 :;
    while (((i64)((u64)(cc_decls_lx.symbol)) == (i64)31)) {
        cc_lex_lex();
        y = cc_parse_readiorexpr();
        cc_parse_coercecond(x);
        cc_parse_coercecond(y);
        if ((((i64)((*x).tag) == (i64)1) && ((i64)((*y).tag) == (i64)1))) {
            (*x).value = ((!!((*x).value) && !!((*y).value))?(i64)1:(i64)0);
            goto L618 ;
        };
        x = cc_lib_createunit2((i64)25,x,y);
        (*x).mode = (i64)4;
L618 :;
    }L619 :;
    ;
    return x;
}

static struct cc_decls_unitrec * cc_parse_readiorexpr(void) {
    struct cc_decls_unitrec *  x;
    struct cc_decls_unitrec *  y;
    i64 u;
    x = cc_parse_readixorexpr();
    L620 :;
    while (((i64)((u64)(cc_decls_lx.symbol)) == (i64)27)) {
        cc_lex_lex();
        y = cc_parse_readixorexpr();
        if (!!((u = (i64)(cc_tables_dominantmode[(cc_decls_ttbasetype[((i64)((*x).mode))])][(cc_decls_ttbasetype[((i64)((*y).mode))])])))) {
            if ((u >= (i64)11)) {
                cc_support_terror((byte*)"float|float");
            };
            x = cc_parse_coercemode(x,u);
            y = cc_parse_coercemode(y,u);
        } else {
            cc_support_terror((byte*)"invalid | operands");
        };
        if ((((i64)((*x).tag) == (i64)1) && ((i64)((*y).tag) == (i64)1))) {
            if ((u==(i64)4) || (u==(i64)5) || (u==(i64)9) || (u==(i64)10)) {
                (*x).value |= (*y).value;
                goto L621 ;
            };
        };
        x = cc_lib_createunit2((i64)46,x,y);
        (*x).mode = u;
L621 :;
    }L622 :;
    ;
    return x;
}

static struct cc_decls_unitrec * cc_parse_readixorexpr(void) {
    struct cc_decls_unitrec *  x;
    struct cc_decls_unitrec *  y;
    i64 u;
    x = cc_parse_readiandexpr();
    L623 :;
    while (((i64)((u64)(cc_decls_lx.symbol)) == (i64)29)) {
        cc_lex_lex();
        y = cc_parse_readiandexpr();
        if (!!((u = (i64)(cc_tables_dominantmode[(cc_decls_ttbasetype[((i64)((*x).mode))])][(cc_decls_ttbasetype[((i64)((*y).mode))])])))) {
            if ((u >= (i64)11)) {
                cc_support_terror((byte*)"float^float");
            };
            x = cc_parse_coercemode(x,u);
            y = cc_parse_coercemode(y,u);
        } else {
            cc_support_terror((byte*)"invalid ^ operands");
        };
        if ((((i64)((*x).tag) == (i64)1) && ((i64)((*y).tag) == (i64)1))) {
            if ((u==(i64)4) || (u==(i64)5) || (u==(i64)9) || (u==(i64)10)) {
                (*x).value ^= (*y).value;
                goto L624 ;
            };
        };
        x = cc_lib_createunit2((i64)47,x,y);
        (*x).mode = u;
L624 :;
    }L625 :;
    ;
    return x;
}

static struct cc_decls_unitrec * cc_parse_readiandexpr(void) {
    struct cc_decls_unitrec *  x;
    struct cc_decls_unitrec *  y;
    i64 u;
    x = cc_parse_readeqexpr();
    L626 :;
    while (((i64)((u64)(cc_decls_lx.symbol)) == (i64)28)) {
        cc_lex_lex();
        y = cc_parse_readeqexpr();
        if (!!((u = (i64)(cc_tables_dominantmode[(cc_decls_ttbasetype[((i64)((*x).mode))])][(cc_decls_ttbasetype[((i64)((*y).mode))])])))) {
            if ((u >= (i64)11)) {
                cc_support_terror((byte*)"float&float");
            };
            x = cc_parse_coercemode(x,u);
            y = cc_parse_coercemode(y,u);
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(cc_lib_strmode((i64)((*x).mode),(i64)1),NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(cc_lib_strmode((i64)((*y).mode),(i64)1),NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            cc_support_terror((byte*)"invalid & operands");
        };
        if ((((i64)((*x).tag) == (i64)1) && ((i64)((*y).tag) == (i64)1))) {
            if ((u==(i64)4) || (u==(i64)5) || (u==(i64)9) || (u==(i64)10)) {
                (*x).value &= (*y).value;
                goto L627 ;
            };
        };
        x = cc_lib_createunit2((i64)45,x,y);
        (*x).mode = u;
L627 :;
    }L628 :;
    ;
    return x;
}

static struct cc_decls_unitrec * cc_parse_readeqexpr(void) {
    struct cc_decls_unitrec *  x;
    struct cc_decls_unitrec *  y;
    i64 opc;
    i64 s;
    i64 t;
    i64 u;
    i64 ss;
    i64 tt;
    x = cc_parse_readrelexpr();
    L629 :;
    while ((((opc = (i64)(cc_decls_lx.symbol)) == (i64)39) || (opc == (i64)40))) {
        cc_lex_lex();
        y = cc_parse_readrelexpr();
        if (!!((u = (i64)(cc_tables_dominantmode[((s = cc_decls_ttbasetype[((i64)((*x).mode))]))][((t = cc_decls_ttbasetype[((i64)((*y).mode))]))])))) {
            x = cc_parse_coercemode(x,u);
            y = cc_parse_coercemode(y,u);
        } else if (((s == (i64)16) && (t == (i64)16))) {
            if (((ss = cc_decls_tttarget[((i64)((*x).mode))]) != (tt = cc_decls_tttarget[((i64)((*y).mode))]))) {
                if (((ss != (i64)1) && (tt != (i64)1))) {
                    if (!(!!(cc_parse_checkpointertypes((i64)((*x).mode),(i64)((*y).mode),(i64)1)))) {
                        cc_support_terror((byte*)"Comparing distinct pointers/eq");
                    };
                };
            };
        } else if (((s == (i64)16) && (t == (i64)4))) {
            if ((((i64)((*y).tag) != (i64)1) || ((*y).value != (i64)0))) {
                cc_support_terror((byte*)"Can't compare pointer to int");
            };
        } else if (((s == (i64)4) && (t == (i64)16))) {
            if ((((i64)((*x).tag) != (i64)1) || ((*x).value != (i64)0))) {
                cc_support_terror((byte*)"Can't compare pointer to int2");
            };
        } else {
            cc_support_terror((byte*)"invalid == operands");
        };
        if ((((i64)((*x).tag) == (i64)1) && ((i64)((*y).tag) == (i64)1))) {
            if ((u==(i64)4) || (u==(i64)5) || (u==(i64)9) || (u==(i64)10) || (u==(i64)0)) {
                if ((opc == (i64)39)) {
                    (*x).value = ((*x).value == (*y).value);
                } else {
                    (*x).value = ((*x).value != (*y).value);
                };
                goto L630 ;
            };
        };
        x = cc_lib_createunit2((i64)(cc_tables_symboltojtag[(opc)-1]),x,y);
        (*x).mode = (i64)4;
L630 :;
    }L631 :;
    ;
    return x;
}

static struct cc_decls_unitrec * cc_parse_readrelexpr(void) {
    struct cc_decls_unitrec *  x;
    struct cc_decls_unitrec *  y;
    i64 opc;
    i64 s;
    i64 t;
    i64 u;
    i64 a;
    i64 b;
    i64 c;
    u64 aa;
    u64 bb;
    u64 cc;
    x = cc_parse_readshiftexpr();
    L632 :;
    while ((((((opc = (i64)(cc_decls_lx.symbol)) == (i64)41) || (opc == (i64)42)) || (opc == (i64)43)) || (opc == (i64)44))) {
        cc_lex_lex();
        y = cc_parse_readshiftexpr();
        if (!!((u = (i64)(cc_tables_dominantmode[((s = cc_decls_ttbasetype[((i64)((*x).mode))]))][((t = cc_decls_ttbasetype[((i64)((*y).mode))]))])))) {
            x = cc_parse_coercemode(x,u);
            y = cc_parse_coercemode(y,u);
        } else if (((s == (i64)16) && (t == (i64)16))) {
            if (!(!!(cc_parse_checkpointertypes((i64)((*x).mode),(i64)((*y).mode),(i64)1)))) {
                cc_support_terror((byte*)"Comparing distinct pointers/rel");
            };
        } else {
            cc_support_terror((byte*)"invalid rel operands");
        };
        if ((((i64)((*x).tag) == (i64)1) && ((i64)((*y).tag) == (i64)1))) {
            a = (*x).value;
            b = (*y).value;
            if ((u==(i64)4) || (u==(i64)5)) {
                if ((opc==(i64)41)) {
                    c = (a < b);
                }else if ((opc==(i64)42)) {
                    c = (a <= b);
                }else if ((opc==(i64)43)) {
                    c = (a >= b);
                } else {
                    c = (a > b);
                };
                (*x).value = c;
                goto L633 ;
            }else if ((u==(i64)9) || (u==(i64)10)) {
                aa = (u64)((*x).value);
                bb = (u64)((*y).value);
                if ((opc==(i64)41)) {
                    cc = (u64)((aa < bb));
                }else if ((opc==(i64)42)) {
                    cc = (u64)((aa <= bb));
                }else if ((opc==(i64)43)) {
                    cc = (u64)((aa >= bb));
                } else {
                    cc = (u64)((aa > bb));
                };
                (*x).value = (i64)(cc);
                goto L633 ;
            };
        };
        x = cc_lib_createunit2((i64)(cc_tables_symboltojtag[(opc)-1]),x,y);
        (*x).mode = (i64)4;
L633 :;
    }L634 :;
    ;
    return x;
}

static struct cc_decls_unitrec * cc_parse_readshiftexpr(void) {
    struct cc_decls_unitrec *  x;
    struct cc_decls_unitrec *  y;
    i64 opc;
    i64 u;
    x = cc_parse_readaddexpr();
    L635 :;
    while ((((opc = (i64)(cc_decls_lx.symbol)) == (i64)32) || (opc == (i64)33))) {
        cc_lex_lex();
        y = cc_parse_readaddexpr();
        cc_parse_coercebasetype(x);
        if (!((((u = cc_decls_ttbasetype[((i64)((*x).mode))]) >= (i64)2) && (u <= (i64)10)))) {
            cc_support_terror((byte*)"shift:Not an int");
        };
        y = cc_parse_coercemode(y,(i64)4);
        if ((((i64)((*x).tag) == (i64)1) && ((i64)((*y).tag) == (i64)1))) {
            if ((u==(i64)4) || (u==(i64)5)) {
                if ((opc == (i64)32)) {
                    (*x).value = ((*x).value << (*y).value);
                } else {
                    (*x).value = ((*x).value >> (*y).value);
                };
                goto L636 ;
            }else if ((u==(i64)9) || (u==(i64)10)) {
                if ((opc == (i64)32)) {
                    (*x).uvalue = ((*x).uvalue << (*y).value);
                } else {
                    (*x).uvalue = ((*x).uvalue >> (*y).value);
                };
                goto L636 ;
            };
        };
        x = cc_lib_createunit2(((opc == (i64)32)?(i64)48:(i64)49),x,y);
        (*x).mode = u;
L636 :;
    }L637 :;
    ;
    return x;
}

static struct cc_decls_unitrec * cc_parse_readaddexpr(void) {
    struct cc_decls_unitrec *  p;
    struct cc_decls_unitrec *  q;
    i64 opc;
    p = cc_parse_readmulexpr();
    L638 :;
    while ((((opc = (i64)(cc_decls_lx.symbol)) == (i64)22) || (opc == (i64)23))) {
        cc_lex_lex();
        q = cc_parse_readmulexpr();
        if ((opc == (i64)22)) {
            p = cc_parse_createaddop(p,q);
        } else {
            p = cc_parse_createsubop(p,q);
        };
L639 :;
    }L640 :;
    ;
    return p;
}

static struct cc_decls_unitrec * cc_parse_readmulexpr(void) {
    struct cc_decls_unitrec *  p;
    struct cc_decls_unitrec *  q;
    i64 opc;
    p = cc_parse_readterm();
    L641 :;
    while (((((opc = (i64)(cc_decls_lx.symbol)) == (i64)24) || (opc == (i64)25)) || (opc == (i64)26))) {
        cc_lex_lex();
        q = cc_parse_readterm();
        if ((opc==(i64)24)) {
            p = cc_parse_createmulop(p,q);
        }else if ((opc==(i64)25)) {
            p = cc_parse_createdivop(p,q);
        }else if ((opc==(i64)26)) {
            p = cc_parse_createremop(p,q);
        };
L642 :;
    }L643 :;
    ;
    return p;
}

static struct cc_decls_unitrec * cc_parse_readterm(void) {
    struct cc_decls_unitrec *  p;
    struct cc_decls_unitrec *  q;
    i64 t;
    i64 opc;
    i64 shift;
    i64 newlen;
    i64 slength;
    i64 fwide;
    byte *  pbyte;
    i64 a;
    struct cc_decls_strec *  d;
    byte *  ss;
    byte *  s;
    struct cc_decls_paramrec *  pm;
    i64 av_1;
    switch ((int)(cc_decls_lx.symbol)) {
    case 59:;
    case 60:;
    {
        p = cc_lib_createconstunit((u64)(cc_decls_lx.value),(i64)(cc_decls_lx.subcode));
        cc_lex_lex();
    }break;
    case 68:;
    {
        if (((i64)((u64)((*cc_decls_lx.symptr).nameid)) <= (i64)1)) {
            d = cc_lib_resolvename((!!(cc_decls_currproc)?cc_decls_currproc:cc_decls_stmodule),cc_decls_lx.symptr,(i64)2,cc_decls_currblockno);
            if ((d == 0)) {
                cc_support_serror_s((byte*)"Undefined name \"%s\"",cc_lib_getstname(cc_decls_lx.symptr));
            };
        } else {
            d = cc_decls_lx.symptr;
        };
        (*d).attribs.ax_used = (u64)((i64)1);
        if (((i64)((*d).nameid)==(i64)11)) {
            p = cc_lib_createconstunit((u64)((*d).index),(i64)4);
        }else if (((i64)((*d).nameid)==(i64)14)) {
            p = cc_lib_createconstunit((u64)((*(*d).code).value),(i64)((*d).mode));
        }else if (((i64)((*d).nameid)==(i64)6)) {
            if (((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)12)) {
                p = cc_lib_createunit0((i64)5);
                (*p).def = d;
                (*p).mode = cc_lib_createrefmode(cc_lib_createprocmode((i64)((*d).mode),(*d).paramlist));
            } else {
                goto L644 ;
;
            };
        } else {
            /*doname:*/
L644 :;
;
            p = cc_lib_createname(d);
            (*p).mode = (t = (i64)((*d).mode));
            if ((cc_decls_ttbasetype[(t)] == (i64)19)) {
                (*p).alength = cc_decls_ttlength[(t)];
                p = cc_parse_createaddrofop(p);
                (*p).mode = cc_lib_createrefmode(cc_decls_tttarget[(t)]);
            } else if (((((i64)((u64)((*d).nameid)) != (i64)6) && ((i64)((u64)((*d).nameid)) != (i64)14)) && (cc_decls_ttsize[(t)] < (i64)4))) {
                cc_parse_fixmemopnd(p);
            } else if (((i64)((u64)((*d).nameid)) == (i64)9)) {
                if (!!(cc_lib_isstructunion((i64)((*p).mode)))) {
                    (*p).lineno = (u64)(cc_decls_lx.lineno);
                    (*p).mode = cc_lib_createrefmode((i64)((*p).mode));
                    p = cc_parse_createptrop(p);
                    (*p).mode = (i64)((*d).mode);
                };
            };
        };
        (*p).lineno = (u64)(cc_decls_lx.lineno);
        cc_lex_lex();
    }break;
    case 63:;
    case 64:;
    {
        fwide = ((i64)((u64)(cc_decls_lx.symbol)) == (i64)64);
        s = cc_decls_lx.svalue;
        slength = (i64)(cc_decls_lx.length);
        L645 :;
        while (((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)63)) {
            newlen = (slength + (i64)(cc_decls_nextlx.length));
            ss = (byte *)(mlib_pcm_alloc((newlen + (i64)1)));
            memcpy((void *)(ss),(void *)(s),(u32)(slength));
            memcpy((void *)((ss + slength)),(void *)(cc_decls_nextlx.svalue),(u32)(cc_decls_nextlx.length));
            (*(ss + newlen)) = (u64)0u;
            s = ss;
            slength = newlen;
            cc_lex_lex();
L646 :;
        }L647 :;
        ;
        if (!!(fwide)) {
            p = cc_lib_createwstringconstunit((u16 *)(s),slength);
            (*p).wslength = slength;
            (*p).mode = cc_decls_trefwchar;
        } else {
            p = cc_lib_createstringconstunit(s,slength);
            (*p).slength = slength;
            (*p).mode = cc_decls_trefchar;
        };
        cc_lex_lex();
    }break;
    case 67:;
    {
        p = cc_parse_readstrinclude();
    }break;
    case 61:;
    {
        a = (i64)0;
        shift = (i64)0;
        pbyte = cc_decls_lx.svalue;
        if (((i64)(cc_decls_lx.length) > (i64)8)) {
            cc_support_serror((byte*)"char const too long");
        };
        if (((i64)(cc_decls_lx.length) > (i64)1)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)"MULTICHAR CONST:",NULL);
            msysnewc_m_print_str(cc_decls_lx.svalue,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        };
        av_1 = (i64)(cc_decls_lx.length);
        while (av_1-- > 0) {
L648 :;
            a = (a | (i64)(((u64)((*pbyte)) << shift)));
            shift += (i64)8;
            ++pbyte;
L649 :;
        }L650 :;
        ;
        p = cc_lib_createconstunit((u64)(a),(((i64)(cc_decls_lx.length) <= (i64)4)?(i64)4:(i64)5));
        cc_lex_lex();
    }break;
    case 22:;
    {
        cc_lex_lex();
        p = cc_parse_readterm();
    }break;
    case 23:;
    {
        cc_lex_lex();
        p = cc_parse_createnegop(cc_parse_readterm());
    }break;
    case 35:;
    {
        cc_lex_lex();
        p = cc_parse_readterm();
        cc_parse_coercecond(p);
        p = cc_lib_createunit1((i64)27,p);
        (*p).mode = (i64)4;
        if ((((i64)((*(*p).a).tag) == (i64)27) && ((i64)((*(*(*p).a).a).tag) == (i64)27))) {
            (*p).a = (*(*(*p).a).a).a;
        };
    }break;
    case 34:;
    {
        cc_lex_lex();
        p = cc_parse_createinotop(cc_parse_readterm());
    }break;
    case 28:;
    {
        cc_lex_lex();
        if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)24)) {
            cc_lex_lex();
            p = cc_parse_readterm();
        } else {
            p = cc_parse_createaddrofop(cc_parse_readterm());
        };
    }break;
    case 31:;
    {
        cc_support_serror((byte*)"rt/&&label");
    }break;
    case 24:;
    {
        cc_lex_lex();
        p = cc_parse_createptrop(cc_parse_readterm());
    }break;
    case 36:;
    case 37:;
    {
        opc = (i64)(cc_tables_symboltojtag[((i64)(cc_decls_lx.symbol))-1]);
        cc_lex_lex();
        p = cc_parse_createincrop(opc,cc_parse_readterm());
    }break;
    case 38:;
    {
        cc_lex_lex();
        cc_lib_skipsymbol((i64)12);
        p = cc_parse_createabsop(cc_parse_readexpression());
        cc_lib_skipsymbol((i64)13);
    }break;
    case 55:;
    {
        cc_lex_lex();
        cc_lib_skipsymbol((i64)12);
        p = cc_parse_createsqrtop(cc_parse_readexpression());
        cc_lib_skipsymbol((i64)13);
    }break;
    case 12:;
    {
        cc_lex_lex();
        if (!!(cc_parse_istypestarter())) {
            t = cc_parse_readcasttype(&d,(i64)0,&pm);
            cc_lib_skipsymbol((i64)13);
            if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)16)) {
                cc_support_serror((byte*)"rt/compound lit");
            } else {
                p = cc_parse_docast(cc_parse_readterm(),t,(i64)1,(i64)0);
            };
        } else {
            p = cc_parse_readexpression();
            cc_lib_skipsymbol((i64)13);
        };
    }break;
    case 91:;
    {
        cc_lex_lex();
        if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)12)) {
            cc_lex_lex();
            if (!!(cc_parse_istypestarter())) {
                t = cc_parse_readcasttype(&d,(i64)0,&pm);
                cc_lib_skipsymbol((i64)13);
                p = cc_lib_createconstunit((u64)(cc_decls_ttsize[(t)]),(i64)10);
            } else {
                p = cc_parse_readexpression();
                cc_lib_skipsymbol((i64)13);
                p = cc_parse_createsizeofop(p);
            };
        } else {
            p = cc_parse_createsizeofop(cc_parse_readterm());
        };
    }break;
    case 92:;
    {
        cc_lex_lex();
        if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)12)) {
            cc_lex_lex();
            if (!!(cc_parse_istypestarter())) {
                t = cc_parse_readcasttype(&d,(i64)0,&pm);
                cc_lib_skipsymbol((i64)13);
                p = cc_lib_createconstunit((u64)(cc_decls_ttlength[(t)]),(i64)4);
            } else {
                p = cc_parse_readexpression();
                cc_lib_skipsymbol((i64)13);
                p = cc_parse_createlengthofop(p);
            };
        } else {
            p = cc_parse_createlengthofop(cc_parse_readterm());
        };
    }break;
    case 94:;
    {
        p = cc_parse_readgeneric();
    }break;
    case 95:;
    {
        cc_support_serror((byte*)"rt/alignof");
    }break;
    case 99:;
    {
        cc_lex_lex();
        cc_lib_skipsymbol((i64)12);
        t = cc_parse_readcasttype(&d,(i64)0,&pm);
        cc_lib_skipsymbol((i64)13);
        p = cc_lib_createstringconstunit(mlib_pcm_copyheapstring(cc_lib_strmode(t,(i64)1)),(i64)-1);
    }break;
    case 101:;
    {
        p = cc_lib_createunit0((i64)77);
        (*p).mode = (i64)5;
        cc_lex_lex();
    }break;
    default: {
        cc_lex_ps((byte*)"RT");
        cc_support_serror((byte*)"Readterm?");
    }
    } /* SW */
;
    L651 :;
    switch ((int)(cc_decls_lx.symbol)) {
    case 14:;
    {
        cc_lex_lex();
        q = cc_parse_readexpression();
        cc_lib_skipsymbol((i64)15);
        p = cc_parse_createindexop(p,q);
    }break;
    case 2:;
    case 3:;
    {
        opc = (i64)(cc_tables_symboltojtag[((i64)(cc_decls_lx.symbol))-1]);
        cc_lex_lex();
        cc_lib_checksymbol((i64)68);
        d = cc_decls_lx.symptr;
        cc_lex_lex();
        p = cc_parse_createdotop(opc,p,d);
    }break;
    case 12:;
    {
        cc_lex_lex();
        if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)13)) {
            q = (struct cc_decls_unitrec *)(0);
            cc_lex_lex();
        } else {
            q = cc_parse_readexprlist((struct cc_decls_unitrec *)(0));
            cc_lib_skipsymbol((i64)13);
        };
        p = cc_parse_createcall(p,q);
    }break;
    case 36:;
    {
        cc_lex_lex();
        p = cc_parse_createincrop((i64)75,p);
    }break;
    case 37:;
    {
        cc_lex_lex();
        p = cc_parse_createincrop((i64)76,p);
    }break;
    default: {
        goto L652 ;
    }
    } /* SW */
goto L651 ;
L652 :;
    ;
    return p;
}

static struct cc_decls_unitrec * cc_parse_readexprlist(struct cc_decls_unitrec * p) {
    struct cc_decls_unitrec *  ulist;
    struct cc_decls_unitrec *  ulistx;
    ulist = (ulistx = p);
    L653 :;
    while (1) {
        p = cc_parse_readassignexpr();
        cc_lib_addlistunit(&ulist,&ulistx,p);
        if (((i64)((u64)(cc_decls_lx.symbol)) != (i64)8)) {
            goto L654 ;
        };
        cc_lex_lex();
    }L654 :;
    ;
    return ulist;
}

static struct cc_decls_strec * cc_parse_readmodulevar(struct cc_decls_strec * d,i64 m,i64 linkage) {
    struct cc_decls_strec *  e;
    i64 scope;
    i64 emode;
    e = cc_lib_checkdupl(cc_decls_stmodule,d,(i64)2,(i64)0);
    if (!!(e)) {
        if (((i64)((u64)((*e).nameid)) != (i64)7)) {
            cc_support_serror_ss((byte*)"var: name in use %s %s",(*e).name,cc_tables_namenames[((i64)((*e).nameid))]);
        };
        emode = (i64)((*e).mode);
        if ((emode != m)) {
            if (!(!!(cc_parse_comparemode(emode,m)))) {
                /*redef:*/
L655 :;
;
                cc_support_serror_s((byte*)"var: redefining %s",(*e).name);
            };
            if ((cc_decls_ttbasetype[(emode)]==(i64)19)) {
                if ((cc_decls_ttlength[(emode)] == (i64)0)) {
                    (*e).mode = m;
                } else if ((!!(cc_decls_ttlength[(m)]) && (cc_decls_ttlength[(emode)] != cc_decls_ttlength[(m)]))) {
                    goto L655 ;
;
                };
            };
        };
        d = e;
        scope = (i64)((*d).scope);
        if (((((scope == (i64)2) && (linkage == (i64)0)) || ((scope == (i64)4) && (linkage == (i64)1))) || ((scope == (i64)3) && (linkage == (i64)1)))) {
        } else if (((scope == (i64)3) && (linkage == (i64)0))) {
            scope = (i64)4;
        };
    } else {
        d = cc_lib_createdupldef(cc_decls_stmodule,d,(!!((u64)(cc_parse_constantseen))?(i64)14:(i64)7));
        (*d).mode = m;
        if ((linkage==(i64)1)) {
            scope = (i64)2;
        }else if ((linkage==(i64)4)) {
            scope = (i64)3;
        } else {
            scope = (i64)4;
        };
    };
    if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)11)) {
        if (!!((*d).code)) {
            cc_support_serror_s((byte*)"Can't init twice %s",(*d).name);
        };
        if ((scope == (i64)3)) {
            cc_support_serror_s((byte*)"Can't init extern %s",(*d).name);
        };
        cc_lex_lex();
        (*d).code = cc_parse_readinitexpr(cc_decls_stmodule,(i64)((*d).mode));
        if (((i64)((u64)((*d).nameid)) == (i64)14)) {
            if (!((((i64)2 <= cc_decls_ttbasetype[((i64)((*d).mode))]) && (cc_decls_ttbasetype[((i64)((*d).mode))] <= (i64)13)))) {
                cc_support_serror((byte*)"constant only for int/float");
            };
            if (((i64)((*(*d).code).tag) != (i64)1)) {
                cc_support_serror((byte*)"constant expr must be constant");
            };
        };
    } else if (!!((u64)(cc_parse_constantseen))) {
        cc_support_serror((byte*)"constant must be initialised");
    };
    (*d).scope = (u64)(scope);
    return d;
}

static struct cc_decls_strec * cc_parse_readframevar(struct cc_decls_strec * d,i64 m,i64 linkage) {
    struct cc_decls_strec *  e;
    i64 scope;
    i64 id;
    e = cc_lib_checkdupl_inproc(cc_decls_currproc,d,(i64)2,cc_decls_currblockno);
    if (!!(e)) {
        cc_support_serror_s((byte*)"var: name in use %s",(*e).name);
        d = e;
        scope = (i64)((*d).scope);
        if (((((scope == (i64)2) && (linkage == (i64)0)) || ((scope == (i64)4) && (linkage == (i64)1))) || ((scope == (i64)3) && (linkage == (i64)1)))) {
        } else if (((scope == (i64)3) && (linkage == (i64)0))) {
            scope = (i64)4;
        };
    } else {
        id = (i64)8;
        scope = (i64)1;
        if ((linkage==(i64)1)) {
            id = (i64)7;
        }else if ((linkage==(i64)4)) {
            scope = (i64)3;
            id = (i64)7;
        };
        d = cc_lib_createdupldef(cc_decls_currproc,d,id);
        (*d).mode = m;
        (*d).blockno = (u64)(cc_decls_currblockno);
        cc_decls_blockcounts[(cc_decls_currblockno)] = (i64)1;
    };
    if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)11)) {
        if (!!((*d).code)) {
            cc_support_serror_s((byte*)"Can't init twice %s",(*d).name);
        };
        if ((scope == (i64)3)) {
            cc_support_serror_s((byte*)"Can't init extern %s",(*d).name);
        };
        cc_lex_lex();
        (*d).code = cc_parse_readinitexpr(cc_decls_currproc,(i64)((*d).mode));
    };
    (*d).scope = (u64)(scope);
    return d;
}

static i64 cc_parse_readtype(struct cc_decls_strec * owner,struct cc_decls_strec * * d,i64 m,struct cc_decls_paramrec * * pm) {
    i64 modtype[20];
    void *  modvalue[20];
    i64 nmodifiers;
    i64 i;
    nmodifiers = (i64)0;
    (*pm) = (struct cc_decls_paramrec *)(0);
    cc_parse_readnamedtype(owner,d,&modtype,&modvalue,&nmodifiers);
    L656 :;
    for (i=nmodifiers;i>=(i64)1;i-=(i64)1) {
L657 :;
        if ((modtype[(i)-1]==(i64)65)) {
            m = cc_lib_createarraymode(m,(i64)(u32)(modvalue[(i)-1]));
        }else if ((modtype[(i)-1]==(i64)82)) {
            m = cc_lib_createrefmode(m);
        }else if ((modtype[(i)-1]==(i64)67)) {
            m = cc_lib_createconstmode(m);
        }else if ((modtype[(i)-1]==(i64)70)) {
            if ((i == (i64)1)) {
                (*pm) = (struct cc_decls_paramrec *)(modvalue[((i64)1)-1]);
            } else {
                m = cc_lib_createprocmode(m,(struct cc_decls_paramrec *)(modvalue[(i)-1]));
            };
        };
L658 :;
    }L659 :;
    ;
    return m;
}

static void cc_parse_readnamedtype(struct cc_decls_strec * owner,struct cc_decls_strec * * d,i64 (*modtype)[],void * (*modvalue)[],i64 * nmodifiers) {
    i64 length;
    i64 fconst[20];
    i64 nrefs;
    struct cc_decls_unitrec *  pdim;
    (*d) = (struct cc_decls_strec *)(0);
    nrefs = (i64)0;
    if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)88)) {
        cc_lex_lex();
    };
    L660 :;
    while (((i64)((u64)(cc_decls_lx.symbol)) == (i64)24)) {
        ++nrefs;
        fconst[(nrefs)-1] = (i64)0;
        cc_lex_lex();
        L663 :;
        while (((i64)((u64)(cc_decls_lx.symbol)) == (i64)87)) {
            if (((i64)(cc_decls_lx.subcode)==(i64)1)) {
                fconst[(nrefs)-1] = (i64)1;
            }else if (((i64)(cc_decls_lx.subcode)==(i64)2) || ((i64)(cc_decls_lx.subcode)==(i64)3)) {
            } else {
                cc_support_serror((byte*)"rnt1");
            };
            cc_lex_lex();
L664 :;
        }L665 :;
        ;
L661 :;
    }L662 :;
    ;
    if (((i64)(cc_decls_lx.symbol)==(i64)68)) {
        (*d) = cc_decls_lx.symptr;
        cc_lex_lex();
    }else if (((i64)(cc_decls_lx.symbol)==(i64)12)) {
        cc_lex_lex();
        cc_parse_readnamedtype(owner,d,modtype,modvalue,nmodifiers);
        cc_lib_skipsymbol((i64)13);
    };
    L666 :;
    if (((i64)(cc_decls_lx.symbol)==(i64)14)) {
        cc_lex_lex();
        if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)15)) {
            length = (i64)0;
        } else {
            pdim = cc_parse_readassignexpr();
            if (((i64)((*pdim).tag) == (i64)1)) {
                length = (*pdim).value;
            } else {
                cc_support_serror((byte*)"Can't do VLAs");
            };
            cc_lib_checksymbol((i64)15);
        };
        if ((length < (i64)0)) {
            cc_support_terror((byte*)"Negative array dim");
        };
        cc_lex_lex();
        (*modtype)[(++(*nmodifiers))-1] = (i64)65;
        (*modvalue)[((*nmodifiers))-1] = (void *)(u32)(length);
    }else if (((i64)(cc_decls_lx.symbol)==(i64)12)) {
        cc_lex_lex();
        (*modtype)[(++(*nmodifiers))-1] = (i64)70;
        (*modvalue)[((*nmodifiers))-1] = (void *)(cc_parse_readparams(owner));
    } else {
        goto L667 ;
    }goto L666 ;
L667 :;
    ;
    L668 :;
    while (!!(nrefs)) {
        if (!!(fconst[(nrefs)-1])) {
            (*modtype)[(++(*nmodifiers))-1] = (i64)67;
        };
        (*modtype)[(++(*nmodifiers))-1] = (i64)82;
        --nrefs;
L669 :;
    }L670 :;
    ;
}

static i64 cc_parse_readconstintexpr(void) {
    struct cc_decls_unitrec *  p;
    p = cc_parse_readassignexpr();
    if (((i64)((*p).tag)==(i64)1)) {
        return (*p).value;
    } else {
        cc_support_serror_s((byte*)"readconstint %s",cc_tables_jtagnames[((i64)((*p).tag))]);
    };
    return (i64)0;
}

static struct cc_decls_unitrec * cc_parse_readinitexpr(struct cc_decls_strec * owner,i64 m) {
    struct cc_decls_unitrec *  p;
    p = cc_parse_readinitexpr2(owner,m,(i64)1);
    return p;
}

static struct cc_decls_unitrec * cc_parse_readinitexpr2(struct cc_decls_strec * owner,i64 m,i64 istop) {
    struct cc_decls_unitrec *  ulist;
    struct cc_decls_unitrec *  ulistx;
    struct cc_decls_unitrec *  p;
    i64 mbase;
    i64 melem;
    i64 mm;
    i64 dim;
    i64 count;
    struct cc_decls_strec *  d;
    struct cc_decls_strec *  e;
    i64 braces;
    mbase = cc_decls_ttbasetype[(m)];
    count = (i64)0;
    if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)16)) {
        cc_lex_lex();
        count = (i64)0;
        if ((mbase==(i64)19)) {
            dim = cc_decls_ttlength[(m)];
            if ((!(!!(istop)) && (dim == (i64)0))) {
                cc_support_terror((byte*)"init/0-size array");
            };
            melem = cc_decls_tttarget[(m)];
            if (((cc_decls_ttbasetype[(melem)] == (i64)7) && ((i64)((u64)(cc_decls_lx.symbol)) == (i64)63))) {
                braces = (i64)1;
                goto L671 ;
;
            };
        }else if ((mbase==(i64)20) || (mbase==(i64)21)) {
            d = cc_decls_ttnamedef[(m)];
            e = (*d).deflist;
            if ((e == 0)) {
                cc_support_terror((byte*)"init/Empty struct");
            };
            melem = (i64)((*e).mode);
        } else {
            p = cc_parse_readassignexpr();
            p = cc_parse_coercemode(p,m);
            cc_lib_skipsymbol((i64)17);
            return p;
        };
        ulist = (ulistx = (struct cc_decls_unitrec *)(0));
        L672 :;
        while (1) {
            p = cc_parse_readinitexpr2(owner,melem,(i64)0);
            ++count;
            if ((mbase==(i64)19)) {
                if ((!!(dim) && (count > dim))) {
                    cc_support_terror((byte*)"Too many array elems");
                };
                if ((((cc_decls_ttbasetype[(melem)] == (i64)19) && (cc_decls_ttbasetype[(cc_decls_tttarget[(melem)])] == (i64)7)) && ((i64)((*p).mode) == cc_decls_trefchar))) {
                } else {
                    p = cc_parse_coercemode(p,melem);
                };
            }else if ((mbase==(i64)20)) {
                mm = (i64)((*e).mode);
                if ((((cc_decls_ttbasetype[(mm)] == (i64)19) && (cc_decls_ttbasetype[(cc_decls_tttarget[(mm)])] == (i64)7)) && ((i64)((*p).mode) == cc_decls_trefchar))) {
                } else {
                    p = cc_parse_coercemode(p,mm);
                };
                e = (*e).nextdef;
                if ((e == 0)) {
                    if ((((i64)((u64)(cc_decls_lx.symbol)) == (i64)8) && ((i64)((u64)(cc_decls_nextlx.symbol)) != (i64)17))) {
                        cc_support_terror((byte*)"Too many struct elems");
                    };
                } else {
                    melem = (i64)((*e).mode);
                };
            }else if ((mbase==(i64)21)) {
                p = cc_parse_coercemode(p,melem);
                ulist = (ulistx = p);
                goto L674 ;
;
            };
            cc_lib_addlistunit(&ulist,&ulistx,p);
            if (((i64)((u64)(cc_decls_lx.symbol)) != (i64)8)) {
                goto L673 ;
            };
            if (((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)17)) {
                cc_lex_lex();
                goto L673 ;
            };
            cc_lex_lex();
        }L673 :;
        ;
        if (((mbase == (i64)19) && (dim == (i64)0))) {
            cc_decls_ttlength[(m)] = count;
            cc_decls_ttsize[(m)] = (count * cc_decls_ttsize[(melem)]);
        };
        /*donestruct:*/
L674 :;
;
        cc_lib_skipsymbol((i64)17);
        p = cc_lib_createunit1((i64)29,ulist);
        (*p).count = count;
        (*p).mode = m;
    } else {
        braces = (i64)0;
        if ((mbase==(i64)19)) {
            /*doarraystring:*/
L671 :;
;
            if (((((i64)((u64)(cc_decls_lx.symbol)) != (i64)63) && ((i64)((u64)(cc_decls_lx.symbol)) != (i64)64)) && (cc_decls_tttarget[(m)] != (i64)7))) {
                cc_support_terror((byte*)"{} initialiser expected");
            };
            p = cc_parse_readassignexpr();
            if (((i64)((*p).tag) == (i64)1)) {
                (*p).strarray = (u64)((i64)1);
            };
            if (((i64)((*p).mode)==cc_decls_trefchar)) {
            }else if (((i64)((*p).mode)==cc_decls_trefwchar)) {
            } else {
                cc_support_terror((byte*)"Array init");
            };
            (*p).mode = m;
            if (((dim = cc_decls_ttlength[(m)]) == (i64)0)) {
                cc_decls_ttlength[(m)] = (cc_decls_ttsize[(m)] = ((i64)((*p).slength) + (i64)1));
            } else {
                if (((i64)((*p).slength) > dim)) {
                    cc_support_terror((byte*)"Init str too long");
                };
            };
            if (!!(braces)) {
                cc_lib_skipsymbol((i64)17);
            };
            return p;
        };
        p = cc_parse_readassignexpr();
        p = cc_parse_coercemode(p,m);
    };
    return p;
}

static void cc_parse_pushblock(void) {
    i64 n;
    i64 m;
    if ((cc_decls_blocklevel >= (i64)100)) {
        cc_support_serror((byte*)"Too many block levels");
    };
    if ((cc_decls_nextblockno >= (i64)2100)) {
        cc_support_serror((byte*)"Too many blocks");
    };
    ++cc_decls_blocklevel;
    ++cc_decls_nextblockno;
    n = cc_decls_currblockno;
    m = cc_decls_blocklevel;
    L675 :;
    while ((!!(m) && ((i64)(cc_decls_blockcounts[((i64)(cc_decls_blockstack[(m)]))]) == (i64)0))) {
        --m;
        n = (i64)(cc_decls_blockstack[(m)]);
L676 :;
    }L677 :;
    ;
    cc_decls_blockowner[(cc_decls_nextblockno)] = n;
    cc_decls_currblockno = (i64)((cc_decls_blockstack[(cc_decls_blocklevel)] = cc_decls_nextblockno));
    cc_decls_blockcounts[(cc_decls_currblockno)] = (i64)0;
}

static void cc_parse_popblock(void) {
    cc_decls_currblockno = (i64)(cc_decls_blockstack[(--cc_decls_blocklevel)]);
}

static struct cc_decls_unitrec * cc_parse_readcompoundstmt(i64 params) {
    struct cc_decls_unitrec *  ulist;
    struct cc_decls_unitrec *  ulistx;
    struct cc_decls_unitrec *  p;
    struct cc_decls_unitrec *  q;
    ulist = (ulistx = (struct cc_decls_unitrec *)(0));
    cc_lex_lex();
    cc_parse_pushblock();
    if (!!(params)) {
        cc_decls_blockcounts[((i64)1)] = (i64)1;
    };
    L678 :;
    while (((i64)((u64)(cc_decls_lx.symbol)) != (i64)17)) {
        p = cc_parse_readstatement();
        if ((p == 0)) {
            goto L679 ;
        };
        if (((i64)((*p).tag) == (i64)7)) {
            L681 :;
            do {
                q = (*p).nextunit;
                if ((!!((*(*p).def).code) && ((i64)((u64)((*(*p).def).nameid)) != (i64)7))) {
                    (*p).tag = (i64)8;
                    (*p).nextunit = (struct cc_decls_unitrec *)(0);
                    cc_lib_addlistunit(&ulist,&ulistx,p);
                };
                p = q;
L682 :;
            } while (!(p == 0));L683 :;
            ;
        } else {
            cc_lib_addlistunit(&ulist,&ulistx,p);
        };
L679 :;
    }L680 :;
    ;
    cc_lex_lex();
    cc_parse_popblock();
    return cc_lib_createunit3((i64)6,ulist,(struct cc_decls_unitrec *)(0),ulistx);
}

static struct cc_decls_unitrec * cc_parse_readblock(i64 ifelse) {
    ++cc_decls_nblocks;
    if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)16)) {
        ++cc_decls_ncompoundblocks;
    } else if ((((i64)((u64)(cc_decls_lx.symbol)) == (i64)72) && !!(ifelse))) {
        ++cc_decls_ncompoundblocks;
    };
    if (!(!!((i64)0))) {
        return cc_parse_readstatement();
    };
    if ((((i64)((u64)(cc_decls_lx.symbol)) == (i64)72) && !!(ifelse))) {
        return cc_parse_readstatement();
    };
    if (((i64)((u64)(cc_decls_lx.symbol)) != (i64)16)) {
        cc_support_serror((byte*)"{...} statement expected");
    };
    return cc_parse_readcompoundstmt((i64)0);
}

static struct cc_decls_unitrec * cc_parse_readstatement(void) {
    struct cc_decls_unitrec *  p;
    struct mlib_strbuffer *  ss;
    struct cc_decls_strec *  d;
    i64 index;
    switch ((int)(cc_decls_lx.symbol)) {
    case 72:;
    {
        return cc_parse_readifstmt();
    }break;
    case 76:;
    {
        return cc_parse_readforstmt();
    }break;
    case 77:;
    {
        return cc_parse_readwhilestmt();
    }break;
    case 78:;
    {
        return cc_parse_readdostmt();
    }break;
    case 79:;
    {
        return cc_parse_readreturnstmt();
    }break;
    case 83:;
    {
        return cc_parse_readswitchstmt();
    }break;
    case 16:;
    {
        return cc_parse_readcompoundstmt((i64)0);
    }break;
    case 82:;
    {
        return cc_parse_readgotostmt();
    }break;
    case 80:;
    {
        if (!!(cc_parse_loopindex)) {
            if (((u64)(cc_parse_looptypestack[(cc_parse_loopindex)-1]) == (u64)76u)) {
                p = cc_lib_createunit0((i64)21);
                cc_lex_lex();
            } else {
                p = cc_lib_createunit0((i64)24);
                cc_lex_lex();
            };
        } else {
            cc_support_serror((byte*)"break outside loop/sw");
        };
    }break;
    case 81:;
    {
        index = cc_parse_loopindex;
        L684 :;
        while ((!!(index) && ((u64)(cc_parse_looptypestack[(index)-1]) != (u64)76u))) {
            --index;
L685 :;
        }L686 :;
        ;
        if ((index == (i64)0)) {
            cc_support_serror((byte*)"continue outside loop");
        };
        p = cc_lib_createunit0((i64)22);
        cc_lex_lex();
    }break;
    case 74:;
    {
        return cc_parse_readcaselabel();
    }break;
    case 75:;
    {
        cc_lex_lex();
        cc_lib_skipsymbol((i64)10);
        return cc_lib_createunit1((i64)20,cc_parse_readstatement());
    }break;
    case 96:;
    {
        cc_lex_lex();
        p = cc_parse_readexpression();
        ss = cc_lib_strexpr(p);
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"Mode is:",NULL);
        msysnewc_m_print_str((*ss).strptr,NULL);
        msysnewc_m_print_str((byte*)":",NULL);
        msysnewc_m_print_str(cc_lib_strmode((i64)((*p).mode),(i64)1),NULL);
        msysnewc_m_print_str((byte*)"\ton line",NULL);
        msysnewc_m_print_u64(cc_decls_lx.lineno,NULL);
        msysnewc_m_print_str((byte*)"Size is",NULL);
        msysnewc_m_print_i64(cc_decls_ttsize[((i64)((*p).mode))],NULL);
        msysnewc_m_print_end();
        ;
        if (!!((u64)(cc_decls_ttisref[((i64)((*p).mode))]))) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)" target size",NULL);
            msysnewc_m_print_i64(cc_decls_ttsize[(cc_decls_tttarget[((i64)((*p).mode))])],NULL);
            msysnewc_m_print_end();
            ;
        };
        msysnewc_m_print_startcon();
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    }break;
    case 100:;
    {
        cc_parse_dostaticassert();
    }break;
    case 9:;
    {
        cc_lex_lex();
        return (struct cc_decls_unitrec *)(0);
    }break;
    case 68:;
    {
        if (((i64)((u64)(cc_decls_nextlx.symbol)) == (i64)10)) {
            p = cc_lib_createunit1((i64)18,(struct cc_decls_unitrec *)(0));
            d = cc_lib_resolvename(cc_decls_currproc,cc_decls_lx.symptr,(i64)4,(i64)0);
            if (!!(d)) {
                if (!!((i64)((*d).index))) {
                    msysnewc_m_print_startcon();
                    msysnewc_m_print_str((*cc_decls_lx.symptr).name,NULL);
                    msysnewc_m_print_newline();
                    msysnewc_m_print_end();
                    ;
                    cc_support_terror((byte*)"Duplicate label");
                } else {
                    (*d).index = ++cc_decls_labelno;
                };
            } else {
                d = cc_lib_createdupldef(cc_decls_currproc,cc_decls_lx.symptr,(i64)15);
                (*d).mode = (i64)1;
                (*d).index = ++cc_decls_labelno;
            };
            (*p).def = d;
            cc_lex_lex();
            cc_lex_lex();
            if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)17)) {
            } else if ((!!(cc_parse_istypestarter()) || ((i64)((u64)(cc_decls_lx.symbol)) == (i64)86))) {
            } else {
                (*p).a = cc_parse_readstatement();
            };
            return p;
        } else {
            cc_parse_ist_symptr = (struct cc_decls_strec *)(0);
            if (!!(cc_parse_isusertype(cc_decls_currproc))) {
                goto L687 ;
;
            };
            if (!!(cc_parse_ist_symptr)) {
                cc_decls_lx.symptr = cc_parse_ist_symptr;
            };
            p = cc_parse_readexpression();
        };
    }break;
    case 71:;
    case 87:;
    case 86:;
    case 88:;
    case 84:;
    case 85:;
    case 90:;
    case 98:;
    {
        /*doreaddecl:*/
L687 :;
;
        return cc_parse_readlocaldecl();
    }break;
    default: {
        p = cc_parse_readexpression();
    }
    } /* SW */
;
    cc_lib_skipsymbol((i64)9);
    return p;
}

static struct cc_decls_unitrec * cc_parse_readifstmt(void) {
    struct cc_decls_unitrec *  pcond;
    struct cc_decls_unitrec *  pbody;
    struct cc_decls_unitrec *  pelse;
    cc_lex_lex();
    pcond = cc_parse_readcond();
    cc_parse_coercecond(pcond);
    pbody = cc_parse_readblock((i64)0);
    pelse = (struct cc_decls_unitrec *)(0);
    if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)73)) {
        cc_lex_lex();
        pelse = cc_parse_readblock((i64)1);
    };
    return cc_lib_createunit3((i64)13,pcond,pbody,pelse);
}

static struct cc_decls_unitrec * cc_parse_readforstmt(void) {
    struct cc_decls_unitrec *  pinit;
    struct cc_decls_unitrec *  pcond;
    struct cc_decls_unitrec *  pincr;
    struct cc_decls_unitrec *  pbody;
    struct cc_decls_unitrec *  ulist;
    struct cc_decls_unitrec *  ulistx;
    struct cc_decls_unitrec *  p;
    i64 linkage;
    i64 hasblock;
    i64 m;
    i64 mbase;
    struct cc_decls_paramrec *  pm;
    struct cc_decls_strec *  d;
    cc_lex_lex();
    cc_lib_skipsymbol((i64)12);
    hasblock = (i64)0;
    if (((i64)((u64)(cc_decls_lx.symbol)) != (i64)9)) {
        if (!!(cc_parse_istypestarter())) {
            hasblock = (i64)1;
            cc_parse_pushblock();
            mbase = cc_parse_readdeclspec(cc_decls_currproc,&linkage);
            ulist = (ulistx = (struct cc_decls_unitrec *)(0));
            L688 :;
            if (((i64)(cc_decls_lx.symbol)==(i64)68) || ((i64)(cc_decls_lx.symbol)==(i64)24) || ((i64)(cc_decls_lx.symbol)==(i64)12)) {
                m = cc_parse_readtype(cc_decls_currproc,&d,mbase,&pm);
                if ((d == 0)) {
                    cc_support_serror((byte*)"Var name expected");
                };
                if (((linkage == (i64)5) || !!(pm))) {
                    cc_support_serror((byte*)"Not allowed in for stmt");
                };
                cc_parse_insidefor = (i64)1;
                d = cc_parse_readframevar(d,m,linkage);
                cc_parse_insidefor = (i64)0;
                if (!!((*d).code)) {
                    p = cc_lib_createunit0((i64)8);
                    (*p).def = d;
                    cc_lib_addlistunit(&ulist,&ulistx,p);
                };
                if (((i64)(cc_decls_lx.symbol)==(i64)8)) {
                    cc_lex_lex();
                } else {
                    goto L689 ;
                };
            } else {
                cc_support_serror((byte*)"For decl error");
            }goto L688 ;
L689 :;
            ;
            pinit = cc_lib_createunit3((i64)6,ulist,(struct cc_decls_unitrec *)(0),ulistx);
        } else {
            pinit = cc_parse_readexpression();
        };
    } else {
        pinit = cc_lib_createunit0((i64)2);
    };
    cc_lib_skipsymbol((i64)9);
    if (((i64)((u64)(cc_decls_lx.symbol)) != (i64)9)) {
        pcond = cc_parse_readexpression();
        cc_parse_coercecond(pcond);
    } else {
        pcond = cc_lib_createunit0((i64)2);
    };
    cc_lib_skipsymbol((i64)9);
    if (((i64)((u64)(cc_decls_lx.symbol)) != (i64)13)) {
        pincr = cc_parse_readexprstmt();
    } else {
        pincr = (struct cc_decls_unitrec *)(0);
    };
    cc_lib_skipsymbol((i64)13);
    cc_parse_pushloop((i64)76);
    pbody = cc_parse_readblock((i64)0);
    cc_parse_poploop();
    if (!!(hasblock)) {
        cc_parse_popblock();
    };
    (*pinit).nextunit = pcond;
    (*pcond).nextunit = pincr;
    return cc_lib_createunit2((i64)14,pinit,pbody);
}

static struct cc_decls_unitrec * cc_parse_readwhilestmt(void) {
    struct cc_decls_unitrec *  pcond;
    struct cc_decls_unitrec *  pbody;
    cc_lex_lex();
    pcond = cc_parse_readcond();
    cc_parse_coercecond(pcond);
    cc_parse_pushloop((i64)76);
    pbody = cc_parse_readblock((i64)0);
    cc_parse_poploop();
    return cc_lib_createunit2((i64)15,pcond,pbody);
}

static struct cc_decls_unitrec * cc_parse_readdostmt(void) {
    struct cc_decls_unitrec *  pbody;
    struct cc_decls_unitrec *  pcond;
    cc_lex_lex();
    cc_parse_pushloop((i64)76);
    pbody = cc_parse_readblock((i64)0);
    cc_parse_poploop();
    cc_lib_skipsymbol((i64)77);
    pcond = cc_parse_readcond();
    cc_parse_coercecond(pcond);
    cc_lib_skipsymbol((i64)9);
    return cc_lib_createunit2((i64)16,pbody,pcond);
}

static struct cc_decls_unitrec * cc_parse_readreturnstmt(void) {
    struct cc_decls_unitrec *  p;
    cc_lex_lex();
    p = (struct cc_decls_unitrec *)(0);
    if (((i64)((u64)(cc_decls_lx.symbol)) != (i64)9)) {
        if (((i64)((*cc_decls_currproc).mode) == (i64)1)) {
            cc_support_terror((byte*)"Can't return value in void function");
        };
        p = cc_parse_readexpression();
        p = cc_parse_coercemode(p,(i64)((*cc_decls_currproc).mode));
        cc_lib_checksymbol((i64)9);
    } else if (((i64)((*cc_decls_currproc).mode) != (i64)1)) {
        cc_support_terror((byte*)"Return value needed");
    };
    cc_lex_lex();
    return cc_lib_createunit1((i64)10,p);
}

static struct cc_decls_unitrec * cc_parse_readgotostmt(void) {
    struct cc_decls_strec *  d;
    struct cc_decls_unitrec *  p;
    cc_lex_lex();
    cc_lib_checksymbol((i64)68);
    d = cc_lib_resolvename(cc_decls_currproc,cc_decls_lx.symptr,(i64)4,(i64)0);
    if ((d == 0)) {
        d = cc_lib_createdupldef(cc_decls_currproc,cc_decls_lx.symptr,(i64)15);
        (*d).mode = (i64)1;
    };
    p = cc_lib_createunit1((i64)17,(struct cc_decls_unitrec *)(0));
    (*p).def = d;
    cc_lex_lex();
    cc_lib_skipsymbol((i64)9);
    return p;
}

static struct cc_decls_unitrec * cc_parse_readswitchstmt(void) {
    struct cc_decls_unitrec *  pindex;
    struct cc_decls_unitrec *  pstmt;
    struct cc_decls_unitrec *  p;
    cc_lex_lex();
    pindex = cc_parse_readcond();
    cc_parse_pushloop((i64)83);
    pstmt = cc_parse_readblock((i64)0);
    p = cc_lib_createunit2((i64)23,pindex,pstmt);
    (*p).nextcase = cc_parse_casevaluestack[(cc_parse_loopindex)-1];
    cc_parse_poploop();
    return p;
}

static struct cc_decls_unitrec * cc_parse_readcaselabel(void) {
    struct cc_decls_unitrec *  p;
    i64 value;
    cc_lex_lex();
    value = cc_parse_readconstintexpr();
    cc_lib_skipsymbol((i64)10);
    p = cc_lib_createunit1((i64)19,cc_parse_readstatement());
    (*p).value = value;
    cc_parse_addcasevalue(value);
    return p;
}

static struct cc_decls_unitrec * cc_parse_readexprstmt(void) {
    return cc_parse_readexpression();
}

static struct cc_decls_unitrec * cc_parse_readcond(void) {
    struct cc_decls_unitrec *  pcond;
    cc_lib_skipsymbol((i64)12);
    pcond = cc_parse_readexpression();
    cc_lib_skipsymbol((i64)13);
    return pcond;
}

static i64 cc_parse_isusertype(struct cc_decls_strec * owner) {
    struct cc_decls_strec *  d;
    d = cc_lib_resolvename(owner,cc_decls_lx.symptr,(i64)2,cc_decls_currblockno);
    if (!!(d)) {
        if (((i64)((u64)((*d).nameid)) == (i64)5)) {
            return (i64)((*d).mode);
        };
        cc_parse_ist_symptr = d;
    };
    return (i64)0;
}

static struct cc_decls_unitrec * cc_parse_readlocaldecl(void) {
    i64 m;
    i64 mbase;
    i64 linkage;
    i64 nitems;
    i64 wasenum;
    i64 wasdef;
    struct cc_decls_strec *  d;
    struct cc_decls_unitrec *  ulist;
    struct cc_decls_unitrec *  ulistx;
    struct cc_decls_unitrec *  p;
    struct cc_decls_paramrec *  pm;
    ulist = (ulistx = (struct cc_decls_unitrec *)(0));
    wasenum = (i64)(cc_decls_lx.symbol);
    mbase = cc_parse_readdeclspec(cc_decls_currproc,&linkage);
    nitems = (i64)0;
    L690 :;
    if (((i64)(cc_decls_lx.symbol)==(i64)68) || ((i64)(cc_decls_lx.symbol)==(i64)24) || ((i64)(cc_decls_lx.symbol)==(i64)12)) {
        ++nitems;
        m = cc_parse_readtype(cc_decls_currproc,&d,mbase,&pm);
        if ((d == 0)) {
            cc_support_serror((byte*)"Var name expected");
        };
        if ((linkage == (i64)5)) {
            d = cc_parse_createtypedef(cc_decls_currproc,d,m);
        } else if (!!(pm)) {
            if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)16)) {
                cc_support_serror((byte*)"Nested function");
            };
            d = cc_parse_readfunction(d,m,linkage,pm,&wasdef);
        } else {
            d = cc_parse_readframevar(d,m,linkage);
            p = cc_lib_createunit0((i64)7);
            (*p).def = d;
            cc_lib_addlistunit(&ulist,&ulistx,p);
        };
        if (((i64)(cc_decls_lx.symbol)==(i64)8)) {
            cc_lex_lex();
        } else {
            cc_lib_skipsymbol((i64)9);
            goto L691 ;
        };
    } else {
        if ((cc_decls_ttbasetype[(mbase)]==(i64)15) || (cc_decls_ttbasetype[(mbase)]==(i64)20) || (cc_decls_ttbasetype[(mbase)]==(i64)21)) {
            cc_lib_skipsymbol((i64)9);
            goto L691 ;
        }else if ((cc_decls_ttbasetype[(mbase)]==(i64)4)) {
            cc_lib_skipsymbol((i64)9);
            goto L691 ;
        } else {
            cc_support_serror_s((byte*)"Local decl error %s",cc_lib_typename(m));
        };
    }goto L690 ;
L691 :;
    ;
    if (((nitems == (i64)0) && !!(cc_decls_fmodern))) {
        if ((cc_decls_ttbasetype[(mbase)]==(i64)20) || (cc_decls_ttbasetype[(mbase)]==(i64)21) || (cc_decls_ttbasetype[(mbase)]==(i64)15)) {
        } else {
            if ((wasenum != (i64)90)) {
                cc_support_serror((byte*)"Empty local declaration");
            };
        };
    };
    return ulist;
}

static struct cc_decls_strec * cc_parse_createtypedef(struct cc_decls_strec * owner,struct cc_decls_strec * symptr,i64 mode) {
    struct cc_decls_strec *  d;
    d = cc_lib_checkdupl(owner,symptr,(i64)2,cc_decls_currblockno);
    if (!!(d)) {
        if (((i64)((u64)((*d).nameid)) != (i64)5)) {
            cc_support_serror_s((byte*)"Typedef name in use %s",(*d).name);
        };
        if (((i64)((*d).mode) != mode)) {
            if (!(!!(cc_parse_comparemode((i64)((*d).mode),mode)))) {
                cc_support_serror_s((byte*)"Typedef redefined or can't match types %s",(*d).name);
            };
        };
        return d;
    };
    d = cc_lib_createdupldef(owner,symptr,(i64)5);
    (*d).mode = mode;
    cc_decls_tttypedef[(mode)] = d;
    (*d).blockno = (u64)(cc_decls_currblockno);
    cc_decls_blockcounts[(cc_decls_currblockno)] = (i64)1;
    return d;
}

static struct cc_decls_paramrec * cc_parse_readparams(struct cc_decls_strec * owner) {
    struct cc_decls_paramrec *  ulist;
    struct cc_decls_paramrec *  ulistx;
    struct cc_decls_paramrec *  pm;
    struct cc_decls_paramrec *  q;
    i64 m;
    i64 nparams;
    i64 variadic;
    i64 flags;
    i64 nnames;
    struct cc_decls_strec *  d;
    ulist = (ulistx = (struct cc_decls_paramrec *)(0));
    variadic = (nparams = (nnames = (i64)0));
    if (!!(cc_decls_callbackflag)) {
        cc_parse_iscallbackfnx = (u64)((i64)1);
        cc_decls_callbackflag = (i64)0;
    };
    L692 :;
    while (((i64)((u64)(cc_decls_lx.symbol)) != (i64)13)) {
        if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)20)) {
            variadic = (i64)1;
            cc_lex_lex();
            goto L694 ;
        };
        m = cc_parse_readcasttype(&d,(i64)1,&pm);
        if (!!(pm)) {
            m = cc_lib_createrefmode(cc_lib_createprocmode(m,pm));
        };
        if ((cc_decls_ttbasetype[(m)] == (i64)19)) {
            m = cc_lib_createrefmode(cc_decls_tttarget[(m)]);
        };
        pm = (struct cc_decls_paramrec *)(mlib_pcm_allocz((i64)16));
        (*pm).def = d;
        (*pm).mode = m;
        ++nparams;
        if (!!(d)) {
            ++nnames;
            q = ulist;
            L695 :;
            while (!!(q)) {
                if (((*q).def == d)) {
                    cc_support_serror_ss((byte*)"Param name reused %s %s",(*d).name,cc_tables_namenames[((i64)((*d).nameid))]);
                };
                q = (*q).nextparam;
L696 :;
            }L697 :;
            ;
        };
        cc_lib_addlistparam(&ulist,&ulistx,pm);
        if (((i64)(cc_decls_lx.symbol)==(i64)8)) {
            cc_lex_lex();
        }else if (((i64)(cc_decls_lx.symbol)==(i64)20) || ((i64)(cc_decls_lx.symbol)==(i64)13)) {
        } else {
            cc_support_serror((byte*)"bad symbol in paramlist");
        };
L693 :;
    }L694 :;
    ;
    flags = (i64)0;
    cc_lib_skipsymbol((i64)13);
    if (!!(variadic)) {
        flags = (i64)3;
    } else if ((nparams == (i64)0)) {
        if (!!(cc_decls_fmodern)) {
            cc_support_terror((byte*)"() Params not allowed");
        } else {
            flags = (i64)1;
        };
    } else if (((nparams == (i64)1) && (m == (i64)1))) {
        flags = (i64)2;
        nparams = (i64)0;
        (*ulist).mode = (i64)0;
    };
    if ((ulist == 0)) {
        ulist = (struct cc_decls_paramrec *)(mlib_pcm_allocz((i64)16));
    };
    (*ulist).nparams = nparams;
    (*ulist).flags = flags;
    return ulist;
}

static i64 cc_parse_readcasttype(struct cc_decls_strec * * d,i64 allowname,struct cc_decls_paramrec * * pm) {
    struct cc_decls_strec *  owner;
    i64 m;
    i64 linkage;
    owner = (!!(cc_decls_currproc)?cc_decls_currproc:cc_decls_stmodule);
    linkage = (i64)0;
    (*d) = (struct cc_decls_strec *)(0);
    m = cc_parse_readdeclspec(owner,&linkage);
    (*pm) = (struct cc_decls_paramrec *)(0);
    if (((i64)(cc_decls_lx.symbol)==(i64)68) || ((i64)(cc_decls_lx.symbol)==(i64)24) || ((i64)(cc_decls_lx.symbol)==(i64)12) || ((i64)(cc_decls_lx.symbol)==(i64)14)) {
        m = cc_parse_readtype(owner,d,m,pm);
        if ((!!((*d)) && !(!!(allowname)))) {
            cc_support_serror_s((byte*)"NAME not allowed in cast type %s",(*(*d)).name);
        };
    };
    return m;
}

static struct cc_decls_strec * cc_parse_readfunction(struct cc_decls_strec * d,i64 m,i64 linkage,struct cc_decls_paramrec * pm,i64 * wasdef) {
    struct cc_decls_strec *  f;
    struct cc_decls_strec *  owner;
    i64 scope;
    owner = cc_decls_stmodule;
    (*wasdef) = (i64)0;
    f = cc_lib_checkdupl(owner,d,(i64)2,(i64)0);
    if (!!(f)) {
        if (((i64)((u64)((*f).nameid)) != (i64)6)) {
            cc_support_serror_s((byte*)"fn: name in use %s",(*d).name);
        };
        d = f;
        scope = (i64)((*d).scope);
        if (((((scope == (i64)2) && (linkage == (i64)0)) || ((scope == (i64)4) && (linkage == (i64)1))) || ((scope == (i64)3) && (linkage == (i64)1)))) {
        } else if (((scope == (i64)3) && (linkage == (i64)0))) {
            scope = (i64)4;
        };
    } else {
        d = cc_lib_createdupldef(owner,d,(i64)6);
        (*d).mode = m;
        if ((linkage==(i64)1)) {
            scope = (i64)2;
        }else if ((linkage==(i64)4)) {
            scope = (i64)3;
        } else {
            scope = (i64)4;
        };
    };
    if ((!!((u64)(cc_parse_iscallbackfnx)) || !!(cc_decls_fcallback))) {
        (*d).attribs.ax_callback = (u64)((i64)1);
        cc_parse_iscallbackfnx = (u64)((i64)0);
    };
    (*d).paramlist = pm;
    (*d).scope = (u64)(scope);
    if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)16)) {
        (*wasdef) = (i64)1;
        if (!!((*d).code)) {
            cc_support_serror_s((byte*)"Can't define function twice %s",(*d).name);
        };
        if ((scope == (i64)3)) {
        };
        cc_parse_readfunctionbody(d);
        if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)9)) {
            cc_support_serror((byte*)"; after function def");
        };
    };
    return d;
}

static void cc_parse_readfunctionbody(struct cc_decls_strec * f) {
    struct cc_decls_strec *  e;
    struct cc_decls_unitrec *  p;
    struct cc_decls_paramrec *  pm;
    i64 pmcount;
    i64 av_1;
    cc_decls_currproc = f;
    cc_decls_nextblockno = (cc_decls_currblockno = (i64)0);
    pmcount = (i64)0;
    pm = (*f).paramlist;
    if (!!((*pm).def)) {
        av_1 = (i64)((*pm).nparams);
        while (av_1-- > 0) {
L698 :;
            e = cc_lib_createdupldef(f,(*pm).def,(i64)9);
            (*e).blockno = (u64)((i64)1);
            (*e).mode = (i64)((*pm).mode);
            pm = (*pm).nextparam;
            pmcount = (i64)1;
L699 :;
        }L700 :;
        ;
    } else if (!!((i64)((*pm).nparams))) {
        cc_support_serror((byte*)"Param names missing");
    };
    p = cc_parse_readcompoundstmt(pmcount);
    (*cc_decls_currproc).code = p;
    cc_decls_currproc = (struct cc_decls_strec *)(0);
}

static struct cc_decls_unitrec * cc_parse_createnegop(struct cc_decls_unitrec * p) {
    struct cc_decls_unitrec *  q;
    i64 t;
    t = (i64)((*p).mode);
    if (((i64)((*p).tag) == (i64)1)) {
        if ((t==(i64)4) || (t==(i64)5) || (t==(i64)10)) {
            (*p).value = -((*p).value);
            return p;
        }else if ((t==(i64)9)) {
            (*p).value = (-((*p).value) & (i64)4294967295LL);
            return p;
        }else if ((t==(i64)12)) {
            (*p).xvalue = -((*p).xvalue);
            return p;
        };
    };
    /*retry:*/
L701 :;
;
    if (((t >= (i64)2) && (t <= (i64)13))) {
        cc_parse_coercebasetype(p);
        q = cc_lib_createunit1((i64)59,p);
    } else if (!!((u64)(cc_decls_ttconst[(t)]))) {
        t = cc_decls_ttconsttype[(t)];
        goto L701 ;
;
    } else {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(cc_lib_strmode(t,(i64)1),NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        cc_support_terror((byte*)"neg bad type");
    };
    (*q).mode = (i64)((*p).mode);
    return q;
}

static struct cc_decls_unitrec * cc_parse_createabsop(struct cc_decls_unitrec * p) {
    struct cc_decls_unitrec *  q;
    i64 t;
    t = (i64)((*p).mode);
    if (((i64)((*p).tag) == (i64)1)) {
        if ((t==(i64)4) || (t==(i64)5)) {
            (*p).value = labs((*p).value);
            return p;
        };
    };
    if (!!(cc_lib_isintcc(t))) {
        cc_parse_coercebasetype(p);
        q = cc_lib_createunit1((i64)60,p);
    } else {
        cc_support_terror((byte*)"abs bad type");
    };
    (*q).mode = (i64)((*p).mode);
    return q;
}

static struct cc_decls_unitrec * cc_parse_createsqrtop(struct cc_decls_unitrec * p) {
    struct cc_decls_unitrec *  q;
    i64 t;
    t = (i64)((*p).mode);
    if (((i64)((*p).tag) == (i64)1)) {
        if ((t==(i64)11) || (t==(i64)12)) {
            (*p).value = (i64)(sqrt(((*p).xvalue)));
            return p;
        };
    };
    cc_parse_coercemode(p,(i64)12);
    q = cc_lib_createunit1((i64)72,p);
    (*q).mode = (i64)12;
    return q;
}

static struct cc_decls_unitrec * cc_parse_createinotop(struct cc_decls_unitrec * p) {
    struct cc_decls_unitrec *  q;
    i64 t;
    t = cc_decls_ttbasetype[((i64)((*p).mode))];
    if (((i64)((*p).tag) == (i64)1)) {
        if ((t==(i64)4) || (t==(i64)5) || (t==(i64)9) || (t==(i64)10)) {
            (*p).value = ~((*p).value);
            return p;
        };
    };
    if (!!(cc_lib_isintcc(t))) {
        cc_parse_coercebasetype(p);
        q = cc_lib_createunit1((i64)61,p);
    } else {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(cc_lib_strmode(t,(i64)1),NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        cc_support_terror((byte*)"! bad type");
    };
    (*q).mode = (i64)((*p).mode);
    return q;
}

static struct cc_decls_unitrec * cc_parse_createptrop(struct cc_decls_unitrec * p) {
    struct cc_decls_unitrec *  q;
    i64 t;
    i64 m;
    if (!(!!((u64)(cc_decls_ttisref[((t = (i64)((*p).mode)))])))) {
        cc_support_terror((byte*)"* not pointer");
    };
    m = cc_decls_tttarget[(t)];
    if (((i64)((*p).tag)==(i64)56)) {
        q = (*p).a;
        if (!!((i64)((*p).alength))) {
            (*q).mode = cc_decls_tttarget[((i64)((*p).mode))];
        };
        return q;
    };
    q = cc_lib_createunit1((i64)53,p);
    (*q).mode = m;
    q = cc_parse_arraytopointer(q);
    cc_parse_fixmemopnd(q);
    return q;
}

static struct cc_decls_unitrec * cc_parse_createincrop(i64 opc,struct cc_decls_unitrec * p) {
    struct cc_decls_unitrec *  q;
    i64 t;
    t = (i64)((*p).mode);
    cc_parse_checklvalue(p);
    if (!(((!!(cc_lib_isintcc(t)) && (t != (i64)6)) || !!((u64)(cc_decls_ttisref[(t)]))))) {
        cc_support_terror((byte*)"++ bad type");
    };
    q = cc_lib_createunit1(opc,p);
    (*q).mode = (i64)((*p).mode);
    return q;
}

static struct cc_decls_unitrec * cc_parse_createlengthofop(struct cc_decls_unitrec * p) {
    struct cc_decls_unitrec *  q;
    i64 t;
    i64 size;
    t = (i64)((*p).mode);
    switch ((int)((*p).tag)) {
    case 3:;
    {
        size = cc_decls_ttlength[((i64)((*(*p).def).mode))];
    }break;
    case 1:;
    {
        if ((t == cc_decls_trefchar)) {
            size = ((i64)((*p).slength) + (i64)1);
        } else {
            size = cc_decls_ttlength[(t)];
        };
    }break;
    case 53:;
    {
        if ((!!((u64)(cc_decls_ttisref[(t)])) && !!((i64)((*p).alength)))) {
            size = (cc_decls_ttlength[(cc_decls_tttarget[(t)])] * (i64)((*p).alength));
        } else {
            size = cc_decls_ttlength[(t)];
        };
    }break;
    case 4:;
    {
        return cc_parse_createsizeofop((*p).a);
    }break;
    default: {
        size = cc_decls_ttlength[(t)];
    }
    } /* SW */
;
    q = cc_lib_createconstunit((u64)(size),(i64)4);
    return q;
}

static struct cc_decls_unitrec * cc_parse_createaddrofop(struct cc_decls_unitrec * p) {
    struct cc_decls_unitrec *  q;
    i64 t;
    i64 alength;
    alength = (i64)0;
    /*restartx:*/
L702 :;
;
    t = (i64)((*p).mode);
    switch ((int)((*p).tag)) {
    case 3:;
    {
        if (!!((i64)((*p).alength))) {
            t = (i64)((*(*p).def).mode);
            alength = (i64)((*p).alength);
        };
    }break;
    case 56:;
    {
        if ((((i64)((*(*p).a).tag) == (i64)3) && !!((i64)((*(*p).a).alength)))) {
            (*p).mode = cc_lib_createrefmode((i64)((*(*(*p).a).def).mode));
            (*p).alength = (i64)((*(*p).a).alength);
            return p;
        };
    }break;
    case 50:;
    {
        q = (*p).a;
        if ((((i64)((*q).tag) == (i64)53) && ((i64)((*(*q).a).tag) == (i64)1))) {
            p = cc_lib_createconstunit((u64)(((i64)((*p).offset) + (*(*q).a).value)),(i64)4);
            return p;
        };
        goto L703 ;
;
    }break;
    case 54:;
    {
        if (!!((i64)((*p).alength))) {
            (*p).mode = cc_lib_createrefmode(cc_lib_createarraymode(cc_decls_tttarget[((i64)((*p).mode))],(i64)((*p).alength)));
            return p;
        };
    }break;
    case 4:;
    {
        p = (*p).a;
        goto L702 ;
;
    }break;
    case 5:;
    {
        return p;
    }break;
    default: {
        /*cad1:*/
L703 :;
;
        cc_parse_checklvalue(p);
    }
    } /* SW */
;
    p = cc_lib_createunit1((i64)56,p);
    (*p).mode = cc_lib_createrefmode(t);
    (*p).alength = alength;
    return p;
}

static struct cc_decls_unitrec * cc_parse_createaddop(struct cc_decls_unitrec * x,struct cc_decls_unitrec * y) {
    struct cc_decls_unitrec *  z;
    i64 s;
    i64 t;
    i64 u;
    i64 opc;
    i64 elemsize;
    s = cc_decls_ttbasetype[(cc_parse_getmemmode(x))];
    t = cc_decls_ttbasetype[(cc_parse_getmemmode(y))];
    opc = (i64)40;
    if (!!((u = (i64)(cc_tables_dominantmode[(s)][(t)])))) {
        x = cc_parse_coercemode(x,u);
        y = cc_parse_coercemode(y,u);
    } else if ((s == (i64)16)) {
        /*doaddref:*/
L704 :;
;
        u = (i64)((*x).mode);
        elemsize = cc_decls_ttsize[(cc_decls_tttarget[(u)])];
        if ((((i64)((*x).tag) == (i64)1) && ((i64)((*y).tag) == (i64)1))) {
            (*x).value += ((*y).value * elemsize);
            return x;
        };
        y = cc_parse_coercemode(y,(i64)5);
        z = cc_lib_createunit2((i64)54,x,y);
        (*z).mode = u;
        (*z).ptrscale = elemsize;
        return z;
    } else if ((t == (i64)16)) {
        {struct cc_decls_unitrec *  temp = x; x = y; y = temp; };
        goto L704 ;
;
    } else {
        cc_support_terror((byte*)"Sub bad types");
    };
    if ((((i64)((*x).tag) == (i64)1) && ((i64)((*y).tag) == (i64)1))) {
        return cc_parse_eval_add(opc,x,y,u);
    };
    z = cc_lib_createunit2(opc,x,y);
    (*z).mode = u;
    return z;
}

static struct cc_decls_unitrec * cc_parse_createsubop(struct cc_decls_unitrec * x,struct cc_decls_unitrec * y) {
    struct cc_decls_unitrec *  z;
    i64 s;
    i64 t;
    i64 u;
    i64 opc;
    i64 elemsize;
    s = cc_decls_ttbasetype[(cc_parse_getmemmode(x))];
    t = cc_decls_ttbasetype[(cc_parse_getmemmode(y))];
    opc = (i64)41;
    if (!!((u = (i64)(cc_tables_dominantmode[(s)][(t)])))) {
        x = cc_parse_coercemode(x,u);
        y = cc_parse_coercemode(y,u);
    } else if ((s == (i64)16)) {
        if ((t != (i64)16)) {
            u = (i64)((*x).mode);
            elemsize = cc_decls_ttsize[(cc_decls_tttarget[(u)])];
            y = cc_parse_coercemode(y,(i64)5);
            z = cc_lib_createunit2((i64)55,x,y);
            (*z).mode = u;
            (*z).ptrscale = elemsize;
            return z;
        } else {
            z = cc_lib_createunit2(opc,x,y);
            (*z).mode = (i64)5;
            z = cc_parse_divunit(z,cc_decls_tttarget[((i64)((*x).mode))]);
            (*z).mode = (i64)5;
            return z;
        };
        y = cc_parse_mulunit(y,cc_decls_tttarget[((i64)((*x).mode))]);
    } else {
        cc_support_terror((byte*)"Sub bad types");
    };
    if ((((i64)((*x).tag) == (i64)1) && ((i64)((*y).tag) == (i64)1))) {
        return cc_parse_eval_sub(opc,x,y,u);
    };
    z = cc_lib_createunit2(opc,x,y);
    (*z).mode = u;
    return z;
}

static struct cc_decls_unitrec * cc_parse_createmulop(struct cc_decls_unitrec * x,struct cc_decls_unitrec * y) {
    struct cc_decls_unitrec *  z;
    i64 s;
    i64 t;
    i64 u;
    i64 opc;
    s = cc_decls_ttbasetype[(cc_parse_getmemmode(x))];
    t = cc_decls_ttbasetype[(cc_parse_getmemmode(y))];
    opc = (i64)42;
    if (!!((u = (i64)(cc_tables_dominantmode[(s)][(t)])))) {
        x = cc_parse_coercemode(x,u);
        y = cc_parse_coercemode(y,u);
    } else {
        cc_support_terror((byte*)"Mul bad types");
    };
    if ((((i64)((*x).tag) == (i64)1) && ((i64)((*y).tag) == (i64)1))) {
        return cc_parse_eval_mul(opc,x,y,u);
    };
    z = cc_lib_createunit2(opc,x,y);
    (*z).mode = u;
    return z;
}

static struct cc_decls_unitrec * cc_parse_createdivop(struct cc_decls_unitrec * x,struct cc_decls_unitrec * y) {
    struct cc_decls_unitrec *  z;
    i64 s;
    i64 t;
    i64 u;
    i64 opc;
    s = cc_decls_ttbasetype[(cc_parse_getmemmode(x))];
    t = cc_decls_ttbasetype[(cc_parse_getmemmode(y))];
    opc = (i64)43;
    if (!!((u = (i64)(cc_tables_dominantmode[(s)][(t)])))) {
        x = cc_parse_coercemode(x,u);
        y = cc_parse_coercemode(y,u);
    } else {
        cc_support_terror((byte*)"Div bad types");
    };
    if ((((i64)((*x).tag) == (i64)1) && ((i64)((*y).tag) == (i64)1))) {
        return cc_parse_eval_div(opc,x,y,u);
    };
    z = cc_lib_createunit2(opc,x,y);
    (*z).mode = u;
    return z;
}

static struct cc_decls_unitrec * cc_parse_createremop(struct cc_decls_unitrec * x,struct cc_decls_unitrec * y) {
    struct cc_decls_unitrec *  z;
    i64 s;
    i64 t;
    i64 u;
    i64 opc;
    s = cc_decls_ttbasetype[((i64)((*x).mode))];
    t = cc_decls_ttbasetype[((i64)((*y).mode))];
    opc = (i64)44;
    if (!!((u = (i64)(cc_tables_dominantmode[(s)][(t)])))) {
        if (((u == (i64)12) || (u == (i64)11))) {
            u = (i64)4;
        };
        x = cc_parse_coercemode(x,u);
        y = cc_parse_coercemode(y,u);
    } else {
        cc_support_terror((byte*)"Rem bad types");
    };
    if ((((i64)((*x).tag) == (i64)1) && ((i64)((*y).tag) == (i64)1))) {
        return cc_parse_eval_rem(opc,x,y,u);
    };
    z = cc_lib_createunit2(opc,x,y);
    (*z).mode = u;
    return z;
}

static void cc_parse_insertunit(struct cc_decls_unitrec * p,i64 tag) {
    struct cc_decls_unitrec *  q;
    q = cc_lib_createunit0((i64)0);
    (*q) = (*p);
    (*p).tag = tag;
    (*p).a = q;
    (*p).b = ((*p).c = (struct cc_decls_unitrec *)(0));
    (*p).lineno = (u64)((*q).lineno);
    (*p).simple = (u64)((i64)0);
    (*p).nextunit = (*q).nextunit;
    (*q).nextunit = (struct cc_decls_unitrec *)(0);
}

static struct cc_decls_unitrec * cc_parse_eval_add(i64 opc,struct cc_decls_unitrec * x,struct cc_decls_unitrec * y,i64 t) {
    struct cc_decls_unitrec *  z;
    if ((t==(i64)4) || (t==(i64)5) || (t==(i64)9) || (t==(i64)10)) {
        (*x).value += (*y).value;
        return x;
    }else if ((t==(i64)12)) {
        (*x).xvalue += (*y).xvalue;
        return x;
    } else {
        if ((cc_decls_ttbasetype[(t)] == (i64)16)) {
            (*x).value += ((*y).value * cc_decls_ttsize[(cc_decls_tttarget[(t)])]);
            return x;
        };
    };
    z = cc_lib_createunit2(opc,x,y);
    (*z).mode = t;
    return z;
}

static struct cc_decls_unitrec * cc_parse_eval_sub(i64 opc,struct cc_decls_unitrec * x,struct cc_decls_unitrec * y,i64 t) {
    struct cc_decls_unitrec *  z;
    if ((t==(i64)4) || (t==(i64)5) || (t==(i64)9) || (t==(i64)10)) {
        (*x).value -= (*y).value;
        return x;
    }else if ((t==(i64)12)) {
        (*x).xvalue -= (*y).xvalue;
        return x;
    } else {
        if ((cc_decls_ttbasetype[(t)] == (i64)16)) {
            if ((cc_decls_ttbasetype[((i64)((*y).mode))] == (i64)16)) {
                cc_support_terror((byte*)"EVALSUB/REF");
            };
            return x;
        };
    };
    z = cc_lib_createunit2(opc,x,y);
    (*z).mode = t;
    return z;
}

static struct cc_decls_unitrec * cc_parse_eval_mul(i64 opc,struct cc_decls_unitrec * x,struct cc_decls_unitrec * y,i64 t) {
    struct cc_decls_unitrec *  z;
    if ((t==(i64)4) || (t==(i64)5) || (t==(i64)3) || (t==(i64)2)) {
        (*x).value *= (*y).value;
        return x;
    }else if ((t==(i64)9) || (t==(i64)10) || (t==(i64)8) || (t==(i64)7)) {
        (*x).uvalue = ((*x).uvalue * (*y).uvalue);
        return x;
    }else if ((t==(i64)12)) {
        (*x).xvalue *= (*y).xvalue;
        return x;
    };
    z = cc_lib_createunit2(opc,x,y);
    (*z).mode = t;
    return z;
}

static struct cc_decls_unitrec * cc_parse_eval_div(i64 opc,struct cc_decls_unitrec * x,struct cc_decls_unitrec * y,i64 t) {
    struct cc_decls_unitrec *  z;
    if ((t==(i64)4) || (t==(i64)5)) {
        if (((*y).value == (i64)0)) {
            cc_support_serror((byte*)"div 0");
        };
        (*x).value = ((*x).value / (*y).value);
        return x;
    }else if ((t==(i64)9) || (t==(i64)10)) {
        if (((*y).value == (i64)0)) {
            cc_support_serror((byte*)"div 0");
        };
        (*x).value = ((*x).value / (*y).value);
        return x;
    }else if ((t==(i64)12)) {
        (*x).xvalue /= (*y).xvalue;
        return x;
    };
    z = cc_lib_createunit2(opc,x,y);
    (*z).mode = t;
    return z;
}

static struct cc_decls_unitrec * cc_parse_eval_rem(i64 opc,struct cc_decls_unitrec * x,struct cc_decls_unitrec * y,i64 t) {
    struct cc_decls_unitrec *  z;
    if ((t==(i64)4) || (t==(i64)5)) {
        if (((*y).value == (i64)0)) {
            cc_support_serror((byte*)"rem 0");
        };
        (*x).value = ((*x).value % (*y).value);
        return x;
    };
    z = cc_lib_createunit2(opc,x,y);
    (*z).mode = t;
    return z;
}

static i64 cc_parse_eval_convert(struct cc_decls_unitrec * p,i64 t,i64 opc) {
    i64 s;
    if ((opc == (i64)1)) {
        /*dosoft:*/
L705 :;
;
        (*p).mode = t;
        return (i64)1;
    };
    s = (i64)((*p).mode);
    if ((s == t)) {
        return (i64)1;
    };
    if ((s==(i64)4) || (s==(i64)3) || (s==(i64)2) || (s==(i64)5)) {
        if ((t==(i64)12) || (t==(i64)11)) {
            (*p).xvalue = (double)((*p).value);
            (*p).mode = t;
            return (i64)1;
        }else if ((t==(i64)10) || (t==(i64)5) || (t==(i64)9) || (t==(i64)4) || (t==(i64)3) || (t==(i64)2) || (t==(i64)7) || (t==(i64)8)) {
            /*dotrunc:*/
L706 :;
;
            if ((cc_decls_ttsize[(t)]==(i64)1)) {
                (*p).value &= (i64)255;
            }else if ((cc_decls_ttsize[(t)]==(i64)2)) {
                (*p).value &= (i64)65535;
            }else if ((cc_decls_ttsize[(t)]==(i64)4)) {
                (*p).value = ((*p).value & (i64)4294967295LL);
            };
            goto L705 ;
;
        };
        if (!!((u64)(cc_decls_ttisref[(t)]))) {
            (*p).mode = t;
            return (i64)1;
        };
    }else if ((s==(i64)9) || (s==(i64)7) || (s==(i64)8) || (s==(i64)10)) {
        if ((t==(i64)12) || (t==(i64)11)) {
            return (i64)1;
            cc_support_serror((byte*)"ULLONG TO FLOAT");
            (*p).mode = t;
            return (i64)1;
        }else if ((t==(i64)10) || (t==(i64)5) || (t==(i64)4) || (t==(i64)9) || (t==(i64)10) || (t==(i64)8) || (t==(i64)2) || (t==(i64)7) || (t==(i64)3)) {
            goto L706 ;
;
        };
        if (!!((u64)(cc_decls_ttisref[(t)]))) {
            (*p).mode = t;
            return (i64)1;
        };
    }else if ((s==(i64)12)) {
        if ((t==(i64)4)) {
            (*p).value = (i64)((*p).xvalue);
            (*p).mode = (i64)4;
            return (i64)1;
        }else if ((t==(i64)11)) {
            (*p).mode = (i64)11;
            return (i64)1;
        };
    } else {
        if (!!((u64)(cc_decls_ttisref[((i64)((*p).mode))]))) {
            if ((t==(i64)4) || (t==(i64)5) || (t==(i64)9) || (t==(i64)10)) {
                (*p).mode = t;
                return (i64)1;
            };
        };
    };
    return (i64)0;
}

static void cc_parse_coercecond(struct cc_decls_unitrec * p) {
    i64 t;
    if (((t = (i64)((*p).mode)) == (i64)4)) {
        return;
    };
    /*retry:*/
L707 :;
;
    if ((cc_decls_ttbasetype[(t)]==(i64)11) || (cc_decls_ttbasetype[(t)]==(i64)12) || (cc_decls_ttbasetype[(t)]==(i64)16)) {
        goto L708 ;
;
    } else {
        if (!!(cc_lib_isintcc(t))) {
            /*doint:*/
L708 :;
;
            if ((((i64)((*p).tag) == (i64)1) && !!((*p).value))) {
                (*p).value = (i64)1;
            } else {
                cc_parse_insertunit(p,(i64)28);
            };
        } else if (!!((u64)(cc_decls_ttconst[(t)]))) {
            t = cc_decls_ttconsttype[(t)];
            goto L707 ;
;
        } else {
            cc_support_serror_s((byte*)"Invalid condition %s",cc_lib_strmode(t,(i64)1));
        };
    };
    (*p).mode = (i64)4;
}

static void cc_parse_coercebasetype(struct cc_decls_unitrec * p) {
    i64 t;
    if ((((t = (i64)((*p).mode)) >= (i64)2) && (t <= (i64)3))) {
        p = cc_parse_coercemode(p,(i64)4);
    } else if (((t >= (i64)6) && (t <= (i64)8))) {
        p = cc_parse_coercemode(p,(i64)9);
    };
}

static void cc_parse_checklvalue(struct cc_decls_unitrec * p) {
    if (((i64)((*p).tag)==(i64)3)) {
        if (((i64)((u64)((*(*p).def).nameid)) == (i64)14)) {
            cc_support_serror((byte*)"'constant' name can't be lvalue");
        };
    }else if (((i64)((*p).tag)==(i64)53)) {
    }else if (((i64)((*p).tag)==(i64)5)) {
    }else if (((i64)((*p).tag)==(i64)4)) {
        if (((i64)((*(*p).a).tag)==(i64)3) || ((i64)((*(*p).a).tag)==(i64)53) || ((i64)((*(*p).a).tag)==(i64)50)) {
            (*p) = (*(*p).a);
        } else {
            cc_support_terror((byte*)"CHECKLV/WIDEN");
        };
    }else if (((i64)((*p).tag)==(i64)50)) {
    }else if (((i64)((*p).tag)==(i64)1)) {
        if (!(!!((u64)(cc_decls_ttisref[((i64)((*p).mode))])))) {
            goto L709 ;
;
        };
    }else if (((i64)((*p).tag)==(i64)57)) {
        if (((i64)((*(*p).a).tag) == (i64)3)) {
            return;
        };
    } else {
        /*notlv:*/
L709 :;
;
        cc_lib_printunit(0,p,(i64)0,(byte*)"*");
        cc_support_terror_s((byte*)"Not lvalue: %s",cc_tables_jtagnames[((i64)((*p).tag))]);
    };
}

static struct cc_decls_unitrec * cc_parse_createcall(struct cc_decls_unitrec * p,struct cc_decls_unitrec * q) {
    struct cc_decls_unitrec *  r;
    struct cc_decls_unitrec *  s;
    struct cc_decls_unitrec *  u;
    struct cc_decls_strec *  d;
    struct cc_decls_paramrec *  pm;
    i64 i;
    i64 nparams;
    i64 aparams;
    i64 retmode;
    i64 mproc;
    i64 c;
    byte str[1024];
    byte *  ss;
    byte *  tt;
    byte *  uu;
    struct mlib_strbuffer *  exprstr;
    i64 av_1;
    d = (struct cc_decls_strec *)(0);
    if (((i64)((*p).tag)==(i64)53)) {
        /*doptr:*/
L710 :;
;
        mproc = (i64)((*p).mode);
        L711 :;
        while ((cc_decls_ttbasetype[(mproc)] == (i64)16)) {
            r = cc_lib_createunit1((i64)53,p);
            mproc = cc_decls_tttarget[(mproc)];
            (*r).mode = mproc;
            p = r;
L712 :;
        }L713 :;
        ;
        if ((cc_decls_ttbasetype[(mproc)] != (i64)17)) {
            cc_support_serror_s((byte*)"Not function pointer: %s",cc_lib_typename(mproc));
        };
        pm = cc_decls_ttparams[(mproc)];
        retmode = cc_decls_tttarget[(mproc)];
    }else if (((i64)((*p).tag)==(i64)3) || ((i64)((*p).tag)==(i64)5)) {
        d = (*p).def;
        if (((i64)((u64)((*d).nameid)) == (i64)6)) {
            pm = (*d).paramlist;
            retmode = (i64)((*d).mode);
        } else {
            r = cc_lib_createunit1((i64)53,p);
            (*r).mode = cc_decls_tttarget[((i64)((*d).mode))];
            (*r).mode = (i64)((*p).mode);
            p = r;
            goto L710 ;
;
        };
    }else if (((i64)((*p).tag)==(i64)50) || ((i64)((*p).tag)==(i64)31) || ((i64)((*p).tag)==(i64)32)) {
        r = cc_lib_createunit1((i64)53,p);
        (*r).mode = cc_decls_tttarget[((i64)((*p).mode))];
        p = r;
        goto L710 ;
;
    } else {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"JTAGNAMES[P^.TAG]=",NULL);
        msysnewc_m_print_str(cc_tables_jtagnames[((i64)((*p).tag))],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        cc_lib_printunit(0,p,(i64)0,(byte*)"*");
        cc_support_serror((byte*)"ccall?");
    };
    nparams = (i64)((*pm).nparams);
    aparams = (i64)0;
    s = q;
    L714 :;
    while (!!(s)) {
        ++aparams;
        s = (*s).nextunit;
L715 :;
    }L716 :;
    ;
    if ((aparams < nparams)) {
        cc_support_terror((byte*)"Too few args");
    } else if ((((aparams > nparams) && ((i64)((*pm).flags) != (i64)3)) && ((i64)((*pm).flags) != (i64)1))) {
        if (((i64)((*pm).flags) != (i64)1)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_i64(aparams,NULL);
            msysnewc_m_print_i64(nparams,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            cc_support_terror((byte*)"Too many args");
        } else if (!!(cc_decls_fmodern)) {
            cc_support_terror((byte*)"Can't call () param function");
        };
    };
    s = q;
    L717 :;
    for (i=(i64)1;i<=aparams;i+=(i64)1) {
L718 :;
        if ((i <= nparams)) {
            cc_parse_coercemode_inplace(s,(i64)((*pm).mode));
            pm = (*pm).nextparam;
        } else {
            if (((i64)((*s).mode) == (i64)1)) {
                cc_support_terror((byte*)"Variadic param is void");
            };
            cc_parse_coercebasetype(s);
        };
        s = (*s).nextunit;
L719 :;
    }L720 :;
    ;
    r = cc_lib_createunit2((i64)31,p,q);
    (*r).mode = retmode;
    (*r).aparams = aparams;
    if (((((!!(d) && !!(mlib_eqstring((*d).name,(byte*)"printf"))) && !!(q)) && ((i64)((*q).tag) == (i64)1)) && ((i64)((*q).slength) < (i64)512))) {
        ss = (*q).svalue;
        tt = str;
        u = (*q).nextunit;
        L721 :;
        while (!!((c = (i64)((*ss++))))) {
            if ((((c == (i64)37) && (((*ss) == (i64)63) || ((*ss) == (i64)61))) && !!(u))) {
                if (((u64)((*ss)) == '=')) {
                    ++ss;
                    exprstr = cc_lib_strexpr(u);
                    uu = (*exprstr).strptr;
                    mlib_convucstring(uu);
                    av_1 = (i64)((*exprstr).length);
                    while (av_1-- > 0) {
L724 :;
                        (*tt++) = (u64)((*uu++));
L725 :;
                    }L726 :;
                    ;
                    (*tt++) = '=';
                };
                ++ss;
                (*tt++) = '%';
                if ((cc_decls_ttbasetype[((i64)((*u).mode))]==(i64)4)) {
                    (*tt++) = 'd';
                }else if ((cc_decls_ttbasetype[((i64)((*u).mode))]==(i64)5)) {
                    (*tt++) = 'l';
                    (*tt++) = 'l';
                    (*tt++) = 'd';
                }else if ((cc_decls_ttbasetype[((i64)((*u).mode))]==(i64)9)) {
                    (*tt++) = 'u';
                }else if ((cc_decls_ttbasetype[((i64)((*u).mode))]==(i64)10)) {
                    (*tt++) = 'l';
                    (*tt++) = 'l';
                    (*tt++) = 'u';
                }else if ((cc_decls_ttbasetype[((i64)((*u).mode))]==(i64)11) || (cc_decls_ttbasetype[((i64)((*u).mode))]==(i64)12) || (cc_decls_ttbasetype[((i64)((*u).mode))]==(i64)13)) {
                    (*tt++) = 'f';
                }else if ((cc_decls_ttbasetype[((i64)((*u).mode))]==(i64)16)) {
                    if ((cc_decls_tttarget[((i64)((*u).mode))] == (i64)2)) {
                        (*tt++) = 's';
                    } else {
                        (*tt++) = 'p';
                    };
                } else {
                    (*tt++) = '?';
                };
                u = (*u).nextunit;
            } else {
                (*tt++) = (u64)(c);
            };
L722 :;
        }L723 :;
        ;
        (*tt) = (u64)0u;
        (*q).svalue = mlib_pcm_copyheapstring(str);
        (*q).slength = (i64)(strlen((i8 *)(str)));
    };
    return r;
}

static struct cc_decls_unitrec * cc_parse_arraytopointer(struct cc_decls_unitrec * p) {
    struct cc_decls_unitrec *  q;
    i64 offset;
    i64 t;
    i64 elemmode;
    i64 refmode;
    t = (i64)((*p).mode);
    elemmode = cc_decls_tttarget[(t)];
    if ((cc_decls_ttbasetype[(t)] == (i64)19)) {
        refmode = cc_lib_createrefmode(elemmode);
        if (((i64)((*p).tag)==(i64)53)) {
            p = (*p).a;
        }else if (((i64)((*p).tag)==(i64)50)) {
            offset = (i64)((*p).offset);
            (*p).tag = (i64)54;
            (*p).ptrscale = (i64)0;
            q = cc_lib_createunit1((i64)56,(*p).a);
            (*q).mode = refmode;
            (*p).a = q;
            (*p).b = cc_lib_createconstunit((u64)(offset),(i64)4);
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)"ATP:",NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            cc_lib_printunit(0,p,(i64)0,(byte*)"*");
            cc_support_terror((byte*)"ATP?");
        };
        (*p).mode = refmode;
        (*p).alength = cc_decls_ttlength[(t)];
    };
    return p;
}

static struct cc_decls_unitrec * cc_parse_createindexop(struct cc_decls_unitrec * p,struct cc_decls_unitrec * q) {
    struct cc_decls_unitrec *  a;
    a = cc_parse_createaddop(p,q);
    return cc_parse_createptrop(a);
}

static i64 cc_parse_readstructdecl(struct cc_decls_strec * owner) {
    struct cc_decls_strec *  d;
    struct cc_decls_strec *  e;
    struct cc_decls_strec *  currrecord;
    struct cc_decls_strec *  ulist;
    struct cc_decls_strec *  ulistx;
    struct cc_decls_strec *  tagowner;
    i64 funion;
    i64 linkage;
    i64 mbase;
    i64 m;
    i64 offset;
    i64 recsize;
    i64 maxsize;
    i64 maxalignment;
    i64 alignment;
    i64 size;
    struct cc_decls_paramrec *  pm;
    struct cc_decls_fieldrec *  fieldlist;
    funion = ((i64)((u64)(cc_decls_lx.symbol)) == (i64)85);
    cc_lex_lex();
    tagowner = (!!(cc_decls_currproc)?cc_decls_currproc:cc_decls_stmodule);
    if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)16)) {
        d = cc_lex_addnamestr(cc_lib_nextautotype());
    } else {
        cc_lib_checksymbol((i64)68);
        d = cc_decls_lx.symptr;
        cc_lex_lex();
        if (((i64)((u64)(cc_decls_lx.symbol)) != (i64)16)) {
            e = cc_lib_resolvename(tagowner,d,(i64)3,cc_decls_currblockno);
            if (!!(e)) {
                if (((i64)((u64)((*e).nameid)) != (i64)13)) {
                    cc_support_serror_s((byte*)"Struct tag in use %s",(*e).name);
                };
                return (i64)((*e).mode);
            };
            e = cc_lib_createdupldef(tagowner,d,(i64)13);
            (*e).mode = cc_lib_createstructmode(e,(!!(funion)?(i64)21:(i64)20));
            (*e).blockno = (u64)(cc_decls_currblockno);
            cc_decls_blockcounts[(cc_decls_currblockno)] = (i64)1;
            return (i64)((*e).mode);
        };
    };
    e = cc_lib_checkdupl(tagowner,d,(i64)3,cc_decls_currblockno);
    if (!!(e)) {
        if (((i64)((u64)((*e).nameid)) != (i64)13)) {
            cc_support_serror_s((byte*)"Struct tag in use %s",(*e).name);
        };
        if (!!((*e).deflist)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)"Prev",NULL);
            msysnewc_m_print_i64(((i64)((u64)((*e).lineno)) & (i64)1677215),NULL);
            msysnewc_m_print_str(cc_decls_sourcefilenames[((i64)(((u64)((*e).lineno) >> (i64)24)))],NULL);
            msysnewc_m_print_str(cc_decls_sourcefilepaths[((i64)(((u64)((*e).lineno) >> (i64)24)))],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            cc_support_serror_s((byte*)"Redefining struct %s",(*e).name);
        };
    } else {
        e = cc_lib_createdupldef(tagowner,d,(i64)13);
        (*e).mode = cc_lib_createstructmode(e,(!!(funion)?(i64)21:(i64)20));
        (*e).blockno = (u64)(cc_decls_currblockno);
        cc_decls_blockcounts[(cc_decls_currblockno)] = (i64)1;
    };
    cc_lex_lex();
    currrecord = e;
    ulist = (ulistx = (struct cc_decls_strec *)(0));
    offset = (maxsize = (recsize = (i64)0));
    maxalignment = (i64)1;
    fieldlist = (struct cc_decls_fieldrec *)(0);
    m = (i64)-1;
    L727 :;
    while (((i64)((u64)(cc_decls_lx.symbol)) != (i64)17)) {
        mbase = cc_parse_readdeclspec(currrecord,&linkage);
        L730 :;
        if (((i64)(cc_decls_lx.symbol)==(i64)68) || ((i64)(cc_decls_lx.symbol)==(i64)24) || ((i64)(cc_decls_lx.symbol)==(i64)12)) {
            m = cc_parse_readtype(currrecord,&d,mbase,&pm);
            if ((d == 0)) {
                cc_support_serror((byte*)"Field name expected");
            };
            if (((linkage == (i64)5) || !!(pm))) {
                cc_support_serror((byte*)"typedef or function inside struct");
            };
            e = cc_lib_checkdupl(currrecord,d,(i64)5,(i64)0);
            if (!!(e)) {
                cc_support_serror_s((byte*)"member name in use %s",(*e).name);
            };
            if ((linkage != (i64)0)) {
                cc_support_serror((byte*)"Can't use ss in struct");
            };
            /*addanonfield:*/
L732 :;
;
            d = cc_lib_createdupldef((struct cc_decls_strec *)(0),d,(i64)10);
            (*d).mode = m;
            cc_lib_addlistdef(&ulist,&ulistx,d);
            (*currrecord).deflist = ulist;
            (*currrecord).deflistx = ulistx;
            (*d).owner = currrecord;
            alignment = cc_lib_getalignment(m);
            if ((alignment > maxalignment)) {
                maxalignment = alignment;
            };
            (*d).offset = cc_parse_roundoffset(offset,alignment);
            size = cc_decls_ttsize[(m)];
            recsize += ((*d).offset - offset);
            offset = (*d).offset;
            cc_parse_addnewfield(&fieldlist,d,offset);
            if (!!(funion)) {
                maxsize = (maxsize>size?maxsize:size);
            } else {
                offset += size;
                recsize += size;
            };
            if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)10)) {
                cc_lex_lex();
                cc_parse_readassignexpr();
            };
            if (((i64)(cc_decls_lx.symbol)==(i64)8)) {
                cc_lex_lex();
            } else {
                cc_lib_skipsymbol((i64)9);
                goto L731 ;
            };
        }else if (((i64)(cc_decls_lx.symbol)==(i64)10)) {
            cc_lex_lex();
            cc_parse_readassignexpr();
            cc_lib_skipsymbol((i64)9);
            goto L731 ;
        } else {
            if ((cc_decls_ttbasetype[(mbase)]==(i64)20) || (cc_decls_ttbasetype[(mbase)]==(i64)21)) {
                d = cc_lib_getautofieldname();
                m = mbase;
                goto L732 ;
;
            } else {
                if ((m == (i64)-1)) {
                    cc_support_serror((byte*)"Struct decl error");
                } else {
                    cc_support_serror_s((byte*)"Struct decl error %s",cc_lib_typename(m));
                };
            };
        }goto L730 ;
L731 :;
        ;
L728 :;
    }L729 :;
    ;
    cc_lib_skipsymbol((i64)17);
    (*currrecord).nextfield = fieldlist;
    cc_decls_ttsize[((i64)((*currrecord).mode))] = cc_parse_roundoffset((!!(funion)?maxsize:recsize),maxalignment);
    (*currrecord).attribs.ax_align = (u64)(maxalignment);
    return (i64)((*currrecord).mode);
}

static i64 cc_parse_checkpointertypes(i64 s,i64 t,i64 hard) {
    i64 starget;
    i64 ttarget;
    i64 sconst;
    i64 tconst;
    starget = cc_decls_tttarget[(s)];
    ttarget = cc_decls_tttarget[(t)];
    sconst = (i64)0;
    tconst = (i64)0;
    if (!!((u64)(cc_decls_ttconst[(starget)]))) {
        starget = cc_decls_ttconsttype[(starget)];
        sconst = (i64)1;
    };
    if (!!((u64)(cc_decls_ttconst[(ttarget)]))) {
        ttarget = cc_decls_ttconsttype[(ttarget)];
        tconst = (i64)1;
    };
    if (((!(!!(hard)) && !!(sconst)) && !(!!(tconst)))) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(cc_lib_strmode(s,(i64)1),NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(cc_lib_strmode(t,(i64)1),NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        cc_support_terror((byte*)"const to non-const pointer");
    };
    if ((starget == ttarget)) {
        return (i64)1;
    };
    s = starget;
    t = ttarget;
    if (((cc_decls_ttbasetype[(s)] == (i64)1) || (cc_decls_ttbasetype[(t)] == (i64)1))) {
        return (i64)1;
    };
    if ((!!((u64)(cc_decls_ttisref[(s)])) && !!((u64)(cc_decls_ttisref[(t)])))) {
        return cc_parse_checkpointertypes(s,t,hard);
    } else if (((cc_decls_ttbasetype[(s)] == (i64)19) && (cc_decls_ttbasetype[(t)] == (i64)19))) {
        if ((cc_decls_ttlength[(s)] != cc_decls_ttlength[(t)])) {
            if ((!!(cc_decls_ttlength[(s)]) && !!(cc_decls_ttlength[(t)]))) {
                return (i64)0;
            };
        };
        starget = cc_decls_tttarget[(s)];
        ttarget = cc_decls_tttarget[(t)];
        if ((starget == ttarget)) {
            return (i64)1;
        };
        if ((!!((u64)(cc_decls_ttisref[(starget)])) && !!((u64)(cc_decls_ttisref[(ttarget)])))) {
            return cc_parse_checkpointertypes(starget,ttarget,hard);
        };
    } else if (((cc_decls_ttbasetype[(s)] == (i64)17) && (cc_decls_ttbasetype[(t)] == (i64)17))) {
        return (i64)1;
    };
    return (i64)0;
}

static i64 cc_parse_comparemode(i64 s,i64 t) {
    if ((s == t)) {
        return (i64)1;
    };
    if (((cc_decls_ttbasetype[(s)] == (i64)19) && (cc_decls_ttbasetype[(s)] == (i64)19))) {
        if ((cc_parse_comparemode(cc_decls_tttarget[(s)],cc_decls_tttarget[(t)]) == (i64)0)) {
            return (i64)0;
        };
        if ((((cc_decls_ttlength[(s)] == (i64)0) || (cc_decls_ttlength[(t)] == (i64)0)) || (cc_decls_ttlength[(s)] == cc_decls_ttlength[(t)]))) {
            return (i64)1;
        };
    };
    return (i64)0;
}

static i64 cc_parse_readenumdecl(struct cc_decls_strec * owner) {
    struct cc_decls_strec *  d;
    struct cc_decls_strec *  e;
    cc_lex_lex();
    if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)16)) {
        cc_parse_readenumnames(owner);
        return (i64)15;
    };
    cc_lib_checksymbol((i64)68);
    d = cc_decls_lx.symptr;
    cc_lex_lex();
    if (((i64)((u64)(cc_decls_lx.symbol)) != (i64)16)) {
        e = cc_lib_checkdupl(owner,d,(i64)3,cc_decls_currblockno);
        if (!!(e)) {
            if (((i64)((u64)((*e).nameid)) != (i64)12)) {
                cc_support_serror_s((byte*)"Enum tag in use %s",(*e).name);
            };
        };
        e = cc_lib_createdupldef(owner,d,(i64)12);
        (*e).mode = cc_lib_createenummode(e);
        (*e).blockno = (u64)(cc_decls_currblockno);
        cc_decls_blockcounts[(cc_decls_currblockno)] = (i64)1;
        return (i64)((*e).mode);
    };
    e = cc_lib_checkdupl(owner,d,(i64)3,cc_decls_currblockno);
    if (!!(e)) {
        if (((i64)((u64)((*e).nameid)) != (i64)12)) {
            cc_support_serror_s((byte*)"Enum tag in use %s",(*e).name);
        };
        if (!!((*e).deflist)) {
            cc_support_serror_s((byte*)"Redefining enum %s",(*e).name);
        };
    } else {
        e = cc_lib_createdupldef(owner,d,(i64)12);
        (*e).mode = cc_lib_createenummode(e);
        (*e).blockno = (u64)(cc_decls_currblockno);
        cc_decls_blockcounts[(cc_decls_currblockno)] = (i64)1;
    };
    cc_parse_readenumnames(owner);
    cc_decls_ttnamedef[((i64)((*e).mode))] = e;
    return (i64)((*e).mode);
}

static void cc_parse_readenumnames(struct cc_decls_strec * owner) {
    struct cc_decls_strec *  d;
    struct cc_decls_strec *  ulist;
    struct cc_decls_strec *  ulistx;
    i64 enumseq;
    ulist = (ulistx = (struct cc_decls_strec *)(0));
    enumseq = (i64)0;
    cc_lex_lex();
    if (((i64)((*owner).nameid)==(i64)6) || ((i64)((*owner).nameid)==(i64)3)) {
    } else {
        owner = (!!(cc_decls_currproc)?cc_decls_currproc:cc_decls_stmodule);
    };
    L733 :;
    while (((i64)((u64)(cc_decls_lx.symbol)) == (i64)68)) {
        d = cc_lib_checkdupl(owner,cc_decls_lx.symptr,(i64)2,cc_decls_currblockno);
        if (!!(d)) {
            cc_support_serror_s((byte*)"enum name reused %s",(*d).name);
        };
        d = cc_lib_createdupldef(owner,cc_decls_lx.symptr,(i64)11);
        cc_lex_lex();
        if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)11)) {
            cc_lex_lex();
            enumseq = cc_parse_readconstintexpr();
        };
        (*d).index = enumseq;
        (*d).blockno = (u64)(cc_decls_currblockno);
        cc_decls_blockcounts[(cc_decls_currblockno)] = (i64)1;
        ++enumseq;
        if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)8)) {
            cc_lex_lex();
        };
L734 :;
    }L735 :;
    ;
    cc_lib_skipsymbol((i64)17);
}

static struct cc_decls_unitrec * cc_parse_createdotop(i64 opc,struct cc_decls_unitrec * p,struct cc_decls_strec * d) {
    struct cc_decls_unitrec *  poffset;
    struct cc_decls_strec *  f;
    struct cc_decls_strec *  prec;
    struct cc_decls_strec *  gend;
    i64 m;
    i64 offset;
    struct cc_decls_fieldrec *  fl;
    m = (i64)((*p).mode);
    if ((opc == (i64)51)) {
        if (!(!!((u64)(cc_decls_ttisref[(m)])))) {
            cc_support_serror((byte*)"-> needs pointer");
        };
        m = cc_decls_tttarget[(m)];
    };
    if ((cc_decls_ttbasetype[(m)]==(i64)20) || (cc_decls_ttbasetype[(m)]==(i64)21)) {
    } else {
        cc_support_serror((byte*)". -> not a struct");
    };
    prec = cc_decls_ttnamedef[(m)];
    f = d;
    L736 :;
    while (!!((f = (*f).nextdupl))) {
        if (((*f).owner == prec)) {
            offset = (*f).offset;
            goto L738 ;
        };
L737 :;
    }L738 :;
    ;
    if (!(!!(f))) {
        gend = d;
        L739 :;
        while (!!((*gend).prevdupl)) {
            gend = (*gend).prevdupl;
L740 :;
        }L741 :;
        ;
        fl = (*prec).nextfield;
        L742 :;
        while (!!(fl)) {
            if (((*fl).gendef == gend)) {
                f = (*fl).def;
                offset = (*fl).offset;
                goto L744 ;
            };
            fl = (*fl).nextfield;
L743 :;
        }L744 :;
        ;
    };
    if (!(!!(f))) {
        cc_support_terror_ss((byte*)"Not a field of struct %s %s",(*d).name,cc_lib_strmode(m,(i64)1));
    };
    poffset = cc_lib_createconstunit((u64)(offset),(i64)4);
    if ((opc == (i64)51)) {
        p = cc_parse_createptrop(p);
    };
    p = cc_lib_createunit1((i64)50,p);
    (*p).offset = offset;
    (*p).mode = (i64)((*f).mode);
    p = cc_parse_arraytopointer(p);
    cc_parse_fixmemopnd(p);
    return p;
}

static struct cc_decls_unitrec * cc_parse_mulunit(struct cc_decls_unitrec * p,i64 elemtype) {
    i64 elemsize;
    if (((elemsize = cc_decls_ttsize[(elemtype)]) != (i64)1)) {
        if (((i64)((*p).tag) == (i64)1)) {
            (*p).value = ((*p).value * elemsize);
        } else {
            p = cc_lib_createunit1((i64)58,p);
            (*p).scale = elemsize;
            (*p).mode = (i64)5;
        };
    };
    return p;
}

static struct cc_decls_unitrec * cc_parse_divunit(struct cc_decls_unitrec * p,i64 elemtype) {
    i64 elemsize;
    if (((elemsize = cc_decls_ttsize[(elemtype)]) != (i64)1)) {
        if (((i64)((*p).tag) == (i64)1)) {
            (*p).value = ((*p).value / elemsize);
        } else {
            p = cc_lib_createunit1((i64)58,p);
            (*p).scale = -(elemsize);
            (*p).mode = (i64)5;
        };
    };
    return p;
}

static struct cc_decls_unitrec * cc_parse_createassignopref(i64 opc,struct cc_decls_unitrec * p,struct cc_decls_unitrec * q) {
    i64 pmode;
    i64 qmode;
    i64 rmode;
    i64 elemmode;
    struct cc_decls_unitrec *  r;
    pmode = (rmode = (i64)((*p).mode));
    elemmode = cc_decls_tttarget[(pmode)];
    qmode = (i64)((*q).mode);
    if ((opc==(i64)11)) {
        q = cc_parse_coercemode(q,pmode);
        r = cc_lib_createunit2((i64)12,p,q);
    }else if ((opc==(i64)45)) {
        if (!!((u64)(cc_decls_ttisref[(qmode)]))) {
            cc_support_serror((byte*)"ptr+=ptr");
        };
        q = cc_parse_coercemode(q,(i64)5);
        r = cc_lib_createunit2((i64)62,p,cc_parse_mulunit(q,elemmode));
    }else if ((opc==(i64)46)) {
        if (!!((u64)(cc_decls_ttisref[(qmode)]))) {
            if (!(!!(cc_parse_comparemode(pmode,qmode)))) {
                cc_support_serror((byte*)"-= refs don't match");
            };
            r = cc_parse_divunit(cc_lib_createunit2((i64)41,p,q),elemmode);
            rmode = (i64)4;
        } else {
            r = cc_lib_createunit2((i64)63,p,cc_parse_mulunit(q,elemmode));
        };
    } else {
        cc_support_serror((byte*)"Not allowed on ptrs");
    };
    (*r).mode = rmode;
    return r;
}

static void cc_parse_addnewfield(struct cc_decls_fieldrec * * flist,struct cc_decls_strec * d,i64 offset) {
    struct cc_decls_strec *  e;
    struct cc_decls_fieldrec *  f;
    if (((u64)((*(*d).name)) != '$')) {
        f = (struct cc_decls_fieldrec *)(mlib_pcm_allocz((i64)20));
        (*f).def = d;
        L745 :;
        while (!!((*d).prevdupl)) {
            d = (*d).prevdupl;
L746 :;
        }L747 :;
        ;
        (*f).gendef = d;
        (*f).offset = offset;
        (*f).nextfield = (*flist);
        (*flist) = f;
    } else {
        e = (*cc_decls_ttnamedef[((i64)((*d).mode))]).deflist;
        L748 :;
        while (!!(e)) {
            cc_parse_addnewfield(flist,e,(offset + (*e).offset));
            e = (*e).nextdef;
L749 :;
        }L750 :;
        ;
    };
}

static void cc_parse_pushloop(i64 looptype) {
    if ((cc_parse_loopindex >= (i64)100)) {
        cc_support_serror((byte*)"Too many nested loop or switch");
    };
    ++cc_parse_loopindex;
    cc_parse_looptypestack[(cc_parse_loopindex)-1] = (u64)(looptype);
    cc_parse_casevaluestack[(cc_parse_loopindex)-1] = (struct cc_decls_caserec *)(0);
}

static void cc_parse_poploop(void) {
    if (!!(cc_parse_loopindex)) {
        --cc_parse_loopindex;
    } else {
        cc_support_serror((byte*)"poploop?");
    };
}

static void cc_parse_addcasevalue(i64 value) {
    struct cc_decls_caserec *  p;
    i64 index;
    index = cc_parse_loopindex;
    L751 :;
    while ((!!(index) && ((u64)(cc_parse_looptypestack[(index)-1]) != (u64)83u))) {
        --index;
L752 :;
    }L753 :;
    ;
    if ((index == (i64)0)) {
        cc_support_serror((byte*)"case not inside switch stmt");
    };
    p = (struct cc_decls_caserec *)(mlib_pcm_alloc((i64)12));
    (*p).value = value;
    (*p).nextcase = cc_parse_casevaluestack[(index)-1];
    cc_parse_casevaluestack[(index)-1] = p;
}

static i64 cc_parse_roundoffset(i64 offset,i64 alignment) {
    i64 mask;
    if (!!(cc_decls_structpadding)) {
        if ((alignment == (i64)1)) {
            return offset;
        };
        mask = (alignment - (i64)1);
        L754 :;
        while (!!((offset & mask))) {
            ++offset;
L755 :;
        }L756 :;
        ;
    };
    return offset;
}

static void cc_parse_fixmemopnd(struct cc_decls_unitrec * p) {
    i64 t;
    if (!!((u64)(cc_parse_ingeneric))) {
        return;
    };
    if (((t = cc_decls_ttbasetype[((i64)((*p).mode))])==(i64)2) || ((t = cc_decls_ttbasetype[((i64)((*p).mode))])==(i64)3)) {
        cc_parse_insertunit(p,(i64)4);
        (*p).mode = (i64)4;
    }else if (((t = cc_decls_ttbasetype[((i64)((*p).mode))])==(i64)7) || ((t = cc_decls_ttbasetype[((i64)((*p).mode))])==(i64)8) || ((t = cc_decls_ttbasetype[((i64)((*p).mode))])==(i64)6)) {
        cc_parse_insertunit(p,(i64)4);
        (*p).mode = (i64)9;
    };
}

static struct cc_decls_unitrec * cc_parse_docast(struct cc_decls_unitrec * p,i64 t,i64 hard,i64 inplace) {
    struct cc_decls_unitrec *  q;
    i64 s;
    i64 opc;
    s = (i64)((*p).mode);
    /*retry:*/
L757 :;
;
    if ((s == t)) {
        return p;
    };
    opc = (i64)0;
    if (((s < (i64)16) && (t < (i64)16))) {
        opc = (i64)(cc_tables_conversionops[(s)][(t)]);
    } else if ((!!((u64)(cc_decls_ttisref[(s)])) && !!((u64)(cc_decls_ttisref[(t)])))) {
        if (!!(cc_parse_checkpointertypes(s,t,hard))) {
            (*p).mode = t;
            return p;
        };
    } else if (!!((u64)(cc_decls_ttconst[(s)]))) {
        s = cc_decls_ttconsttype[(s)];
        goto L757 ;
;
    } else if (!!((u64)(cc_decls_ttconst[(t)]))) {
        t = cc_decls_ttconsttype[(t)];
        goto L757 ;
;
    } else if ((((!!((u64)(cc_decls_ttisref[(t)])) && !!(cc_lib_isintcc(s))) && ((i64)((*p).tag) == (i64)1)) && ((*p).value == (i64)0))) {
        opc = (i64)1;
    };
    if ((opc == (i64)0)) {
        if (!(!!(hard))) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(cc_lib_strmode(s,(i64)1),NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(cc_lib_strmode(t,(i64)1),NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            cc_support_terror_ss((byte*)"Can't do conversion %s => %s",cc_lib_typename(s),cc_lib_typename(t));
        };
        opc = (i64)2;
    };
    if (((i64)((*p).tag)==(i64)1)) {
        if (!!(cc_parse_eval_convert(p,t,opc))) {
            return p;
        };
    }else if (((i64)((*p).tag)==(i64)5)) {
        (*p).mode = t;
        return p;
    }else if (((i64)((*p).tag)==(i64)40)) {
        if ((((i64)((*(*p).a).tag) == (i64)1) && ((i64)((*(*p).b).tag) == (i64)1))) {
            (*p).value = ((*(*p).a).value + (*(*p).b).value);
            (*p).mode = t;
            (*p).tag = (i64)1;
            return p;
        };
    };
    if (!!(inplace)) {
        cc_parse_insertunit(p,(i64)57);
        (*p).mode = t;
        (*p).opcode = opc;
        return (struct cc_decls_unitrec *)(0);
    } else {
        q = cc_lib_createunit1((i64)57,p);
        (*q).opcode = opc;
        (*q).mode = t;
    };
    return q;
}

static struct cc_decls_unitrec * cc_parse_coercemode(struct cc_decls_unitrec * p,i64 t) {
    if (((i64)((*p).mode) == t)) {
        return p;
    };
    cc_parse_docast(p,t,(i64)0,(i64)1);
    return p;
}

static void cc_parse_coercemode_inplace(struct cc_decls_unitrec * p,i64 t) {
    if (((i64)((*p).mode) == t)) {
        return;
    };
    cc_parse_docast(p,t,(i64)0,(i64)1);
}

static void cc_parse_dostaticassert(void) {
    i64 x;
    byte str[256];
    cc_lex_lex();
    cc_lib_skipsymbol((i64)12);
    x = cc_parse_readconstintexpr();
    cc_lib_skipsymbol((i64)8);
    cc_lib_checksymbol((i64)63);
    if (!(!!(x))) {
        memcpy((void *)(str),(void *)(cc_decls_lx.svalue),(u32)(cc_decls_lx.length));
        str[(((i64)(cc_decls_lx.length) + (i64)1))-1] = (u64)0u;
        cc_support_serror(str);
    };
    cc_lex_lex();
    cc_lib_skipsymbol((i64)13);
}

static struct cc_decls_unitrec * cc_parse_createsizeofop(struct cc_decls_unitrec * p) {
    struct cc_decls_unitrec *  q;
    i64 t;
    i64 size;
    t = (i64)((*p).mode);
    switch ((int)((*p).tag)) {
    case 3:;
    {
        if (!!((i64)((*p).alength))) {
            size = (cc_decls_ttsize[((i64)((*(*p).def).mode))] / (i64)((*p).alength));
        } else {
            size = cc_decls_ttsize[((i64)((*(*p).def).mode))];
        };
    }break;
    case 1:;
    {
        if ((t==cc_decls_trefchar)) {
            size = ((i64)((*p).slength) + (i64)1);
        }else if ((t==cc_decls_trefwchar)) {
            size = (((i64)((*p).wslength) + (i64)1) * (i64)2);
        } else {
            size = cc_decls_ttsize[(t)];
        };
    }break;
    case 53:;
    {
        if ((!!((u64)(cc_decls_ttisref[(t)])) && !!((i64)((*p).alength)))) {
            size = (cc_decls_ttsize[(cc_decls_tttarget[(t)])] * (i64)((*p).alength));
        } else {
            size = cc_decls_ttsize[(t)];
        };
    }break;
    case 54:;
    {
        if (!!((i64)((*p).alength))) {
            size = (cc_decls_ttsize[(cc_decls_tttarget[(t)])] * (i64)((*p).alength));
        } else {
            goto L758 ;
;
        };
    }break;
    case 56:;
    {
        if ((((i64)((*(*p).a).tag) == (i64)3) && !!((i64)((*(*p).a).alength)))) {
            size = cc_decls_ttsize[((i64)((*(*(*p).a).def).mode))];
        };
    }break;
    case 4:;
    {
        return cc_parse_createsizeofop((*p).a);
    }break;
    default: {
        /*cad1:*/
L758 :;
;
        size = cc_decls_ttsize[(t)];
    }
    } /* SW */
;
    q = cc_lib_createconstunit((u64)(size),(i64)10);
    return q;
}

static struct cc_decls_unitrec * cc_parse_readgeneric(void) {
    struct cc_decls_unitrec *  pexpr;
    struct cc_decls_unitrec *  pmatch;
    struct cc_decls_unitrec *  p;
    struct cc_decls_paramrec *  pm;
    i64 m;
    i64 t;
    i64 def;
    i64 oldingeneric;
    i64 count;
    struct cc_decls_strec *  d;
    cc_lex_lex();
    cc_lib_checksymbol((i64)12);
    cc_lex_lex();
    oldingeneric = (i64)(cc_parse_ingeneric);
    cc_parse_ingeneric = (u64)((i64)1);
    pexpr = cc_parse_readassignexpr();
    cc_parse_ingeneric = (u64)(oldingeneric);
    m = (i64)((*pexpr).mode);
    pmatch = (struct cc_decls_unitrec *)(0);
    def = (i64)0;
    count = (i64)0;
    cc_lib_checksymbol((i64)8);
    L759 :;
    do {
        cc_lex_lex();
        if (((i64)((u64)(cc_decls_lx.symbol)) == (i64)75)) {
            if (!!(def)) {
                cc_support_serror((byte*)"generic/default twice");
            };
            def = (i64)1;
            if ((count == (i64)0)) {
                t = (i64)-1;
            } else {
                t = (i64)-2;
            };
            cc_lex_lex();
        } else {
            t = cc_parse_readcasttype(&d,(i64)0,&pm);
        };
        cc_lib_checksymbol((i64)10);
        cc_lex_lex();
        p = cc_parse_readassignexpr();
        if (((t == (i64)-1) || (t == m))) {
            pmatch = p;
            ++count;
        };
L760 :;
    } while (!((i64)((u64)(cc_decls_lx.symbol)) != (i64)8));L761 :;
    ;
    cc_lib_checksymbol((i64)13);
    cc_lex_lex();
    if (!(!!(pmatch))) {
        cc_support_serror((byte*)"Generic: no type match");
    };
    if ((count > (i64)1)) {
        cc_support_serror((byte*)"Generic: multiple types match");
    };
    return pmatch;
}

static void cc_parse_readstructinfosym(void) {
    struct cc_decls_strec *  d;
    struct cc_decls_strec *  e;
    struct cc_decls_paramrec *  pm;
    i64 m;
    i64 nfields;
    void *  f;
    byte *  name;
    byte str[256];
    cc_lex_lex();
    m = cc_parse_readcasttype(&d,(i64)0,&pm);
    if ((cc_decls_ttbasetype[(m)] != (i64)20)) {
        cc_support_serror((byte*)"Struct type expected");
    };
    d = cc_decls_tttypedef[(m)];
    e = (*d).deflist;
    nfields = (i64)0;
    L762 :;
    while (!!(e)) {
        ++nfields;
        e = (*e).nextdef;
L763 :;
    }L764 :;
    ;
    name = (*d).name;
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str((byte*)"$",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str(name,NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str((byte*)"_info.h",NULL);
    msysnewc_m_print_end();
    ;
    f = fopen((i8 *)(str),(i8 *)((byte*)"w"));
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_str((byte*)"memberinfo_t $",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str(name,NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str((byte*)"[] = {",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    e = (*cc_decls_ttnamedef[(m)]).deflist;
    nfields = (i64)0;
    L765 :;
    while (!!(e)) {
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_str((byte*)"    {\"#\", #,#,#,#,#,#}#",NULL);
        msysnewc_m_print_str((*e).name,NULL);
        msysnewc_m_print_i64((*e).mode,NULL);
        msysnewc_m_print_i64(cc_decls_ttbasetype[((i64)((*e).mode))],NULL);
        msysnewc_m_print_i64(cc_decls_tttarget[((i64)((*e).mode))],NULL);
        msysnewc_m_print_i64(cc_decls_ttsize[((i64)((*e).mode))],NULL);
        msysnewc_m_print_i64((*e).offset,NULL);
        msysnewc_m_print_i64((i64)0,NULL);
        msysnewc_m_print_str((!!((*e).nextdef)?(byte*)",":(byte*)""),NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        ++nfields;
        e = (*e).nextdef;
L766 :;
    }L767 :;
    ;
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_str((byte*)"};",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_str((byte*)"enum {$#_length = #};",NULL);
    msysnewc_m_print_str(name,NULL);
    msysnewc_m_print_i64(nfields,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    fclose(f);
}

static i64 cc_parse_getmemmode(struct cc_decls_unitrec * p) {
    if (((i64)((*p).tag) == (i64)4)) {
        return (i64)((*(*p).a).mode);
    } else {
        return (i64)((*p).mode);
    };
}

static struct cc_decls_unitrec * cc_parse_readstrinclude(void) {
    struct cc_decls_unitrec *  p;
    byte *  text;
    cc_lex_lex();
    cc_lib_checksymbol((i64)12);
    cc_lex_lex();
    p = cc_parse_readexpression();
    cc_lib_checksymbol((i64)13);
    cc_lex_lex();
    if ((((i64)((*p).tag) != (i64)1) || ((i64)((*p).mode) != cc_decls_trefchar))) {
        cc_support_serror((byte*)"String const expected");
    };
    text = (byte *)(mlib_readfile((*p).svalue));
    if (!(!!(text))) {
        cc_support_serror_s((byte*)"Can't read strinclude file: %s",(*p).svalue);
    };
    return cc_lib_createstringconstunit(text,(i64)(strlen((i8 *)(text))));
}

i64 cc_genmcl_codegen_mcl(i64 n) {
    struct cc_decls_strec *  d;
    struct cc_decls_strec *  e;
    cc_libmcl_mclinit();
    cc_decls_stmodule = cc_decls_moduletable[(n)].stmodule;
    d = (*cc_decls_stmodule).deflist;
    L768 :;
    while (!!(d)) {
        if (((i64)((*d).nameid)==(i64)7)) {
            cc_genmcl_dostaticvar(d);
        }else if (((i64)((*d).nameid)==(i64)6)) {
            e = (*d).deflist;
            L771 :;
            while (!!(e)) {
                if (((i64)((*e).nameid)==(i64)7)) {
                    cc_genmcl_dostaticvar_fn(e);
                }else if (((i64)((*e).nameid)==(i64)8)) {
                    if (!!((*e).code)) {
                        if ((((i64)((*(*e).code).tag) == (i64)29) || ((cc_decls_ttbasetype[((i64)((*e).mode))] == (i64)19) && ((i64)((*(*e).code).tag) == (i64)1)))) {
                            cc_genmcl_dostaticvar_fn(e);
                        };
                    };
                };
                e = (*e).nextdef;
L772 :;
            }L773 :;
            ;
        };
        d = (*d).nextdef;
L769 :;
    }L770 :;
    ;
    cc_libmcl_modulecode = cc_libmcl_mccode;
    d = (*cc_decls_stmodule).deflist;
    L774 :;
    while (!!(d)) {
        if (((i64)((*d).nameid)==(i64)6)) {
            if (!!((*d).code)) {
                cc_genmcl_genprocdef(d);
            };
        };
        d = (*d).nextdef;
L775 :;
    }L776 :;
    ;
    return (i64)1;
}

static void cc_genmcl_genprocdef(struct cc_decls_strec * p) {
    byte str[256];
    i64 paramoffset;
    i64 nparams;
    struct cc_decls_strec *  d;
    i64 n;
    i64 lab;
    i64 np;
    i64 offset;
    i64 i;
    i64 ismain;
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    i64 paramtypes[4];
    cc_libmcl_setsegment((i64)67,(i64)1);
    cc_libmcl_initmcdest();
    cc_libmcl_setalign((i64)16);
    cc_libmcl_genassem((byte*)"!------------------------------------");
    cc_decls_currproc = p;
    cc_genmcl_dolabel(p);
    cc_libmcl_frameoffset = (i64)0;
    paramoffset = (i64)16;
    nparams = (i64)0;
    d = (*p).deflist;
    L777 :;
    while (!!(d)) {
        switch ((int)((*d).nameid)) {
        case 8:;
        {
            cc_libmcl_frameoffset -= cc_libmcl_roundsizetg(cc_decls_ttsize[((i64)((*d).mode))]);
            (*d).offset = cc_libmcl_frameoffset;
        }break;
        case 9:;
        {
            (*d).offset = paramoffset;
            paramoffset += (i64)8;
            ++nparams;
            if ((nparams <= (i64)4)) {
                paramtypes[(nparams)-1] = (i64)((*d).mode);
            };
        }break;
        default: {
        }
        } /* SW */
;
        d = (*d).nextdef;
L778 :;
    }L779 :;
    ;
    cc_libmcl_structretoffset = (i64)0;
    cc_libmcl_stacksetinstr = (struct cc_libmcl_mclrec *)(0);
    cc_libmcl_retbeforeblock = (i64)0;
    if ((cc_decls_ttsize[((i64)((*p).mode))] > (i64)8)) {
        cc_libmcl_frameoffset -= (i64)8;
        cc_libmcl_structretoffset = cc_libmcl_frameoffset;
    };
    cc_libmcl_currblocksize = (i64)0;
    cc_libmcl_framebytes = -(cc_libmcl_frameoffset);
    cc_libmcl_parambytes = (paramoffset - (i64)16);
    cc_libmcl_iscallbackproc = cc_libmcl_iscallbackfn(p);
    n = (i64)7;
    L780 :;
    while (!!((cc_libmcl_framebytes & n))) {
        ++cc_libmcl_framebytes;
        --cc_libmcl_frameoffset;
L781 :;
    }L782 :;
    ;
    L783 :;
    while (!!((cc_libmcl_parambytes & n))) {
        ++cc_libmcl_parambytes;
L784 :;
    }L785 :;
    ;
    cc_libmcl_setsegment((i64)67,(i64)1);
    ismain = (i64)0;
#ifndef BLDGENERIC
    if (!!(mlib_eqstring((*p).name,(byte*)"main"))) {
        ismain = (i64)1;
        if (!!(cc_libmcl_parambytes)) {
            cc_genmcl_genmainprelude();
        };
        if (((i64)((*p).mode) != (i64)4)) {
            cc_support_gerror((byte*)"main needs int return type",(struct cc_decls_unitrec *)(0));
        };
    };
#endif
    cc_genmcl_genprocentry(cc_libmcl_framebytes,cc_libmcl_parambytes);
    if (!!(nparams)) {
        np = ((i64)4<nparams?(i64)4:nparams);
        if (((i64)((*(*p).paramlist).flags) == (i64)3)) {
            L786 :;
            for (i=(np + (i64)1);i<=(i64)4;i+=(i64)1) {
L787 :;
                paramtypes[(i)-1] = (i64)1;
L788 :;
            }L789 :;
            ;
            np = (i64)4;
        };
        offset = (i64)16;
        L790 :;
        for (i=(i64)1;i<=np;i+=(i64)1) {
L791 :;
            ax = cc_libmcl_genireg((i64)15,(i64)8);
            (*ax).value = offset;
            (*ax).valtype = (u64)((i64)1);
            if (!!(cc_lib_isrealcc(paramtypes[(i)-1]))) {
                cc_libmcl_genmc((i64)10,ax,cc_libmcl_genxreg((((i64)1 + i) - (i64)1),cc_decls_ttsize[(paramtypes[(i)-1])]));
            } else {
                cc_libmcl_genmc((i64)5,ax,cc_libmcl_genreg((((i64)11 + i) - (i64)1),(i64)8));
            };
            offset += (i64)8;
L792 :;
        }L793 :;
        ;
    };
    if (!!(cc_libmcl_structretoffset)) {
        bx = cc_libmcl_genindex((i64)15,(i64)0,(i64)1,cc_libmcl_structretoffset,(i64)0,(i64)0,(struct cc_decls_strec *)(0));
        cc_libmcl_genmc((i64)5,bx,cc_libmcl_genreg((i64)10,(i64)8));
    };
    if (!!(cc_libmcl_iscallbackproc)) {
        strcpy((i8 *)(str),(i8 *)((byte*)"m$pushcallback*"));
        cc_libmcl_genmc((i64)15,cc_libmcl_genname(str),(struct cc_libmcl_opndrec *)(0));
    };
    cc_libmcl_stackaligned = (i64)1;
    cc_libmcl_retindex = (lab = cc_libmcl_createfwdlabel());
    cc_libmcl_gencomment((byte*)"-------------------------------------------------");
    cc_libmcl_enterproc((*p).name);
    cc_blockmcl_do_stmt((*p).code);
    cc_libmcl_definefwdlabel(cc_libmcl_retindex);
    cc_libmcl_gencomment((byte*)"-------------------------------------------------");
    if (!!(ismain)) {
        cc_libmcl_pushstack((i64)32);
        cc_libmcl_genmc((i64)5,cc_libmcl_genreg((i64)11,(i64)8),cc_libmcl_genint((i64)0,(i64)4));
        cc_libmcl_genmc((i64)15,cc_libmcl_genname((byte*)"exit*"),(struct cc_libmcl_opndrec *)(0));
    } else {
        cc_libmcl_leaveproc((*p).name);
        cc_libmcl_genreturn(cc_libmcl_framebytes,cc_libmcl_parambytes);
    };
    cc_libmcl_gencomment((byte*)"");
    (*p).mclcode = (void *)(cc_libmcl_mccode);
}

static void cc_genmcl_dolabel(struct cc_decls_strec * d) {
    byte str[256];
    strcpy((i8 *)(str),(i8 *)((byte*)"`"));
    strcat((i8 *)(str),(i8 *)(cc_libmcl_getfullname(d)));
    strcat((i8 *)(str),(!!(cc_lib_isexported(d))?(i8 *)((byte*)"::"):(i8 *)((byte*)":")));
    cc_libmcl_genmc((i64)4,cc_libmcl_genname(str),(struct cc_libmcl_opndrec *)(0));
}

static void cc_genmcl_dolabel_fn(struct cc_decls_strec * d,i64 dollar) {
    byte str[256];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_setfmt((byte*)"`##.#.#:");
    msysnewc_m_print_str((!!(dollar)?(byte*)"$":(byte*)""),NULL);
    msysnewc_m_print_str((*(*d).owner).name,NULL);
    msysnewc_m_print_str((*d).name,NULL);
    msysnewc_m_print_u64((*d).blockno,NULL);
    msysnewc_m_print_end();
    ;
    cc_libmcl_genmc((i64)4,cc_libmcl_genname(str),(struct cc_libmcl_opndrec *)(0));
}

static void cc_genmcl_dostaticvar(struct cc_decls_strec * d) {
    i64 align;
    if (((i64)((*d).scope)==(i64)3)) {
        return;
    };
    align = cc_lib_getalignment((i64)((*d).mode));
    if (!!((*d).code)) {
        cc_libmcl_setsegment((i64)73,align);
        cc_genmcl_dolabel(d);
        cc_genmcl_genidata((*d).code,(i64)1,(i64)1,(i64)0);
    } else {
        cc_libmcl_setsegment((i64)90,align);
        cc_genmcl_dolabel(d);
        cc_libmcl_genmc((i64)57,cc_libmcl_genint(cc_decls_ttsize[((i64)((*d).mode))],(i64)4),(struct cc_libmcl_opndrec *)(0));
    };
}

static void cc_genmcl_dostaticvar_fn(struct cc_decls_strec * d) {
    i64 align;
    if (((i64)((*d).scope)==(i64)3)) {
        cc_genmcl_dostaticvar(d);
        return;
    };
    align = cc_lib_getalignment((i64)((*d).mode));
    if (!!((*d).code)) {
        cc_libmcl_setsegment((i64)73,align);
        cc_genmcl_dolabel_fn(d,((i64)((u64)((*d).nameid)) == (i64)8));
        cc_genmcl_genidata((*d).code,(i64)1,(i64)1,(i64)0);
    } else {
        cc_libmcl_setsegment((i64)90,align);
        cc_genmcl_dolabel_fn(d,(i64)0);
        cc_libmcl_genmc((i64)57,cc_libmcl_genint(cc_decls_ttsize[((i64)((*d).mode))],(i64)4),(struct cc_libmcl_opndrec *)(0));
    };
}

static void cc_genmcl_genprocentry(i64 fbytes,i64 pbytes) {
    if ((!!(fbytes) || !!(pbytes))) {
        cc_libmcl_genmc((i64)6,cc_libmcl_dframeopnd,(struct cc_libmcl_opndrec *)(0));
        cc_libmcl_genmc((i64)5,cc_libmcl_dframeopnd,cc_libmcl_dstackopnd);
        if (!!(fbytes)) {
            cc_libmcl_pushstack(cc_libmcl_roundto(fbytes,(i64)16));
        };
    } else {
        cc_libmcl_pushstack((i64)8);
    };
    cc_libmcl_stacksetinstr = cc_libmcl_mccodex;
}

static void cc_genmcl_genidata(struct cc_decls_unitrec * p,i64 doterm,i64 am,i64 offset) {
    i64 t;
    i64 length;
    i64 n;
    i64 i;
    i64 offset1;
    i64 offset2;
    i64 size;
    i64 padding;
    i64 isunion;
    struct cc_decls_unitrec *  q;
    struct cc_decls_unitrec *  a;
    struct cc_decls_unitrec *  b;
    struct cc_decls_strec *  d;
    float sx;
    byte str[256];
    byte str2[16];
    struct cc_libmcl_opndrec *  ax;
    i64 av_1;
    i64 av_2;
    t = (i64)((*p).mode);
    a = (*p).a;
    b = (*p).b;
    if (((i64)((*p).tag)==(i64)29)) {
        n = (i64)((*p).count);
        if ((cc_decls_ttbasetype[(t)] == (i64)19)) {
            length = cc_decls_ttlength[(t)];
            q = a;
            L794 :;
            for (i=(i64)1;i<=n;i+=(i64)1) {
L795 :;
                cc_genmcl_genidata(q,(i64)1,(i64)1,(i64)0);
                q = (*q).nextunit;
L796 :;
            }L797 :;
            ;
            if ((n < length)) {
                n = ((length - n) * cc_decls_ttsize[(cc_decls_tttarget[(t)])]);
                L798 :;
                while ((n >= (i64)8)) {
                    cc_libmcl_genmc((i64)61,cc_libmcl_genint((i64)0,(i64)8),(struct cc_libmcl_opndrec *)(0));
                    n -= (i64)8;
L799 :;
                }L800 :;
                ;
                av_1 = n;
                while (av_1-- > 0) {
L801 :;
                    cc_libmcl_genmc((i64)58,cc_libmcl_genint((i64)0,(i64)4),(struct cc_libmcl_opndrec *)(0));
L802 :;
                }L803 :;
                ;
            };
        } else {
            isunion = (cc_decls_ttbasetype[(t)] == (i64)21);
            d = (*cc_decls_ttnamedef[(t)]).deflist;
            size = cc_decls_ttsize[(t)];
            offset1 = (offset2 = (i64)0);
            q = a;
            L804 :;
            for (i=(i64)1;i<=n;i+=(i64)1) {
L805 :;
                cc_genmcl_genidata(q,(i64)0,(i64)1,(i64)0);
                if (((cc_decls_ttbasetype[((i64)((*q).mode))] == (i64)16) && !!((u64)((*q).strarray)))) {
                    offset1 += (i64)((*q).slength);
                } else {
                    offset1 += cc_decls_ttsize[((i64)((*q).mode))];
                };
                d = (*d).nextdef;
                if ((!!(d) && !(!!(isunion)))) {
                    offset2 = (*d).offset;
                } else {
                    offset2 = size;
                };
                padding = (offset2 - offset1);
                if ((padding > (i64)0)) {
                    padding = (offset2 - offset1);
                    if ((padding > (i64)0)) {
                        cc_libmcl_genmc((i64)57,cc_libmcl_genint(padding,(i64)4),(struct cc_libmcl_opndrec *)(0));
                    };
                    offset1 = offset2;
                };
                q = (*q).nextunit;
L806 :;
            }L807 :;
            ;
            if ((offset2 < size)) {
                n = (size - offset2);
                L808 :;
                while ((n >= (i64)8)) {
                    cc_libmcl_genmc((i64)61,cc_libmcl_genint((i64)0,(i64)8),(struct cc_libmcl_opndrec *)(0));
                    n -= (i64)8;
L809 :;
                }L810 :;
                ;
                av_2 = n;
                while (av_2-- > 0) {
L811 :;
                    cc_libmcl_genmc((i64)58,cc_libmcl_genint((i64)0,(i64)4),(struct cc_libmcl_opndrec *)(0));
L812 :;
                }L813 :;
                ;
            };
        };
        return;
    }else if (((i64)((*p).tag)==(i64)1)) {
        if ((!!(cc_lib_isintcc(t)) || !!(cc_lib_isrealcc(t)))) {
            if ((t == (i64)11)) {
                sx = (float)((*p).xvalue);
                cc_libmcl_genmc((i64)60,cc_libmcl_genint(*(i64*)&sx,(i64)4),(struct cc_libmcl_opndrec *)(0));
            } else {
                cc_libmcl_genmc((cc_decls_ttsize[(t)]==1?(i64)58:(cc_decls_ttsize[(t)]==2?(i64)59:(cc_decls_ttsize[(t)]==3?(i64)0:(cc_decls_ttsize[(t)]==4?(i64)60:(cc_decls_ttsize[(t)]==5?(i64)0:(cc_decls_ttsize[(t)]==6?(i64)0:(cc_decls_ttsize[(t)]==7?(i64)0:(cc_decls_ttsize[(t)]==8?(i64)61:(i64)0)))))))),cc_libmcl_genint((*p).value,cc_decls_ttsize[(t)]),(struct cc_libmcl_opndrec *)(0));
            };
        } else if ((cc_decls_ttbasetype[(t)] == (i64)16)) {
            padding = (i64)0;
            /*doref:*/
L814 :;
;
            if (((*p).value == (i64)0)) {
                cc_libmcl_genmc((i64)61,cc_libmcl_genint((i64)0,(i64)8),(struct cc_libmcl_opndrec *)(0));
            } else if (!!((u64)((*p).strarray))) {
                if ((cc_decls_ttsize[(cc_decls_tttarget[(t)])] == (i64)1)) {
                    cc_libmcl_genmc((i64)62,cc_libmcl_genstrimm((*p).svalue,(i64)((*p).slength)),(struct cc_libmcl_opndrec *)(0));
                } else {
                    cc_libmcl_genmc((i64)63,cc_libmcl_genwstrimm((*p).wsvalue,(i64)((*p).wslength)),(struct cc_libmcl_opndrec *)(0));
                };
                if ((padding > (i64)0)) {
                    cc_libmcl_genmc((i64)57,cc_libmcl_genint(padding,(i64)4),(struct cc_libmcl_opndrec *)(0));
                };
            } else if (!!((u64)((*p).isstrconst))) {
                cc_libmcl_genmc((i64)61,cc_libmcl_genstrimm((*p).svalue,(i64)((*p).slength)),(struct cc_libmcl_opndrec *)(0));
                if ((padding > (i64)0)) {
                    cc_libmcl_genmc((i64)57,cc_libmcl_genint(padding,(i64)4),(struct cc_libmcl_opndrec *)(0));
                };
            } else if (!!((u64)((*p).iswstrconst))) {
                cc_libmcl_genmc((i64)61,cc_libmcl_genwstrimm((*p).wsvalue,(i64)((*p).wslength)),(struct cc_libmcl_opndrec *)(0));
                if ((padding > (i64)0)) {
                    cc_libmcl_genmc((i64)57,cc_libmcl_genint(padding,(i64)4),(struct cc_libmcl_opndrec *)(0));
                };
            } else {
                cc_libmcl_genmc((i64)61,cc_libmcl_genint((*p).value,(i64)4),(struct cc_libmcl_opndrec *)(0));
            };
        } else if ((cc_decls_ttbasetype[(t)] == (i64)19)) {
            padding = ((cc_decls_ttlength[(t)] - (i64)((*p).slength)) * cc_decls_ttsize[(cc_decls_tttarget[(t)])]);
            goto L814 ;
;
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(cc_lib_strmode(t,(i64)1),NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            cc_support_gerror((byte*)"IDATA/SCALAR",(struct cc_decls_unitrec *)(0));
        };
        return;
    }else if (((i64)((*p).tag)==(i64)3) || ((i64)((*p).tag)==(i64)5)) {
        d = (*p).def;
        if (((i64)((*d).nameid)==(i64)7) || ((i64)((*d).nameid)==(i64)6)) {
            ax = cc_libmcl_genmemaddr_d(d);
            if (!!(ax)) {
                ax = cc_libmcl_applyoffset(ax,offset,(i64)0);
            };
            cc_libmcl_genmc((((am == (i64)0) || (cc_decls_ttsize[((i64)((*p).mode))] == (i64)8))?(i64)61:(i64)60),ax,(struct cc_libmcl_opndrec *)(0));
        } else {
            cc_support_gerror((byte*)"Idata &frame",p);
        };
        return;
    }else if (((i64)((*p).tag)==(i64)40)) {
        if ((((i64)((*a).tag) == (i64)3) && ((i64)((*b).tag) == (i64)1))) {
            d = (*a).def;
            if (((i64)((*d).nameid)==(i64)7)) {
                strcpy((i8 *)(str),(i8 *)((byte*)"`"));
                if (((i64)((u64)((*d).scope)) == (i64)1)) {
                    strcat((i8 *)(str),(i8 *)((*cc_decls_currproc).name));
                    strcat((i8 *)(str),(i8 *)((byte*)","));
                };
                strcat((i8 *)(str),(i8 *)((*d).name));
                strcat((i8 *)(str),(i8 *)((byte*)"+"));
                msysnewc_getstrint((*b).value,str2);
                strcat((i8 *)(str),(i8 *)(str2));
                cc_libmcl_genmc((i64)61,cc_libmcl_genname(str),(struct cc_libmcl_opndrec *)(0));
            } else {
                cc_support_gerror((byte*)"Add/Idata &frame",(struct cc_decls_unitrec *)(0));
            };
        } else if (((((i64)((*a).tag) == (i64)1) && ((i64)((*b).tag) == (i64)1)) && (cc_decls_ttbasetype[((i64)((*a).mode))] == (i64)16))) {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_i64((*a).value,NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str((byte*)"+",NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_i64((*b).value,NULL);
            msysnewc_m_print_end();
            ;
            cc_libmcl_genmc((i64)61,cc_libmcl_genname(str),(struct cc_libmcl_opndrec *)(0));
        } else {
            cc_support_gerror((byte*)"1:Runtime or unsupported expr in static data",(struct cc_decls_unitrec *)(0));
        };
        return;
    }else if (((i64)((*p).tag)==(i64)56)) {
        if (((i64)((*a).tag) == (i64)53)) {
            cc_genmcl_genidata((*a).a,(i64)1,(i64)1,offset);
        } else {
            cc_genmcl_genidata(a,(i64)1,(i64)0,offset);
        };
    }else if (((i64)((*p).tag)==(i64)54) || ((i64)((*p).tag)==(i64)55)) {
        if (((i64)((*b).tag) != (i64)1)) {
            cc_support_gerror((byte*)"Complex ptr expr in static data",(struct cc_decls_unitrec *)(0));
        };
        cc_genmcl_genidata(a,(i64)1,(i64)1,(((*b).value * (i64)((*p).ptrscale)) + offset));
    }else if (((i64)((*p).tag)==(i64)57)) {
        cc_genmcl_genidata(a,(i64)1,(i64)1,offset);
    } else {
        cc_lib_printunit(0,p,(i64)0,(byte*)"*");
        cc_support_gerror((byte*)"2:Runtime expr in static data",p);
    };
}

static void cc_genmcl_genmainprelude(void) {
    cc_libmcl_genassem((byte*)"\tsub\tDstack,152");
    cc_libmcl_genassem((byte*)"\tsub\tDstack,8");
    cc_libmcl_genassem((byte*)"\tlea\tD0,[Dstack+8]");
    cc_libmcl_genassem((byte*)"\tpush\tD0");
    cc_libmcl_genassem((byte*)"\tsub\tDstack,32");
    cc_libmcl_genassem((byte*)"\tlea\tD0,[Dstack+196]");
    cc_libmcl_genassem((byte*)"\tmov\t[Dstack],D0");
    cc_libmcl_genassem((byte*)"\tlea\tD0,[Dstack+184]");
    cc_libmcl_genassem((byte*)"\tmov\t[Dstack+8],D0");
    cc_libmcl_genassem((byte*)"\tlea\tD0,[Dstack+176]");
    cc_libmcl_genassem((byte*)"\tmov\t[Dstack+16],D0");
    cc_libmcl_genassem((byte*)"\tmov\tA0,0");
    cc_libmcl_genassem((byte*)"\tmov\t[Dstack+24],A0");
    cc_libmcl_genassem((byte*)"\tmov\tD10,[Dstack]");
    cc_libmcl_genassem((byte*)"\tmov\tD11,[Dstack+8]");
    cc_libmcl_genassem((byte*)"\tmov\tD12,[Dstack+16]");
    cc_libmcl_genassem((byte*)"\tmov\tD13,[Dstack+24]");
    cc_libmcl_genassem((byte*)"\tcall\t__getmainargs*");
    cc_libmcl_genassem((byte*)"\tadd\tDstack,48");
    cc_libmcl_genassem((byte*)"\tsub\tDstack,32");
    cc_libmcl_genassem((byte*)"\tmov\tA0,[Dstack+180]");
    cc_libmcl_genassem((byte*)"\tmov\t[Dstack],A0");
    cc_libmcl_genassem((byte*)"\tmov\tD0,[Dstack+168]");
    cc_libmcl_genassem((byte*)"\tmov\t[Dstack+8],D0");
    cc_libmcl_genassem((byte*)"\tmov\tD10,[Dstack]");
    cc_libmcl_genassem((byte*)"\tmov\tD11,[Dstack+8]");
    cc_libmcl_genassem((byte*)"\tcall\t.main");
    cc_libmcl_genassem((byte*)"\tmov A10,A0");
    cc_libmcl_genassem((byte*)"\tcall exit*");
    cc_libmcl_gencomment((byte*)"");
    cc_libmcl_genassem((byte*)".main::");
}

void cc_libmcl_mclinit(void) {
    cc_libmcl_zero_opnd = cc_libmcl_genint((i64)0,(i64)4);
    cc_libmcl_zero_unit = cc_lib_createconstunit((u64)((i64)0),(i64)4);
    (*cc_libmcl_zero_unit).mode = (i64)4;
    cc_libmcl_dframeopnd = cc_libmcl_genreg((i64)15,(i64)8);
    cc_libmcl_dstackopnd = cc_libmcl_genreg((i64)16,(i64)8);
    cc_libmcl_initmcdest();
}

i64 cc_libmcl_gettargetdata(i64 f64) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"GETTARGETDATA",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    return (i64)1;
}

void cc_libmcl_initmcdest(void) {
    cc_libmcl_mccode = (cc_libmcl_mccodex = (struct cc_libmcl_mclrec *)(0));
}

void cc_libmcl_genmc(i64 opcode,struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    struct cc_libmcl_mclrec *  m;
    struct cc_libmcl_mclrec *  oldm;
    m = (struct cc_libmcl_mclrec *)(mlib_pcm_alloc((i64)20));
    (*m).nextmcl = NULL; /* paul added this - should allocz be used instead? */
    (*m).lineno = cc_decls_clineno;
    (*m).opcode = (u64)(opcode);
    (*m).a = a;
    (*m).b = b;
    if ((opcode==(i64)5)) {
        if ((((!!(a) && ((i64)((u64)((*a).mode)) == (i64)1)) && !!(b)) && ((i64)((u64)((*b).mode)) == (i64)4))) {
            oldm = cc_libmcl_mccodex;
            if ((((!!(oldm) && ((i64)((u64)((*oldm).opcode)) == (i64)5)) && ((i64)((u64)((*(*oldm).a).mode)) == (i64)4)) && ((i64)((u64)((*(*oldm).b).mode)) == (i64)1))) {
                if ((!!(cc_libmcl_sameoperand(a,(*oldm).b)) && !!(cc_libmcl_sameoperand((*oldm).a,b)))) {
                    return;
                };
            };
        };
    }else if ((opcode==(i64)18)) {
        if (((i64)((*cc_libmcl_mccodex).opcode)==(i64)16) || ((i64)((*cc_libmcl_mccodex).opcode)==(i64)17) || ((i64)((*cc_libmcl_mccodex).opcode)==(i64)18)) {
            return;
        };
    }else if ((opcode==(i64)6) || (opcode==(i64)7)) {
        cc_libmcl_stackaligned ^= (i64)1;
    };
    if (!!(cc_libmcl_mccode)) {
        (*cc_libmcl_mccodex).nextmcl = m;
        cc_libmcl_mccodex = m;
    } else {
        cc_libmcl_mccode = (cc_libmcl_mccodex = m);
    };
}

void cc_libmcl_genmc_cond(i64 opcode,i64 cond,struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_libmcl_genmc(opcode,a,b);
    (*cc_libmcl_mccodex).cond = (u64)(cond);
}

struct cc_libmcl_mclrec * cc_libmcl_lastmc(void) {
    return cc_libmcl_mccodex;
}

void cc_libmcl_genmcstr(i64 opcode,byte * s) {
    cc_libmcl_genmc(opcode,cc_libmcl_genstrimm(s,(i64)-1),(struct cc_libmcl_opndrec *)(0));
}

static struct cc_libmcl_opndrec * cc_libmcl_newopnd(void) {
    struct cc_libmcl_opndrec *  a;
    a = (struct cc_libmcl_opndrec *)(mlib_pcm_allocz((i64)28));
    return a;
}

struct cc_libmcl_opndrec * cc_libmcl_duplopnd(struct cc_libmcl_opndrec * a) {
    struct cc_libmcl_opndrec *  b;
    b = (struct cc_libmcl_opndrec *)(mlib_pcm_alloc((i64)28));
    (*b) = (*a);
    return b;
}

struct cc_libmcl_opndrec * cc_libmcl_genxreg(i64 xreg,i64 size) {
    struct cc_libmcl_opndrec *  a;
    a = cc_libmcl_newopnd();
    (*a).mode = (u64)((i64)6);
    (*a).reg = (u64)(xreg);
    (*a).size = size;
    return a;
}

struct cc_libmcl_opndrec * cc_libmcl_genindex(i64 areg,i64 ireg,i64 scale,i64 offset,i64 size,i64 labno,struct cc_decls_strec * def) {
    struct cc_libmcl_opndrec *  a;
    a = cc_libmcl_newopnd();
    (*a).mode = (u64)((i64)4);
    (*a).reg = (u64)(areg);
    (*a).regix = (u64)(ireg);
    (*a).scale = (u64)(scale);
    (*a).size = (!!(size)?size:scale);
    (*a).value = offset;
    if (!!(offset)) {
        (*a).valtype = (u64)((i64)1);
    };
    (*a).def = def;
    if (!!(labno)) {
        (*a).valtype = (u64)((i64)5);
        (*a).value = labno;
    } else if ((!!(def) && !!(cc_libmcl_isframe(def)))) {
        if (!!(areg)) {
            cc_support_gerror((byte*)"gen/index/areg",(struct cc_decls_unitrec *)(0));
        };
        (*a).reg = (u64)((i64)15);
    };
    return a;
}

static void cc_libmcl_writemclblock(struct cc_libmcl_mclrec * m) {
    i64 i;
    i = (i64)1;
    L815 :;
    while (!!(m)) {
        cc_libmcl_writemcl(i,m);
        ++i;
        m = (*m).nextmcl;
L816 :;
    }L817 :;
    ;
}

struct mlib_strbuffer * cc_libmcl_writemclcode(byte * caption,i64 nmodule) {
    struct cc_decls_strec *  d;
    mlib_gs_init(cc_libmcl_dest);
    mlib_gs_strln(cc_libmcl_dest,caption);
    mlib_gs_strln(cc_libmcl_dest,(byte*)"---------------------------------------------");
    mlib_gs_strln(cc_libmcl_dest,(byte*)"MODULE CODE");
    cc_libmcl_writemclblock(cc_libmcl_modulecode);
    mlib_gs_strln(cc_libmcl_dest,(byte*)"---------------------------------------------");
    d = (*cc_decls_moduletable[(nmodule)].stmodule).deflist;
    L818 :;
    while (!!(d)) {
        if ((((i64)((u64)((*d).nameid)) == (i64)6) && !!((*d).mclcode))) {
            mlib_gs_str(cc_libmcl_dest,(byte*)"PROC:");
            mlib_gs_strln(cc_libmcl_dest,(*d).name);
            cc_libmcl_writemclblock((struct cc_libmcl_mclrec *)((*d).mclcode));
        };
        d = (*d).nextdef;
L819 :;
    }L820 :;
    ;
    mlib_gs_strln(cc_libmcl_dest,(byte*)"---------------------------------------------");
    return cc_libmcl_dest;
}

void cc_libmcl_gencomment(byte * s) {
    if (((s == 0) || ((i64)((*s)) == (i64)0))) {
        cc_libmcl_genmc((i64)2,(struct cc_libmcl_opndrec *)(0),(struct cc_libmcl_opndrec *)(0));
    } else {
        cc_libmcl_genmcstr((i64)1,s);
    };
}

struct cc_libmcl_opndrec * cc_libmcl_genstrimm(byte * s,i64 length) {
    struct cc_libmcl_opndrec *  a;
    a = cc_libmcl_newopnd();
    (*a).mode = (u64)((i64)2);
    if ((length < (i64)0)) {
        length = (i64)(strlen((i8 *)(s)));
    };
    (*a).svalue = (byte *)(mlib_pcm_alloc((length + (i64)1)));
    memcpy((void *)((*a).svalue),(void *)(s),(u32)((length + (i64)1)));
    (*a).valtype = (u64)((i64)3);
    (*a).size = (i64)8;
    (*a).slength = length;
    return a;
}

struct cc_libmcl_opndrec * cc_libmcl_genwstrimm(u16 * s,i64 length) {
    struct cc_libmcl_opndrec *  a;
    a = cc_libmcl_newopnd();
    (*a).mode = (u64)((i64)2);
    (*a).wsvalue = (u16 *)(mlib_pcm_alloc(((length * (i64)2) + (i64)2)));
    memcpy((void *)((*a).wsvalue),(void *)(s),(u32)(((length + (i64)1) * (i64)2)));
    (*a).valtype = (u64)((i64)4);
    (*a).size = (i64)8;
    (*a).slength = length;
    return a;
}

struct cc_libmcl_opndrec * cc_libmcl_genname(byte * s) {
    struct cc_libmcl_opndrec *  a;
    a = cc_libmcl_newopnd();
    (*a).mode = (u64)((i64)2);
    (*a).svalue = mlib_pcm_copyheapstring(s);
    (*a).valtype = (u64)((i64)6);
    (*a).size = (i64)8;
    return a;
}

static void cc_libmcl_writemcl(i64 index,struct cc_libmcl_mclrec * mcl) {
    mlib_gs_strln(cc_libmcl_dest,cc_libmcl_strmcl(mcl));
}

byte * cc_libmcl_strmcl(struct cc_libmcl_mclrec * mcl) {
    static byte str[512];
    byte opnds[512];
    byte opnd2[256];
    byte opcname[128];
    struct cc_libmcl_opndrec *  a;
    struct cc_libmcl_opndrec *  b;
    i64 opcode;
    i64 cond;
    i64 sizepref;
    opcode = (i64)((*mcl).opcode);
    cond = (i64)((*mcl).cond);
    a = (*mcl).a;
    b = (*mcl).b;
    if ((opcode==(i64)67)) {
        return (*a).svalue;
    }else if ((opcode==(i64)2)) {
        return (byte*)"";
    }else if ((opcode==(i64)1)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_str((byte*)";",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((*a).svalue,NULL);
        msysnewc_m_print_end();
        ;
        return str;
    }else if ((opcode==(i64)4)) {
        strcpy((i8 *)(str),(i8 *)((*a).svalue));
        return str;
    }else if ((opcode==(i64)3)) {
        if (!!(b)) {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_setfmt((byte*)"L#:#\t<#>");
            msysnewc_m_print_i64((*a).value,NULL);
            msysnewc_m_print_str((!!((u64)((*a).isglobal))?(byte*)":":(byte*)""),NULL);
            msysnewc_m_print_str((*(*b).def).name,NULL);
            msysnewc_m_print_end();
            ;
        } else {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_setfmt((byte*)"L#:#");
            msysnewc_m_print_i64((*a).value,NULL);
            msysnewc_m_print_str((!!((u64)((*a).isglobal))?(byte*)":":(byte*)""),NULL);
            msysnewc_m_print_end();
            ;
        };
        return str;
    };
    if ((opcode==(i64)19)) {
        msysnewc_m_print_startstr(opcname);
        msysnewc_m_print_str((byte*)"j",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(cc_libmcl_asmcondnames[(cond)],NULL);
        msysnewc_m_print_end();
        ;
    }else if ((opcode==(i64)40)) {
        msysnewc_m_print_startstr(opcname);
        msysnewc_m_print_str((byte*)"set",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(cc_libmcl_asmcondnames[(cond)],NULL);
        msysnewc_m_print_end();
        ;
    }else if ((opcode==(i64)9)) {
        msysnewc_m_print_startstr(opcname);
        msysnewc_m_print_str((byte*)"cmov",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(cc_libmcl_asmcondnames[(cond)],NULL);
        msysnewc_m_print_end();
        ;
    } else {
        strcpy((i8 *)(opcname),(i8 *)((cc_libmcl_mclnames[(opcode)-1] + (i64)2)));
    };
    mlib_ipadstr(opcname,(i64)11,(byte*)" ");
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str((byte*)"\t",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str(opcname,NULL);
    msysnewc_m_print_end();
    ;
    if ((!!(a) && !!(b))) {
        sizepref = cc_libmcl_needsizeprefix(opcode,a,b);
        strcpy((i8 *)(opnd2),(i8 *)(cc_libmcl_stropnd(b,sizepref,(i64)0)));
        msysnewc_m_print_startstr(opnds);
        msysnewc_m_print_setfmt((byte*)"#,\t#");
        msysnewc_m_print_str(cc_libmcl_stropnd(a,sizepref,(i64)0),NULL);
        msysnewc_m_print_str(opnd2,NULL);
        msysnewc_m_print_end();
        ;
    } else if ((!!(a) && !!((u64)((*a).mode)))) {
        if ((opcode == (i64)15)) {
            strcpy((i8 *)(opnds),(i8 *)(cc_libmcl_stropnd(a,(i64)0,(i64)0)));
        } else {
            strcpy((i8 *)(opnds),(i8 *)(cc_libmcl_stropnd(a,(i64)1,(i64)0)));
        };
    } else {
        opnds[((i64)1)-1] = (u64)0u;
    };
    if (!!((u64)(opnds[((i64)1)-1]))) {
        strcat((i8 *)(str),(i8 *)(opnds));
    };
    return str;
}

byte * cc_libmcl_stropnd(struct cc_libmcl_opndrec * a,i64 sizeprefix,i64 debug) {
    static byte str[512];
    byte str2[128];
    byte *  plus;
    byte *  t;
    if (((i64)((*a).mode)==(i64)1)) {
        return cc_libmcl_getregname((i64)((*a).reg),(i64)((*a).size));
    }else if (((i64)((*a).mode)==(i64)2)) {
        return cc_libmcl_strvalue(a);
    }else if (((i64)((*a).mode)==(i64)4)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_str(cc_libmcl_getsizeprefix((i64)((*a).size),sizeprefix),NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((byte*)"[",NULL);
        msysnewc_m_print_end();
        ;
        plus = (byte*)"";
        if (!!((u64)((*a).reg))) {
            strcat((i8 *)(str),(i8 *)(cc_libmcl_getregname((i64)((*a).reg),(i64)8)));
            plus = (byte*)"+";
        };
        if (!!((u64)((*a).regix))) {
            strcat((i8 *)(str),(i8 *)(plus));
            strcat((i8 *)(str),(i8 *)(cc_libmcl_getregname((i64)((*a).regix),(i64)8)));
            plus = (byte*)"+";
            if (((i64)((u64)((*a).scale)) > (i64)1)) {
                msysnewc_m_print_startstr(str2);
                msysnewc_m_print_str((byte*)"*",NULL);
                msysnewc_m_print_nogap();
                msysnewc_m_print_u64((*a).scale,NULL);
                msysnewc_m_print_end();
                ;
                strcat((i8 *)(str),(i8 *)(str2));
            };
        };
        if ((!!((*a).def) || !!((u64)((*a).valtype)))) {
            t = cc_libmcl_strvalue(a);
            if (((u64)((*t)) != '-')) {
                strcat((i8 *)(str),(i8 *)(plus));
            };
            strcat((i8 *)(str),(i8 *)(t));
        };
        strcat((i8 *)(str),(i8 *)((byte*)"]"));
    }else if (((i64)((*a).mode)==(i64)3)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((byte*)"/#/*#");
        msysnewc_m_print_str((*a).svalue,NULL);
        msysnewc_m_print_i64((*a).slength,NULL);
        msysnewc_m_print_end();
        ;
    }else if (((i64)((*a).mode)==(i64)6)) {
        return cc_libmcl_fgetregname((i64)((*a).reg),(i64)((*a).size));
    } else {
        return (byte*)"<BAD OPND>";
    };
    return str;
}

byte * cc_libmcl_strvalue(struct cc_libmcl_opndrec * a) {
    static byte str[512];
    byte str2[128];
    struct cc_decls_strec *  def;
    i64 value;
    def = (*a).def;
    value = (*a).value;
    if (!!(def)) {
        if (((i64)((*def).nameid)==(i64)7)) {
            if (((i64)((u64)((*(*def).owner).nameid)) == (i64)6)) {
                msysnewc_m_print_startstr(str);
                msysnewc_m_print_setfmt((byte*)"`#.#.#");
                msysnewc_m_print_str((*(*def).owner).name,NULL);
                msysnewc_m_print_str((*def).name,NULL);
                msysnewc_m_print_u64((*def).blockno,NULL);
                msysnewc_m_print_end();
                ;
            } else {
                strcpy((i8 *)(str),(i8 *)(cc_libmcl_getfullname(def)));
                if (!!(cc_lib_isimported(def))) {
                    strcat((i8 *)(str),(i8 *)((byte*)"*"));
                };
            };
        }else if (((i64)((*def).nameid)==(i64)8) || ((i64)((*def).nameid)==(i64)9)) {
            strcpy((i8 *)(str),(i8 *)(cc_libmcl_getfullname(def)));
        } else {
            strcpy((i8 *)(str),(i8 *)(cc_libmcl_getfullname(def)));
            if (!!(cc_lib_isimported(def))) {
                strcat((i8 *)(str),(i8 *)((byte*)"*"));
            };
        };
        if ((((i64)((u64)((*a).valtype)) == (i64)1) && (value != (i64)0))) {
            msysnewc_m_print_startstr(str2);
            msysnewc_m_print_str(((value > (i64)0)?(byte*)"+":(byte*)""),NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_i64(value,NULL);
            msysnewc_m_print_end();
            ;
            strcat((i8 *)(str),(i8 *)(str2));
        };
        return str;
    };
    if (((i64)((*a).valtype)==(i64)1) || ((i64)((*a).valtype)==(i64)9)) {
        msysnewc_getstrint(value,str);
    }else if (((i64)((*a).valtype)==(i64)2) || ((i64)((*a).valtype)==(i64)10)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_r64((*a).xvalue,NULL);
        msysnewc_m_print_end();
        ;
    }else if (((i64)((*a).valtype)==(i64)3) || ((i64)((*a).valtype)==(i64)7)) {
        if ((((i64)((u64)(strlen((i8 *)((*a).svalue)))) + (i64)4) < (i64)512)) {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_setfmt((byte*)"\"#\"*#");
            msysnewc_m_print_str((*a).svalue,NULL);
            msysnewc_m_print_i64((*a).slength,NULL);
            msysnewc_m_print_end();
            ;
        } else {
            return (byte*)"<LONGSTR>";
        };
    }else if (((i64)((*a).valtype)==(i64)4) || ((i64)((*a).valtype)==(i64)8)) {
        return (byte*)"<WSTRING>";
    }else if (((i64)((*a).valtype)==(i64)6)) {
        return (*a).svalue;
    }else if (((i64)((*a).valtype)==(i64)5)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_str((byte*)"L",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_i64(value,NULL);
        msysnewc_m_print_end();
        ;
    } else {
        str[((i64)1)-1] = (u64)0u;
    };
    return str;
}

void cc_libmcl_setsegment(i64 seg,i64 align) {
    if ((seg == cc_libmcl_currsegment)) {
        return;
    };
    if ((seg==(i64)73)) {
        cc_libmcl_genmc((i64)65,cc_libmcl_genname((byte*)"idata"),(struct cc_libmcl_opndrec *)(0));
    }else if ((seg==(i64)90)) {
        cc_libmcl_genmc((i64)65,cc_libmcl_genname((byte*)"zdata"),(struct cc_libmcl_opndrec *)(0));
    }else if ((seg==(i64)67)) {
        cc_libmcl_genmc((i64)65,cc_libmcl_genname((byte*)"code"),(struct cc_libmcl_opndrec *)(0));
    }else if ((seg==(i64)82)) {
        cc_libmcl_genmc((i64)65,cc_libmcl_genname((byte*)"rodata"),(struct cc_libmcl_opndrec *)(0));
    };
    cc_libmcl_currsegment = seg;
    cc_libmcl_currzdataalign = (cc_libmcl_curridataalign = (i64)0);
    cc_libmcl_setalign(align);
}

byte * cc_libmcl_getprocname(struct cc_decls_strec * d) {
    if (((*d).name==(byte*)"main")) {
        return (byte*)"main";
    }else if (((*d).name==(byte*)"start")) {
        return (byte*)"start";
    } else {
        return cc_lib_getdottedname(d);
    };
    return (byte*)"";
}

i64 cc_libmcl_widenstr(byte * s,i64 w) {
    L821 :;
    while (((i64)((u64)(strlen((i8 *)(s)))) >= (w - (i64)2))) {
        w += (i64)8;
L822 :;
    }L823 :;
    ;
    return w;
}

void cc_libmcl_genassem(byte * s) {
    cc_libmcl_genmcstr((i64)67,s);
}

byte * cc_libmcl_strlabel(i64 n) {
    static byte str[16];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str((byte*)"L",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_i64(n,NULL);
    msysnewc_m_print_end();
    ;
    return str;
}

struct cc_libmcl_opndrec * cc_libmcl_makeindirect(struct cc_libmcl_opndrec * a,i64 size) {
    struct cc_libmcl_opndrec *  b;
    b = cc_libmcl_duplopnd(a);
    if (((i64)((*b).mode)==(i64)1)) {
        (*b).mode = (u64)((i64)4);
    } else {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"STROPND(B)=",NULL);
        msysnewc_m_print_str(cc_libmcl_stropnd(b,(i64)0,(i64)0),NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        cc_support_gerror((byte*)"makeind",(struct cc_decls_unitrec *)(0));
    };
    if (!!(size)) {
        (*b).size = size;
    };
    return b;
}

struct cc_libmcl_opndrec * cc_libmcl_applyoffset(struct cc_libmcl_opndrec * a,i64 offset,i64 size) {
    struct cc_libmcl_opndrec *  b;
    if (((offset == (i64)0) && (size == (i64)0))) {
        return a;
    };
    b = cc_libmcl_duplopnd(a);
    (*b).value += offset;
    (*b).valtype = (u64)((i64)1);
    if (!!(size)) {
        (*b).size = size;
    };
    return b;
}

struct cc_libmcl_opndrec * cc_libmcl_applysize(struct cc_libmcl_opndrec * a,i64 size) {
    if (((i64)((*a).size) != size)) {
        a = cc_libmcl_duplopnd(a);
        (*a).size = size;
    };
    return a;
}

i64 cc_libmcl_isframe(struct cc_decls_strec * d) {
    if (((i64)((*d).nameid)==(i64)8) || ((i64)((*d).nameid)==(i64)9)) {
        return (i64)1;
    };
    return (i64)0;
}

void cc_libmcl_genreturn(i64 fbytes,i64 pbytes) {
    byte str[256];
    i64 iscallback;
    iscallback = cc_libmcl_iscallbackfn(cc_decls_currproc);
    cc_libmcl_retbeforeblock = (i64)1;
    if ((!!(fbytes) || !!(pbytes))) {
        if (!!(fbytes)) {
            cc_libmcl_popstack(cc_libmcl_roundto(fbytes,(i64)16));
        };
        cc_libmcl_genmc((i64)7,cc_libmcl_dframeopnd,(struct cc_libmcl_opndrec *)(0));
        if (!!(iscallback)) {
            strcpy((i8 *)(str),(i8 *)((byte*)"\tcall m$popcallback*"));
            cc_libmcl_genassem(str);
        };
        cc_libmcl_genmc((i64)16,(struct cc_libmcl_opndrec *)(0),(struct cc_libmcl_opndrec *)(0));
    } else {
        if (!!(iscallback)) {
            strcpy((i8 *)(str),(i8 *)((byte*)"\tcall m$popcallback*"));
            cc_libmcl_genassem(str);
        };
        cc_libmcl_popstack((i64)8);
        cc_libmcl_genmc((i64)16,(struct cc_libmcl_opndrec *)(0),(struct cc_libmcl_opndrec *)(0));
    };
    cc_libmcl_stackaligned = (i64)1;
}

byte * cc_libmcl_getsizeprefix(i64 size,i64 enable) {
    if (!(!!(enable))) {
        return (byte*)"";
    };
    if ((size==(i64)1)) {
        return (byte*)"byte ";
    }else if ((size==(i64)2)) {
        return (byte*)"word16 ";
    }else if ((size==(i64)4)) {
        return (byte*)"word32 ";
    }else if ((size==(i64)8)) {
        return (byte*)"word64 ";
    };
    return (byte*)"N:";
}

i64 cc_libmcl_needsizeprefix(i64 opcode,struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    if ((opcode==(i64)12) || (opcode==(i64)11) || (opcode==(i64)74) || (opcode==(i64)73) || (opcode==(i64)89) || (opcode==(i64)90)) {
        return (i64)1;
    }else if ((opcode==(i64)50)) {
        return (i64)1;
    }else if ((opcode==(i64)33) || (opcode==(i64)71) || (opcode==(i64)70)) {
        if (((i64)((u64)((*a).mode)) == (i64)4)) {
            return (i64)1;
        };
        return (i64)0;
    };
    if ((((((i64)((u64)((*a).mode)) == (i64)1) || ((i64)((u64)((*a).mode)) == (i64)6)) || ((i64)((u64)((*b).mode)) == (i64)1)) || ((i64)((u64)((*b).mode)) == (i64)6))) {
        return (i64)0;
    };
    return (i64)1;
}

struct cc_libmcl_opndrec * cc_libmcl_changeopndsize(struct cc_libmcl_opndrec * a,i64 size) {
    struct cc_libmcl_opndrec *  b;
    if (((i64)((*a).size) != size)) {
        b = cc_libmcl_duplopnd(a);
        (*b).size = size;
        return b;
    };
    return a;
}

struct cc_libmcl_opndrec * cc_libmcl_genint(i64 x,i64 size) {
    struct cc_libmcl_opndrec *  a;
    a = cc_libmcl_newopnd();
    (*a).mode = (u64)((i64)2);
    (*a).value = x;
    (*a).valtype = (u64)((i64)1);
    (*a).size = size;
    return a;
}

struct cc_libmcl_opndrec * cc_libmcl_genreal(double x,i64 size) {
    struct cc_libmcl_opndrec *  a;
    a = cc_libmcl_newopnd();
    (*a).mode = (u64)((i64)2);
    (*a).xvalue = x;
    (*a).valtype = (u64)((i64)2);
    (*a).size = size;
    return a;
}

struct cc_libmcl_opndrec * cc_libmcl_genimm(struct cc_decls_unitrec * p,i64 size) {
    struct cc_libmcl_opndrec *  a;
    i64 t;
    a = cc_libmcl_newopnd();
    (*a).mode = (u64)((i64)2);
    if (((i64)((*p).tag)==(i64)1)) {
        t = (i64)((*p).mode);
        if (!!(cc_lib_isintcc(t))) {
            (*a).value = (*p).value;
            (*a).valtype = (u64)((i64)1);
            (*a).size = (!!(size)?size:cc_decls_ttsize[(t)]);
        } else if (!!(cc_lib_isrealcc(t))) {
            (*a).xvalue = (*p).xvalue;
            (*a).valtype = (u64)((i64)2);
            (*a).size = (!!(size)?size:cc_decls_ttsize[(t)]);
        } else {
            cc_support_gerror((byte*)"GENIMM/MODE?",(struct cc_decls_unitrec *)(0));
        };
    }else if (((i64)((*p).tag)==(i64)3)) {
        (*a).def = (*p).def;
        (*a).size = cc_decls_ttsize[((i64)((*(*p).def).mode))];
    } else {
        cc_support_gerror((byte*)"genimm/unit",(struct cc_decls_unitrec *)(0));
    };
    return a;
}

struct cc_libmcl_opndrec * cc_libmcl_genlabel(i64 x,i64 isglobal) {
    struct cc_libmcl_opndrec *  a;
    a = cc_libmcl_newopnd();
    (*a).size = (i64)8;
    (*a).mode = (u64)((i64)2);
    (*a).value = x;
    (*a).valtype = (u64)((i64)5);
    (*a).isglobal = (u64)(isglobal);
    return a;
}

struct cc_libmcl_opndrec * cc_libmcl_genmem_u(struct cc_decls_unitrec * p,i64 size) {
    return cc_libmcl_genmem_d((*p).def,cc_decls_ttsize[((i64)((*p).mode))]);
}

struct cc_libmcl_opndrec * cc_libmcl_genmem_d(struct cc_decls_strec * d,i64 size) {
    struct cc_libmcl_opndrec *  a;
    ++cc_libmcl_nmem;
    a = cc_libmcl_newopnd();
    (*a).mode = (u64)((i64)4);
    if ((!!(cc_libmcl_isframe(d)) && !!(cc_libmcl_fshowfullnames))) {
        (*a).reg = (u64)((i64)15);
    };
    (*a).def = d;
    (*a).size = (!!(size)?size:cc_decls_ttsize[((i64)((*d).mode))]);
    return a;
}

struct cc_libmcl_opndrec * cc_libmcl_genmemaddr_u(struct cc_decls_unitrec * p) {
    return cc_libmcl_genmemaddr_d((*p).def);
}

struct cc_libmcl_opndrec * cc_libmcl_genmemaddr_d(struct cc_decls_strec * d) {
    struct cc_libmcl_opndrec *  a;
    ++cc_libmcl_nmemaddr;
    a = cc_libmcl_newopnd();
    (*a).mode = (u64)((i64)2);
    if ((!!(cc_libmcl_isframe(d)) && !!(cc_libmcl_fshowfullnames))) {
        (*a).reg = (u64)((i64)15);
    };
    (*a).def = d;
    (*a).size = (i64)8;
    return a;
}

struct cc_libmcl_opndrec * cc_libmcl_genreg(i64 reg,i64 size) {
    static i64 isnormal[9] = {(i64)0,(i64)1,(i64)1,(i64)0,(i64)1,(i64)0,(i64)0,(i64)0,(i64)1};
    struct cc_libmcl_opndrec *  a;
    if (((size <= (i64)8) && !!(isnormal[(size)]))) {
        a = cc_libmcl_newopnd();
        (*a).mode = (u64)((i64)1);
        (*a).reg = (u64)(reg);
        (*a).size = size;
    } else {
        cc_support_gerror((byte*)"GENREG/BLOCK SIZE",(struct cc_decls_unitrec *)(0));
    };
    return a;
}

struct cc_libmcl_opndrec * cc_libmcl_genireg(i64 reg,i64 size) {
    struct cc_libmcl_opndrec *  a;
    a = cc_libmcl_newopnd();
    (*a).mode = (u64)((i64)4);
    (*a).reg = (u64)(reg);
    (*a).size = size;
    return a;
}

i64 cc_libmcl_getopndsize_u(struct cc_decls_unitrec * p) {
    return cc_decls_ttsize[((i64)((*p).mode))];
}

i64 cc_libmcl_getopndsize_d(struct cc_decls_strec * d) {
    return cc_decls_ttsize[((i64)((*d).mode))];
}

i64 cc_libmcl_getmclcond(i64 opc,i64 m) {
    i64 signedx;
    signedx = (i64)(cc_tables_stdtypesigned[(cc_decls_ttbasetype[(m)])]);
    if (!!(cc_lib_isrealcc(m))) {
        if ((opc==(i64)36)) {
            return (i64)16;
        }else if ((opc==(i64)37)) {
            return (i64)18;
        }else if ((opc==(i64)39)) {
            return (i64)17;
        }else if ((opc==(i64)38)) {
            return (i64)19;
        }else if ((opc==(i64)34)) {
            return (i64)20;
        }else if ((opc==(i64)35)) {
            return (i64)21;
        };
    } else {
        if ((opc==(i64)36)) {
            return (!!(signedx)?(i64)12:(i64)2);
        }else if ((opc==(i64)37)) {
            return (!!(signedx)?(i64)14:(i64)6);
        }else if ((opc==(i64)39)) {
            return (!!(signedx)?(i64)13:(i64)3);
        }else if ((opc==(i64)38)) {
            return (!!(signedx)?(i64)15:(i64)7);
        }else if ((opc==(i64)34)) {
            return (i64)4;
        }else if ((opc==(i64)35)) {
            return (i64)5;
        };
    };
    return (i64)0;
}

byte * cc_libmcl_getfullname(struct cc_decls_strec * d) {
    return (*d).name;
}

i64 cc_libmcl_roundsizetg(i64 size) {
    L824 :;
    while (!!((size & (i64)7))) {
        ++size;
L825 :;
    }L826 :;
    ;
    return size;
}

i64 cc_libmcl_iscallbackfn(struct cc_decls_strec * p) {
    return (i64)((*p).attribs.ax_callback);
}

byte * cc_libmcl_getregname(i64 reg,i64 size) {
    static byte *  prefix[8] = {(byte*)"B",(byte*)"W",(byte*)"",(byte*)"A",(byte*)"",(byte*)"",(byte*)"",(byte*)"D"};
    static byte str[32];
    byte str2[16];
    byte *  rs;
    if ((size > (i64)8)) {
        return (byte*)"DBIG";
    };
    if ((reg==(i64)0)) {
        return (byte*)"-";
    }else if ((reg==(i64)15)) {
        rs = (byte*)"frame";
    }else if ((reg==(i64)16)) {
        rs = (byte*)"stack";
    } else {
        msysnewc_getstrint((reg - (i64)1),str2);
        rs = str2;
    };
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str(prefix[(size)-1],NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str(rs,NULL);
    msysnewc_m_print_end();
    ;
    return str;
}

byte * cc_libmcl_getblockname(i64 reg,i64 size) {
    static byte str[32];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_setfmt((byte*)"N#(#)");
    msysnewc_m_print_i64((reg - (i64)1),NULL);
    msysnewc_m_print_i64(size,NULL);
    msysnewc_m_print_end();
    ;
    return str;
}

byte * cc_libmcl_fgetregname(i64 reg,i64 size) {
    static byte str[32];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str(((size == (i64)8)?(byte*)"DX":(byte*)"SX"),NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_i64((reg - (i64)1),NULL);
    msysnewc_m_print_end();
    ;
    return str;
}

i64 cc_libmcl_issimple(struct cc_decls_unitrec * p) {
    if (!(!!((i64)1))) {
        return (i64)0;
    };
    return cc_libmcl_issimple0(p,(i64)0);
}

static i64 cc_libmcl_issimple0(struct cc_decls_unitrec * p,i64 level) {
    struct cc_decls_unitrec *  a;
    ++level;
    if ((level > (i64)5)) {
        return (i64)0;
    };
    a = (*p).a;
    switch ((int)((*p).tag)) {
    case 1:;
    case 3:;
    case 5:;
    {
        return (i64)1;
    }break;
    case 53:;
    {
        if ((((i64)((*a).tag) == (i64)54) || ((i64)((*a).tag) == (i64)55))) {
            if ((!!(cc_libmcl_issimple0((*a).a,level)) && !!(cc_libmcl_issimple0((*a).b,level)))) {
                return (i64)1;
            };
        } else {
            return cc_libmcl_issimple0(a,level);
        };
    }break;
    case 40:;
    case 41:;
    case 45:;
    case 46:;
    case 47:;
    {
        /*dobin:*/
L827 :;
;
        if ((!!(cc_libmcl_issimple0(a,level)) && !!(cc_libmcl_issimple0((*p).b,level)))) {
            return (i64)1;
        };
    }break;
    case 42:;
    {
        if ((cc_libmcl_gettypecat(p) == (i64)73)) {
            goto L827 ;
;
        };
    }break;
    case 57:;
    {
        if (((i64)((*p).opcode)==(i64)1) || ((i64)((*p).opcode)==(i64)2) || ((i64)((*p).opcode)==(i64)3) || ((i64)((*p).opcode)==(i64)4)) {
            return cc_libmcl_issimple0(a,level);
        };
    }break;
    case 56:;
    {
        return cc_libmcl_issimple0(a,level);
    }break;
    case 50:;
    {
        return cc_libmcl_issimple0(a,level);
    }break;
    case 48:;
    case 49:;
    {
        if ((!!(cc_libmcl_issimple0(a,level)) && ((i64)((*(*p).b).tag) == (i64)1))) {
            return (i64)1;
        };
    }break;
    default: {
    }
    } /* SW */
;
    return (i64)0;
}

i64 cc_libmcl_issimplepm(struct cc_decls_unitrec * p) {
    if (!(!!((i64)1))) {
        return (i64)0;
    };
    if (((i64)((*p).tag)==(i64)1) || ((i64)((*p).tag)==(i64)3)) {
        return (i64)1;
    };
    return (i64)0;
}

i64 cc_libmcl_getaregs(struct cc_libmcl_opndrec * ax) {
    i64 n;
    if (((i64)((*ax).mode)==(i64)1)) {
        return (i64)1;
    }else if (((i64)((*ax).mode)==(i64)4)) {
        n = (i64)0;
        if ((!!((u64)((*ax).reg)) && ((i64)((u64)((*ax).reg)) != (i64)15))) {
            ++n;
        };
        if (!!((u64)((*ax).regix))) {
            ++n;
        };
        return n;
    }else if (((i64)((*ax).mode)==(i64)6)) {
        return (i64)0;
    } else {
        cc_support_gerror((byte*)"getaregs",(struct cc_decls_unitrec *)(0));
    };
    return (i64)0;
}

i64 cc_libmcl_getlregs(struct cc_libmcl_opndrec * ax) {
    if (((i64)((*ax).mode)==(i64)1) || ((i64)((*ax).mode)==(i64)6)) {
        return (i64)1;
    }else if (((i64)((*ax).mode)==(i64)4)) {
        if (((!!((u64)((*ax).reg)) && ((i64)((u64)((*ax).reg)) != (i64)15)) || !!((u64)((*ax).regix)))) {
            return (i64)1;
        };
    }else if (((i64)((*ax).mode)==(i64)2)) {
        return (i64)0;
    } else {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(cc_libmcl_opndnames[((i64)((*ax).mode))],NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        cc_support_gerror((byte*)"getlregs",(struct cc_decls_unitrec *)(0));
    };
    return (i64)0;
}

i64 cc_libmcl_isintconst(struct cc_decls_unitrec * p) {
    if ((((i64)((*p).tag) == (i64)1) && !!(cc_lib_isintcc((i64)((*p).mode))))) {
        return (i64)1;
    };
    return (i64)0;
}

i64 cc_libmcl__getnextreg(struct cc_libmcl_opndrec * ax,i64 reg) {
    i64 maxreg;
    i64 r;
    i64 rix;
    r = (i64)((*ax).reg);
    rix = (i64)((*ax).regix);
    if (((i64)((*ax).mode)==(i64)1) || ((i64)((*ax).mode)==(i64)6)) {
        if ((r < (i64)15)) {
            return ((r + (i64)1) + (i64)1);
        };
    }else if (((i64)((*ax).mode)==(i64)4)) {
        maxreg = (i64)0;
        if (((r >= (i64)15) && (rix > (i64)15))) {
        } else if ((r > (i64)15)) {
            maxreg = rix;
        } else if ((rix > (i64)15)) {
            maxreg = r;
        } else {
            if ((r != (i64)15)) {
                maxreg = (r>rix?r:rix);
            } else {
                maxreg = rix;
            };
        };
        if (!!(maxreg)) {
            return (maxreg + (i64)1);
        };
    };
    if ((reg == (i64)0)) {
        reg = (i64)1;
    };
    return reg;
}

i64 cc_libmcl_getnextreg(struct cc_libmcl_opndrec * ax,i64 r) {
    static i64 maxreg = (i64)0;
    i64 reg;
    reg = cc_libmcl__getnextreg(ax,r);
    if ((reg > maxreg)) {
        maxreg = reg;
    };
    return reg;
}

i64 cc_libmcl_ispoweroftwo(i64 x) {
    i64 a;
    i64 n;
    i64 av_1;
    a = (i64)1;
    n = (i64)0;
    av_1 = (i64)30;
    while (av_1-- > 0) {
L828 :;
        ++n;
        a = (a << (i64)1);
        if ((a == x)) {
            return n;
        };
L829 :;
    }L830 :;
    ;
    return (i64)0;
}

static i64 cc_libmcl_sameoperand(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    if (((u64)((*a).mode) != (u64)((*b).mode))) {
        return (i64)0;
    };
    if (((i64)((*a).size) != (i64)((*b).size))) {
        return (i64)0;
    };
    if (((*a).value != (*b).value)) {
        return (i64)0;
    };
    if (((u64)((*a).reg) != (u64)((*b).reg))) {
        return (i64)0;
    };
    if (((u64)((*a).regix) != (u64)((*b).regix))) {
        return (i64)0;
    };
    if (((u64)((*a).valtype) != (u64)((*b).valtype))) {
        return (i64)0;
    };
    if (((u64)((*a).scale) != (u64)((*b).scale))) {
        return (i64)0;
    };
    if ((((!!((*a).def) && !!((*b).def)) && ((*a).def == (*b).def)) && ((*a).value == (*b).value))) {
        return (i64)1;
    } else if (((((*a).def == 0) && ((*b).def == 0)) && ((*a).value == (*b).value))) {
        return (i64)1;
    };
    return (i64)0;
}

static struct cc_libmcl_mclrec * cc_libmcl_findlastmcl(void) {
    cc_support_gerror((byte*)"FINDLASTMCL",(struct cc_decls_unitrec *)(0));
    return (struct cc_libmcl_mclrec *)(0);
}

void cc_libmcl_genmsource(i64 lineno) {
}

i64 cc_libmcl_roundto(i64 a,i64 n) {
    --n;
    L831 :;
    while (!!((a & n))) {
        ++a;
L832 :;
    }L833 :;
    ;
    return a;
}

void cc_libmcl_pushstack(i64 n) {
    if (!!(n)) {
        cc_libmcl_genmc((i64)22,cc_libmcl_dstackopnd,cc_libmcl_genint(n,(i64)4));
        if (!!((n & (i64)8))) {
            cc_libmcl_stackaligned ^= (i64)1;
        };
    };
}

void cc_libmcl_pushstackfp(i64 n) {
    i64 av_1;
    if (!!(n)) {
        cc_libmcl_genmc((i64)5,cc_libmcl_genreg((i64)14,(i64)8),cc_libmcl_genint((i64)0,(i64)4));
        av_1 = (n / (i64)8);
        while (av_1-- > 0) {
L834 :;
            cc_libmcl_genmc((i64)6,cc_libmcl_genreg((i64)14,(i64)8),(struct cc_libmcl_opndrec *)(0));
L835 :;
        }L836 :;
        ;
        if (!!((n & (i64)8))) {
            cc_libmcl_stackaligned ^= (i64)1;
        };
    };
}

void cc_libmcl_popstack(i64 n) {
    if (!!(n)) {
        cc_libmcl_genmc((i64)21,cc_libmcl_dstackopnd,cc_libmcl_genint(n,(i64)4));
        if (!!((n & (i64)8))) {
            cc_libmcl_stackaligned ^= (i64)1;
        };
    };
}

i64 cc_libmcl_definelabel(void) {
    cc_libmcl_genmc((i64)3,cc_libmcl_genlabel(++cc_decls_labelno,(i64)0),(struct cc_libmcl_opndrec *)(0));
    return cc_decls_labelno;
}

i64 cc_libmcl_createfwdlabel(void) {
    return ++cc_decls_labelno;
}

void cc_libmcl_definefwdlabel(i64 lab) {
    cc_libmcl_genmc((i64)3,cc_libmcl_genlabel(lab,(i64)0),(struct cc_libmcl_opndrec *)(0));
}

void cc_libmcl_genjumpl(i64 lab) {
    cc_libmcl_genmc((i64)18,cc_libmcl_genlabel(lab,(i64)0),(struct cc_libmcl_opndrec *)(0));
}

void cc_libmcl_setalign(i64 align) {
    if ((align > (i64)1)) {
        cc_libmcl_genmc((i64)64,cc_libmcl_genint(align,(i64)4),(struct cc_libmcl_opndrec *)(0));
    };
}

i64 cc_libmcl_gettypecat(struct cc_decls_unitrec * a) {
    return (i64)(cc_tables_stdtypecat[(cc_decls_ttbasetype[((i64)((*a).mode))])]);
}

void cc_libmcl_doblockcall(i64 size) {
    struct cc_libmcl_opndrec *  ax;
    if (!!(cc_libmcl_retbeforeblock)) {
        cc_support_gerror((byte*)"Block call after return",(struct cc_decls_unitrec *)(0));
    };
    L837 :;
    while (!!((size & (i64)15))) {
        ++size;
L838 :;
    }L839 :;
    ;
    if ((cc_libmcl_currblocksize == (i64)0)) {
        cc_libmcl_currblocksize = size;
        cc_libmcl_frameoffset -= size;
        cc_libmcl_framebytes += size;
        (*(*cc_libmcl_stacksetinstr).b).value = cc_libmcl_roundto(cc_libmcl_framebytes,(i64)16);
    } else if ((cc_libmcl_currblocksize < size)) {
        cc_libmcl_frameoffset -= (size - cc_libmcl_currblocksize);
        cc_libmcl_framebytes += (size - cc_libmcl_currblocksize);
        cc_libmcl_currblocksize = size;
        (*(*cc_libmcl_stacksetinstr).b).value = cc_libmcl_roundto(cc_libmcl_framebytes,(i64)16);
    };
    ax = cc_libmcl_genreg((i64)10,(i64)8);
    cc_libmcl_genmc((i64)8,ax,cc_libmcl_genindex((i64)15,(i64)0,(i64)1,cc_libmcl_frameoffset,(i64)0,(i64)0,(struct cc_decls_strec *)(0)));
}

struct cc_libmcl_opndrec * cc_libmcl_getblockreg(i64 size) {
    struct cc_libmcl_opndrec *  ax;
    L840 :;
    while (!!((size & (i64)15))) {
        ++size;
L841 :;
    }L842 :;
    ;
    if ((cc_libmcl_currblocksize < size)) {
        cc_support_gerror((byte*)"getblockreg?",(struct cc_decls_unitrec *)(0));
    };
    cc_libmcl_genmc((i64)8,(ax = cc_libmcl_genreg((i64)1,(i64)8)),cc_libmcl_genindex((i64)15,(i64)0,(i64)1,cc_libmcl_frameoffset,(i64)0,(i64)0,(struct cc_decls_strec *)(0)));
    return ax;
}

void cc_libmcl_copyretvalue(i64 size) {
    byte str[256];
    cc_libmcl_genassem((byte*)";-----------");
    cc_libmcl_genassem((byte*)"\tpush d0");
    cc_libmcl_genassem((byte*)"\tpush d0");
    cc_libmcl_genassem((byte*)"\tsub dstack,32");
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_setfmt((byte*)"\tmov d10,[dframe#]");
    msysnewc_m_print_i64(cc_libmcl_structretoffset,NULL);
    msysnewc_m_print_end();
    ;
    cc_libmcl_genassem(str);
    cc_libmcl_genassem((byte*)"\tmov d11,d0");
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str((byte*)"\tmov d12,",NULL);
    msysnewc_m_print_i64(size,NULL);
    msysnewc_m_print_end();
    ;
    cc_libmcl_genassem(str);
    cc_libmcl_genassem((byte*)"\tcall memcpy*");
    cc_libmcl_genassem((byte*)"\tadd dstack,32");
    cc_libmcl_genassem((byte*)"\tpop d0");
    cc_libmcl_genassem((byte*)"\tpop d0");
    cc_libmcl_genassem((byte*)";-----------");
}

void cc_libmcl_enterproc(byte * name) {
    return;
    if ((!!(mlib_eqstring(name,(byte*)"$showentry")) || !!(mlib_eqstring(name,(byte*)"$showreturn")))) {
        return;
    };
    cc_libmcl_genmc((i64)22,cc_libmcl_genreg((i64)16,(i64)8),cc_libmcl_genint((i64)32,(i64)4));
    cc_libmcl_genmc((i64)5,cc_libmcl_genreg((i64)11,(i64)8),cc_libmcl_genstrimm(name,(i64)-1));
    cc_libmcl_genmc((i64)15,cc_libmcl_genname((byte*)"$showentry*"),(struct cc_libmcl_opndrec *)(0));
    cc_libmcl_genmc((i64)21,cc_libmcl_genreg((i64)16,(i64)8),cc_libmcl_genint((i64)32,(i64)4));
}

void cc_libmcl_leaveproc(byte * name) {
    return;
    if ((!!(mlib_eqstring(name,(byte*)"$showentry")) || !!(mlib_eqstring(name,(byte*)"$showreturn")))) {
        return;
    };
    cc_libmcl_genmc((i64)22,cc_libmcl_genreg((i64)16,(i64)8),cc_libmcl_genint((i64)32,(i64)4));
    cc_libmcl_genmc((i64)5,cc_libmcl_genreg((i64)11,(i64)8),cc_libmcl_genstrimm(name,(i64)-1));
    cc_libmcl_genmc((i64)15,cc_libmcl_genname((byte*)"$showreturn*"),(struct cc_libmcl_opndrec *)(0));
    cc_libmcl_genmc((i64)21,cc_libmcl_genreg((i64)16,(i64)8),cc_libmcl_genint((i64)32,(i64)4));
}

void cc_blockmcl_do_stmt(struct cc_decls_unitrec * p) {
    i64 oldclineno;
    i64 value;
    i64 i;
    struct cc_decls_unitrec *  a;
    struct cc_decls_unitrec *  b;
    byte str[256];
    if ((p == 0)) {
        return;
    };
    oldclineno = cc_decls_clineno;
    cc_decls_clineno = (i64)((((u64)((*p).fileno) << (i64)24) + (u64)((*p).lineno)));
    a = (*p).a;
    b = (*p).b;
    switch ((int)((*p).tag)) {
    case 6:;
    {
        L843 :;
        while (!!(a)) {
            cc_blockmcl_do_stmt(a);
            a = (*a).nextunit;
L844 :;
        }L845 :;
        ;
    }break;
    case 8:;
    {
        cc_blockmcl_do_decl((*p).def);
    }break;
    case 31:;
    {
        cc_blockmcl_dx_call(p,a,b,(i64)1);
    }break;
    case 10:;
    {
        cc_blockmcl_do_return(a);
    }break;
    case 12:;
    {
        cc_blockmcl_do_assign(a,b);
    }break;
    case 13:;
    {
        cc_blockmcl_do_if(a,b,(*p).c);
    }break;
    case 14:;
    {
        cc_blockmcl_do_for(a,b);
    }break;
    case 15:;
    {
        cc_blockmcl_do_while(a,b);
    }break;
    case 16:;
    {
        cc_blockmcl_do_dowhile(a,b);
    }break;
    case 17:;
    {
        cc_blockmcl_do_goto((*p).def);
    }break;
    case 18:;
    {
        cc_blockmcl_do_labeldef((*p).def);
        cc_blockmcl_do_stmt(a);
    }break;
    case 19:;
    {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((byte*)"case");
        msysnewc_m_print_i64((*p).index,NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((byte*)":",NULL);
        msysnewc_m_print_end();
        ;
        cc_libmcl_gencomment(mlib_pcm_copyheapstring(str));
        if ((cc_blockmcl_sw_ncases == (i64)0)) {
            cc_libmcl_genmc((i64)3,cc_libmcl_genlabel((*cc_blockmcl_sw_labeltable)[((((*p).value - cc_blockmcl_sw_lower) + (i64)1))-1],(i64)0),(struct cc_libmcl_opndrec *)(0));
        } else {
            value = (*p).value;
            L846 :;
            for (i=(i64)1;i<=cc_blockmcl_sw_ncases;i+=(i64)1) {
L847 :;
                if (((*cc_blockmcl_sw_valuetable)[(i)-1] == value)) {
                    cc_libmcl_genmc((i64)3,cc_libmcl_genlabel((*cc_blockmcl_sw_labeltable)[(i)-1],(i64)0),(struct cc_libmcl_opndrec *)(0));
                    goto L849 ;
                };
L848 :;
            }
            {
                cc_support_gerror((byte*)"case: serial switch not found",(struct cc_decls_unitrec *)(0));
            }L849 :;
            ;
        };
        cc_blockmcl_do_stmt(a);
    }break;
    case 20:;
    {
        cc_blockmcl_sw_defaultseen = (u64)((i64)1);
        cc_libmcl_gencomment((byte*)"default:");
        cc_libmcl_genmc((i64)3,cc_libmcl_genlabel(cc_blockmcl_sw_defaultlabel,(i64)0),(struct cc_libmcl_opndrec *)(0));
        cc_blockmcl_do_stmt(a);
    }break;
    case 24:;
    {
        cc_libmcl_genjumpl(cc_blockmcl_sw_breaklabel);
    }break;
    case 21:;
    {
        cc_libmcl_genjumpl(cc_blockmcl_breakstack[(cc_blockmcl_loopindex)-1]);
    }break;
    case 22:;
    {
        cc_libmcl_genjumpl(cc_blockmcl_continuestack[(cc_blockmcl_loopindex)-1]);
    }break;
    case 23:;
    {
        cc_blockmcl_do_switch(p,a,b);
    }break;
    case 62:;
    {
        cc_blockmcl_dx_addto((i64)21,a,b,(i64)0);
    }break;
    case 63:;
    {
        cc_blockmcl_dx_addto((i64)22,a,b,(i64)0);
    }break;
    case 64:;
    {
        cc_blockmcl_dx_multo(a,b,(i64)0);
    }break;
    case 65:;
    case 66:;
    {
        cc_blockmcl_dx_divto(p,a,b,(i64)0);
    }break;
    case 67:;
    {
        cc_blockmcl_dx_addto((i64)28,a,b,(i64)0);
    }break;
    case 68:;
    {
        cc_blockmcl_dx_addto((i64)29,a,b,(i64)0);
    }break;
    case 69:;
    {
        cc_blockmcl_dx_addto((i64)30,a,b,(i64)0);
    }break;
    case 70:;
    case 71:;
    {
        cc_blockmcl_dx_shlto(p,a,b,(i64)0);
    }break;
    case 73:;
    case 75:;
    {
        cc_blockmcl_do_preincr(a,(i64)21,(i64)38);
    }break;
    case 74:;
    case 76:;
    {
        cc_blockmcl_do_preincr(a,(i64)22,(i64)39);
    }break;
    case 30:;
    {
        cc_blockmcl_do_exprlist(a);
    }break;
    default: {
        if ((((i64)((*p).tag) != (i64)1) || !(!!(cc_decls_fshownames)))) {
            cc_blockmcl_loneexpr(p);
        };
    }
    } /* SW */
;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_expr(struct cc_decls_unitrec * p,i64 reg,i64 am) {
    i64 oldclineno;
    i64 m;
    struct cc_decls_unitrec *  a;
    struct cc_decls_unitrec *  b;
    struct cc_libmcl_opndrec *  tx;
    if ((p == 0)) {
        return (struct cc_libmcl_opndrec *)(0);
    };
    if (((reg > (i64)9) && (reg < (i64)11))) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"DOEXPR TOO MANY REGS?",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    oldclineno = cc_decls_clineno;
    cc_decls_clineno = (i64)((((u64)((*p).fileno) << (i64)24) + (u64)((*p).lineno)));
    tx = (struct cc_libmcl_opndrec *)(0);
    a = (*p).a;
    b = (*p).b;
    m = (i64)((*p).mode);
    switch ((int)((*p).tag)) {
    case 1:;
    {
        return cc_blockmcl_dx_const(p,reg);
    }break;
    case 3:;
    {
        return cc_blockmcl_dx_name(p,reg,am);
    }break;
    case 4:;
    {
        return cc_blockmcl_dx_widen(a,m,reg);
    }break;
    case 5:;
    {
        return cc_libmcl_genmemaddr_u(p);
    }break;
    case 12:;
    {
        return cc_blockmcl_dx_assign(a,b,reg);
    }break;
    case 25:;
    case 26:;
    {
        return cc_blockmcl_dx_andorl(p,reg);
    }break;
    case 27:;
    {
        return cc_blockmcl_dx_notl(a,reg);
    }break;
    case 28:;
    {
        return cc_blockmcl_dx_istruel(a,reg);
    }break;
    case 30:;
    {
        return cc_blockmcl_dx_exprlist(a,reg);
    }break;
    case 31:;
    {
        return cc_blockmcl_dx_call(p,a,b,reg);
    }break;
    case 32:;
    {
        return cc_blockmcl_dx_ifx(a,b,(*p).c,reg);
    }break;
    case 34:;
    case 35:;
    case 36:;
    case 37:;
    case 39:;
    case 38:;
    {
        return cc_blockmcl_dx_eq(p,a,b,reg);
    }break;
    case 40:;
    {
        if ((!!((u64)(cc_decls_ttisref[((i64)((*a).mode))])) && (cc_decls_ttsize[((i64)((*b).mode))] <= (i64)4))) {
            (*b).mode = (i64)10;
        };
        return cc_blockmcl_dx_add(a,b,reg);
    }break;
    case 41:;
    {
        return cc_blockmcl_dx_sub(a,b,reg);
    }break;
    case 42:;
    {
        return cc_blockmcl_dx_mul(p,a,b,reg);
    }break;
    case 43:;
    {
        return cc_blockmcl_dx_div(p,a,b,reg);
    }break;
    case 44:;
    {
        return cc_blockmcl_dx_rem(p,a,b,reg);
    }break;
    case 45:;
    {
        return cc_blockmcl_dx_iand((i64)28,a,b,reg);
    }break;
    case 46:;
    {
        return cc_blockmcl_dx_iand((i64)29,a,b,reg);
    }break;
    case 47:;
    {
        return cc_blockmcl_dx_iand((i64)30,a,b,reg);
    }break;
    case 48:;
    case 49:;
    {
        return cc_blockmcl_dx_shl(p,a,b,reg);
    }break;
    case 53:;
    {
        return cc_blockmcl_dx_ptr(p,a,reg,am);
    }break;
    case 54:;
    {
        return cc_blockmcl_dx_addptr(p,a,b,reg,am);
    }break;
    case 55:;
    {
        return cc_blockmcl_dx_subptr(a,b,reg,am);
    }break;
    case 57:;
    {
        if ((m == (i64)1)) {
            return cc_blockmcl_evalexpr(a,reg);
        } else {
            return cc_blockmcl_dx_convert(a,m,(i64)((*p).opcode),reg);
        };
    }break;
    case 58:;
    {
        return cc_blockmcl_dx_scale(p,a,b,reg);
    }break;
    case 59:;
    {
        return cc_blockmcl_dx_neg(a,reg);
    }break;
    case 61:;
    {
        return cc_blockmcl_dx_inot(a,reg);
    }break;
    case 73:;
    case 74:;
    {
        return cc_blockmcl_dx_preincrx(p,a,reg);
    }break;
    case 75:;
    case 76:;
    {
        return cc_blockmcl_dx_postincrx(p,a,reg);
    }break;
    case 62:;
    {
        return cc_blockmcl_dx_addto((i64)21,a,b,reg);
    }break;
    case 63:;
    {
        return cc_blockmcl_dx_addto((i64)22,a,b,reg);
    }break;
    case 64:;
    {
        return cc_blockmcl_dx_multo(a,b,reg);
    }break;
    case 65:;
    case 66:;
    {
        return cc_blockmcl_dx_divto(p,a,b,reg);
    }break;
    case 67:;
    {
        return cc_blockmcl_dx_addto((i64)28,a,b,reg);
    }break;
    case 68:;
    {
        return cc_blockmcl_dx_addto((i64)29,a,b,reg);
    }break;
    case 69:;
    {
        return cc_blockmcl_dx_addto((i64)30,a,b,reg);
    }break;
    case 70:;
    case 71:;
    {
        return cc_blockmcl_dx_shlto(p,a,b,reg);
    }break;
    case 72:;
    {
        return cc_blockmcl_dx_sqrt(a,reg);
    }break;
    case 56:;
    {
        return cc_blockmcl_dx_addrof(p,a,reg,am);
    }break;
    case 50:;
    {
        return cc_blockmcl_dx_dot(p,a,b,reg,am);
    }break;
    default: {
        cc_support_gerror_s((byte*)"DX-EXPR: can't do tag: %s",cc_tables_jtagnames[((i64)((*p).tag))],(struct cc_decls_unitrec *)(0));
    }
    } /* SW */
;
    if ((tx == 0)) {
        cc_support_gerror_s((byte*)"DX-EXPR: NO RESULT: %s",cc_tables_jtagnames[((i64)((*p).tag))],(struct cc_decls_unitrec *)(0));
    };
    cc_decls_clineno = oldclineno;
    return tx;
}

static void cc_blockmcl_loneexpr(struct cc_decls_unitrec * p) {
    if ((!!(p) && ((i64)((*p).tag) != (i64)2))) {
        cc_blockmcl_loadexpr(p,(i64)1,(i64)0);
    };
}

static void cc_blockmcl_do_assign(struct cc_decls_unitrec * a,struct cc_decls_unitrec * b) {
    struct cc_libmcl_opndrec *  lhs;
    struct cc_libmcl_opndrec *  rhs;
    i64 reg;
    i64 tx;
    if ((cc_decls_ttsize[((i64)((*a).mode))]==(i64)1) || (cc_decls_ttsize[((i64)((*a).mode))]==(i64)2) || (cc_decls_ttsize[((i64)((*a).mode))]==(i64)4) || (cc_decls_ttsize[((i64)((*a).mode))]==(i64)8)) {
    } else {
        cc_blockmcl_do_assignblock(a,b,(i64)0);
        return;
    };
    reg = (i64)1;
    if (!!(cc_libmcl_issimple(a))) {
        if (!!(cc_libmcl_issimple(b))) {
            lhs = cc_blockmcl_getlvalueopnd(a,reg);
            if (!!(cc_libmcl_isintconst(b))) {
                rhs = cc_blockmcl_evalexpr(b,cc_libmcl_getnextreg(lhs,reg));
            } else {
                rhs = cc_blockmcl_loadexpr(b,cc_libmcl_getnextreg(lhs,reg),(i64)1);
            };
        } else {
            rhs = cc_blockmcl_loadexpr(b,reg,(i64)1);
            lhs = cc_blockmcl_getlvalueopnd(a,cc_libmcl_getnextreg(rhs,reg));
        };
    } else {
        if (!!(cc_libmcl_issimple(b))) {
            lhs = cc_blockmcl_getlvalueopnd(a,reg);
            rhs = cc_blockmcl_loadexpr(b,cc_libmcl_getnextreg(lhs,reg),(i64)1);
        } else {
            tx = cc_blockmcl_saveexpr(b,(i64)1);
            lhs = cc_blockmcl_getlvalueopnd(a,(i64)1);
            rhs = cc_blockmcl_restoreexpr(tx,cc_libmcl_getnextreg(lhs,reg));
        };
    };
    cc_blockmcl_storeopnd(lhs,rhs);
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_assign(struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg) {
    struct cc_libmcl_opndrec *  lhs;
    struct cc_libmcl_opndrec *  rhs;
    struct cc_libmcl_opndrec *  rx;
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    i64 tx;
    if ((cc_decls_ttsize[((i64)((*a).mode))]==(i64)1) || (cc_decls_ttsize[((i64)((*a).mode))]==(i64)2) || (cc_decls_ttsize[((i64)((*a).mode))]==(i64)4) || (cc_decls_ttsize[((i64)((*a).mode))]==(i64)8)) {
    } else {
        return cc_blockmcl_do_assignblock(a,b,reg);
    };
    if (!!(cc_libmcl_issimple(a))) {
        if (!!(cc_libmcl_issimple(b))) {
            lhs = cc_blockmcl_getlvalueopnd(a,reg);
            rhs = cc_blockmcl_loadexpr(b,cc_libmcl_getnextreg(lhs,reg),(i64)1);
            cc_blockmcl_storeopnd(lhs,rhs);
        } else {
            rhs = cc_blockmcl_loadexpr(b,reg,(i64)1);
            lhs = cc_blockmcl_getlvalueopnd(a,cc_libmcl_getnextreg(rhs,reg));
            cc_blockmcl_storeopnd(lhs,rhs);
        };
    } else {
        if (!!(cc_libmcl_issimple(b))) {
            lhs = cc_blockmcl_getlvalueopnd(a,reg);
            rhs = cc_blockmcl_loadexpr(b,cc_libmcl_getnextreg(lhs,reg),(i64)1);
            cc_blockmcl_storeopnd(lhs,rhs);
        } else {
            tx = cc_blockmcl_saveexpr(b,(i64)1);
            ax = cc_blockmcl_getlvalueopnd(a,(i64)1);
            bx = cc_blockmcl_restoreexpr(tx,cc_libmcl_getnextreg(ax,reg));
            cc_blockmcl_storeopnd(ax,bx);
            rhs = bx;
        };
    };
    if (((i64)((*rhs).mode)==(i64)1)) {
        if (((i64)((u64)((*rhs).reg)) != reg)) {
            rx = cc_libmcl_genreg(reg,(i64)((*rhs).size));
            cc_libmcl_genmc((i64)5,rx,rhs);
            return rx;
        };
    }else if (((i64)((*rhs).mode)==(i64)6)) {
        if (((i64)((u64)((*rhs).reg)) != reg)) {
            rx = cc_libmcl_genxreg(reg,(i64)((*rhs).size));
            cc_libmcl_genmc((i64)10,rx,rhs);
            return rx;
        };
    };
    return rhs;
}

static i64 cc_blockmcl_saveexpr(struct cc_decls_unitrec * a,i64 reg) {
    cc_blockmcl_pushexpr(a,reg);
    return cc_decls_ttsize[((i64)((*a).mode))];
}

static i64 cc_blockmcl_fsaveexpr(struct cc_decls_unitrec * a,i64 reg) {
    cc_blockmcl_fpushexpr(a,reg);
    return cc_decls_ttsize[((i64)((*a).mode))];
}

static struct cc_libmcl_opndrec * cc_blockmcl_restoreexpr(i64 tx,i64 reg) {
    struct cc_libmcl_opndrec *  rx;
    cc_libmcl_genmc((i64)7,(rx = cc_libmcl_genreg(reg,(i64)8)),(struct cc_libmcl_opndrec *)(0));
    rx = cc_libmcl_duplopnd(rx);
    (*rx).size = tx;
    return rx;
}

static struct cc_libmcl_opndrec * cc_blockmcl_frestoreexpr(i64 tx,i64 reg) {
    struct cc_libmcl_opndrec *  rx;
    cc_libmcl_genmc((i64)7,(rx = cc_libmcl_genxreg(reg,tx)),(struct cc_libmcl_opndrec *)(0));
    rx = cc_libmcl_duplopnd(rx);
    (*rx).size = tx;
    return rx;
}

static struct cc_libmcl_opndrec * cc_blockmcl_getlvalueopnd(struct cc_decls_unitrec * a,i64 reg) {
    return cc_blockmcl_evalexpr(a,reg);
}

static void cc_blockmcl_storeopnd(struct cc_libmcl_opndrec * ax,struct cc_libmcl_opndrec * bx) {
    if (((i64)((u64)((*bx).mode)) == (i64)6)) {
        cc_libmcl_genmc((i64)10,ax,bx);
    } else {
        if (((i64)((*ax).size)==(i64)1) || ((i64)((*ax).size)==(i64)2) || ((i64)((*ax).size)==(i64)4)) {
            bx = cc_libmcl_changeopndsize(bx,(i64)((*ax).size));
        };
        cc_libmcl_genmc((i64)5,ax,bx);
    };
}

static void cc_blockmcl_pushexpr(struct cc_decls_unitrec * a,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    if (!!(a)) {
        ax = cc_blockmcl_dx_expr(a,reg,(i64)1);
        cc_libmcl_genmc((i64)6,ax,(struct cc_libmcl_opndrec *)(0));
    } else {
        cc_libmcl_genmc((i64)6,cc_libmcl_zero_opnd,(struct cc_libmcl_opndrec *)(0));
    };
}

static void cc_blockmcl_fpushexpr(struct cc_decls_unitrec * a,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    ax = cc_blockmcl_dx_expr(a,reg,(i64)1);
    cc_libmcl_genmc((i64)6,ax,(struct cc_libmcl_opndrec *)(0));
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_const(struct cc_decls_unitrec * p,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    i64 t;
    if ((((t = cc_decls_ttbasetype[((i64)((*p).mode))]) >= (i64)2) && (t <= (i64)10))) {
        return cc_libmcl_genint((*p).value,cc_decls_ttsize[((i64)((*p).mode))]);
    } else if (((t >= (i64)11) && (t <= (i64)13))) {
        ax = cc_libmcl_genreal((*p).xvalue,cc_decls_ttsize[((i64)((*p).mode))]);
        return ax;
    } else if ((t == (i64)16)) {
        if (!!((u64)((*p).isstrconst))) {
            return cc_libmcl_genstrimm((*p).svalue,(i64)((*p).slength));
        } else if (!!((u64)((*p).iswstrconst))) {
            return cc_libmcl_genwstrimm((*p).wsvalue,(i64)((*p).wslength));
        };
        return cc_libmcl_genint((*p).value,(i64)8);
    };
    cc_support_gerror_s((byte*)"dxconst %s",cc_lib_strmode((i64)((*p).mode),(i64)1),(struct cc_decls_unitrec *)(0));
    return ax;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_constant(struct cc_decls_strec * d,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    i64 t;
    if ((((t = cc_decls_ttbasetype[((i64)((*d).mode))]) >= (i64)2) && (t <= (i64)10))) {
        return cc_libmcl_genint((*(*d).code).value,cc_decls_ttsize[((i64)((*d).mode))]);
    } else if (((t >= (i64)11) && (t <= (i64)13))) {
        ax = cc_libmcl_genreal((*(*d).code).xvalue,cc_decls_ttsize[((i64)((*d).mode))]);
        return ax;
    };
    cc_support_gerror_s((byte*)"dxconstant %s",cc_lib_strmode((i64)((*d).mode),(i64)1),(struct cc_decls_unitrec *)(0));
    return ax;
}

static void cc_blockmcl_do_labeldef(struct cc_decls_strec * d) {
    cc_libmcl_genmc((i64)3,cc_libmcl_genlabel((i64)((*d).index),(i64)0),cc_libmcl_genmemaddr_d(d));
}

static void cc_blockmcl_do_goto(struct cc_decls_strec * d) {
    if (((i64)((*d).index) == (i64)0)) {
        cc_support_gerror_s((byte*)"Label not defined: %s",(*d).name,(struct cc_decls_unitrec *)(0));
    };
    cc_libmcl_genmc((i64)18,cc_libmcl_genlabel((i64)((*d).index),(i64)0),(struct cc_libmcl_opndrec *)(0));
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_add(struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    i64 tx;
    if ((cc_libmcl_gettypecat(a) == (i64)82)) {
        return cc_blockmcl_dx_fadd((i64)21,a,b,reg);
    };
    if (!!(cc_libmcl_issimple(b))) {
        /*simpleadd:*/
L850 :;
;
        ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
        bx = cc_blockmcl_evalexpr(b,cc_libmcl_getnextreg(ax,reg));
    } else if (!!(cc_libmcl_issimple(a))) {
        ax = cc_blockmcl_loadexpr(b,reg,(i64)0);
        bx = cc_blockmcl_evalexpr(a,cc_libmcl_getnextreg(ax,reg));
    } else {
        tx = cc_blockmcl_saveexpr(a,reg);
        ax = cc_blockmcl_loadexpr(b,reg,(i64)0);
        bx = cc_blockmcl_restoreexpr(tx,cc_libmcl_getnextreg(ax,reg));
    };
    cc_libmcl_genmc((i64)21,ax,bx);
    return ax;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_fadd(i64 opc,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    i64 tx;
    if (!!(cc_libmcl_issimple(b))) {
        ax = cc_blockmcl_floadexpr(a,reg);
        if (((((opc == (i64)23) && ((i64)((*a).tag) == (i64)3)) && ((i64)((*b).tag) == (i64)3)) && ((*a).def == (*b).def))) {
            bx = ax;
        } else {
            bx = cc_blockmcl_fevalexpr(b,cc_libmcl_getnextreg(ax,reg));
        };
    } else if ((!!(cc_libmcl_issimple(a)) && ((opc == (i64)21) || (opc == (i64)23)))) {
        ax = cc_blockmcl_floadexpr(b,reg);
        bx = cc_blockmcl_fevalexpr(a,cc_libmcl_getnextreg(ax,reg));
    } else {
        tx = cc_blockmcl_fsaveexpr(b,reg);
        ax = cc_blockmcl_floadexpr(a,reg);
        bx = cc_blockmcl_frestoreexpr(tx,cc_libmcl_getnextreg(ax,reg));
    };
    if ((opc==(i64)21)) {
        cc_libmcl_genmc((i64)44,ax,bx);
    }else if ((opc==(i64)22)) {
        cc_libmcl_genmc((i64)45,ax,bx);
    }else if ((opc==(i64)23)) {
        cc_libmcl_genmc((i64)46,ax,bx);
    }else if ((opc==(i64)24)) {
        cc_libmcl_genmc((i64)47,ax,bx);
    };
    return ax;
}

static struct cc_libmcl_opndrec * cc_blockmcl_loadexpr(struct cc_decls_unitrec * a,i64 reg,i64 isassign) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  rx;
    ax = cc_blockmcl_dx_expr(a,reg,(i64)1);
    if (((i64)((*ax).size)==(i64)1) || ((i64)((*ax).size)==(i64)2) || ((i64)((*ax).size)==(i64)4) || ((i64)((*ax).size)==(i64)8)) {
    } else {
        if (((i64)((*ax).mode)==(i64)4)) {
            if (((((*ax).def == 0) && ((i64)((u64)((*ax).regix)) == (i64)0)) && ((*ax).value == (i64)0))) {
                return cc_libmcl_genreg((i64)((*ax).reg),(i64)8);
            };
            rx = cc_libmcl_genreg((reg + cc_libmcl_getaregs(ax)),(i64)8);
            cc_libmcl_genmc((i64)8,rx,ax);
            return rx;
        }else if (((i64)((*ax).mode)==(i64)1)) {
            return ax;
        }else if (((i64)((*ax).mode)==(i64)2)) {
        } else {
            cc_support_gerror((byte*)"loadexpr block not mem/reg",(struct cc_decls_unitrec *)(0));
        };
    };
    if (((i64)((*ax).mode)==(i64)1)) {
        if (((i64)((u64)((*ax).reg)) == reg)) {
            return ax;
        };
        rx = cc_libmcl_genreg(reg,(i64)((*ax).size));
        cc_libmcl_genmc((i64)5,rx,ax);
        return rx;
    }else if (((i64)((*ax).mode)==(i64)6)) {
        if ((!!(isassign) && ((i64)((u64)((*ax).reg)) == reg))) {
            return ax;
        };
        rx = cc_libmcl_genreg(reg,(i64)((*ax).size));
        cc_libmcl_genmc((i64)10,rx,ax);
        return rx;
    };
    rx = cc_libmcl_genreg(reg,(i64)((*ax).size));
    cc_libmcl_genmc((i64)5,rx,ax);
    return rx;
}

static struct cc_libmcl_opndrec * cc_blockmcl_evalexpr(struct cc_decls_unitrec * p,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  rx;
    ax = cc_blockmcl_dx_expr(p,reg,(i64)1);
    if (((i64)((u64)((*ax).mode)) == (i64)6)) {
        rx = cc_libmcl_genreg((i64)((*ax).reg),(i64)((*ax).size));
        cc_libmcl_genmc((i64)10,rx,ax);
        return rx;
    };
    return ax;
}

static struct cc_libmcl_opndrec * cc_blockmcl_evaladdr(struct cc_decls_unitrec * p,i64 reg) {
    return cc_blockmcl_dx_expr(p,reg,(i64)0);
}

static struct cc_libmcl_opndrec * cc_blockmcl_evalptr(struct cc_decls_unitrec * p,i64 reg) {
    return cc_blockmcl_dx_expr(p,reg,(i64)2);
}

static struct cc_libmcl_opndrec * cc_blockmcl_floadexpr(struct cc_decls_unitrec * a,i64 xreg) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  rx;
    ax = cc_blockmcl_dx_expr(a,xreg,(i64)1);
    rx = cc_libmcl_genxreg(xreg,cc_libmcl_getopndsize_u(a));
    if (((i64)((*ax).mode)==(i64)6)) {
        if (((i64)((u64)((*ax).reg)) == xreg)) {
            return ax;
        };
        cc_libmcl_genmc((i64)10,rx,ax);
        return rx;
    }else if (((i64)((*ax).mode)==(i64)1)) {
        rx = cc_libmcl_genxreg((i64)((*ax).reg),(i64)((*ax).size));
        cc_libmcl_genmc((i64)10,rx,ax);
        return rx;
    };
    cc_libmcl_genmc((i64)10,rx,ax);
    return rx;
}

static struct cc_libmcl_opndrec * cc_blockmcl_fevalexpr(struct cc_decls_unitrec * p,i64 xreg) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  rx;
    ax = cc_blockmcl_dx_expr(p,xreg,(i64)1);
    if (((i64)((u64)((*ax).mode)) == (i64)1)) {
        rx = cc_libmcl_genxreg(xreg,cc_libmcl_getopndsize_u(p));
        cc_libmcl_genmc((i64)10,rx,ax);
        return rx;
    };
    return ax;
}

static void cc_blockmcl_do_if(struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,struct cc_decls_unitrec * c) {
    i64 lab1;
    i64 lab2;
    lab1 = cc_libmcl_createfwdlabel();
    cc_blockmcl_genjumpcond((i64)0,a,lab1,(i64)1);
    cc_blockmcl_do_stmt(b);
    if (!!(c)) {
        lab2 = cc_libmcl_createfwdlabel();
        cc_libmcl_genjumpl(lab2);
        cc_libmcl_definefwdlabel(lab1);
        cc_blockmcl_do_stmt(c);
        cc_libmcl_definefwdlabel(lab2);
    } else {
        cc_libmcl_definefwdlabel(lab1);
    };
}

static void cc_blockmcl_genjumpcond(i64 opc,struct cc_decls_unitrec * p,i64 lab,i64 reg) {
    struct cc_decls_unitrec *  q;
    struct cc_decls_unitrec *  r;
    i64 lab2;
    struct cc_libmcl_opndrec *  ax;
    q = (*p).a;
    r = (*p).b;
    switch ((int)((*p).tag)) {
    case 25:;
    {
        if ((opc==(i64)0)) {
            cc_blockmcl_genjumpcond((i64)0,q,lab,reg);
            cc_blockmcl_genjumpcond((i64)0,r,lab,reg);
        }else if ((opc==(i64)1)) {
            lab2 = cc_libmcl_createfwdlabel();
            cc_blockmcl_genjumpcond((i64)0,q,lab2,reg);
            cc_blockmcl_genjumpcond((i64)1,r,lab,reg);
            cc_libmcl_definefwdlabel(lab2);
        };
    }break;
    case 26:;
    {
        if ((opc==(i64)0)) {
            lab2 = cc_libmcl_createfwdlabel();
            cc_blockmcl_genjumpcond((i64)1,q,lab2,reg);
            cc_blockmcl_genjumpcond((i64)0,r,lab,reg);
            cc_libmcl_definefwdlabel(lab2);
        }else if ((opc==(i64)1)) {
            cc_blockmcl_genjumpcond((i64)1,q,lab,reg);
            cc_blockmcl_genjumpcond((i64)1,r,lab,reg);
        };
    }break;
    case 27:;
    {
        if ((opc==(i64)0)) {
            cc_blockmcl_genjumpcond((i64)1,q,lab,reg);
        }else if ((opc==(i64)1)) {
            cc_blockmcl_genjumpcond((i64)0,q,lab,reg);
        };
    }break;
    case 28:;
    {
        cc_blockmcl_genjumpcond(opc,q,lab,reg);
    }break;
    case 34:;
    case 35:;
    case 36:;
    case 37:;
    case 39:;
    case 38:;
    {
        cc_blockmcl_gcomparejump(opc,p,q,r,lab,reg);
    }break;
    case 30:;
    {
        L851 :;
        while ((!!(q) && !!((r = (*q).nextunit)))) {
            cc_blockmcl_dx_expr(q,reg,(i64)1);
            q = r;
L852 :;
        }L853 :;
        ;
        cc_blockmcl_genjumpcond(opc,q,lab,reg);
    }break;
    default: {
        if (((i64)((*p).tag)==(i64)73)) {
            cc_blockmcl_do_preincr((*p).a,(i64)21,(i64)38);
        }else if (((i64)((*p).tag)==(i64)74)) {
            cc_blockmcl_do_preincr((*p).a,(i64)22,(i64)39);
        } else {
            ax = cc_blockmcl_loadexpr(p,reg,(i64)0);
            cc_libmcl_genmc((i64)32,ax,cc_libmcl_genint((i64)0,(i64)4));
        };
        cc_libmcl_genmc_cond((i64)19,(!!(opc)?(i64)5:(i64)4),cc_libmcl_genlabel(lab,(i64)0),(struct cc_libmcl_opndrec *)(0));
    }
    } /* SW */
;
}

static void cc_blockmcl_gcomparejump(i64 jumpopc,struct cc_decls_unitrec * p,struct cc_decls_unitrec * lhs,struct cc_decls_unitrec * rhs,i64 lab,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    i64 mclcond;
    i64 cond;
    i64 tx;
    cond = (i64)((*p).tag);
    if ((jumpopc == (i64)0)) {
        cond = cc_blockmcl_reversecond(cond);
    };
    mclcond = cc_libmcl_getmclcond(cond,(i64)((*lhs).mode));
    if ((mclcond==(i64)16) || (mclcond==(i64)17) || (mclcond==(i64)18) || (mclcond==(i64)19) || (mclcond==(i64)20) || (mclcond==(i64)21)) {
        if (!!(cc_libmcl_issimple(rhs))) {
            ax = cc_blockmcl_floadexpr(lhs,reg);
            bx = cc_blockmcl_fevalexpr(rhs,cc_libmcl_getnextreg(ax,reg));
        } else {
            tx = cc_blockmcl_saveexpr(rhs,reg);
            ax = cc_blockmcl_floadexpr(lhs,reg);
            bx = cc_blockmcl_frestoreexpr(tx,cc_libmcl_getnextreg(ax,reg));
        };
        cc_libmcl_genmc((i64)48,ax,bx);
    } else {
        if (!!(cc_libmcl_issimple(rhs))) {
            ax = cc_blockmcl_loadexpr(lhs,reg,(i64)0);
            bx = cc_blockmcl_evalexpr(rhs,cc_libmcl_getnextreg(ax,reg));
            cc_libmcl_genmc((i64)32,ax,bx);
        } else if (!!(cc_libmcl_issimple(lhs))) {
            mclcond = cc_blockmcl_reversemclcond(mclcond);
            ax = cc_blockmcl_loadexpr(rhs,reg,(i64)0);
            bx = cc_blockmcl_evalexpr(lhs,cc_libmcl_getnextreg(ax,reg));
            cc_libmcl_genmc((i64)32,ax,bx);
        } else {
            cc_blockmcl_pushexpr(rhs,reg);
            ax = cc_blockmcl_loadexpr(lhs,reg,(i64)0);
            bx = cc_libmcl_genreg(cc_libmcl_getnextreg(ax,reg),(i64)((*ax).size));
            cc_libmcl_genmc((i64)7,cc_libmcl_changeopndsize(bx,(i64)8),(struct cc_libmcl_opndrec *)(0));
            cc_libmcl_genmc((i64)32,ax,bx);
        };
    };
    cc_libmcl_genmc_cond((i64)19,mclcond,cc_libmcl_genlabel(lab,(i64)0),(struct cc_libmcl_opndrec *)(0));
}

static i64 cc_blockmcl_reversecond(i64 op) {
    if ((op==(i64)34)) {
        return (i64)35;
    }else if ((op==(i64)35)) {
        return (i64)34;
    }else if ((op==(i64)36)) {
        return (i64)39;
    }else if ((op==(i64)37)) {
        return (i64)38;
    }else if ((op==(i64)39)) {
        return (i64)36;
    }else if ((op==(i64)38)) {
        return (i64)37;
    };
    return (i64)0;
}

static void cc_blockmcl_do_preincr(struct cc_decls_unitrec * a,i64 addop,i64 incrop) {
    struct cc_libmcl_opndrec *  ptropnd;
    i64 size;
    ptropnd = cc_blockmcl_getlvalueopnd(a,(i64)1);
    if (((cc_decls_ttbasetype[((i64)((*a).mode))] == (i64)16) && (cc_decls_ttsize[(cc_decls_tttarget[((i64)((*a).mode))])] != (i64)1))) {
        size = cc_decls_ttsize[(cc_decls_tttarget[((i64)((*a).mode))])];
        cc_libmcl_genmc(addop,ptropnd,cc_libmcl_genint(size,(i64)4));
    } else {
        cc_libmcl_genmc(incrop,ptropnd,(struct cc_libmcl_opndrec *)(0));
    };
}

static i64 cc_blockmcl_reversemclcond(i64 cond) {
    switch ((int)cond) {
    case 12:;
    {
        cond = (i64)15;
    }break;
    case 14:;
    {
        cond = (i64)13;
    }break;
    case 13:;
    {
        cond = (i64)14;
    }break;
    case 15:;
    {
        cond = (i64)12;
    }break;
    case 2:;
    {
        cond = (i64)7;
    }break;
    case 6:;
    {
        cond = (i64)3;
    }break;
    case 3:;
    {
        cond = (i64)6;
    }break;
    case 7:;
    {
        cond = (i64)2;
    }break;
    case 16:;
    {
        cond = (i64)19;
    }break;
    case 18:;
    {
        cond = (i64)17;
    }break;
    case 17:;
    {
        cond = (i64)18;
    }break;
    case 19:;
    {
        cond = (i64)16;
    }break;
    default: {
    }
    } /* SW */
;
    return cond;
}

static void cc_blockmcl_do_while(struct cc_decls_unitrec * pcond,struct cc_decls_unitrec * pbody) {
    i64 lab_b;
    i64 lab_c;
    i64 lab_d;
    if ((((i64)((*pcond).tag) == (i64)1) && !!((*pcond).value))) {
        cc_blockmcl_do_while1(pbody);
        return;
    };
    lab_c = cc_libmcl_createfwdlabel();
    lab_d = cc_libmcl_createfwdlabel();
    cc_blockmcl_stacklooplabels(lab_c,lab_d);
    cc_libmcl_genjumpl(lab_c);
    lab_b = cc_libmcl_definelabel();
    cc_blockmcl_do_stmt(pbody);
    cc_libmcl_definefwdlabel(lab_c);
    cc_blockmcl_genjumpcond((i64)1,pcond,lab_b,(i64)1);
    cc_libmcl_definefwdlabel(lab_d);
    --cc_blockmcl_loopindex;
}

static void cc_blockmcl_do_while1(struct cc_decls_unitrec * pbody) {
    i64 lab_b;
    i64 lab_c;
    i64 lab_d;
    lab_c = cc_libmcl_createfwdlabel();
    lab_d = cc_libmcl_createfwdlabel();
    cc_blockmcl_stacklooplabels(lab_c,lab_d);
    lab_b = cc_libmcl_definelabel();
    cc_blockmcl_do_stmt(pbody);
    cc_libmcl_definefwdlabel(lab_c);
    cc_libmcl_genjumpl(lab_b);
    cc_libmcl_definefwdlabel(lab_d);
    --cc_blockmcl_loopindex;
}

static void cc_blockmcl_stacklooplabels(i64 a,i64 b) {
    cc_blockmcl_continuestack[(++cc_blockmcl_loopindex)-1] = a;
    cc_blockmcl_breakstack[(cc_blockmcl_loopindex)-1] = b;
}

static void cc_blockmcl_do_dowhile(struct cc_decls_unitrec * pbody,struct cc_decls_unitrec * pcond) {
    i64 lab_b;
    i64 lab_c;
    i64 lab_d;
    lab_c = cc_libmcl_createfwdlabel();
    lab_d = cc_libmcl_createfwdlabel();
    cc_blockmcl_stacklooplabels(lab_c,lab_d);
    lab_b = cc_libmcl_definelabel();
    cc_blockmcl_do_stmt(pbody);
    cc_libmcl_definefwdlabel(lab_c);
    cc_blockmcl_genjumpcond((i64)1,pcond,lab_b,(i64)1);
    cc_libmcl_definefwdlabel(lab_d);
    --cc_blockmcl_loopindex;
}

static void cc_blockmcl_do_for(struct cc_decls_unitrec * pinit,struct cc_decls_unitrec * pbody) {
    struct cc_decls_unitrec *  pcond;
    struct cc_decls_unitrec *  pincr;
    i64 lab_b;
    i64 lab_c;
    i64 lab_d;
    i64 lab_cond;
    pcond = (*pinit).nextunit;
    pincr = (*pcond).nextunit;
    lab_c = cc_libmcl_createfwdlabel();
    lab_d = cc_libmcl_createfwdlabel();
    lab_cond = cc_libmcl_createfwdlabel();
    if (((i64)((*pinit).tag) != (i64)2)) {
        cc_blockmcl_do_stmt(pinit);
    };
    cc_libmcl_genjumpl(lab_cond);
    cc_blockmcl_stacklooplabels(lab_c,lab_d);
    lab_b = cc_libmcl_definelabel();
    cc_blockmcl_do_stmt(pbody);
    cc_libmcl_definefwdlabel(lab_c);
    cc_blockmcl_do_stmt(pincr);
    cc_libmcl_definefwdlabel(lab_cond);
    if (((i64)((*pcond).tag) != (i64)2)) {
        cc_blockmcl_genjumpcond((i64)1,pcond,lab_b,(i64)1);
    } else {
        cc_libmcl_genjumpl(lab_b);
    };
    cc_libmcl_definefwdlabel(lab_d);
    --cc_blockmcl_loopindex;
}

static i64 cc_blockmcl_pushffparams(struct cc_decls_unitrec * p,i64 variadic) {
    struct cc_libmcl_opndrec *  rx;
    struct cc_libmcl_opndrec *  fx;
    byte iscomplex[4];
    i64 i;
    i64 m;
    i64 n;
    i64 dummypush;
    i64 size;
    i64 popbytes;
    i64 ncomplex;
    struct cc_decls_unitrec *  q;
    struct cc_decls_unitrec *  paramlist[200];
    n = (i64)0;
    L854 :;
    while (!!(p)) {
        if ((n >= (i64)200)) {
            cc_support_gerror((byte*)"TOO MANY PARAMS",(struct cc_decls_unitrec *)(0));
        };
        ++n;
        paramlist[(n)-1] = p;
        p = (*p).nextunit;
L855 :;
    }L856 :;
    ;
    m = (n>(i64)4?n:(i64)4);
    dummypush = (i64)0;
    if (((!!((m & (i64)1)) && !!(cc_libmcl_stackaligned)) || (((m & (i64)1) == (i64)0) && !(!!(cc_libmcl_stackaligned))))) {
        dummypush = (i64)1;
        if ((n > (i64)4)) {
            cc_libmcl_pushstack((i64)8);
        };
        popbytes = ((m + (i64)1) * (i64)8);
    } else {
        popbytes = (m * (i64)8);
    };
    L857 :;
    for (i=n;i>=(i64)5;i-=(i64)1) {
L858 :;
        q = paramlist[(i)-1];
        if ((!!(variadic) && (cc_decls_ttbasetype[((i64)((*q).mode))] == (i64)11))) {
            cc_blockmcl_pushfloatparam(q);
        } else {
            cc_blockmcl_pushexpr(q,(i64)1);
        };
L859 :;
    }L860 :;
    ;
    if ((!!(dummypush) && (n <= (i64)4))) {
        cc_libmcl_pushstack((i64)40);
    } else {
        cc_libmcl_pushstack((i64)32);
    };
    n = (n<(i64)4?n:(i64)4);
    if ((n == (i64)1)) {
        cc_blockmcl_pushoneparam(paramlist[(i)-1],variadic);
        return popbytes;
    };
    ncomplex = (i64)0;
    L861 :;
    for (i=n;i>=(i64)1;i-=(i64)1) {
L862 :;
        q = paramlist[(i)-1];
        if (!!(cc_libmcl_issimplepm(q))) {
            iscomplex[(i)-1] = (u64)((i64)0);
        } else {
            cc_blockmcl_pushexpr(q,(i64)1);
            iscomplex[(i)-1] = (u64)((i64)1);
            ++ncomplex;
        };
L863 :;
    }L864 :;
    ;
    L865 :;
    for (i=(i64)1;i<=n;i+=(i64)1) {
L866 :;
        q = paramlist[(i)-1];
        if ((cc_libmcl_gettypecat(q) != (i64)82)) {
            if (!!((u64)(iscomplex[(i)-1]))) {
                cc_libmcl_genmc((i64)7,(rx = cc_libmcl_genreg((((i64)11 + i) - (i64)1),(i64)8)),(struct cc_libmcl_opndrec *)(0));
            } else {
                rx = cc_blockmcl_loadexpr(q,(((i64)11 + i) - (i64)1),(i64)0);
            };
        } else {
            if ((!!(variadic) && (cc_decls_ttbasetype[((i64)((*q).mode))] == (i64)11))) {
                cc_blockmcl_loadfloatparam(q,(i - (i64)1),(i64)(iscomplex[(i)-1]));
            } else {
                size = cc_decls_ttsize[((i64)((*q).mode))];
                if (!!((u64)(iscomplex[(i)-1]))) {
                    cc_libmcl_genmc((i64)7,(rx = cc_libmcl_genreg((i64)14,(i64)8)),(struct cc_libmcl_opndrec *)(0));
                    cc_libmcl_genmc((i64)10,(fx = cc_libmcl_genxreg((((i64)1 + i) - (i64)1),size)),cc_libmcl_changeopndsize(rx,size));
                } else {
                    fx = cc_blockmcl_floadexpr(q,(((i64)1 + i) - (i64)1));
                };
                if (!!(variadic)) {
                    cc_libmcl_genmc((i64)10,cc_libmcl_genreg((((i64)11 + i) - (i64)1),size),fx);
                };
            };
        };
L867 :;
    }L868 :;
    ;
    return popbytes;
}

static void cc_blockmcl_pushoneparam(struct cc_decls_unitrec * q,i64 variadic) {
    struct cc_libmcl_opndrec *  fx;
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    if ((cc_libmcl_gettypecat(q) != (i64)82)) {
        if (!!(cc_libmcl_issimple(q))) {
            cc_blockmcl_loadexpr(q,(i64)11,(i64)0);
        } else {
            ax = cc_blockmcl_loadexpr(q,(i64)1,(i64)0);
            bx = cc_libmcl_genreg((i64)11,(i64)((*ax).size));
            cc_libmcl_genmc((i64)5,bx,ax);
        };
    } else {
        fx = cc_blockmcl_floadexpr(q,(i64)1);
        if (!!(variadic)) {
            cc_libmcl_genmc((i64)10,cc_libmcl_genreg((i64)11,cc_decls_ttsize[((i64)((*q).mode))]),fx);
        };
    };
}

static void cc_blockmcl_pushfloatparam(struct cc_decls_unitrec * q) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    struct cc_libmcl_opndrec *  fx;
    fx = cc_blockmcl_floadexpr(q,(i64)14);
    cc_libmcl_genmc((i64)53,(ax = cc_libmcl_changeopndsize(fx,(i64)8)),fx);
    cc_libmcl_genmc((i64)10,(bx = cc_libmcl_genreg((i64)14,(i64)8)),ax);
    cc_libmcl_genmc((i64)6,bx,(struct cc_libmcl_opndrec *)(0));
}

static void cc_blockmcl_loadfloatparam(struct cc_decls_unitrec * q,i64 regoffset,i64 iscomplex) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  ax32;
    struct cc_libmcl_opndrec *  fx;
    struct cc_libmcl_opndrec *  fx32;
    fx = cc_libmcl_genxreg(((i64)1 + regoffset),(i64)8);
    fx32 = cc_libmcl_genxreg(((i64)1 + regoffset),(i64)4);
    ax = cc_libmcl_genreg(((i64)11 + regoffset),(i64)8);
    ax32 = cc_libmcl_genreg(((i64)11 + regoffset),(i64)4);
    if (!!(iscomplex)) {
        cc_libmcl_genmc((i64)7,ax,(struct cc_libmcl_opndrec *)(0));
        cc_libmcl_genmc((i64)10,fx32,ax32);
        cc_libmcl_genmc((i64)53,fx,fx32);
        cc_libmcl_genmc((i64)10,ax,fx);
    } else {
        cc_blockmcl_floadexpr(q,((i64)1 + regoffset));
        cc_libmcl_genmc((i64)53,fx,fx32);
        cc_libmcl_genmc((i64)10,ax,fx);
    };
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_call(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg) {
    struct cc_libmcl_opndrec *  result;
    struct cc_libmcl_opndrec *  cx;
    struct cc_libmcl_opndrec *  sx;
    struct cc_decls_paramrec *  pm;
    i64 isfnptr;
    i64 variadic;
    i64 nparams;
    i64 retmode;
    i64 nbytes;
    i64 retsize;
    i64 m;
    i64 nregparams;
    i64 i;
    retmode = (i64)((*p).mode);
    if ((retmode == (i64)1)) {
        retmode = (i64)4;
    };
    if (((i64)((*a).tag)==(i64)53)) {
        m = (i64)((*a).mode);
        L869 :;
        while ((cc_decls_ttbasetype[(m)] == (i64)16)) {
            m = cc_decls_tttarget[(m)];
L870 :;
        }L871 :;
        ;
        pm = cc_decls_ttparams[(m)];
        isfnptr = (i64)1;
    } else {
        pm = (*(*a).def).paramlist;
        isfnptr = (i64)0;
    };
    variadic = ((i64)((*pm).flags) == (i64)3);
    nparams = (i64)((*pm).nparams);
    nbytes = cc_blockmcl_pushffparams(b,variadic);
    retsize = cc_decls_ttsize[(retmode)];
    if ((retsize > (i64)8)) {
        cc_libmcl_doblockcall(retsize);
    };
    if (!(!!(isfnptr))) {
        cc_libmcl_genmc((i64)15,cc_libmcl_genmemaddr_u(a),(struct cc_libmcl_opndrec *)(0));
    } else {
        if (!!(cc_libmcl_issimple(a))) {
            cc_libmcl_genmc((i64)15,cc_libmcl_changeopndsize(cc_blockmcl_loadexpr((*a).a,(i64)1,(i64)0),(i64)8),(struct cc_libmcl_opndrec *)(0));
        } else {
            nregparams = (nparams<(i64)4?nparams:(i64)4);
            sx = cc_libmcl_genireg((i64)16,(i64)8);
            L872 :;
            for (i=(i64)1;i<=nregparams;i+=(i64)1) {
L873 :;
                cc_libmcl_genmc((i64)5,cc_libmcl_applyoffset(sx,((i - (i64)1) * (i64)8),(i64)0),cc_libmcl_genreg((((i64)11 + i) - (i64)1),(i64)8));
L874 :;
            }L875 :;
            ;
            cx = cc_libmcl_changeopndsize(cc_blockmcl_loadexpr((*a).a,(i64)1,(i64)0),(i64)8);
            sx = cc_libmcl_genireg((i64)16,(i64)8);
            L876 :;
            for (i=(i64)1;i<=nregparams;i+=(i64)1) {
L877 :;
                cc_libmcl_genmc((i64)5,cc_libmcl_genreg((((i64)11 + i) - (i64)1),(i64)8),cc_libmcl_applyoffset(sx,((i - (i64)1) * (i64)8),(i64)0));
L878 :;
            }L879 :;
            ;
            cc_libmcl_genmc((i64)15,cx,(struct cc_libmcl_opndrec *)(0));
        };
    };
    cc_libmcl_popstack(nbytes);
    if ((cc_libmcl_gettypecat(p) == (i64)82)) {
        result = cc_libmcl_genxreg(reg,retsize);
    } else if ((retsize <= (i64)8)) {
        result = cc_libmcl_genreg(reg,retsize);
    } else {
        result = cc_libmcl_getblockreg(retsize);
    };
    return result;
}

static void cc_blockmcl_do_return(struct cc_decls_unitrec * a) {
    cc_libmcl_leaveproc((*cc_decls_currproc).name);
    if (!!(a)) {
        if (!!(cc_lib_isrealcc((i64)((*a).mode)))) {
            cc_blockmcl_floadexpr(a,(i64)1);
        } else {
            cc_blockmcl_loadexpr(a,(i64)1,(i64)0);
            if (!!(cc_libmcl_structretoffset)) {
                cc_libmcl_copyretvalue(cc_decls_ttsize[((i64)((*a).mode))]);
            };
        };
    };
    cc_libmcl_genreturn(cc_libmcl_framebytes,cc_libmcl_parambytes);
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_sub(struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    i64 tx;
    i64 doneg;
    if ((cc_libmcl_gettypecat(a) == (i64)82)) {
        return cc_blockmcl_dx_fadd((i64)22,a,b,reg);
    };
    doneg = (i64)0;
    if (!!(cc_libmcl_issimple(b))) {
        /*simplesub:*/
L880 :;
;
        ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
        bx = cc_blockmcl_evalexpr(b,cc_libmcl_getnextreg(ax,reg));
    } else if (!!(cc_libmcl_issimple(a))) {
        ax = cc_blockmcl_loadexpr(b,reg,(i64)0);
        bx = cc_blockmcl_evalexpr(a,cc_libmcl_getnextreg(ax,reg));
        doneg = (i64)1;
    } else {
        tx = cc_blockmcl_saveexpr(b,reg);
        ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
        bx = cc_blockmcl_restoreexpr(tx,cc_libmcl_getnextreg(ax,reg));
    };
    cc_libmcl_genmc((i64)22,ax,bx);
    if (!!(doneg)) {
        cc_libmcl_genmc((i64)36,ax,(struct cc_libmcl_opndrec *)(0));
    };
    return ax;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_mul(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    i64 x;
    i64 n;
    i64 tx;
    if ((cc_libmcl_gettypecat(a)==(i64)82)) {
        return cc_blockmcl_dx_fadd((i64)23,a,b,reg);
    };
    if ((((i64)((*b).tag) == (i64)1) && !!(cc_lib_isintcc((i64)((*b).mode))))) {
        x = (*b).value;
        if (!!((n = cc_libmcl_ispoweroftwo(x)))) {
            (*p).tag = (i64)48;
            (*b).value = n;
            return cc_blockmcl_dx_shl(p,a,b,reg);
        };
    };
    if (!!(cc_libmcl_issimple(b))) {
        ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
        if (((((i64)((*a).tag) == (i64)3) && ((i64)((*b).tag) == (i64)3)) && ((*a).def == (*b).def))) {
            bx = ax;
        } else {
            bx = cc_blockmcl_evalexpr(b,cc_libmcl_getnextreg(ax,reg));
        };
    } else if (!!(cc_libmcl_issimple(a))) {
        ax = cc_blockmcl_loadexpr(b,reg,(i64)0);
        bx = cc_blockmcl_evalexpr(a,cc_libmcl_getnextreg(ax,reg));
    } else {
        tx = cc_blockmcl_saveexpr(b,reg);
        ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
        bx = cc_blockmcl_restoreexpr(tx,cc_libmcl_getnextreg(ax,reg));
    };
    cc_libmcl_genmc((i64)23,ax,bx);
    return ax;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_div(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    i64 opc;
    i64 n;
    i64 tx;
    if ((cc_libmcl_gettypecat(a)==(i64)82)) {
        return cc_blockmcl_dx_fadd((i64)24,a,b,reg);
    }else if ((cc_libmcl_gettypecat(a)==(i64)73)) {
        opc = (i64)24;
    } else {
        opc = (i64)25;
    };
    if ((((i64)((*b).tag) == (i64)1) && !!(cc_lib_isintcc((i64)((*b).mode))))) {
        if (!!((n = cc_libmcl_ispoweroftwo((*b).value)))) {
            (*p).tag = (i64)49;
            (*b).value = n;
            return cc_blockmcl_dx_shl(p,a,b,reg);
        };
    };
    if ((reg != (i64)1)) {
        cc_support_gerror((byte*)"DIV REG NOT ZERO",(struct cc_decls_unitrec *)(0));
    };
    if (!!(cc_libmcl_issimple(b))) {
        ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
        if (((i64)((*b).tag) == (i64)1)) {
            bx = cc_blockmcl_loadexpr(b,cc_libmcl_getnextreg(ax,reg),(i64)0);
        } else {
            bx = cc_blockmcl_evalexpr(b,cc_libmcl_getnextreg(ax,reg));
        };
    } else {
        tx = cc_blockmcl_saveexpr(b,reg);
        ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
        bx = cc_blockmcl_restoreexpr(tx,cc_libmcl_getnextreg(ax,reg));
    };
    cc_libmcl_genmc(opc,bx,(struct cc_libmcl_opndrec *)(0));
    return ax;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_shl(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    i64 opc;
    i64 tx;
    if (((i64)((*p).tag) == (i64)48)) {
        opc = (i64)33;
    } else {
        if ((cc_libmcl_gettypecat(p)==(i64)73)) {
            opc = (i64)34;
        } else {
            opc = (i64)35;
        };
    };
    if ((!!(cc_libmcl_issimple(b)) && (reg != (i64)11))) {
        ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
        if (((i64)((*b).tag) == (i64)1)) {
            bx = cc_blockmcl_evalexpr(b,(i64)11);
        } else {
            bx = cc_blockmcl_loadexpr(b,(i64)11,(i64)0);
        };
    } else {
        tx = cc_blockmcl_saveexpr(b,reg);
        ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
        bx = cc_blockmcl_restoreexpr(tx,cc_libmcl_getnextreg(ax,reg));
    };
    cc_libmcl_genmc(opc,ax,bx);
    return ax;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_iand(i64 opc,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    i64 tx;
    if (!!(cc_libmcl_issimple(b))) {
        ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
        bx = cc_blockmcl_evalexpr(b,cc_libmcl_getnextreg(ax,reg));
    } else if (!!(cc_libmcl_issimple(a))) {
        ax = cc_blockmcl_loadexpr(b,reg,(i64)0);
        bx = cc_blockmcl_evalexpr(a,cc_libmcl_getnextreg(ax,reg));
    } else {
        tx = cc_blockmcl_saveexpr(b,reg);
        ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
        bx = cc_blockmcl_restoreexpr(tx,cc_libmcl_getnextreg(ax,reg));
    };
    cc_libmcl_genmc(opc,ax,bx);
    return ax;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_preincrx(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,i64 reg) {
    i64 opc;
    i64 size;
    struct cc_libmcl_opndrec *  ptropnd;
    struct cc_libmcl_opndrec *  result;
    ptropnd = cc_blockmcl_getlvalueopnd(a,reg);
    opc = (i64)5;
    result = cc_libmcl_genreg(cc_libmcl_getnextreg(ptropnd,reg),cc_libmcl_getopndsize_u(p));
    if (((i64)((*result).size) > (i64)((*ptropnd).size))) {
        cc_support_gerror((byte*)"PREINCRX WIDENING NEEDED",(struct cc_decls_unitrec *)(0));
    };
    cc_libmcl_genmc(opc,result,ptropnd);
    if (((cc_decls_ttbasetype[((i64)((*a).mode))] == (i64)16) && (cc_decls_ttsize[(cc_decls_tttarget[((i64)((*a).mode))])] != (i64)1))) {
        size = cc_decls_ttsize[(cc_decls_tttarget[((i64)((*a).mode))])];
        if (((i64)((*p).tag) == (i64)73)) {
            opc = (i64)21;
        } else {
            opc = (i64)22;
        };
        cc_libmcl_genmc(opc,result,cc_libmcl_genint(size,(i64)4));
    } else {
        cc_libmcl_genmc((((i64)((*p).tag) == (i64)73)?(i64)38:(i64)39),result,(struct cc_libmcl_opndrec *)(0));
    };
    cc_blockmcl_storeopnd(ptropnd,result);
    return result;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_postincrx(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,i64 reg) {
    i64 opc;
    i64 size;
    struct cc_libmcl_opndrec *  ptropnd;
    struct cc_libmcl_opndrec *  result;
    struct cc_libmcl_opndrec *  rr1;
    result = cc_libmcl_genreg(reg,cc_libmcl_getopndsize_u(p));
    ptropnd = cc_blockmcl_getlvalueopnd(a,(reg + (i64)1));
    opc = (i64)5;
    if (((i64)((*result).size) > (i64)((*ptropnd).size))) {
        cc_support_gerror((byte*)"POSTINCRX WIDENING NEEDED",(struct cc_decls_unitrec *)(0));
    };
    cc_libmcl_genmc(opc,(rr1 = cc_libmcl_genreg((cc_libmcl_getnextreg(ptropnd,reg) + (i64)1),cc_libmcl_getopndsize_u(p))),ptropnd);
    cc_libmcl_genmc((i64)5,result,rr1);
    if (((cc_decls_ttbasetype[((i64)((*a).mode))] == (i64)16) && (cc_decls_ttsize[(cc_decls_tttarget[((i64)((*a).mode))])] != (i64)1))) {
        size = cc_decls_ttsize[(cc_decls_tttarget[((i64)((*a).mode))])];
        if (((i64)((*p).tag) == (i64)75)) {
            opc = (i64)21;
        } else {
            opc = (i64)22;
        };
        cc_libmcl_genmc(opc,rr1,cc_libmcl_genint(size,(i64)4));
    } else {
        cc_libmcl_genmc((((i64)((*p).tag) == (i64)75)?(i64)38:(i64)39),rr1,(struct cc_libmcl_opndrec *)(0));
    };
    cc_blockmcl_storeopnd(ptropnd,rr1);
    return result;
}

static struct cc_libmcl_opndrec * cc_blockmcl_makeindexopnd(struct cc_decls_unitrec * a,struct cc_decls_unitrec * index,i64 scale,i64 size,i64 offset,i64 reg) {
    i64 mulfactor;
    i64 tx;
    i64 reg2;
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  ix;
    struct cc_libmcl_opndrec *  m;
    struct cc_decls_strec *  d;
    if ((!!(index) && ((i64)((*index).tag) == (i64)1))) {
        offset += ((*index).value * scale);
        index = (struct cc_decls_unitrec *)(0);
    };
    if (!!(index)) {
        if ((scale==(i64)1) || (scale==(i64)2) || (scale==(i64)4) || (scale==(i64)8)) {
            mulfactor = (i64)1;
        } else {
            mulfactor = scale;
            scale = (i64)1;
        };
    };
    if (((i64)((*a).tag) == (i64)3)) {
        d = (*a).def;
        if ((((i64)((u64)((*d).nameid)) == (i64)9) && !!(cc_lib_isstructunion((i64)((*d).mode))))) {
            goto L881 ;
;
        };
        if (!!(index)) {
            if ((mulfactor == (i64)1)) {
                ix = cc_blockmcl_loadexpr(index,reg,(i64)0);
                m = cc_libmcl_genindex((i64)0,(i64)((*ix).reg),scale,offset,size,(i64)0,d);
            } else {
                cc_blockmcl_loadexpr(index,reg,(i64)0);
                cc_blockmcl_mulreg(reg,mulfactor);
                m = cc_libmcl_genindex((i64)0,reg,scale,offset,size,(i64)0,d);
            };
        } else {
            m = cc_libmcl_genindex((i64)0,(i64)0,(i64)1,offset,size,(i64)0,d);
        };
    } else {
        /*mx2:*/
L881 :;
;
        if (!!(index)) {
            if (!!(cc_libmcl_issimple(a))) {
                if ((mulfactor == (i64)1)) {
                    ix = cc_blockmcl_loadexpr(index,reg,(i64)0);
                    ax = cc_blockmcl_loadexpr(a,(reg + (i64)1),(i64)0);
                    m = cc_libmcl_genindex((i64)((*ax).reg),(i64)((*ix).reg),scale,offset,size,(i64)0,(struct cc_decls_strec *)(0));
                } else {
                    cc_blockmcl_loadexpr(index,reg,(i64)0);
                    cc_blockmcl_mulreg(reg,mulfactor);
                    cc_blockmcl_loadexpr(a,(reg + (i64)1),(i64)0);
                    m = cc_libmcl_genindex((reg + (i64)1),reg,scale,offset,size,(i64)0,(struct cc_decls_strec *)(0));
                };
            } else if (!!(cc_libmcl_issimple(index))) {
                cc_blockmcl_loadexpr(a,reg,(i64)0);
                cc_blockmcl_loadexpr(index,(reg + (i64)1),(i64)0);
                cc_blockmcl_mulreg((reg + (i64)1),mulfactor);
                m = cc_libmcl_genindex(reg,(reg + (i64)1),scale,offset,size,(i64)0,(struct cc_decls_strec *)(0));
            } else {
                tx = cc_blockmcl_saveexpr(a,reg);
                ix = cc_blockmcl_loadexpr(index,reg,(i64)0);
                cc_blockmcl_mulreg(reg,mulfactor);
                ax = cc_blockmcl_restoreexpr(tx,(reg2 = cc_libmcl_getnextreg(ix,reg)));
                m = cc_libmcl_genindex(reg2,reg,scale,offset,size,(i64)0,(struct cc_decls_strec *)(0));
            };
        } else {
            ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
            m = cc_libmcl_genindex((i64)((*ax).reg),(i64)0,scale,offset,size,(i64)0,(struct cc_decls_strec *)(0));
        };
    };
    return m;
}

static void cc_blockmcl_mulreg(i64 reg,i64 x) {
    i64 n;
    if ((x > (i64)1)) {
        if (!!((n = cc_libmcl_ispoweroftwo(x)))) {
            cc_libmcl_genmc((i64)33,cc_libmcl_genreg(reg,(i64)8),cc_libmcl_genint(n,(i64)4));
        } else {
            cc_libmcl_genmc((i64)23,cc_libmcl_genreg(reg,(i64)8),cc_libmcl_genint(x,(i64)4));
        };
    };
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_ptr(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,i64 reg,i64 am) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    if ((am == (i64)0)) {
        return cc_blockmcl_loadexpr(a,reg,(i64)0);
    };
    if ((cc_decls_ttbasetype[((i64)((*p).mode))] == (i64)17)) {
        cc_support_gerror((byte*)"deref/proc",(struct cc_decls_unitrec *)(0));
    };
    ax = cc_blockmcl_evalptr(a,reg);
    if (((i64)((*a).tag)==(i64)54) || ((i64)((*a).tag)==(i64)55)) {
        if (((i64)((u64)((*ax).mode)) != (i64)1)) {
            ax = cc_libmcl_applysize(ax,cc_decls_ttsize[((i64)((*p).mode))]);
            return ax;
        };
    }else if (((i64)((*a).tag)==(i64)56)) {
        return cc_blockmcl_dx_expr((*a).a,reg,am);
    };
    if (((i64)((u64)((*ax).mode)) != (i64)1)) {
        cc_libmcl_genmc((i64)5,(bx = cc_libmcl_genreg(reg,(i64)8)),ax);
        ax = bx;
    };
    ax = cc_libmcl_makeindirect(ax,cc_decls_ttsize[((i64)((*p).mode))]);
    return ax;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_addptr(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg,i64 am) {
    i64 size;
    i64 scale;
    i64 mulfactor;
    i64 reg1;
    i64 tx;
    i64 offset;
    struct cc_libmcl_opndrec *  m;
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    struct cc_libmcl_opndrec *  rx;
    struct cc_decls_unitrec *  pname;
    size = (scale = cc_decls_ttsize[(cc_decls_tttarget[((i64)((*a).mode))])]);
    if (((i64)((*p).ptrscale) == (i64)0)) {
        scale = (i64)1;
    };
    offset = (i64)0;
    if (((i64)((*b).tag) == (i64)1)) {
        (*b).value *= scale;
        offset = (*b).value;
        scale = (i64)1;
    };
    if ((scale==(i64)2) || (scale==(i64)4) || (scale==(i64)8)) {
        mulfactor = (i64)1;
    } else {
        mulfactor = scale;
        scale = (i64)1;
    };
    reg1 = (reg + (i64)1);
    if (((i64)((*b).tag) == (i64)1)) {
        if (((i64)((*a).tag)==(i64)56)) {
            pname = (*a).a;
            if (((i64)((*pname).tag) != (i64)3)) {
                goto L882 ;
;
            };
            m = cc_libmcl_genindex((i64)0,(i64)0,(i64)1,offset,size,(i64)0,(*pname).def);
        } else {
            /*other:*/
L882 :;
;
            cc_blockmcl_loadexpr(a,reg,(i64)0);
            m = cc_libmcl_genindex(reg,(i64)0,scale,(*b).value,size,(i64)0,(struct cc_decls_strec *)(0));
        };
    } else if ((((i64)((*a).tag) == (i64)56) && ((i64)((*(*a).a).tag) == (i64)3))) {
        pname = (*a).a;
        bx = cc_blockmcl_loadexpr(b,reg,(i64)0);
        cc_blockmcl_mulreg((i64)((*bx).reg),mulfactor);
        bx = cc_libmcl_makeindirect(bx,size);
        (*bx).regix = (u64)((*bx).reg);
        (*bx).reg = (u64)((i64)0);
        (*bx).scale = (u64)(scale);
        (*bx).def = (*pname).def;
        if (!!(cc_libmcl_isframe((*pname).def))) {
            (*bx).reg = (u64)((i64)15);
        };
        m = bx;
    } else if (!!(cc_libmcl_issimple(b))) {
        cc_blockmcl_loadexpr(a,reg,(i64)0);
        cc_blockmcl_loadexpr(b,reg1,(i64)0);
        cc_blockmcl_mulreg(reg1,mulfactor);
        m = cc_libmcl_genindex(reg,reg1,scale,(i64)0,size,(i64)0,(struct cc_decls_strec *)(0));
    } else if (!!(cc_libmcl_issimple(a))) {
        cc_blockmcl_loadexpr(b,reg,(i64)0);
        cc_blockmcl_mulreg(reg,mulfactor);
        cc_blockmcl_loadexpr(a,reg1,(i64)0);
        m = cc_libmcl_genindex(reg1,reg,scale,(i64)0,size,(i64)0,(struct cc_decls_strec *)(0));
    } else {
        /*cxcx:*/
L883 :;
;
        tx = cc_blockmcl_saveexpr(b,reg);
        ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
        bx = cc_blockmcl_restoreexpr(tx,cc_libmcl_getnextreg(ax,reg));
        cc_blockmcl_mulreg((i64)((*bx).reg),mulfactor);
        m = cc_libmcl_genindex(reg,(i64)((*bx).reg),scale,(i64)0,size,(i64)0,(struct cc_decls_strec *)(0));
    };
    if ((am==(i64)1)) {
        cc_libmcl_genmc((i64)8,(rx = cc_libmcl_genreg(reg,(i64)8)),m);
        return rx;
    };
    return m;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_subptr(struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg,i64 am) {
    i64 size;
    i64 scale;
    i64 mulfactor;
    i64 reg1;
    i64 tx;
    i64 offset;
    struct cc_libmcl_opndrec *  m;
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    struct cc_libmcl_opndrec *  rx;
    size = (scale = cc_decls_ttsize[(cc_decls_tttarget[((i64)((*a).mode))])]);
    if ((cc_decls_ttbasetype[((i64)((*b).mode))] == (i64)16)) {
        ax = cc_blockmcl_dx_sub(a,b,reg);
        cc_blockmcl_divreg((i64)((*ax).reg),scale);
        return ax;
    };
    offset = (i64)0;
    if (((i64)((*b).tag) == (i64)1)) {
        (*b).value = ((*b).value * scale);
        offset = -((*b).value);
        scale = (i64)1;
    };
    mulfactor = scale;
    scale = (i64)1;
    reg1 = (reg + (i64)1);
    if ((((i64)((*a).tag) == (i64)56) && ((i64)((*(*a).a).tag) == (i64)3))) {
        a = (*a).a;
    };
    if (((i64)((*b).tag) == (i64)1)) {
        cc_blockmcl_loadexpr(a,reg,(i64)0);
        m = cc_libmcl_genindex(reg,(i64)0,scale,offset,size,(i64)0,(struct cc_decls_strec *)(0));
        if ((am == (i64)2)) {
            return m;
        };
        cc_libmcl_genmc((i64)8,(rx = cc_libmcl_genreg(reg,(i64)8)),m);
        return rx;
    } else if (!!(cc_libmcl_issimple(b))) {
        ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
        bx = cc_blockmcl_loadexpr(b,reg1,(i64)0);
        cc_blockmcl_mulreg(reg1,mulfactor);
    } else if (!!(cc_libmcl_issimple(a))) {
        bx = cc_blockmcl_loadexpr(b,reg,(i64)0);
        cc_blockmcl_mulreg(reg,mulfactor);
        ax = cc_blockmcl_loadexpr(a,reg1,(i64)0);
    } else {
        /*cxcx:*/
L884 :;
;
        tx = cc_blockmcl_saveexpr(b,reg);
        ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
        bx = cc_blockmcl_restoreexpr(tx,cc_libmcl_getnextreg(ax,reg));
        cc_blockmcl_mulreg((i64)((*bx).reg),mulfactor);
    };
    m = cc_libmcl_genindex(reg,(i64)((*bx).reg),scale,(i64)0,size,(i64)0,(struct cc_decls_strec *)(0));
    cc_libmcl_genmc((i64)22,ax,bx);
    return ax;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_convert(struct cc_decls_unitrec * a,i64 t,i64 opc,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  rx;
    i64 ssize;
    i64 tsize;
    ssize = cc_decls_ttsize[((i64)((*a).mode))];
    tsize = cc_decls_ttsize[(t)];
    if ((opc==(i64)7) || (opc==(i64)8) || (opc==(i64)10) || (opc==(i64)9)) {
        ax = cc_blockmcl_fevalexpr(a,reg);
    } else {
        ax = cc_blockmcl_evalexpr(a,reg);
    };
    if ((opc==(i64)1)) {
        /*dosoft:*/
L885 :;
;
        return ax;
    }else if ((opc==(i64)2)) {
        rx = cc_libmcl_genreg(reg,tsize);
        if ((tsize < ssize)) {
            cc_libmcl_genmc((i64)14,rx,ax);
        } else if ((tsize > ssize)) {
            cc_libmcl_genmc((i64)12,rx,ax);
        } else {
            return ax;
        };
    }else if ((opc==(i64)3) || (opc==(i64)4)) {
        if (((i64)((u64)((*ax).mode)) == (i64)2)) {
            (*ax).size = tsize;
            return ax;
        };
        if ((ssize == tsize)) {
            return ax;
        };
        rx = cc_libmcl_genreg(reg,tsize);
        cc_libmcl_genmc(((opc == (i64)3)?(i64)11:(i64)12),rx,ax);
    }else if ((opc==(i64)5) || (opc==(i64)6)) {
        rx = cc_libmcl_genxreg(reg,tsize);
        cc_libmcl_genmc(((opc == (i64)5)?(i64)52:(i64)51),rx,ax);
    }else if ((opc==(i64)7) || (opc==(i64)8)) {
        rx = cc_libmcl_genreg(reg,tsize);
        cc_libmcl_genmc(((opc == (i64)7)?(i64)50:(i64)49),rx,ax);
    }else if ((opc==(i64)10) || (opc==(i64)9)) {
        rx = cc_libmcl_genxreg(reg,tsize);
        cc_libmcl_genmc(((opc == (i64)10)?(i64)54:(i64)53),rx,ax);
    }else if ((opc==(i64)11) || (opc==(i64)12)) {
        rx = cc_libmcl_genreg(reg,tsize);
        cc_libmcl_genmc((i64)14,rx,ax);
    } else {
        cc_support_gerror_s((byte*)"Convert op not implem: %s",cc_tables_convnames[(opc)],(struct cc_decls_unitrec *)(0));
    };
    return rx;
}

static void cc_blockmcl_do_decl(struct cc_decls_strec * d) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_decls_unitrec *  a;
    struct cc_decls_unitrec *  dest;
    byte str[256];
    i64 nbytes;
    a = (*d).code;
    if (((i64)((*a).tag) != (i64)29)) {
        if (((cc_decls_ttbasetype[((i64)((*d).mode))] == (i64)19) && ((i64)((*a).tag) == (i64)1))) {
            goto L886 ;
;
        };
        if ((cc_libmcl_gettypecat(a) == (i64)82)) {
            ax = cc_blockmcl_floadexpr(a,(i64)1);
            cc_libmcl_genmc((i64)10,cc_libmcl_genmem_d(d,(i64)0),ax);
        } else if (((i64)((*a).tag) != (i64)1)) {
            if ((cc_decls_ttsize[((i64)((*a).mode))]==(i64)1) || (cc_decls_ttsize[((i64)((*a).mode))]==(i64)2) || (cc_decls_ttsize[((i64)((*a).mode))]==(i64)4) || (cc_decls_ttsize[((i64)((*a).mode))]==(i64)8)) {
                ax = cc_blockmcl_loadexpr(a,(i64)1,(i64)0);
                cc_libmcl_genmc((i64)5,cc_libmcl_genmem_d(d,(i64)0),ax);
            } else {
                dest = cc_lib_createname(d);
                (*dest).mode = (i64)((*d).mode);
                cc_blockmcl_do_assignblock(dest,a,(i64)1);
            };
        } else {
            cc_libmcl_genmc((i64)5,cc_libmcl_genmem_d(d,(i64)0),cc_blockmcl_evalexpr(a,(i64)1));
        };
        return;
    };
    /*copyl:*/
L886 :;
;
    nbytes = cc_decls_ttsize[((i64)((*d).mode))];
    cc_libmcl_pushstack((i64)32);
    cc_libmcl_genmc((i64)8,cc_libmcl_genreg((i64)11,(i64)8),cc_libmcl_genmem_d(d,(i64)0));
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_setfmt((byte*)"`$#.#.#");
    msysnewc_m_print_str((*cc_decls_currproc).name,NULL);
    msysnewc_m_print_str((*d).name,NULL);
    msysnewc_m_print_u64((*d).blockno,NULL);
    msysnewc_m_print_end();
    ;
    cc_libmcl_genmc((i64)5,cc_libmcl_genreg((i64)12,(i64)8),cc_libmcl_genname(str));
    cc_libmcl_genmc((i64)5,cc_libmcl_genreg((i64)13,(i64)8),cc_libmcl_genint(nbytes,(i64)4));
    cc_libmcl_genmc((i64)15,cc_libmcl_genname((byte*)"memcpy*"),(struct cc_libmcl_opndrec *)(0));
    cc_libmcl_popstack((i64)32);
}

static struct cc_libmcl_opndrec * cc_blockmcl_do_assignblock(struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 regx) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    struct cc_libmcl_opndrec *  rx;
    struct cc_libmcl_opndrec *  rs;
    struct cc_libmcl_opndrec *  rd;
    struct cc_libmcl_opndrec *  rcount;
    struct cc_libmcl_opndrec *  bx2;
    struct cc_libmcl_opndrec *  rsa;
    struct cc_libmcl_opndrec *  rda;
    i64 rev;
    i64 workreg;
    i64 nwords;
    i64 lab;
    i64 regcount;
    i64 regsource;
    i64 regdest;
    i64 offset;
    i64 n;
    i64 oddbytes;
    i64 reg;
    i64 av_1;
    reg = (!!(regx)?regx:(i64)1);
    rev = (i64)0;
    if (!!(cc_libmcl_issimple(b))) {
        ax = cc_blockmcl_getlvalueopnd(a,reg);
        bx = cc_blockmcl_getlvalueopnd(b,cc_libmcl_getnextreg(ax,reg));
    } else if (!!(cc_libmcl_issimple(a))) {
        rev = (i64)1;
        ax = cc_blockmcl_getlvalueopnd(b,reg);
        bx = cc_blockmcl_getlvalueopnd(a,cc_libmcl_getnextreg(ax,reg));
    } else {
        bx = cc_blockmcl_getlvalueopnd(b,reg);
        if (((i64)((u64)((*bx).mode)) != (i64)1)) {
            cc_libmcl_genmc((i64)8,(bx2 = cc_libmcl_genreg(reg,(i64)8)),bx);
        } else {
            bx2 = bx;
        };
        cc_libmcl_genmc((i64)6,bx2,(struct cc_libmcl_opndrec *)(0));
        ax = cc_blockmcl_getlvalueopnd(a,reg);
        cc_libmcl_genmc((i64)7,(bx = cc_libmcl_genreg(cc_libmcl_getnextreg(ax,reg),(i64)8)),(struct cc_libmcl_opndrec *)(0));
        bx = cc_libmcl_genireg((i64)((*bx).reg),(i64)4);
    };
    if (((i64)((u64)((*ax).mode)) == (i64)1)) {
        ax = cc_libmcl_genireg((i64)((*ax).reg),(i64)4);
    };
    if (((i64)((u64)((*bx).mode)) == (i64)1)) {
        bx = cc_libmcl_genireg((i64)((*bx).reg),(i64)4);
    };
    if (!!(rev)) {
        {struct cc_libmcl_opndrec *  temp = ax; ax = bx; bx = temp; };
    };
    if (((cc_libmcl_getnextreg(ax,(i64)0) > (i64)5) || (cc_libmcl_getnextreg(bx,(i64)0) > (i64)5))) {
        cc_support_gerror((byte*)"ASSIGNBLOCK/REG",(struct cc_decls_unitrec *)(0));
    };
    workreg = (i64)5;
    n = cc_decls_ttsize[((i64)((*a).mode))];
    oddbytes = (n % (i64)8);
    n -= oddbytes;
    nwords = (n / (i64)8);
    if ((((i64)1 <= nwords) && (nwords <= (i64)4))) {
        offset = (i64)0;
        ax = cc_libmcl_changeopndsize(ax,(i64)8);
        bx = cc_libmcl_changeopndsize(bx,(i64)8);
        rx = cc_libmcl_genreg(workreg,(i64)8);
        av_1 = nwords;
        while (av_1-- > 0) {
L887 :;
            cc_libmcl_genmc((i64)5,rx,cc_libmcl_applyoffset(bx,offset,(i64)0));
            cc_libmcl_genmc((i64)5,cc_libmcl_applyoffset(ax,offset,(i64)0),rx);
            offset += (i64)8;
L888 :;
        }L889 :;
        ;
        rs = bx;
        rd = ax;
    } else if ((nwords != (i64)0)) {
        lab = ++cc_decls_labelno;
        regcount = (workreg + (i64)1);
        regsource = (regcount + (i64)1);
        regdest = (regsource + (i64)1);
        cc_libmcl_genmc((i64)8,(rsa = cc_libmcl_genreg(regsource,(i64)8)),bx);
        cc_libmcl_genmc((i64)8,(rda = cc_libmcl_genreg(regdest,(i64)8)),ax);
        rs = cc_libmcl_genireg(regsource,(i64)8);
        rd = cc_libmcl_genireg(regdest,(i64)8);
        rx = cc_libmcl_genreg(workreg,(i64)8);
        rcount = cc_libmcl_genreg(regcount,(i64)4);
        cc_libmcl_genmc((i64)5,rcount,cc_libmcl_genint(nwords,(i64)4));
        cc_libmcl_genmc((i64)3,cc_libmcl_genlabel(lab,(i64)0),(struct cc_libmcl_opndrec *)(0));
        cc_libmcl_genmc((i64)5,rx,rs);
        cc_libmcl_genmc((i64)5,rd,rx);
        cc_libmcl_genmc((i64)21,rsa,cc_libmcl_genint((i64)8,(i64)4));
        cc_libmcl_genmc((i64)21,rda,cc_libmcl_genint((i64)8,(i64)4));
        cc_libmcl_genmc((i64)39,rcount,(struct cc_libmcl_opndrec *)(0));
        cc_libmcl_genmc_cond((i64)19,(i64)5,cc_libmcl_genlabel(lab,(i64)0),(struct cc_libmcl_opndrec *)(0));
        offset = (i64)0;
    } else {
        rd = cc_libmcl_changeopndsize(ax,(i64)8);
        rs = cc_libmcl_changeopndsize(bx,(i64)8);
        offset = (i64)0;
    };
    if (!!(oddbytes)) {
        n = oddbytes;
        if ((n >= (i64)4)) {
            rx = cc_libmcl_genreg(workreg,(i64)4);
            cc_libmcl_genmc((i64)5,rx,cc_libmcl_applyoffset(rs,offset,(i64)0));
            cc_libmcl_genmc((i64)5,cc_libmcl_applyoffset(rd,offset,(i64)0),rx);
            n -= (i64)4;
            offset += (i64)4;
        };
        if ((n >= (i64)2)) {
            rx = cc_libmcl_genreg(workreg,(i64)2);
            cc_libmcl_genmc((i64)5,rx,cc_libmcl_applyoffset(rs,offset,(i64)0));
            cc_libmcl_genmc((i64)5,cc_libmcl_applyoffset(rd,offset,(i64)0),rx);
            n -= (i64)2;
            offset += (i64)2;
        };
        if ((n == (i64)1)) {
            rx = cc_libmcl_genreg(workreg,(i64)1);
            cc_libmcl_genmc((i64)5,rx,cc_libmcl_applyoffset(rs,offset,(i64)0));
            cc_libmcl_genmc((i64)5,cc_libmcl_applyoffset(rd,offset,(i64)0),rx);
        };
    };
    if (!!(regx)) {
        return cc_blockmcl_getlvalueopnd(a,reg);
    };
    return cc_libmcl_genint((i64)0,(i64)4);
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_widen(struct cc_decls_unitrec * a,i64 m,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    i64 opc;
    opc = ((cc_libmcl_gettypecat(a) == (i64)73)?(i64)11:(i64)12);
    ax = cc_blockmcl_evalexpr(a,reg);
    if ((cc_decls_ttsize[(m)] == (i64)((*ax).size))) {
        return ax;
    };
    bx = cc_libmcl_genreg(reg,cc_decls_ttsize[(m)]);
    cc_libmcl_genmc(opc,bx,ax);
    return bx;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_neg(struct cc_decls_unitrec * a,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    if ((cc_libmcl_gettypecat(a) == (i64)82)) {
        return cc_blockmcl_dx_fneg(a,reg);
    };
    ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
    cc_libmcl_genmc((i64)36,ax,(struct cc_libmcl_opndrec *)(0));
    return ax;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_fneg(struct cc_decls_unitrec * a,i64 reg) {
    struct cc_libmcl_opndrec *  fx;
    fx = cc_blockmcl_floadexpr(a,reg);
    cc_libmcl_genmc((i64)41,fx,(struct cc_libmcl_opndrec *)(0));
    return fx;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_inot(struct cc_decls_unitrec * a,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
    cc_libmcl_genmc((i64)37,ax,(struct cc_libmcl_opndrec *)(0));
    return ax;
}

static void cc_blockmcl_do_switch(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b) {
    i64 labeltable[500];
    i64 valuetable[500];
    byte flags[500];
    i64 defaultlabel;
    i64 breakswlabel;
    i64 switchlabel;
    i64 lower;
    i64 upper;
    i64 length;
    i64 value;
    i64 ncases;
    byte serialsw;
    i64 i;
    i64 index;
    struct cc_decls_caserec *  pcase;
    struct cc_libmcl_opndrec *  ax;
    i64 (*old_labeltable)[];
    i64 (*old_valuetable)[];
    i64 old_ncases;
    i64 old_lower;
    byte old_defaultseen;
    i64 old_defaultlabel;
    i64 old_breaklabel;
    pcase = (*p).nextcase;
    ncases = (length = (i64)0);
    L890 :;
    while (!!(pcase)) {
        ++ncases;
        if ((ncases > (i64)500)) {
            cc_support_gerror((byte*)"Too many cases on one switch",(struct cc_decls_unitrec *)(0));
        };
        valuetable[(ncases)-1] = (value = (*pcase).value);
        if ((ncases == (i64)1)) {
            lower = (upper = value);
        } else {
            lower = (lower<value?lower:value);
            upper = (upper>value?upper:value);
        };
        pcase = (*pcase).nextcase;
L891 :;
    }L892 :;
    ;
    if (!!((*p).nextcase)) {
        length = ((upper - lower) + (i64)1);
    } else {
        length = (i64)0;
    };
    defaultlabel = cc_libmcl_createfwdlabel();
    breakswlabel = cc_libmcl_createfwdlabel();
    if ((length > (i64)500)) {
        serialsw = (u64)((i64)1);
        ax = cc_blockmcl_loadexpr(a,(i64)1,(i64)0);
        L893 :;
        for (i=(i64)1;i<=ncases;i+=(i64)1) {
L894 :;
            labeltable[(i)-1] = cc_libmcl_createfwdlabel();
            cc_libmcl_genmc((i64)32,ax,cc_libmcl_genint(valuetable[(i)-1],(i64)4));
            cc_libmcl_genmc_cond((i64)19,(i64)4,cc_libmcl_genlabel(labeltable[(i)-1],(i64)0),(struct cc_libmcl_opndrec *)(0));
L895 :;
        }L896 :;
        ;
        cc_libmcl_genmc((i64)18,cc_libmcl_genlabel(defaultlabel,(i64)0),(struct cc_libmcl_opndrec *)(0));
    } else if ((length == (i64)0)) {
        cc_libmcl_genmc((i64)18,cc_libmcl_genlabel(defaultlabel,(i64)0),(struct cc_libmcl_opndrec *)(0));
    } else {
        serialsw = (u64)((i64)0);
        memset((void *)(&flags),(i32)0,(u32)(length));
        L897 :;
        for (i=(i64)1;i<=length;i+=(i64)1) {
L898 :;
            labeltable[(i)-1] = defaultlabel;
L899 :;
        }L900 :;
        ;
        L901 :;
        for (i=(i64)1;i<=ncases;i+=(i64)1) {
L902 :;
            value = valuetable[(i)-1];
            index = ((value - lower) + (i64)1);
            labeltable[(index)-1] = cc_libmcl_createfwdlabel();
            if (!!((u64)(flags[(index)-1]))) {
                cc_support_gerror_s((byte*)"Dupl case value: %d",(byte *)(u32)(value),(struct cc_decls_unitrec *)(0));
            };
            flags[(index)-1] = (u64)((i64)1);
L903 :;
        }L904 :;
        ;
        switchlabel = cc_libmcl_createfwdlabel();
        ax = cc_blockmcl_loadexpr(a,(i64)1,(i64)0);
        cc_libmcl_genmc((i64)22,ax,cc_libmcl_genint(lower,(i64)4));
        cc_libmcl_genmc((i64)32,ax,cc_libmcl_genint(length,(i64)4));
        cc_libmcl_genmc_cond((i64)19,(i64)3,cc_libmcl_genlabel(defaultlabel,(i64)0),(struct cc_libmcl_opndrec *)(0));
        cc_libmcl_genmc((i64)18,cc_libmcl_genindex((i64)0,(i64)1,(i64)8,(i64)0,(i64)0,switchlabel,(struct cc_decls_strec *)(0)),(struct cc_libmcl_opndrec *)(0));
        cc_libmcl_setsegment((i64)73,(i64)8);
        cc_libmcl_definefwdlabel(switchlabel);
        L905 :;
        for (i=(i64)1;i<=length;i+=(i64)1) {
L906 :;
            cc_libmcl_genmc((i64)61,cc_libmcl_genlabel(labeltable[(i)-1],(i64)0),(struct cc_libmcl_opndrec *)(0));
L907 :;
        }L908 :;
        ;
        cc_libmcl_setsegment((i64)67,(i64)1);
    };
    old_labeltable = cc_blockmcl_sw_labeltable;
    old_valuetable = cc_blockmcl_sw_valuetable;
    old_lower = cc_blockmcl_sw_lower;
    old_ncases = cc_blockmcl_sw_ncases;
    old_defaultseen = (u64)(cc_blockmcl_sw_defaultseen);
    old_defaultlabel = cc_blockmcl_sw_defaultlabel;
    old_breaklabel = cc_blockmcl_sw_breaklabel;
    cc_blockmcl_sw_labeltable = &labeltable;
    cc_blockmcl_sw_valuetable = &valuetable;
    cc_blockmcl_sw_lower = lower;
    cc_blockmcl_sw_ncases = (!!((u64)(serialsw))?ncases:(i64)0);
    cc_blockmcl_sw_defaultseen = (u64)((i64)0);
    cc_blockmcl_sw_defaultlabel = defaultlabel;
    cc_blockmcl_sw_breaklabel = breakswlabel;
    cc_blockmcl_do_stmt(b);
    if (!(!!((u64)(cc_blockmcl_sw_defaultseen)))) {
        cc_libmcl_definefwdlabel(defaultlabel);
    };
    cc_libmcl_definefwdlabel(breakswlabel);
    cc_blockmcl_sw_labeltable = old_labeltable;
    cc_blockmcl_sw_valuetable = old_valuetable;
    cc_blockmcl_sw_lower = old_lower;
    cc_blockmcl_sw_ncases = old_ncases;
    cc_blockmcl_sw_defaultseen = (u64)(old_defaultseen);
    cc_blockmcl_sw_defaultlabel = old_defaultlabel;
    cc_blockmcl_sw_breaklabel = old_breaklabel;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_rem(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    i64 tx;
    i64 n;
    i64 opc;
    if ((cc_libmcl_gettypecat(a)==(i64)73)) {
        opc = (i64)26;
    } else {
        opc = (i64)27;
        if ((((i64)((*b).tag) == (i64)1) && !!(cc_lib_isintcc((i64)((*b).mode))))) {
            if (!!((n = cc_libmcl_ispoweroftwo((*b).value)))) {
                (*p).tag = (i64)49;
                (*b).value = ((*b).value - (i64)1);
                return cc_blockmcl_dx_iand((i64)28,a,b,reg);
            };
        };
    };
    if ((reg != (i64)1)) {
        cc_support_gerror((byte*)"REM REG NOT ZERO",(struct cc_decls_unitrec *)(0));
    };
    if (!!(cc_libmcl_issimple(b))) {
        ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
        if (((i64)((*b).tag) == (i64)1)) {
            bx = cc_blockmcl_loadexpr(b,cc_libmcl_getnextreg(ax,reg),(i64)0);
        } else {
            bx = cc_blockmcl_evalexpr(b,cc_libmcl_getnextreg(ax,reg));
        };
    } else {
        tx = cc_blockmcl_saveexpr(b,reg);
        ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
        bx = cc_blockmcl_restoreexpr(tx,cc_libmcl_getnextreg(ax,reg));
    };
    cc_libmcl_genmc(opc,bx,(struct cc_libmcl_opndrec *)(0));
    return ax;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_ifx(struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,struct cc_decls_unitrec * c,i64 reg) {
    struct cc_libmcl_opndrec *  bx;
    struct cc_libmcl_opndrec *  result;
    i64 lab1;
    i64 lab2;
    i64 isreal;
    lab1 = cc_libmcl_createfwdlabel();
    lab2 = cc_libmcl_createfwdlabel();
    isreal = (cc_libmcl_gettypecat(b) == (i64)82);
    cc_blockmcl_genjumpcond((i64)0,a,lab1,reg);
    if (!!(isreal)) {
        result = cc_blockmcl_floadexpr(b,reg);
    } else {
        result = cc_blockmcl_loadexpr(b,reg,(i64)0);
    };
    cc_libmcl_genjumpl(lab2);
    cc_libmcl_definefwdlabel(lab1);
    if (!!(isreal)) {
        bx = cc_blockmcl_floadexpr(c,reg);
    } else {
        bx = cc_blockmcl_loadexpr(c,reg,(i64)0);
    };
    cc_libmcl_definefwdlabel(lab2);
    return result;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_addto(i64 opc,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 regx) {
    struct cc_libmcl_opndrec *  rhs;
    struct cc_libmcl_opndrec *  ptropnd;
    struct cc_libmcl_opndrec *  rr2;
    i64 reg;
    i64 tx;
    if ((cc_libmcl_gettypecat(b) == (i64)82)) {
        return cc_blockmcl_dx_faddto(opc,a,b,regx);
    };
    reg = (!!(regx)?regx:(i64)1);
    if (!!(cc_libmcl_issimple(b))) {
        ptropnd = cc_blockmcl_getlvalueopnd(a,reg);
        if ((((i64)((*b).tag) == (i64)1) && ((i64)((*b).mode) == (i64)4))) {
            rhs = cc_blockmcl_evalexpr(b,cc_libmcl_getnextreg(ptropnd,reg));
        } else {
            rhs = cc_blockmcl_loadexpr(b,cc_libmcl_getnextreg(ptropnd,reg),(i64)0);
        };
        rhs = cc_libmcl_changeopndsize(rhs,(i64)((*ptropnd).size));
        cc_libmcl_genmc(opc,ptropnd,rhs);
    } else if (!!(cc_libmcl_issimple(a))) {
        rhs = cc_blockmcl_loadexpr(b,reg,(i64)0);
        ptropnd = cc_blockmcl_getlvalueopnd(a,cc_libmcl_getnextreg(rhs,reg));
        rhs = cc_libmcl_changeopndsize(rhs,(i64)((*ptropnd).size));
        cc_libmcl_genmc(opc,ptropnd,rhs);
    } else {
        tx = cc_blockmcl_saveexpr(b,reg);
        ptropnd = cc_blockmcl_getlvalueopnd(a,reg);
        rr2 = cc_blockmcl_restoreexpr(tx,cc_libmcl_getnextreg(ptropnd,reg));
        rr2 = cc_libmcl_changeopndsize(rr2,(i64)((*ptropnd).size));
        cc_libmcl_genmc(opc,ptropnd,rr2);
    };
    return ptropnd;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_faddto(i64 opc,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 regx) {
    struct cc_libmcl_opndrec *  work;
    struct cc_libmcl_opndrec *  rhs;
    struct cc_libmcl_opndrec *  ptropnd;
    i64 reg;
    i64 tx;
    reg = (!!(regx)?regx:(i64)1);
    if (!!(cc_libmcl_issimple(b))) {
        ptropnd = cc_blockmcl_getlvalueopnd(a,reg);
        reg = cc_libmcl_getnextreg(ptropnd,reg);
        rhs = cc_blockmcl_fevalexpr(b,reg);
        reg = cc_libmcl_getnextreg(rhs,reg);
    } else if (!!(cc_libmcl_issimple(a))) {
        rhs = cc_blockmcl_fevalexpr(b,reg);
        reg = cc_libmcl_getnextreg(rhs,reg);
        ptropnd = cc_blockmcl_getlvalueopnd(a,reg);
        reg = cc_libmcl_getnextreg(ptropnd,reg);
    } else {
        tx = cc_blockmcl_saveexpr(b,reg);
        ptropnd = cc_blockmcl_getlvalueopnd(a,reg);
        reg = cc_libmcl_getnextreg(ptropnd,reg);
        rhs = cc_blockmcl_frestoreexpr(tx,reg);
        ++reg;
    };
    work = cc_libmcl_genxreg(reg,cc_libmcl_getopndsize_u(b));
    cc_libmcl_genmc((i64)10,work,ptropnd);
    if ((opc==(i64)21)) {
        opc = (i64)44;
    }else if ((opc==(i64)22)) {
        opc = (i64)45;
    }else if ((opc==(i64)23)) {
        opc = (i64)46;
    }else if ((opc==(i64)24)) {
        opc = (i64)47;
    };
    cc_libmcl_genmc(opc,work,rhs);
    cc_libmcl_genmc((i64)10,ptropnd,work);
    return ptropnd;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_eq(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    struct cc_libmcl_opndrec *  rx;
    struct cc_libmcl_opndrec *  rxb;
    i64 mclcond;
    i64 tx;
    mclcond = cc_libmcl_getmclcond((i64)((*p).tag),(i64)((*a).mode));
    if ((mclcond==(i64)20) || (mclcond==(i64)21) || (mclcond==(i64)16) || (mclcond==(i64)17) || (mclcond==(i64)18) || (mclcond==(i64)19)) {
        if (!!(cc_libmcl_issimple(b))) {
            ax = cc_blockmcl_floadexpr(a,reg);
            bx = cc_blockmcl_fevalexpr(b,cc_libmcl_getnextreg(ax,reg));
        } else if (!!(cc_libmcl_issimple(a))) {
            mclcond = cc_blockmcl_reversemclcond(mclcond);
            ax = cc_blockmcl_floadexpr(b,reg);
            bx = cc_blockmcl_fevalexpr(a,cc_libmcl_getnextreg(ax,reg));
        } else {
            tx = cc_blockmcl_saveexpr(b,reg);
            ax = cc_blockmcl_floadexpr(a,reg);
            bx = cc_blockmcl_frestoreexpr(tx,cc_libmcl_getnextreg(ax,reg));
        };
        cc_libmcl_genmc((i64)48,ax,bx);
    } else {
        if (!!(cc_libmcl_issimple(b))) {
            ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
            bx = cc_blockmcl_evalexpr(b,cc_libmcl_getnextreg(ax,reg));
        } else if (!!(cc_libmcl_issimple(a))) {
            mclcond = cc_blockmcl_reversemclcond(mclcond);
            ax = cc_blockmcl_loadexpr(b,reg,(i64)0);
            bx = cc_blockmcl_evalexpr(a,reg);
        } else {
            tx = cc_blockmcl_saveexpr(b,reg);
            ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
            bx = cc_blockmcl_restoreexpr(tx,cc_libmcl_getnextreg(ax,reg));
        };
        cc_libmcl_genmc((i64)32,ax,bx);
    };
    rx = cc_libmcl_genreg(reg,(i64)4);
    rxb = cc_libmcl_genreg(reg,(i64)1);
    cc_libmcl_genmc_cond((i64)40,mclcond,rxb,(struct cc_libmcl_opndrec *)(0));
    cc_libmcl_genmc((i64)12,rx,rxb);
    return rx;
}

static void cc_blockmcl_do_exprlist(struct cc_decls_unitrec * a) {
    L909 :;
    while (!!(a)) {
        cc_blockmcl_do_stmt(a);
        a = (*a).nextunit;
L910 :;
    }L911 :;
    ;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_exprlist(struct cc_decls_unitrec * a,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    L912 :;
    while (!!(a)) {
        ax = cc_blockmcl_dx_expr(a,reg,(i64)1);
        a = (*a).nextunit;
L913 :;
    }L914 :;
    ;
    return ax;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_shlto(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 regx) {
    struct cc_libmcl_opndrec *  rhs;
    struct cc_libmcl_opndrec *  ptropnd;
    struct cc_libmcl_opndrec *  rr2;
    i64 reg;
    i64 tx;
    i64 opc;
    if (((i64)((*p).tag) == (i64)70)) {
        opc = (i64)33;
    } else {
        if ((cc_libmcl_gettypecat(p)==(i64)73)) {
            opc = (i64)34;
        } else {
            opc = (i64)35;
        };
    };
    reg = (!!(regx)?regx:(i64)1);
    if (!!(cc_libmcl_issimple(b))) {
        ptropnd = cc_blockmcl_getlvalueopnd(a,reg);
        if ((((i64)((*b).tag) == (i64)1) && ((i64)((*b).mode) == (i64)4))) {
            rhs = cc_blockmcl_evalexpr(b,cc_libmcl_getnextreg(ptropnd,reg));
        } else {
            rhs = cc_blockmcl_loadexpr(b,cc_libmcl_getnextreg(ptropnd,reg),(i64)0);
        };
        rhs = cc_libmcl_changeopndsize(rhs,(i64)((*ptropnd).size));
        cc_libmcl_genmc(opc,ptropnd,rhs);
    } else if (!!(cc_libmcl_issimple(a))) {
        rhs = cc_blockmcl_loadexpr(b,reg,(i64)0);
        ptropnd = cc_blockmcl_getlvalueopnd(a,cc_libmcl_getnextreg(rhs,reg));
        rhs = cc_libmcl_changeopndsize(rhs,(i64)((*ptropnd).size));
        cc_libmcl_genmc(opc,ptropnd,rhs);
    } else {
        tx = cc_blockmcl_saveexpr(b,reg);
        ptropnd = cc_blockmcl_getlvalueopnd(a,reg);
        rr2 = cc_blockmcl_restoreexpr(tx,cc_libmcl_getnextreg(ptropnd,reg));
        rr2 = cc_libmcl_changeopndsize(rr2,(i64)((*ptropnd).size));
        cc_libmcl_genmc(opc,ptropnd,rr2);
    };
    return ptropnd;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_multo(struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 regx) {
    struct cc_libmcl_opndrec *  work;
    struct cc_libmcl_opndrec *  rhs;
    struct cc_libmcl_opndrec *  ptropnd;
    i64 reg;
    i64 tx;
    i64 sgned;
    if ((cc_libmcl_gettypecat(b)==(i64)82)) {
        return cc_blockmcl_dx_faddto((i64)23,a,b,regx);
    }else if ((cc_libmcl_gettypecat(b)==(i64)73)) {
        sgned = (i64)1;
    } else {
        sgned = (i64)0;
    };
    reg = (!!(regx)?regx:(i64)1);
    work = cc_libmcl_genreg(reg,cc_libmcl_getopndsize_u(b));
    ++reg;
    if (!!(cc_libmcl_issimple(b))) {
        ptropnd = cc_blockmcl_getlvalueopnd(a,reg);
        reg = cc_libmcl_getnextreg(ptropnd,reg);
        rhs = cc_blockmcl_evalexpr(b,reg);
        reg = cc_libmcl_getnextreg(rhs,reg);
    } else if (!!(cc_libmcl_issimple(a))) {
        rhs = cc_blockmcl_evalexpr(b,reg);
        reg = cc_libmcl_getnextreg(rhs,reg);
        ptropnd = cc_blockmcl_getlvalueopnd(a,reg);
        reg = cc_libmcl_getnextreg(ptropnd,reg);
    } else {
        tx = cc_blockmcl_saveexpr(b,reg);
        ptropnd = cc_blockmcl_getlvalueopnd(a,reg);
        reg = cc_libmcl_getnextreg(ptropnd,reg);
        rhs = cc_blockmcl_restoreexpr(tx,reg);
        ++reg;
    };
    cc_blockmcl_loadviaptr(work,ptropnd,sgned);
    cc_libmcl_genmc((i64)23,work,rhs);
    cc_libmcl_genmc((i64)5,ptropnd,cc_libmcl_changeopndsize(work,(i64)((*ptropnd).size)));
    return ptropnd;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_notl(struct cc_decls_unitrec * a,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  rx;
    struct cc_libmcl_opndrec *  rxb;
    if (((i64)((*a).tag) == (i64)27)) {
        return cc_blockmcl_dx_istruel((*a).a,reg);
    };
    ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
    cc_libmcl_genmc((i64)28,ax,ax);
    rx = cc_libmcl_genreg(reg,(i64)4);
    rxb = cc_libmcl_genreg(reg,(i64)1);
    cc_libmcl_genmc_cond((i64)40,(i64)4,rxb,(struct cc_libmcl_opndrec *)(0));
    cc_libmcl_genmc((i64)12,rx,rxb);
    return rx;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_istruel(struct cc_decls_unitrec * a,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  rx;
    struct cc_libmcl_opndrec *  rxb;
    ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
    cc_libmcl_genmc((i64)28,ax,ax);
    rx = cc_libmcl_genreg(reg,(i64)4);
    rxb = cc_libmcl_genreg(reg,(i64)1);
    cc_libmcl_genmc_cond((i64)40,(i64)5,rxb,(struct cc_libmcl_opndrec *)(0));
    cc_libmcl_genmc((i64)12,rx,rxb);
    return rx;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_andorl(struct cc_decls_unitrec * p,i64 reg) {
    i64 lab1;
    i64 lab2;
    struct cc_libmcl_opndrec *  rx;
    lab1 = cc_libmcl_createfwdlabel();
    cc_blockmcl_genjumpcond((i64)0,p,lab1,(i64)1);
    rx = cc_libmcl_genreg(reg,(i64)4);
    lab2 = cc_libmcl_createfwdlabel();
    cc_libmcl_genmc((i64)5,rx,cc_libmcl_genint((i64)1,(i64)4));
    cc_libmcl_genjumpl(lab2);
    cc_libmcl_definefwdlabel(lab1);
    cc_libmcl_genmc((i64)5,rx,cc_libmcl_genint((i64)0,(i64)4));
    cc_libmcl_definefwdlabel(lab2);
    return rx;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_sqrt(struct cc_decls_unitrec * a,i64 reg) {
    struct cc_libmcl_opndrec *  fx;
    fx = cc_blockmcl_floadexpr(a,reg);
    cc_libmcl_genmc((i64)43,fx,fx);
    return fx;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_scale(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    struct cc_libmcl_opndrec *  cx;
    i64 opc;
    i64 scale;
    i64 n;
    ax = cc_blockmcl_loadexpr(a,reg,(i64)0);
    scale = (i64)((*p).scale);
    opc = (i64)23;
    if ((scale < (i64)0)) {
        scale = -(scale);
        opc = (i64)24;
    };
    n = cc_libmcl_ispoweroftwo(scale);
    if ((n == (i64)0)) {
        bx = cc_libmcl_genint(scale,(i64)4);
        if ((opc == (i64)23)) {
            cc_libmcl_genmc((i64)23,ax,bx);
        } else {
            if (((i64)((u64)((*ax).reg)) != (i64)1)) {
                cc_support_gerror((byte*)"scale/div by non-power-of-two/not r0",(struct cc_decls_unitrec *)(0));
            };
            cc_libmcl_genmc((i64)5,(cx = cc_libmcl_genreg((reg + (i64)1),(i64)((*ax).size))),bx);
            cc_libmcl_genmc((i64)24,cx,(struct cc_libmcl_opndrec *)(0));
        };
    } else {
        bx = cc_libmcl_genint(n,(i64)4);
        if ((opc == (i64)23)) {
            cc_libmcl_genmc((i64)33,ax,bx);
        } else {
            cc_libmcl_genmc((i64)34,ax,bx);
        };
    };
    return ax;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_divto(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 regx) {
    struct cc_libmcl_opndrec *  work;
    struct cc_libmcl_opndrec *  rhs;
    struct cc_libmcl_opndrec *  ptropnd;
    i64 reg;
    i64 tx;
    i64 opc;
    i64 sgned;
    if ((cc_libmcl_gettypecat(b)==(i64)82)) {
        return cc_blockmcl_dx_faddto((i64)24,a,b,regx);
    }else if ((cc_libmcl_gettypecat(b)==(i64)73)) {
        opc = (((i64)((*p).tag) == (i64)65)?(i64)24:(i64)26);
        sgned = (i64)1;
    } else {
        opc = (((i64)((*p).tag) == (i64)65)?(i64)25:(i64)27);
        sgned = (i64)0;
    };
    reg = (!!(regx)?regx:(i64)1);
    if ((reg != (i64)1)) {
        cc_support_gerror((byte*)"DIVTO: not R0",(struct cc_decls_unitrec *)(0));
    };
    work = cc_libmcl_genreg(reg,cc_libmcl_getopndsize_u(b));
    ++reg;
    if (!!(cc_libmcl_issimple(b))) {
        ptropnd = cc_blockmcl_getlvalueopnd(a,reg);
        reg = cc_libmcl_getnextreg(ptropnd,reg);
        rhs = cc_blockmcl_evalexpr(b,reg);
        reg = cc_libmcl_getnextreg(rhs,reg);
    } else if (!!(cc_libmcl_issimple(a))) {
        rhs = cc_blockmcl_evalexpr(b,reg);
        reg = cc_libmcl_getnextreg(rhs,reg);
        ptropnd = cc_blockmcl_getlvalueopnd(a,reg);
        reg = cc_libmcl_getnextreg(ptropnd,reg);
    } else {
        tx = cc_blockmcl_saveexpr(b,reg);
        ptropnd = cc_blockmcl_getlvalueopnd(a,reg);
        reg = cc_libmcl_getnextreg(ptropnd,reg);
        rhs = cc_blockmcl_restoreexpr(tx,reg);
        ++reg;
    };
    cc_blockmcl_loadviaptr(work,ptropnd,sgned);
    cc_libmcl_genmc(opc,rhs,(struct cc_libmcl_opndrec *)(0));
    cc_libmcl_genmc((i64)5,ptropnd,cc_libmcl_changeopndsize(work,(i64)((*ptropnd).size)));
    return ptropnd;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_name(struct cc_decls_unitrec * p,i64 reg,i64 am) {
    struct cc_libmcl_opndrec *  ax;
    if (((i64)((*(*p).def).nameid)==(i64)6)) {
        return cc_libmcl_genmemaddr_u(p);
    };
    ax = cc_libmcl_genmem_u(p,(i64)0);
    return ax;
}

static void cc_blockmcl_divreg(i64 reg,i64 x) {
    struct cc_libmcl_opndrec *  rr2;
    i64 n;
    if ((x > (i64)1)) {
        if (!!((n = cc_libmcl_ispoweroftwo(x)))) {
            cc_libmcl_genmc((i64)34,cc_libmcl_genreg(reg,(i64)8),cc_libmcl_genint(n,(i64)4));
        } else {
            if ((reg != (i64)1)) {
                cc_support_gerror((byte*)"DIVREG NOT R0",(struct cc_decls_unitrec *)(0));
            };
            cc_libmcl_genmc((i64)66,(struct cc_libmcl_opndrec *)(0),(struct cc_libmcl_opndrec *)(0));
            cc_libmcl_genmc((i64)5,(rr2 = cc_libmcl_genreg((i64)3,(i64)8)),cc_libmcl_genint(x,(i64)4));
            cc_libmcl_genmc((i64)24,rr2,(struct cc_libmcl_opndrec *)(0));
        };
    };
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_addrof(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,i64 reg,i64 am) {
    struct cc_libmcl_opndrec *  ax;
    struct cc_libmcl_opndrec *  bx;
    if (((i64)((*a).tag) == (i64)3)) {
        ax = cc_libmcl_genmem_u(a,(i64)0);
    } else {
        ax = cc_blockmcl_evaladdr(a,reg);
    };
    if (((am != (i64)0) && ((i64)((u64)((*ax).mode)) != (i64)1))) {
        cc_libmcl_genmc((i64)8,(bx = cc_libmcl_genreg(reg,(i64)8)),ax);
        return bx;
    };
    return ax;
}

static struct cc_libmcl_opndrec * cc_blockmcl_dx_dot(struct cc_decls_unitrec * p,struct cc_decls_unitrec * a,struct cc_decls_unitrec * b,i64 reg,i64 am) {
    struct cc_libmcl_opndrec *  ax;
    ax = cc_blockmcl_evalexpr(a,reg);
    ax = cc_libmcl_applyoffset(ax,(i64)((*p).offset),cc_decls_ttsize[((i64)((*p).mode))]);
    return ax;
}

static void cc_blockmcl_loadviaptr(struct cc_libmcl_opndrec * w,struct cc_libmcl_opndrec * ptropnd,i64 sgned) {
    if (((i64)((*w).size) <= (i64)((*ptropnd).size))) {
        cc_libmcl_genmc((i64)5,w,ptropnd);
        return;
    };
    cc_libmcl_genmc((!!(sgned)?(i64)11:(i64)12),w,ptropnd);
}

i64 cc_genasm_codegen_writeasm(i64 moduleno,byte * outfile) {
    struct cc_decls_strec *  d;
    mlib_gs_init(cc_libmcl_dest);
    cc_genasm_inita64();
    cc_decls_stmodule = cc_decls_moduletable[(moduleno)].stmodule;
    mlib_gs_str(cc_libmcl_dest,(byte*)"!x64 output for ");
    mlib_gs_str(cc_libmcl_dest,(*cc_decls_stmodule).name);
    mlib_gs_strln(cc_libmcl_dest,(byte*)".c");
    cc_genasm_writetoasm(cc_libmcl_modulecode);
    d = (*cc_decls_stmodule).deflist;
    L915 :;
    while (!!(d)) {
        if (((i64)((*d).nameid)==(i64)6)) {
            cc_decls_currproc = d;
            cc_genasm_writetoasm((struct cc_libmcl_mclrec *)((*d).mclcode));
        };
        d = (*d).nextdef;
L916 :;
    }L917 :;
    ;
    cc_genasm_writefabs();
    cc_genasm_genstringtable();
    cc_genasm_genwstringtable();
    cc_genasm_genrealtable();
    cc_genasm_gendinttable();
    cc_genasm_terma64();
    if (!!(cc_decls_fverbose)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"Writing",NULL);
        msysnewc_m_print_str(outfile,NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((byte*)":",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    if (!!(cc_decls_fastasm)) {
    } else {
        mlib_writefile(outfile,(byte *)((*cc_libmcl_dest).strptr),(i64)((*cc_libmcl_dest).length));
    };
    cc_decls_moduletable[(moduleno)].asmstr = (*cc_libmcl_dest).strptr;
    return (i64)1;
}

void cc_genasm_inita64(void) {
    cc_genasm_initasmline();
    cc_genasm_stringtable = (byte * (*)[])(mlib_pcm_alloc((i64)4096));
    cc_genasm_stringlentable = (i64 (*)[])(mlib_pcm_alloc((i64)8192));
    cc_genasm_realtable = (double (*)[])(mlib_pcm_alloc((i64)128));
    cc_genasm_dinttable = (i64 (*)[])(mlib_pcm_alloc((i64)128));
    cc_genasm_stringtablesize = (i64)1024;
    cc_genasm_realtablesize = (i64)16;
    cc_genasm_dinttablesize = (i64)16;
}

void cc_genasm_terma64(void) {
}

static void cc_genasm_writetoasm(struct cc_libmcl_mclrec * m) {
    L918 :;
    while (!!(m)) {
        cc_genasm_mcltoa64(m);
        m = (*m).nextmcl;
L919 :;
    }L920 :;
    ;
}

void cc_genasm_mcltoa64(struct cc_libmcl_mclrec * m) {
    i64 opcode;
    i64 cond;
    struct cc_libmcl_opndrec *  a;
    struct cc_libmcl_opndrec *  b;
    cc_genasm_currmcl = m;
    opcode = (i64)((*m).opcode);
    cond = (i64)((*m).cond);
    a = (*m).a;
    b = (*m).b;
    switch ((int)opcode) {
    case 1:;
    {
        cc_genasm_do_comment(a,b);
    }break;
    case 2:;
    {
        cc_genasm_do_blank(a,b);
    }break;
    case 68:;
    {
        cc_genasm_do_end(a,b);
    }break;
    case 3:;
    {
        cc_genasm_do_label(a,b);
    }break;
    case 4:;
    {
        cc_genasm_do_labelname(a,b);
    }break;
    case 5:;
    {
        cc_genasm_do_mov(a,b);
    }break;
    case 6:;
    {
        cc_genasm_do_push(a);
    }break;
    case 7:;
    {
        cc_genasm_do_pop(a);
    }break;
    case 8:;
    {
        cc_genasm_do_lea(a,b);
    }break;
    case 9:;
    {
        cc_genasm_do_cmovcc(a,b,cond);
    }break;
    case 10:;
    {
        cc_genasm_do_fmov(a,b);
    }break;
    case 11:;
    {
        cc_genasm_do_changeop((i64)74);
    }break;
    case 12:;
    {
        cc_genasm_do_changeop((i64)73);
    }break;
    case 13:;
    {
        cc_genasm_do_inarrow(a,b);
    }break;
    case 14:;
    {
        cc_genasm_do_unarrow(a,b);
    }break;
    case 15:;
    {
        cc_genasm_do_call(a,b);
    }break;
    case 16:;
    {
        cc_genasm_do_ret(a,b);
    }break;
    case 17:;
    {
        cc_genasm_do_retn(a,b);
    }break;
    case 18:;
    {
        cc_genasm_do_jmp(a,b);
    }break;
    case 19:;
    {
        cc_genasm_do_jmpcc(a,b,cond);
    }break;
    case 20:;
    {
        cc_genasm_do_exch(a,b);
    }break;
    case 21:;
    {
        cc_genasm_do_add(a,b);
    }break;
    case 22:;
    {
        cc_genasm_do_sub(a,b);
    }break;
    case 23:;
    {
        cc_genasm_do_imul(a,b);
    }break;
    case 24:;
    case 25:;
    {
        cc_genasm_do_idiv(a);
    }break;
    case 26:;
    {
        cc_genasm_do_irem(a);
    }break;
    case 27:;
    {
        cc_genasm_do_urem(a);
    }break;
    case 28:;
    {
        cc_genasm_do_and(a,b);
    }break;
    case 29:;
    {
        cc_genasm_do_or(a,b);
    }break;
    case 30:;
    {
        cc_genasm_do_xor(a,b);
    }break;
    case 31:;
    {
        cc_genasm_do_test(a,b);
    }break;
    case 32:;
    {
        cc_genasm_do_cmp(a,b);
    }break;
    case 33:;
    {
        cc_genasm_do_shl((i64)33,a,b);
    }break;
    case 34:;
    {
        cc_genasm_do_shl((i64)70,a,b);
    }break;
    case 35:;
    {
        cc_genasm_do_shl((i64)71,a,b);
    }break;
    case 36:;
    {
        cc_genasm_do_neg(a,b);
    }break;
    case 37:;
    {
        cc_genasm_do_not(a,b);
    }break;
    case 38:;
    {
        cc_genasm_do_inc(a,b);
    }break;
    case 39:;
    {
        cc_genasm_do_dec(a,b);
    }break;
    case 40:;
    {
        cc_genasm_do_setcc(a,b,cond);
    }break;
    case 41:;
    {
        cc_genasm_do_fneg(a);
    }break;
    case 42:;
    {
        cc_genasm_do_fabs(a);
    }break;
    case 43:;
    {
        cc_genasm_do_changeop((((i64)((*a).size) == (i64)4)?(i64)95:(i64)96));
    }break;
    case 44:;
    {
        if (((i64)((u64)((*b).mode)) == (i64)2)) {
            cc_genasm_convertimm(b,(i64)1);
        };
        cc_genasm_do_changeop((((i64)((*a).size) == (i64)4)?(i64)79:(i64)80));
    }break;
    case 45:;
    {
        if (((i64)((u64)((*b).mode)) == (i64)2)) {
            cc_genasm_convertimm(b,(i64)1);
        };
        cc_genasm_do_changeop((((i64)((*a).size) == (i64)4)?(i64)81:(i64)82));
    }break;
    case 46:;
    {
        if (((i64)((u64)((*b).mode)) == (i64)2)) {
            cc_genasm_convertimm(b,(i64)1);
        };
        cc_genasm_do_changeop((((i64)((*a).size) == (i64)4)?(i64)83:(i64)84));
    }break;
    case 47:;
    {
        if (((i64)((u64)((*b).mode)) == (i64)2)) {
            cc_genasm_convertimm(b,(i64)1);
        };
        cc_genasm_do_changeop((((i64)((*a).size) == (i64)4)?(i64)85:(i64)86));
    }break;
    case 48:;
    {
        if (((i64)((u64)((*b).mode)) == (i64)2)) {
            cc_genasm_convertimm(b,(i64)1);
        };
        cc_genasm_do_changeop((((i64)((*a).size) == (i64)4)?(i64)87:(i64)88));
    }break;
    case 49:;
    {
        cc_genasm_do_ufix(a,b);
    }break;
    case 50:;
    {
        cc_genasm_do_ifix(a,b);
    }break;
    case 51:;
    {
        cc_genasm_do_ufloat(a,b);
    }break;
    case 52:;
    {
        cc_genasm_do_ifloat(a,b);
    }break;
    case 53:;
    {
        cc_genasm_convertimm(b,(i64)0);
        cc_genasm_do_changeop((i64)91);
    }break;
    case 54:;
    {
        cc_genasm_do_changeop((i64)92);
    }break;
    case 55:;
    {
        cc_genasm_do_changeop((((i64)((*a).size) == (i64)4)?(i64)97:(i64)99));
    }break;
    case 56:;
    {
        cc_genasm_do_changeop((((i64)((*a).size) == (i64)4)?(i64)98:(i64)100));
    }break;
    case 58:;
    {
        cc_genasm_do_db(a,b);
    }break;
    case 59:;
    {
        cc_genasm_do_dw(a,b);
    }break;
    case 60:;
    {
        cc_genasm_do_dd(a,b);
    }break;
    case 61:;
    {
        cc_genasm_do_dq(a,b);
    }break;
    case 62:;
    {
        cc_genasm_do_defstr((*a).svalue,(i64)((*a).slength));
    }break;
    case 63:;
    {
        cc_genasm_do_defwstr((*a).wsvalue,(i64)((*a).wslength));
    }break;
    case 64:;
    {
        cc_genasm_do_align(a,b);
    }break;
    case 65:;
    {
        cc_genasm_do_segment(a,b);
    }break;
    case 67:;
    {
        cc_genasm_do_assem(a,b);
    }break;
    case 57:;
    {
        cc_genasm_convmcl();
    }break;
    default: {
        cc_support_gerror_s((byte*)"a64:UNKNOWN MCL OP: %s",cc_libmcl_mclnames[(opcode)-1],(struct cc_decls_unitrec *)(0));
    }
    } /* SW */
;
}

static void cc_genasm_passthru(i64 opc) {
    cc_genasm_strmclx(cc_genasm_currmcl);
    mlib_gs_strn(cc_libmcl_dest,cc_genasm_asmstart,(cc_genasm_asmptr - cc_genasm_asmstart));
}

static void cc_genasm_convmcl(void) {
    cc_genasm_strmclx(cc_genasm_currmcl);
    mlib_gs_strn(cc_libmcl_dest,cc_genasm_asmstart,(cc_genasm_asmptr - cc_genasm_asmstart));
}

static void cc_genasm_do_changeop(i64 opc) {
    (*cc_genasm_currmcl).opcode = (u64)(opc);
    cc_genasm_convmcl();
}

static void cc_genasm_do_comment(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    mlib_gs_str(cc_libmcl_dest,(byte*)"! ");
    mlib_gs_strln(cc_libmcl_dest,(*a).svalue);
}

static void cc_genasm_do_blank(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    mlib_gs_line(cc_libmcl_dest);
}

static void cc_genasm_do_end(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)68);
}

static void cc_genasm_do_label(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)3);
}

static void cc_genasm_do_labelname(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)4);
}

static void cc_genasm_do_mov(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    struct cc_libmcl_mclrec *  m;
    if ((((i64)((u64)((*a).mode)) == (i64)1) && ((i64)((u64)((*b).mode)) == (i64)2))) {
        cc_genasm_convertimm(b,(i64)0);
    } else if ((((i64)((u64)((*a).mode)) == (i64)4) && ((i64)((u64)((*b).mode)) == (i64)2))) {
        if (((i64)((*b).size) == (i64)8)) {
            cc_genasm_convertimm(b,(i64)0);
            m = cc_genasm_currmcl;
            cc_libmcl_initmcdest();
            cc_libmcl_genmc((i64)5,cc_libmcl_genreg((i64)14,(i64)8),b);
            cc_genasm_domclseq(cc_libmcl_mccode);
            cc_genasm_currmcl = m;
            (*m).b = cc_libmcl_genreg((i64)14,(i64)8);
        } else {
            if (((i64)((*a).size) == (i64)8)) {
                cc_genasm_convertimm(b,(i64)-1);
            } else {
                cc_genasm_convertimm(b,(i64)0);
            };
        };
    };
    cc_genasm_convmcl();
}

static void cc_genasm_do_push(struct cc_libmcl_opndrec * a) {
    if (((i64)((*a).mode)==(i64)1)) {
        if (((i64)((*a).size) != (i64)8)) {
            (*a).size = (i64)8;
        };
    }else if (((i64)((*a).mode)==(i64)2)) {
        cc_genasm_convertimm(a,(i64)1);
        if (((i64)((*a).size) != (i64)8)) {
            (*a).size = (i64)8;
        };
    }else if (((i64)((*a).mode)==(i64)4)) {
        if (((i64)((*a).size) != (i64)8)) {
            cc_libmcl_initmcdest();
            if (((i64)((*a).size)==(i64)1) || ((i64)((*a).size)==(i64)2) || ((i64)((*a).size)==(i64)4) || ((i64)((*a).size)==(i64)8)) {
                cc_libmcl_genmc((i64)5,cc_libmcl_genreg((i64)14,(i64)((*a).size)),a);
            } else {
                cc_libmcl_genmc((i64)8,cc_libmcl_genreg((i64)14,(i64)8),a);
            };
            cc_libmcl_genmc((i64)6,cc_libmcl_genreg((i64)14,(i64)8),(struct cc_libmcl_opndrec *)(0));
            cc_genasm_domclseq(cc_libmcl_mccode);
            return;
        };
    }else if (((i64)((*a).mode)==(i64)6)) {
        if (((i64)((*a).size) == (i64)4)) {
            mlib_gs_str(cc_libmcl_dest,(byte*)"\tmovd A13, ");
            mlib_gs_strln(cc_libmcl_dest,cc_genasm_fgetregnamex((i64)((*a).reg)));
        } else {
            mlib_gs_str(cc_libmcl_dest,(byte*)"\tmovq D13, ");
            mlib_gs_strln(cc_libmcl_dest,cc_genasm_fgetregnamex((i64)((*a).reg)));
        };
        mlib_gs_strln(cc_libmcl_dest,(byte*)"\tpush D13");
        return;
    };
    cc_genasm_convmcl();
}

static void cc_genasm_do_pop(struct cc_libmcl_opndrec * a) {
    if (((i64)((*a).mode)==(i64)6)) {
        mlib_gs_strln(cc_libmcl_dest,(byte*)"\tpop D13");
        if (((i64)((*a).size) == (i64)4)) {
            mlib_gs_str(cc_libmcl_dest,(byte*)"\tmovd ");
            mlib_gs_str(cc_libmcl_dest,cc_genasm_fgetregnamex((i64)((*a).reg)));
            mlib_gs_strln(cc_libmcl_dest,(byte*)", A13");
        } else {
            mlib_gs_str(cc_libmcl_dest,(byte*)"\tmovq ");
            mlib_gs_str(cc_libmcl_dest,cc_genasm_fgetregnamex((i64)((*a).reg)));
            mlib_gs_strln(cc_libmcl_dest,(byte*)", D13");
        };
        return;
    };
    cc_genasm_convmcl();
}

static void cc_genasm_do_lea(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)8);
}

static void cc_genasm_do_cmovcc(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b,i64 cond) {
    cc_genasm_passthru((i64)9);
}

static void cc_genasm_do_fmov(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    if (((i64)((u64)((*b).mode)) == (i64)2)) {
        cc_genasm_convertimm(b,(i64)1);
    };
    cc_genasm_do_changeop((((i64)((*a).size) == (i64)4)?(i64)77:(i64)78));
}

static void cc_genasm_do_iwiden(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)11);
}

static void cc_genasm_do_uwiden(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)12);
}

static void cc_genasm_do_inarrow(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)13);
}

static void cc_genasm_do_unarrow(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    i64 asize;
    asize = (i64)((*a).size);
    if ((asize == (i64)4)) {
        (*cc_genasm_currmcl).b = cc_libmcl_changeopndsize(b,(i64)4);
        cc_genasm_do_changeop((i64)5);
    } else {
        if ((((i64)((u64)((*b).mode)) == (i64)1) && ((u64)((*a).reg) == (u64)((*b).reg)))) {
        } else {
            cc_libmcl_initmcdest();
            cc_libmcl_genmc((i64)5,cc_libmcl_changeopndsize(a,(i64)((*b).size)),b);
            cc_genasm_domclseq(cc_libmcl_mccode);
        };
        cc_libmcl_initmcdest();
        if ((asize > (i64)2)) {
            cc_support_gerror((byte*)"unarrow 4->8?",(struct cc_decls_unitrec *)(0));
        };
        cc_libmcl_genmc((i64)28,a,cc_libmcl_genint((asize==1?(i64)255:(asize==2?(i64)65535:(i64)0)),(i64)4));
        cc_genasm_domclseq(cc_libmcl_mccode);
    };
}

static void cc_genasm_do_call(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)15);
}

static void cc_genasm_do_ret(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)16);
}

static void cc_genasm_do_retn(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)17);
}

static void cc_genasm_do_jmp(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)18);
}

static void cc_genasm_do_jmpcc(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b,i64 cond) {
    cc_genasm_passthru((i64)19);
}

static void cc_genasm_do_exch(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)20);
}

static void cc_genasm_do_add(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    if (((i64)((u64)((*b).mode)) == (i64)2)) {
        cc_genasm_convertimm(b,(i64)1);
    };
    cc_genasm_passthru((i64)21);
}

static void cc_genasm_do_sub(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    if (((i64)((u64)((*b).mode)) == (i64)2)) {
        cc_genasm_convertimm(b,(i64)1);
    };
    cc_genasm_passthru((i64)22);
}

static void cc_genasm_do_imul(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    if ((!!(b) && !!((u64)((*b).mode)))) {
        (*cc_genasm_currmcl).opcode = (u64)((i64)69);
    };
    if (((i64)((u64)((*b).mode)) == (i64)2)) {
        cc_genasm_convertimm(b,(i64)1);
    };
    cc_genasm_convmcl();
}

static void cc_genasm_do_idiv(struct cc_libmcl_opndrec * a) {
    struct cc_libmcl_opndrec *  dx;
    struct cc_libmcl_mclrec *  m;
    if (((i64)((u64)((*a).mode)) == (i64)2)) {
        m = cc_genasm_currmcl;
        cc_libmcl_initmcdest();
        cc_libmcl_genmc((i64)5,(dx = cc_libmcl_genreg((i64)14,(i64)((*a).size))),a);
        cc_genasm_domclseq(cc_libmcl_mccode);
        cc_genasm_currmcl = m;
        (*cc_genasm_currmcl).a = dx;
    };
    if (((i64)((u64)((*a).reg)) == (i64)12)) {
        cc_support_gerror((byte*)"asm/div/dividing by edx",(struct cc_decls_unitrec *)(0));
    };
    if (((i64)((u64)((*cc_genasm_currmcl).opcode)) == (i64)24)) {
        mlib_gs_strln(cc_libmcl_dest,(((i64)((*a).size) <= (i64)4)?(byte*)"\tcdq":(byte*)"\tcqo"));
        cc_genasm_convmcl();
    } else {
        mlib_gs_strln(cc_libmcl_dest,(byte*)"\txor rdx,rdx");
        cc_genasm_do_changeop((i64)72);
    };
}

static void cc_genasm_do_irem(struct cc_libmcl_opndrec * a) {
    (*cc_genasm_currmcl).opcode = (u64)((i64)24);
    cc_genasm_do_idiv(a);
    mlib_gs_strln(cc_libmcl_dest,(byte*)"\txchg rax,rdx");
}

static void cc_genasm_do_urem(struct cc_libmcl_opndrec * a) {
    (*cc_genasm_currmcl).opcode = (u64)((i64)25);
    cc_genasm_do_idiv(a);
    mlib_gs_strln(cc_libmcl_dest,(byte*)"\txchg rax,rdx");
}

static void cc_genasm_do_and(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    if (((i64)((u64)((*b).mode)) == (i64)2)) {
        if (((i64)((*a).size) <= (i64)4)) {
            (*b).value = ((*b).value & (i64)4294967295LL);
            cc_genasm_convertimm(b,(i64)0);
        } else {
            cc_genasm_convertimm(b,(i64)1);
        };
    };
    cc_genasm_passthru((i64)28);
}

static void cc_genasm_do_or(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    if (((i64)((u64)((*b).mode)) == (i64)2)) {
        if (((i64)((*a).size) <= (i64)4)) {
            (*b).value = ((*b).value & (i64)4294967295LL);
            cc_genasm_convertimm(b,(i64)0);
        } else {
            cc_genasm_convertimm(b,(i64)1);
        };
    };
    cc_genasm_passthru((i64)29);
}

static void cc_genasm_do_xor(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    if (((i64)((u64)((*b).mode)) == (i64)2)) {
        if (((i64)((*a).size) <= (i64)4)) {
            (*b).value = ((*b).value & (i64)4294967295LL);
            cc_genasm_convertimm(b,(i64)0);
        } else {
            cc_genasm_convertimm(b,(i64)1);
        };
    };
    cc_genasm_passthru((i64)30);
}

static void cc_genasm_do_test(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    if (((i64)((u64)((*b).mode)) == (i64)2)) {
        cc_genasm_convertimm(b,(i64)1);
    };
    cc_genasm_passthru((i64)31);
}

static void cc_genasm_do_cmp(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    if (((i64)((u64)((*b).mode)) == (i64)2)) {
        cc_genasm_convertimm(b,(i64)1);
    };
    cc_genasm_passthru((i64)32);
}

static void cc_genasm_do_shl(i64 opc,struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    i64 exchreg;
    i64 breg;
    (*cc_genasm_currmcl).opcode = (u64)(opc);
    if (((i64)((*b).mode)==(i64)1)) {
        breg = (i64)((*b).reg);
        if ((((i64)((u64)((*a).mode)) == (i64)1) && ((i64)((u64)((*a).reg)) == (i64)11))) {
            mlib_gs_str(cc_libmcl_dest,(byte*)"\txchg D10,");
            mlib_gs_strln(cc_libmcl_dest,cc_genasm_getregnamex(breg,(i64)8));
            (*cc_genasm_currmcl).a = cc_libmcl_genreg(breg,(i64)((*a).size));
            (*cc_genasm_currmcl).b = cc_libmcl_genreg((i64)11,(i64)1);
            cc_genasm_convmcl();
            mlib_gs_str(cc_libmcl_dest,(byte*)"\txchg D10,");
            mlib_gs_strln(cc_libmcl_dest,cc_genasm_getregnamex(breg,(i64)8));
        } else {
            (*b).size = (i64)1;
            exchreg = (i64)0;
            if (((i64)((u64)((*b).reg)) != (i64)11)) {
                mlib_gs_str(cc_libmcl_dest,(byte*)"\txchg D10,");
                mlib_gs_strln(cc_libmcl_dest,cc_genasm_getregnamex((i64)((*b).reg),(i64)8));
                exchreg = (i64)((*b).reg);
                (*b).reg = (u64)((i64)11);
            };
            cc_genasm_convmcl();
            if (!!(exchreg)) {
                mlib_gs_str(cc_libmcl_dest,(byte*)"\txchg D10,");
                mlib_gs_strln(cc_libmcl_dest,cc_genasm_getregnamex(exchreg,(i64)8));
            };
        };
        return;
    }else if (((i64)((*b).mode)==(i64)2)) {
    }else if (((i64)((*b).mode)==(i64)4)) {
        cc_support_gerror((byte*)"SHL/MEM",(struct cc_decls_unitrec *)(0));
    };
    cc_genasm_convmcl();
}

static void cc_genasm_do_neg(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)36);
}

static void cc_genasm_do_not(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)37);
}

static void cc_genasm_do_inc(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)38);
}

static void cc_genasm_do_dec(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)39);
}

static void cc_genasm_do_setcc(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b,i64 cond) {
    cc_genasm_passthru((i64)40);
}

static void cc_genasm_do_fneg(struct cc_libmcl_opndrec * a) {
    if (((i64)((*a).size) == (i64)4)) {
        (*cc_genasm_currmcl).opcode = (u64)((i64)101);
        (*cc_genasm_currmcl).b = cc_libmcl_genname((byte*)"[fchsmask_ps]");
    } else {
        (*cc_genasm_currmcl).opcode = (u64)((i64)102);
        (*cc_genasm_currmcl).b = cc_libmcl_genname((byte*)"[fchsmask_pd]");
    };
    cc_libmcl_fchsused = (i64)1;
    cc_genasm_convmcl();
}

static void cc_genasm_do_fabs(struct cc_libmcl_opndrec * a) {
    if (((i64)((*a).size) == (i64)4)) {
        (*cc_genasm_currmcl).opcode = (u64)((i64)103);
        (*cc_genasm_currmcl).b = cc_libmcl_genname((byte*)"[fabsmask_ps]");
    } else {
        (*cc_genasm_currmcl).opcode = (u64)((i64)104);
        (*cc_genasm_currmcl).b = cc_libmcl_genname((byte*)"[fabsmask_pd]");
    };
    cc_libmcl_fabsused = (i64)1;
    cc_genasm_convmcl();
}

static void cc_genasm_do_fsqrt(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)43);
}

static void cc_genasm_do_ufix(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_do_ifix(a,b);
}

static void cc_genasm_do_ifix(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_do_changeop((((i64)((*b).size) == (i64)4)?(i64)93:(i64)94));
}

static void cc_genasm_do_ufloat(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    struct cc_libmcl_opndrec *  rx;
    struct cc_libmcl_opndrec *  fx;
    byte *  name;
    rx = cc_libmcl_genreg((i64)11,(i64)((*b).size));
    fx = cc_libmcl_genxreg((i64)16,(i64)((*a).size));
    if (((i64)((*a).size) == (i64)4)) {
        if (((i64)((*b).size) == (i64)4)) {
            name = (byte*)"m$ufloat_r32u32*";
        } else {
            name = (byte*)"m$ufloat_r32u64*";
        };
    } else {
        if (((i64)((*b).size) == (i64)4)) {
            name = (byte*)"m$ufloat_r64u32*";
        } else {
            name = (byte*)"m$ufloat_r64u64*";
        };
    };
    cc_libmcl_initmcdest();
    cc_libmcl_genmc((i64)5,rx,b);
    cc_libmcl_genmc((i64)15,cc_libmcl_genname(name),(struct cc_libmcl_opndrec *)(0));
    cc_libmcl_genmc((i64)10,a,fx);
    cc_genasm_domclseq(cc_libmcl_mccode);
}

static void cc_genasm_do_ifloat(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_do_changeop((((i64)((*a).size) == (i64)4)?(i64)89:(i64)90));
}

static void cc_genasm_do_db(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)58);
}

static void cc_genasm_do_dw(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)59);
}

static void cc_genasm_do_dd(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_convertimm(a,(i64)0);
    cc_genasm_passthru((i64)60);
}

static void cc_genasm_do_dq(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_convertimm(a,(i64)0);
    cc_genasm_passthru((i64)61);
}

static void cc_genasm_do_align(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)64);
}

static void cc_genasm_do_segment(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    cc_genasm_passthru((i64)65);
}

static void cc_genasm_do_assem(struct cc_libmcl_opndrec * a,struct cc_libmcl_opndrec * b) {
    mlib_gs_strln(cc_libmcl_dest,(*a).svalue);
}

static void cc_genasm_strmclasm(struct cc_libmcl_mclrec * mcl) {
    struct cc_libmcl_opndrec *  a;
    struct cc_libmcl_opndrec *  b;
    i64 opcode;
    i64 cond;
    i64 sizepref;
    i64 n;
    cc_genasm_initasmline();
    opcode = (i64)((*mcl).opcode);
    cond = (i64)((*mcl).cond);
    a = (*mcl).a;
    b = (*mcl).b;
    if ((opcode==(i64)67)) {
        cc_genasm_asmstr((*a).svalue);
        return;
    }else if ((opcode==(i64)2)) {
        return;
    }else if ((opcode==(i64)1)) {
        cc_genasm_asmchar((i64)33);
        cc_genasm_asmstr((*a).svalue);
        return;
    }else if ((opcode==(i64)4)) {
        cc_genasm_asmstr((*a).svalue);
        return;
    }else if ((opcode==(i64)3)) {
        cc_genasm_asmchar((i64)76);
        cc_genasm_asmint((*a).value);
        cc_genasm_asmchar((i64)58);
        if (!!((u64)((*a).isglobal))) {
            cc_genasm_asmchar((i64)58);
        };
        if (!!(b)) {
            cc_genasm_asmstr((byte*)"\t!<");
            cc_genasm_asmstr((*(*b).def).name);
            cc_genasm_asmchar((i64)62);
        };
        return;
    };
    cc_genasm_asmchar((i64)9);
    if ((opcode==(i64)19)) {
        cc_genasm_asmchar((i64)106);
        cc_genasm_asmstr(cc_libmcl_asmcondnames[(cond)]);
    }else if ((opcode==(i64)40)) {
        cc_genasm_asmstr((byte*)"set");
        cc_genasm_asmstr(cc_libmcl_asmcondnames[(cond)]);
    }else if ((opcode==(i64)9)) {
        cc_genasm_asmstr((byte*)"cmov");
        cc_genasm_asmstr(cc_libmcl_asmcondnames[(cond)]);
    } else {
        cc_genasm_asmstr((cc_libmcl_mclnames[(opcode)-1] + ((opcode <= (i64)68)?(i64)2:(i64)3)));
    };
    n = (cc_genasm_asmptr - cc_genasm_asmstart);
    L921 :;
    while ((n < (i64)11)) {
        cc_genasm_asmchar((i64)32);
        ++n;
L922 :;
    }L923 :;
    ;
    if ((!!(a) && !!(b))) {
        sizepref = cc_libmcl_needsizeprefix(opcode,a,b);
        cc_genasm_stropndx(a,sizepref,(i64)0);
        cc_genasm_asmstr((byte*)",\t");
        cc_genasm_stropndx(b,sizepref,(i64)0);
    } else if ((!!(a) && !!((u64)((*a).mode)))) {
        if ((opcode == (i64)15)) {
            cc_genasm_stropndx(a,(i64)0,(i64)0);
        } else {
            cc_genasm_stropndx(a,(i64)1,(i64)0);
        };
    };
}

void cc_genasm_stropndx(struct cc_libmcl_opndrec * a,i64 sizeprefix,i64 debug) {
    byte *  plus;
    byte *  p;
    byte *  q;
    i64 av_1;
    if (((i64)((*a).mode)==(i64)1)) {
        cc_genasm_asmstr(cc_libmcl_getregname((i64)((*a).reg),(i64)((*a).size)));
    }else if (((i64)((*a).mode)==(i64)2)) {
        cc_genasm_strvaluex(a);
    }else if (((i64)((*a).mode)==(i64)4)) {
        if (!!(sizeprefix)) {
            cc_genasm_asmstr(cc_libmcl_getsizeprefix((i64)((*a).size),(i64)1));
        };
        cc_genasm_asmchar((i64)91);
        plus = (byte*)"";
        if (!!((u64)((*a).reg))) {
            if (((!!(cc_decls_fshownames) && !!((*a).def)) && ((i64)((u64)((*a).reg)) == (i64)15))) {
            } else {
                cc_genasm_asmstr(cc_genasm_getregnamex((i64)((*a).reg),(i64)8));
                plus = (byte*)"+";
            };
        };
        if (!!((u64)((*a).regix))) {
            cc_genasm_asmstr(plus);
            cc_genasm_asmstr(cc_genasm_getregnamex((i64)((*a).regix),(i64)8));
            plus = (byte*)"+";
            if (((i64)((u64)((*a).scale)) > (i64)1)) {
                cc_genasm_asmchar((i64)42);
                cc_genasm_asmint((i64)((*a).scale));
            };
        };
        if ((!!((*a).def) || !!((u64)((*a).valtype)))) {
            p = cc_genasm_asmptr;
            cc_genasm_asmchar((i64)32);
            q = cc_genasm_asmptr;
            cc_genasm_strvaluex(a);
            if ((((u64)((*q)) != '-') && ((u64)((*plus)) == '+'))) {
                (*p) = '+';
            };
            if (((u64)((*p)) == ' ')) {
                av_1 = ((cc_genasm_asmptr - p) - (i64)1);
                while (av_1-- > 0) {
L924 :;
                    (*p) = (u64)((*(p + (i64)1)));
                    ++p;
L925 :;
                }L926 :;
                ;
                --cc_genasm_asmptr;
            };
        };
        cc_genasm_asmchar((i64)93);
    }else if (((i64)((*a).mode)==(i64)3)) {
        cc_genasm_asmchar((i64)47);
        cc_genasm_asmstr((*a).svalue);
        cc_genasm_asmchar((i64)47);
    }else if (((i64)((*a).mode)==(i64)6)) {
        cc_genasm_asmstr(cc_genasm_fgetregnamex((i64)((*a).reg)));
    } else {
        cc_genasm_asmstr((byte*)"<BAD OPND>");
    };
}

static void cc_genasm_strmclx(struct cc_libmcl_mclrec * mcl) {
    cc_genasm_strmclasm(mcl);
    (*cc_genasm_asmptr++) = (u64)10u;
    (*cc_genasm_asmptr) = (u64)0u;
}

static byte * cc_genasm_fgetregnamex(i64 reg) {
    static byte str[16];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str((byte*)"XMM",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_i64((reg - (i64)1),NULL);
    msysnewc_m_print_end();
    ;
    return str;
}

byte * cc_genasm_getstringname(i64 n) {
    static byte str[16];
    if ((n == (i64)0)) {
        cc_libmcl_kk0used = (i64)1;
    };
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str((byte*)"KK",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_i64(n,NULL);
    msysnewc_m_print_end();
    ;
    return str;
}

byte * cc_genasm_getwstringname(i64 n) {
    static byte str[16];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str((byte*)"WW",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_i64(n,NULL);
    msysnewc_m_print_end();
    ;
    return str;
}

byte * cc_genasm_getrealname(i64 n) {
    static byte str[16];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str((byte*)"R.",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_i64(n,NULL);
    msysnewc_m_print_end();
    ;
    return str;
}

byte * cc_genasm_getsrealname(i64 n) {
    static byte str[16];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str((byte*)"SR.",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_i64(n,NULL);
    msysnewc_m_print_end();
    ;
    return str;
}

byte * cc_genasm_getdintname(i64 n) {
    static byte str[16];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str((byte*)"DD.",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_i64(n,NULL);
    msysnewc_m_print_end();
    ;
    return str;
}

i64 cc_genasm_getstringindex(byte * s,i64 length) {
    if (((s == 0) || (length == (i64)0))) {
        cc_libmcl_kk0used = (i64)1;
        return (i64)0;
    };
    if ((cc_genasm_nstrings >= cc_genasm_stringtablesize)) {
        cc_genasm_extendstringtable();
    };
    (*cc_genasm_stringtable)[(++cc_genasm_nstrings)-1] = s;
    (*cc_genasm_stringlentable)[(cc_genasm_nstrings)-1] = length;
    return cc_genasm_nstrings;
}

i64 cc_genasm_getwstringindex(u16 * s,i64 length) {
    if ((cc_genasm_nwstrings >= (i64)1024)) {
        cc_support_gerror((byte*)"Too many wide strings",(struct cc_decls_unitrec *)(0));
    };
    cc_genasm_wstringtable[(++cc_genasm_nwstrings)-1] = s;
    cc_genasm_wstringlentable[(cc_genasm_nwstrings)-1] = length;
    return cc_genasm_nwstrings;
}

static i64 cc_genasm_getrealindex(double x) {
    if ((cc_genasm_nreals >= cc_genasm_realtablesize)) {
        cc_genasm_extendrealtable();
    };
    (*cc_genasm_realtable)[(++cc_genasm_nreals)-1] = x;
    return cc_genasm_nreals;
}

static i64 cc_genasm_getdintindex(i64 x) {
    if ((cc_genasm_ndints >= cc_genasm_dinttablesize)) {
        cc_genasm_extenddinttable();
    };
    (*cc_genasm_dinttable)[(++cc_genasm_ndints)-1] = x;
    return cc_genasm_ndints;
}

static void cc_genasm_strvaluex(struct cc_libmcl_opndrec * a) {
    struct cc_decls_strec *  d;
    i64 value;
    d = (*a).def;
    value = (*a).value;
    if (!!(d)) {
        if (((i64)((*d).nameid)==(i64)7)) {
            if (((i64)((u64)((*(*d).owner).nameid)) == (i64)6)) {
                cc_genasm_asmchar((i64)96);
                cc_genasm_asmstr((*(*d).owner).name);
                cc_genasm_asmchar((i64)46);
                cc_genasm_asmstr((*d).name);
                cc_genasm_asmchar((i64)46);
                cc_genasm_asmint((i64)((*d).blockno));
            } else {
                cc_genasm_asmchar((i64)96);
                cc_genasm_asmstr(cc_libmcl_getfullname(d));
                if (!!(cc_lib_isimported(d))) {
                    cc_genasm_asmchar((i64)42);
                };
            };
        }else if (((i64)((*d).nameid)==(i64)8) || ((i64)((*d).nameid)==(i64)9)) {
            if (!!(cc_decls_fshownames)) {
                cc_genasm_asmstr((*d).name);
            } else {
                cc_genasm_asmint((*d).offset);
            };
        } else {
            cc_genasm_asmchar((i64)96);
            cc_genasm_asmstr(cc_libmcl_getfullname(d));
            if (!!(cc_lib_isimported(d))) {
                cc_genasm_asmchar((i64)42);
            };
        };
        if ((((i64)((u64)((*a).valtype)) == (i64)1) && (value != (i64)0))) {
            if ((value > (i64)0)) {
                cc_genasm_asmchar((i64)43);
            };
            cc_genasm_asmint(value);
        };
        return;
    };
    if (((i64)((*a).valtype)==(i64)9)) {
        cc_genasm_asmstr(cc_genasm_getdintname((i64)((*a).index)));
        return;
    }else if (((i64)((*a).valtype)==(i64)10)) {
        if (!!((u64)((*a).isfloat))) {
            cc_genasm_asmstr(cc_genasm_getsrealname((i64)((*a).index)));
        } else {
            cc_genasm_asmstr(cc_genasm_getrealname((i64)((*a).index)));
        };
        return;
    }else if (((i64)((*a).valtype)==(i64)7)) {
        cc_genasm_asmstr(cc_genasm_getstringname((i64)((*a).index)));
        return;
    }else if (((i64)((*a).valtype)==(i64)8)) {
        cc_genasm_asmstr(cc_genasm_getwstringname((i64)((*a).index)));
        return;
    };
    cc_genasm_asmstr(cc_libmcl_strvalue(a));
}

static void cc_genasm_convertimm(struct cc_libmcl_opndrec * a,i64 sx) {
    i64 value;
    if (!!((*a).def)) {
        return;
    };
    value = (*a).value;
    if (((i64)((*a).valtype)==(i64)1)) {
        if ((labs(sx)==(i64)1)) {
            if ((((i64)-2147483648LL <= value) && (value <= (i64)2147483647))) {
            } else {
                if ((sx < (i64)0)) {
                    cc_support_gerror((byte*)"conv/imm1",(struct cc_decls_unitrec *)(0));
                };
                (*a).index = cc_genasm_getdintindex(value);
                (*a).valtype = (u64)((i64)9);
                (*a).mode = (u64)((i64)4);
            };
        }else if ((labs(sx)==(i64)2)) {
            if ((((i64)0 <= value) && (value <= (i64)4294967295LL))) {
            } else {
                if ((sx < (i64)0)) {
                    cc_support_gerror((byte*)"conv/imm2",(struct cc_decls_unitrec *)(0));
                };
                (*a).index = cc_genasm_getdintindex(value);
                (*a).valtype = (u64)((i64)9);
                (*a).mode = (u64)((i64)4);
            };
        };
    }else if (((i64)((*a).valtype)==(i64)2)) {
        (*a).index = cc_genasm_getrealindex((*a).xvalue);
        (*a).valtype = (u64)((i64)10);
        (*a).mode = (u64)((i64)4);
        (*a).isfloat = (u64)(((i64)((*a).size) == (i64)4));
    }else if (((i64)((*a).valtype)==(i64)3)) {
        (*a).index = cc_genasm_getstringindex((*a).svalue,(i64)((*a).slength));
        (*a).valtype = (u64)((i64)7);
    }else if (((i64)((*a).valtype)==(i64)4)) {
        (*a).index = cc_genasm_getwstringindex((*a).wsvalue,(i64)((*a).wslength));
        (*a).valtype = (u64)((i64)8);
    };
}

static void cc_genasm_genstringtable(void) {
    i64 i;
    i64 col;
    if (!((!!(cc_genasm_nstrings) || !!(cc_libmcl_kk0used)))) {
        return;
    };
    mlib_gs_strln(cc_libmcl_dest,(byte*)"!String Table");
    mlib_gs_strln(cc_libmcl_dest,(byte*)"\tsegment idata");
    mlib_gs_str(cc_libmcl_dest,(byte*)"\talign ");
    mlib_gs_strint(cc_libmcl_dest,(i64)8);
    mlib_gs_line(cc_libmcl_dest);
    if (!!(cc_libmcl_kk0used)) {
        mlib_gs_strln(cc_libmcl_dest,(byte*)"kk0:    db 0");
    };
    L927 :;
    for (i=(i64)1;i<=cc_genasm_nstrings;i+=(i64)1) {
L928 :;
        col = (i64)((*cc_libmcl_dest).length);
        mlib_gs_str(cc_libmcl_dest,cc_genasm_getstringname(i));
        mlib_gs_str(cc_libmcl_dest,(byte*)":");
        mlib_gs_padto(cc_libmcl_dest,(i64)8,(i64)32);
        cc_genasm_genstring((*cc_genasm_stringtable)[(i)-1],(*cc_genasm_stringlentable)[(i)-1]);
L929 :;
    }L930 :;
    ;
    mlib_gs_line(cc_libmcl_dest);
}

static void cc_genasm_genwstringtable(void) {
    i64 i;
    i64 col;
    if (!(!!(cc_genasm_nwstrings))) {
        return;
    };
    mlib_gs_strln(cc_libmcl_dest,(byte*)"!Wide String Table");
    mlib_gs_strln(cc_libmcl_dest,(byte*)"\tsegment idata");
    mlib_gs_str(cc_libmcl_dest,(byte*)"\talign ");
    mlib_gs_strint(cc_libmcl_dest,(i64)8);
    mlib_gs_line(cc_libmcl_dest);
    L931 :;
    for (i=(i64)1;i<=cc_genasm_nwstrings;i+=(i64)1) {
L932 :;
        col = (i64)((*cc_libmcl_dest).length);
        mlib_gs_str(cc_libmcl_dest,cc_genasm_getwstringname(i));
        mlib_gs_str(cc_libmcl_dest,(byte*)":");
        mlib_gs_padto(cc_libmcl_dest,(i64)8,(i64)32);
        cc_genasm_genwstring(cc_genasm_wstringtable[(i)-1],cc_genasm_wstringlentable[(i)-1]);
L933 :;
    }L934 :;
    ;
    mlib_gs_line(cc_libmcl_dest);
}

static void cc_genasm_do_defstr(byte * s,i64 length) {
    mlib_gs_str(cc_libmcl_dest,(byte*)"\t");
    cc_genasm_genstring(s,length);
}

static void cc_genasm_do_defwstr(u16 * s,i64 length) {
    mlib_gs_str(cc_libmcl_dest,(byte*)"\t");
    cc_genasm_genwstring(s,length);
}

static void cc_genasm_genrealtable(void) {
    struct cc_genasm_genrealtable_fprec fp;
    double x;
    i64 i;
    byte str[1282];
    if (!(!!(cc_genasm_nreals))) {
        return;
    };
    mlib_gs_strln(cc_libmcl_dest,(byte*)"!Real64 Table");
    mlib_gs_strln(cc_libmcl_dest,(byte*)"\tsegment idata");
    mlib_gs_str(cc_libmcl_dest,(byte*)"\talign ");
    mlib_gs_strint(cc_libmcl_dest,(i64)8);
    mlib_gs_line(cc_libmcl_dest);
    L935 :;
    for (i=(i64)1;i<=cc_genasm_nreals;i+=(i64)1) {
L936 :;
        x = (*cc_genasm_realtable)[(i)-1];
        fp.x64 = x;
        mlib_gs_str(cc_libmcl_dest,cc_genasm_getrealname(i));
        mlib_gs_str(cc_libmcl_dest,(byte*)":");
        mlib_gs_padto(cc_libmcl_dest,(i64)10,(i64)32);
        mlib_gs_str(cc_libmcl_dest,(byte*)"dq ");
        mlib_gs_strint(cc_libmcl_dest,fp.ix64);
        mlib_gs_str(cc_libmcl_dest,(byte*)"\t; ");
        strcpy((i8 *)(str),(i8 *)(msysnewc_strint(fp.ix64,(byte*)"z16H")));
        mlib_gs_str(cc_libmcl_dest,str);
        strcpy((i8 *)(str),(i8 *)(msysnewc_strreal(x,(byte*)".30g")));
        mlib_gs_strln(cc_libmcl_dest,str);
L937 :;
    }L938 :;
    ;
    mlib_gs_line(cc_libmcl_dest);
    mlib_gs_strln(cc_libmcl_dest,(byte*)"!Real32 Table");
    L939 :;
    for (i=(i64)1;i<=cc_genasm_nreals;i+=(i64)1) {
L940 :;
        x = (*cc_genasm_realtable)[(i)-1];
        fp.x32 = (float)(x);
        mlib_gs_str(cc_libmcl_dest,cc_genasm_getsrealname(i));
        mlib_gs_str(cc_libmcl_dest,(byte*)":");
        mlib_gs_padto(cc_libmcl_dest,(i64)10,(i64)32);
        mlib_gs_str(cc_libmcl_dest,(byte*)"dd ");
        mlib_gs_strint(cc_libmcl_dest,(i64)(fp.ix32));
        mlib_gs_str(cc_libmcl_dest,(byte*)"\t; ");
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_r64((double)(fp.x32),(byte*)".30g");
        msysnewc_m_print_end();
        ;
        mlib_gs_strln(cc_libmcl_dest,str);
L941 :;
    }L942 :;
    ;
    mlib_gs_line(cc_libmcl_dest);
}

static void cc_genasm_gendinttable(void) {
    i64 i;
    i64 x;
    if (!(!!(cc_genasm_ndints))) {
        return;
    };
    mlib_gs_strln(cc_libmcl_dest,(byte*)"!Int64 Table");
    mlib_gs_strln(cc_libmcl_dest,(byte*)"\tsegment idata");
    mlib_gs_str(cc_libmcl_dest,(byte*)"\talign ");
    mlib_gs_strint(cc_libmcl_dest,(i64)8);
    mlib_gs_line(cc_libmcl_dest);
    L943 :;
    for (i=(i64)1;i<=cc_genasm_ndints;i+=(i64)1) {
L944 :;
        x = (*cc_genasm_dinttable)[(i)-1];
        mlib_gs_str(cc_libmcl_dest,cc_genasm_getdintname(i));
        mlib_gs_str(cc_libmcl_dest,(byte*)":");
        mlib_gs_str(cc_libmcl_dest,(byte*)"dq ");
        mlib_gs_strint(cc_libmcl_dest,x);
        mlib_gs_line(cc_libmcl_dest);
L945 :;
    }L946 :;
    ;
    mlib_gs_line(cc_libmcl_dest);
}

static void cc_genasm_writefabs(void) {
    if ((!!(cc_libmcl_fabsused) || !!(cc_libmcl_fchsused))) {
        mlib_gs_strln(cc_libmcl_dest,(byte*)"\tsegment idata");
        mlib_gs_strln(cc_libmcl_dest,(byte*)"\talign 16");
        if (!!(cc_libmcl_fchsused)) {
            mlib_gs_strln(cc_libmcl_dest,(byte*)"fchsmask_ps:\tdq 0x80000000'80000000, 0x80000000'80000000");
            mlib_gs_strln(cc_libmcl_dest,(byte*)"fchsmask_pd:\tdq 0x80000000'00000000, 0x80000000'00000000");
        };
        if (!!(cc_libmcl_fabsused)) {
            mlib_gs_strln(cc_libmcl_dest,(byte*)"fabsmask_ps:\tdq 0x7fffffff'7fffffff, 0x7fffffff'7fffffff");
            mlib_gs_strln(cc_libmcl_dest,(byte*)"fabsmask_pd:\tdq 0x7fffffff'ffffffff, 0x7fffffff'ffffffff");
        };
    };
}

static void cc_genasm_domclseq(struct cc_libmcl_mclrec * m) {
    L947 :;
    while (!!(m)) {
        cc_genasm_mcltoa64(m);
        m = (*m).nextmcl;
L948 :;
    }L949 :;
    ;
}

static void cc_genasm_asmstr(byte * s) {
    L950 :;
    while (!!((u64)((*s)))) {
        (*cc_genasm_asmptr++) = (u64)((*s++));
L951 :;
    }L952 :;
    ;
}

static void cc_genasm_asmstrln(byte * s) {
    byte c;
    L953 :;
    while (!!((u64)((c = (u64)((*s)))))) {
        (*cc_genasm_asmptr) = (u64)(c);
        ++cc_genasm_asmptr;
        ++s;
L954 :;
    }L955 :;
    ;
    (*cc_genasm_asmptr) = (u64)10u;
    ++cc_genasm_asmptr;
}

static void cc_genasm_asmline(void) {
    (*cc_genasm_asmptr) = (u64)10u;
    ++cc_genasm_asmptr;
}

static void cc_genasm_asmln(void) {
    cc_genasm_asmline();
}

static void cc_genasm_asmint(i64 a) {
    byte *  s;
    s = cc_genasm_asmptr;
    msysnewc_getstrint(a,s);
    cc_genasm_asmptr += (i64)(strlen((i8 *)(s)));
}

static void cc_genasm_asmchar(i64 c) {
    (*cc_genasm_asmptr) = (u64)(c);
    ++cc_genasm_asmptr;
}

static void cc_genasm_asmterm(void) {
    (*cc_genasm_asmptr) = (u64)0u;
}

static void cc_genasm_initasmline(void) {
    cc_genasm_asmptr = (cc_genasm_asmstart = cc_genasm_asmbuffer);
    cc_genasm_asmend = (cc_genasm_asmbuffer + (i64)20000);
}

static byte * cc_genasm_getregnamex(i64 reg,i64 size) {
    static byte *  regnames[8][17] = {
    {
        (byte*)"-",
        (byte*)"B0",
        (byte*)"B1",
        (byte*)"B2",
        (byte*)"B3",
        (byte*)"B4",
        (byte*)"B5",
        (byte*)"B6",
        (byte*)"B7",
        (byte*)"B8",
        (byte*)"B9",
        (byte*)"B10",
        (byte*)"B11",
        (byte*)"B12",
        (byte*)"B13",
        (byte*)"B14",
        (byte*)"B15"
},
    {
        (byte*)"-",
        (byte*)"W0",
        (byte*)"W1",
        (byte*)"W2",
        (byte*)"W3",
        (byte*)"W4",
        (byte*)"W5",
        (byte*)"W6",
        (byte*)"W7",
        (byte*)"W8",
        (byte*)"W9",
        (byte*)"W10",
        (byte*)"W11",
        (byte*)"W12",
        (byte*)"W13",
        (byte*)"W14",
        (byte*)"W15"
},
    {
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
},
    {
        (byte*)"-",
        (byte*)"A0",
        (byte*)"A1",
        (byte*)"A2",
        (byte*)"A3",
        (byte*)"A4",
        (byte*)"A5",
        (byte*)"A6",
        (byte*)"A7",
        (byte*)"A8",
        (byte*)"A9",
        (byte*)"A10",
        (byte*)"A11",
        (byte*)"A12",
        (byte*)"A13",
        (byte*)"Aframe",
        (byte*)"Astack"
},
    {
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
},
    {
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
},
    {
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
},
    {
        (byte*)"-",
        (byte*)"D0",
        (byte*)"D1",
        (byte*)"D2",
        (byte*)"D3",
        (byte*)"D4",
        (byte*)"D5",
        (byte*)"D6",
        (byte*)"D7",
        (byte*)"D8",
        (byte*)"D9",
        (byte*)"D10",
        (byte*)"D11",
        (byte*)"D12",
        (byte*)"D13",
        (byte*)"Dframe",
        (byte*)"Dstack"
}
};
    return regnames[(size)-1][(reg)];
}

static void cc_genasm_genstring(byte * s,i64 length) {
    i64 state;
    i64 a;
    i64 av_1;
    mlib_gs_str(cc_libmcl_dest,(byte*)"db ");
    if ((length == (i64)0)) {
        mlib_gs_strln(cc_libmcl_dest,(byte*)"0");
        return;
    };
    state = (i64)0;
    av_1 = length;
    while (av_1-- > 0) {
L956 :;
        a = (i64)((*s++));
        if ((((a < (i64)32) || (a >= (i64)127)) || (a == (i64)34))) {
            if ((state == (i64)1)) {
                mlib_gs_str(cc_libmcl_dest,(byte*)"\",");
                state = (i64)0;
            };
            mlib_gs_strint(cc_libmcl_dest,a);
            mlib_gs_str(cc_libmcl_dest,(byte*)",");
        } else {
            if ((state == (i64)0)) {
                mlib_gs_str(cc_libmcl_dest,(byte*)"\"");
                state = (i64)1;
            };
            mlib_gs_char(cc_libmcl_dest,a);
        };
L957 :;
    }L958 :;
    ;
    if ((state == (i64)1)) {
        mlib_gs_str(cc_libmcl_dest,(byte*)"\",");
    };
    mlib_gs_str(cc_libmcl_dest,(byte*)"0");
    mlib_gs_line(cc_libmcl_dest);
}

static void cc_genasm_genwstring(u16 * s,i64 length) {
    i64 i;
    i64 state;
    mlib_gs_str(cc_libmcl_dest,(byte*)"dw ");
    if ((length == (i64)0)) {
        mlib_gs_strln(cc_libmcl_dest,(byte*)"0");
        return;
    };
    state = (i64)0;
    L959 :;
    for (i=(i64)1;i<=length;i+=(i64)1) {
L960 :;
        mlib_gs_strint(cc_libmcl_dest,(i64)((*s++)));
        mlib_gs_str(cc_libmcl_dest,(byte*)",");
L961 :;
    }L962 :;
    ;
    mlib_gs_str(cc_libmcl_dest,(byte*)"0");
    mlib_gs_line(cc_libmcl_dest);
}

static void cc_genasm_extendrealtable(void) {
    double (*oldrealtable)[];
    i64 oldrealtablesize;
    i64 i;
    oldrealtablesize = cc_genasm_realtablesize;
    oldrealtable = cc_genasm_realtable;
    cc_genasm_realtablesize *= (i64)2;
    cc_genasm_realtable = (double (*)[])(mlib_pcm_alloc(((i64)8 * cc_genasm_realtablesize)));
    L963 :;
    for (i=(i64)1;i<=cc_genasm_nreals;i+=(i64)1) {
L964 :;
        (*cc_genasm_realtable)[(i)-1] = (*oldrealtable)[(i)-1];
L965 :;
    }L966 :;
    ;
    mlib_pcm_free((void *)(oldrealtable),((i64)8 * oldrealtablesize));
}

static void cc_genasm_extenddinttable(void) {
    i64 (*olddinttable)[];
    i64 olddinttablesize;
    i64 i;
    olddinttablesize = cc_genasm_dinttablesize;
    olddinttable = cc_genasm_dinttable;
    cc_genasm_dinttablesize *= (i64)2;
    cc_genasm_dinttable = (i64 (*)[])(mlib_pcm_alloc(((i64)8 * cc_genasm_dinttablesize)));
    L967 :;
    for (i=(i64)1;i<=cc_genasm_ndints;i+=(i64)1) {
L968 :;
        (*cc_genasm_dinttable)[(i)-1] = (*olddinttable)[(i)-1];
L969 :;
    }L970 :;
    ;
    mlib_pcm_free((void *)(olddinttable),((i64)8 * olddinttablesize));
}

static void cc_genasm_extendstringtable(void) {
    byte * (*oldstringtable)[];
    i64 (*oldstringlentable)[];
    i64 oldstringtablesize;
    i64 i;
    oldstringtablesize = cc_genasm_stringtablesize;
    oldstringtable = cc_genasm_stringtable;
    oldstringlentable = cc_genasm_stringlentable;
    cc_genasm_stringtablesize *= (i64)2;
    cc_genasm_stringtable = (byte * (*)[])(mlib_pcm_alloc(((i64)4 * cc_genasm_stringtablesize)));
    cc_genasm_stringlentable = (i64 (*)[])(mlib_pcm_alloc(((i64)8 * cc_genasm_stringtablesize)));
    L971 :;
    for (i=(i64)1;i<=cc_genasm_nstrings;i+=(i64)1) {
L972 :;
        (*cc_genasm_stringtable)[(i)-1] = (*oldstringtable)[(i)-1];
        (*cc_genasm_stringlentable)[(i)-1] = (*oldstringlentable)[(i)-1];
L973 :;
    }L974 :;
    ;
    mlib_pcm_free((void *)(oldstringtable),((i64)4 * oldstringtablesize));
    mlib_pcm_free((void *)(oldstringlentable),((i64)8 * oldstringtablesize));
}

void cc_export_writemheader(byte * infile) {
    byte mfile[300];
    struct cc_decls_strec *  d;
    struct cc_decls_strec *  e;
    i64 i;
    strcpy((i8 *)(mfile),(i8 *)(mlib_pcm_copyheapstring(mlib_changeext(infile,(byte*)".m"))));
    mlib_gs_init(cc_export_mm);
    cc_export_mmstr((byte*)"importdll ");
    cc_export_mmstr(mlib_extractbasefile(infile));
    cc_export_mmstrln((byte*)" =");
    cc_decls_stmodule = cc_decls_moduletable[((i64)1)].stmodule;
    d = (*cc_decls_stmodule).deflist;
    L975 :;
    while (!!(d)) {
        if (!!(cc_headers_isheaderfile(cc_decls_sourcefilenames[((i64)(((u64)((*d).lineno) >> (i64)24)))]))) {
            d = (*d).nextdef;
            goto L976 ;
        };
        if (((i64)((*d).nameid)==(i64)7)) {
            cc_export_mmstr((byte*)"    ");
            cc_export_mmmode((i64)((*d).mode),(i64)1);
            cc_export_mmstr((byte*)" ");
            cc_export_mmstr(cc_export_fixname((*d).name));
            if (!!((*d).code)) {
                cc_export_mmstr((byte*)" =");
                cc_export_mmstr((*cc_lib_strexpr((*d).code)).strptr);
            };
            cc_export_mmline();
        }else if (((i64)((*d).nameid)==(i64)6)) {
            cc_export_writefunction(d);
        }else if (((i64)((*d).nameid)==(i64)5)) {
        }else if (((i64)((*d).nameid)==(i64)11)) {
            cc_export_mmstr((byte*)"    const ");
            cc_export_mmleftstr(cc_export_fixname((*d).name),(i64)34);
            cc_export_mmstr((byte*)" = ");
            cc_export_mmint((i64)((*d).index));
            cc_export_mmline();
        }else if (((i64)((*d).nameid)==(i64)1)) {
            cc_export_mmstr((byte*)"MACRO ");
            cc_export_mmstrln(cc_export_fixname((*d).name));
        }else if (((i64)((*d).nameid)==(i64)13)) {
            cc_export_writerecord((i64)((*d).mode),(i64)82,(i64)1);
        };
        d = (*d).nextdef;
L976 :;
    }L977 :;
    ;
    L978 :;
    for (i=(i64)0;i<=cc_decls_hstmask;i+=(i64)1) {
L979 :;
        e = (*cc_decls_hashtable)[(i)];
        if (((!!((*e).name) && ((i64)((u64)((*e).symbol)) == (i64)68)) && ((i64)((u64)((*e).nameid)) == (i64)1))) {
            if (!(!!(cc_headers_isheaderfile(cc_decls_sourcefilenames[((i64)(((u64)((*e).lineno) >> (i64)24)))])))) {
                if (!!((*e).tokenlist)) {
                    cc_export_mmstr((byte*)"    const ");
                    cc_export_mmleftstr(cc_export_fixname((*e).name),(i64)34);
                    cc_export_mmstr((byte*)" = ");
                    cc_export_showmacroseq((*e).tokenlist);
                    cc_export_mmstrln((byte*)"    ! macro");
                };
            };
        };
L980 :;
    }L981 :;
    ;
    cc_export_mmstrln((byte*)"end");
    cc_decls_moduletable[((i64)1)].mhdrstr = (*cc_export_mm).strptr;
    if (!!(cc_decls_logdest)) {
        msysnewc_m_print_startfile(cc_decls_logdev);
        msysnewc_m_print_str((byte*)"M HEADERS\n=========",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        msysnewc_m_print_startfile(cc_decls_logdev);
        msysnewc_m_print_str((*cc_export_mm).strptr,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"Writing M Header:",NULL);
    msysnewc_m_print_str(mfile,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    mlib_writefile(mfile,(byte *)((*cc_export_mm).strptr),(i64)((*cc_export_mm).length));
}

static void cc_export_showmacroseq(struct cc_decls_tokenrec * tk) {
    L982 :;
    while (!!(tk)) {
        cc_lex_emittoken(tk,cc_export_mm,(i64)0);
        tk = (*tk).nexttoken;
L983 :;
    }L984 :;
    ;
}

static void cc_export_mmstr(byte * s) {
    mlib_gs_str(cc_export_mm,s);
}

static void cc_export_mmleftstr(byte * s,i64 n) {
    mlib_gs_leftstr(cc_export_mm,s,n,(i64)32);
}

static void cc_export_mmstrln(byte * s) {
    mlib_gs_strln(cc_export_mm,s);
}

static void cc_export_mmint(i64 a) {
    byte str[32];
    msysnewc_getstrint(a,str);
    mlib_gs_str(cc_export_mm,str);
}

static void cc_export_mmline(void) {
    mlib_gs_line(cc_export_mm);
}

static void cc_export_writefunction(struct cc_decls_strec * d) {
    struct cc_decls_paramrec *  pm;
    i64 n;
    i64 isvar;
    i64 i;
    if (((i64)((*d).mode) == (i64)1)) {
        cc_export_mmstr((byte*)"    clang proc     ");
    } else {
        cc_export_mmstr((byte*)"    clang function ");
    };
    cc_export_mmstr((byte*)"\"");
    cc_export_mmstr((*d).name);
    cc_export_mmstr((byte*)"\"");
    cc_export_mmleftstr((byte*)" ",((i64)34 - (i64)((u64)(strlen((i8 *)((*d).name))))));
    cc_export_mmstr((byte*)"(");
    pm = (*d).paramlist;
    n = (i64)((*pm).nparams);
    isvar = ((i64)((*pm).flags) == (i64)3);
    L985 :;
    for (i=(i64)1;i<=n;i+=(i64)1) {
L986 :;
        cc_export_mmmode((i64)((*pm).mode),(i64)1);
        if (((i != n) || !!(isvar))) {
            cc_export_mmstr((byte*)",");
        };
        pm = (*pm).nextparam;
L987 :;
    }L988 :;
    ;
    if (!!(isvar)) {
        cc_export_mmstr((byte*)"...");
    };
    cc_export_mmstr((byte*)")");
    if (((i64)((*d).mode) != (i64)1)) {
        cc_export_mmmode((i64)((*d).mode),(i64)1);
    };
    cc_export_mmline();
}

static void cc_export_mmmode(i64 m,i64 expand) {
    i64 t;
    i64 u;
    t = cc_decls_ttbasetype[(m)];
    if ((t==(i64)16)) {
        cc_export_mmstr((byte*)"ref ");
        u = cc_decls_tttarget[(m)];
        if ((cc_decls_ttbasetype[(u)] == (i64)17)) {
            cc_export_writefnptr(u);
        } else {
            cc_export_mmmode(cc_decls_tttarget[(m)],(i64)1);
        };
    }else if ((t==(i64)19)) {
        cc_export_mmstr((byte*)"[");
        if (!!(cc_decls_ttlength[(m)])) {
            cc_export_mmint(cc_decls_ttlength[(m)]);
        };
        cc_export_mmstr((byte*)"]");
        cc_export_mmmode(cc_decls_tttarget[(m)],(i64)1);
    }else if ((t==(i64)15)) {
        cc_export_mmstr((byte*)"int");
    }else if ((t==(i64)20) || (t==(i64)21)) {
        cc_export_mmstr(cc_export_fixname((*cc_decls_ttnamedef[(m)]).name));
    }else if ((t==(i64)17)) {
        cc_export_mmstr((byte*)"<PROC>");
    } else {
        cc_export_mmstr(cc_tables_stdtypemnames[(t)]);
    };
}

static void cc_export_writerecord(i64 m,i64 rectype,i64 level) {
    struct cc_decls_strec *  d;
    struct cc_decls_strec *  e;
    i64 emode;
    i64 av_1;
    i64 av_2;
    i64 av_3;
    i64 av_4;
    av_1 = level;
    while (av_1-- > 0) {
L989 :;
        cc_export_mmstr((byte*)"    ");
L990 :;
    }L991 :;
    ;
    ++level;
    d = cc_decls_ttnamedef[(m)];
    if ((rectype == (i64)82)) {
        cc_export_mmstr((byte*)"record ");
        cc_export_mmstr(cc_export_fixname((*d).name));
        cc_export_mmstrln((byte*)" =");
    } else {
        cc_export_mmstrln(((rectype == (i64)83)?(byte*)"struct":(byte*)"union"));
    };
    e = (*d).deflist;
    if ((e == 0)) {
        av_2 = level;
        while (av_2-- > 0) {
L992 :;
            cc_export_mmstr((byte*)"    ");
L993 :;
        }L994 :;
        ;
        cc_export_mmstrln((byte*)"var int dummy    !empty record");
    };
    L995 :;
    while (!!(e)) {
        emode = (i64)((*e).mode);
        av_3 = level;
        while (av_3-- > 0) {
L998 :;
            cc_export_mmstr((byte*)"    ");
L999 :;
        }L1000 :;
        ;
        if (!!(strchr((i8 *)((*e).name),(i32)36))) {
            if ((cc_decls_ttbasetype[(emode)]==(i64)21)) {
                cc_export_writerecord(emode,(i64)85,level);
            }else if ((cc_decls_ttbasetype[(emode)]==(i64)20)) {
                cc_export_writerecord(emode,(i64)83,level);
            };
        } else {
            cc_export_mmstr((byte*)"var ");
            cc_export_mmmode((i64)((*e).mode),(i64)1);
            cc_export_mmstr((byte*)" ");
            cc_export_mmstrln(cc_export_fixname((*e).name));
        };
        e = (*e).nextdef;
L996 :;
    }L997 :;
    ;
    av_4 = (level - (i64)1);
    while (av_4-- > 0) {
L1001 :;
        cc_export_mmstr((byte*)"    ");
L1002 :;
    }L1003 :;
    ;
    cc_export_mmstrln((byte*)"end");
    cc_export_mmline();
}

static void cc_export_writefnptr(i64 m) {
    struct cc_decls_paramrec *  pm;
    i64 isvar;
    i64 n;
    i64 target;
    i64 i;
    target = cc_decls_tttarget[(m)];
    if ((target == (i64)1)) {
        cc_export_mmstr((byte*)"clang proc(");
    } else {
        cc_export_mmstr((byte*)"clang function(");
    };
    pm = cc_decls_ttparams[(m)];
    n = (i64)((*pm).nparams);
    isvar = ((i64)((*pm).flags) == (i64)3);
    L1004 :;
    for (i=(i64)1;i<=n;i+=(i64)1) {
L1005 :;
        cc_export_mmmode((i64)((*pm).mode),(i64)1);
        if (((i != n) || !!(isvar))) {
            cc_export_mmstr((byte*)",");
        };
        pm = (*pm).nextparam;
L1006 :;
    }L1007 :;
    ;
    if (!!(isvar)) {
        cc_export_mmstr((byte*)"...");
    };
    cc_export_mmstr((byte*)")");
    if ((target != (i64)1)) {
        cc_export_mmmode(target,(i64)1);
    };
}

static byte * cc_export_fixname(byte * name) {
    static byte *  reservedwords[8] = {(byte*)"function",(byte*)"read",(byte*)"type",(byte*)"next",(byte*)"stop",(byte*)"callback",(byte*)"len",(byte*)"$dummy"};
    byte str[128];
    i64 av_1;
    i64 i;
    L1008 :;
    for (i=(i64)1;i<=(i64)8;i+=(i64)1) {
L1009 :;
        if (!!(mlib_eqstring(reservedwords[(i)-1],name))) {
            strcpy((i8 *)(str),(i8 *)(name));
            strcat((i8 *)(str),(i8 *)((byte*)"$"));
            return mlib_pcm_copyheapstring(str);
        };
L1010 :;
    }L1011 :;
    ;
    return name;
}

i64 cc_assembler_assembler(byte * outputfile,byte * (*asmfiles)[],byte * (*dllfiles)[],i64 nasmfiles,i64 ndllfiles,i64 fobj,i64 fcaption,byte * (*assemsources)[],byte * entrypointname) {
    i64 i;
    cc_assembler_initall();
    L1012 :;
    for (i=(i64)1;i<=nasmfiles;i+=(i64)1) {
L1013 :;
        cc_assembler_addmodule((*asmfiles)[(i)-1]);
L1014 :;
    }L1015 :;
    ;
    ax_decls_searchlibs[((i64)1)-1] = (byte*)"ucrtbase";
    ax_decls_searchlibs[((i64)1)-1] = (byte*)"msvcrt";
    ax_decls_searchlibs[((i64)2)-1] = (byte*)"gdi32";
    ax_decls_searchlibs[((i64)3)-1] = (byte*)"user32";
    ax_decls_searchlibs[((i64)4)-1] = (byte*)"kernel32";
    ax_decls_nsearchlibs = (i64)4;
    L1016 :;
    for (i=(i64)1;i<=ndllfiles;i+=(i64)1) {
L1017 :;
        cc_assembler_addsearchlib((*dllfiles)[(i)-1]);
L1018 :;
    }L1019 :;
    ;
    if ((ax_decls_nmodules == (i64)0)) {
        cc_assembler_loaderror((byte*)"No input files specified");
    };
    if (!!(fcaption)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"Assembling to",NULL);
        msysnewc_m_print_str(outputfile,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    cc_assembler_loadsourcefiles(assemsources);
    cc_assembler_parsemodules();
    if (!!(fobj)) {
        ax_genss_genss();
        ax_writeobj_writess(outputfile);
    } else {
        ax_genss_genss();
        ax_writeexe_initsectiontable();
        ax_writeexe_genexe(entrypointname);
        ax_writeexe_writeexe(outputfile);
    };
    return (i64)1;
}

static void cc_assembler_loadsourcefiles(byte * (*assemsources)[]) {
    i64 i;
    byte *  source;
    L1020 :;
    for (i=(i64)1;i<=ax_decls_nmodules;i+=(i64)1) {
L1021 :;
        if (!!(assemsources)) {
            source = (*assemsources)[(i)-1];
        } else {
            source = (byte *)(mlib_readfile(ax_decls_moduletable[(i)-1].filename));
            if ((source == 0)) {
                cc_assembler_loaderror_s((byte*)"Can't load file: %s",ax_decls_moduletable[(i)-1].filename);
            };
        };
        ax_decls_moduletable[(i)-1].source = source;
L1022 :;
    }L1023 :;
    ;
}

static void cc_assembler_parsemodules(void) {
    i64 i;
    struct ax_lib_mclrec *  m;
    L1024 :;
    for (i=(i64)1;i<=ax_decls_nmodules;i+=(i64)1) {
L1025 :;
        ax_decls_currmoduleno = i;
        ax_decls_modulenamelist = (struct ax_decls_strec *)(0);
        ax_parse_readmodule(i);
        ax_parse_checkundefined();
        if (!!(ax_decls_nundefined)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)"Couldn't assemble - press key",NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            osnos_os_getch();
            exit((i64)1);
        };
        cc_assembler_scanglobals();
        cc_assembler_resethashtable();
L1026 :;
    }L1027 :;
    ;
    m = ax_lib_mccode;
    L1028 :;
    while (!!(m)) {
        cc_assembler_fixopnd((*m).a);
        cc_assembler_fixopnd((*m).b);
        m = (*m).nextmcl;
L1029 :;
    }L1030 :;
    ;
}

static void cc_assembler_fixopnd(struct ax_decls_opndrec * a) {
    struct ax_decls_strec *  d;
    if ((a == 0)) {
        return;
    };
    if (!!((*a).labeldef)) {
        d = (*a).labeldef;
        if (!!((*d).basedef)) {
            (*a).labeldef = (*d).basedef;
        };
    };
}

static void cc_assembler_initall(void) {
    ax_lex_initlex();
    ax_lib_initlib();
}

static void cc_assembler_loaderror(byte * mess) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"Error:",NULL);
    msysnewc_m_print_str(mess,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    exit((i64)1);
}

static void cc_assembler_loaderror_s(byte * mess,byte * s) {
    byte str[256];
    strcpy((i8 *)(str),(i8 *)(mess));
    strcat((i8 *)(str),(i8 *)(mess));
    cc_assembler_loaderror(str);
}

static void cc_assembler_addmodule(byte * name) {
    if ((ax_decls_nmodules >= (i64)200)) {
        cc_assembler_loaderror((byte*)"Too many modules");
    };
    ++ax_decls_nmodules;
    ax_decls_moduletable[(ax_decls_nmodules)-1].filename = mlib_pcm_copyheapstring(name);
    ax_decls_moduletable[(ax_decls_nmodules)-1].name = mlib_pcm_copyheapstring(mlib_extractfile(name));
    ax_decls_moduletable[(ax_decls_nmodules)-1].source = (byte*)"<empty>";
}

static void cc_assembler_addsearchlib(byte * name) {
    byte str[300];
    if ((ax_decls_nsearchlibs >= (i64)30)) {
        cc_assembler_loaderror((byte*)"Too many libraries");
    };
    ++ax_decls_nsearchlibs;
    strcpy((i8 *)(str),(i8 *)(name));
    str[(((i64)((u64)(strlen((i8 *)(name)))) - (i64)3))-1] = (u64)0u;
    ax_decls_searchlibs[(ax_decls_nsearchlibs)-1] = mlib_pcm_copyheapstring(str);
}

static struct ax_decls_strec * cc_assembler_getemptyst(struct ax_decls_strec * d) {
    struct ax_decls_strec *  dnew;
    if (!!((u64)((*d).ksymbol))) {
        dnew = (struct ax_decls_strec *)(mlib_pcm_allocz((i64)104));
        (*dnew).name = (*d).name;
        (*dnew).namelen = (u64)((*d).namelen);
        (*dnew).ksymbol = (u64)((*d).ksymbol);
        (*dnew).subcode = (u64)((*d).subcode);
        (*dnew).regsize = (u64)((*d).regsize);
        return dnew;
    };
    return (struct ax_decls_strec *)(0);
}

static struct ax_decls_strec * cc_assembler_findduplname(struct ax_decls_strec * d) {
    struct ax_decls_strec *  e;
    if (!!((*d).basedef)) {
        return (*d).basedef;
    };
    e = ax_decls_dupltable[((i64)((*d).htfirstindex))];
    L1031 :;
    while (!!(e)) {
        if ((((u64)((*d).namelen) == (u64)((*e).namelen)) && ((i64)(memcmp((void *)((*d).name),(void *)((*e).name),(u32)((*d).namelen))) == (i64)0))) {
            (*d).basedef = e;
            return e;
        };
        e = (*e).nextdupl;
L1032 :;
    }L1033 :;
    ;
    return (struct ax_decls_strec *)(0);
}

static void cc_assembler_adddupl(struct ax_decls_strec * d) {
    (*d).nextdupl = ax_decls_dupltable[((i64)((*d).htfirstindex))];
    ax_decls_dupltable[((i64)((*d).htfirstindex))] = d;
}

static void cc_assembler_scanglobals(void) {
    struct ax_decls_strec *  d;
    struct ax_decls_strec *  e;
    d = ax_decls_modulenamelist;
    L1034 :;
    while (!!(d)) {
        if (((i64)((*d).symbol)==(i64)21)) {
            e = cc_assembler_findduplname(d);
            if (!!(e)) {
                if (((i64)((*e).symbol)==(i64)21)) {
                }else if (((i64)((*e).symbol)==(i64)22)) {
                    (*d).symbol = (u64)((i64)22);
                    (*d).reftype = (u64)(((*e).reftype = (u64)((i64)1)));
                };
            } else {
                ax_lib_addimport(d);
                cc_assembler_adddupl(d);
            };
        }else if (((i64)((*d).symbol)==(i64)22)) {
            e = cc_assembler_findduplname(d);
            if (!!(e)) {
                if (((i64)((*e).symbol)==(i64)21)) {
                    (*e).symbol = (u64)((i64)22);
                    (*d).reftype = (u64)(((*e).reftype = (u64)((i64)1)));
                }else if (((i64)((*e).symbol)==(i64)22)) {
                    msysnewc_m_print_startcon();
                    msysnewc_m_print_str(ax_decls_moduletable[((i64)((*d).moduleno))-1].name,NULL);
                    msysnewc_m_print_str((*d).name,NULL);
                    msysnewc_m_print_u64((*d).htindex,NULL);
                    msysnewc_m_print_newline();
                    msysnewc_m_print_end();
                    ;
                    msysnewc_m_print_startcon();
                    msysnewc_m_print_str(ax_decls_moduletable[((i64)((*e).moduleno))-1].name,NULL);
                    msysnewc_m_print_str((*e).name,NULL);
                    msysnewc_m_print_u64((*e).htindex,NULL);
                    msysnewc_m_print_newline();
                    msysnewc_m_print_end();
                    ;
                    ax_lib_serror_s((byte*)"Multiply-defined global: %s",(*d).name);
                };
            } else {
                e = d;
                ax_lib_addimport(d);
                cc_assembler_adddupl(d);
            };
        };
        d = (*d).nextdef;
L1035 :;
    }L1036 :;
    ;
}

static void cc_assembler_resethashtable(void) {
    struct ax_decls_strec *  d;
    d = ax_decls_modulenamelist;
    L1037 :;
    while (!!(d)) {
        ax_decls_lexhashtable[((i64)((*d).htindex))] = cc_assembler_getemptyst(d);
        d = (*d).nextdef;
L1038 :;
    }L1039 :;
    ;
    ax_decls_modulenamelist = (struct ax_decls_strec *)(0);
}

void ax_lex_lex(void) {
    i64 i;
    i64 c;
    i64 hsum;
    i64 csum;
    i64 length;
    byte *  pstart;
    ax_lex_lxsubcode = (i64)0;
    L1040 :;
    switch ((int)(c = (i64)((*ax_lex_lxsptr++)))) {
    case 97:;
    case 98:;
    case 99:;
    case 100:;
    case 101:;
    case 102:;
    case 103:;
    case 104:;
    case 105:;
    case 106:;
    case 107:;
    case 108:;
    case 109:;
    case 110:;
    case 111:;
    case 112:;
    case 113:;
    case 114:;
    case 115:;
    case 116:;
    case 117:;
    case 118:;
    case 119:;
    case 120:;
    case 121:;
    case 122:;
    case 36:;
    case 95:;
    case 46:;
    {
        pstart = (ax_lex_lxsptr - (i64)1);
        /*doname:*/
L1042 :;
;
        hsum = (csum = c);
        L1043 :;
        switch ((int)(c = (i64)((*ax_lex_lxsptr++)))) {
        case 97:;
        case 98:;
        case 99:;
        case 100:;
        case 101:;
        case 102:;
        case 103:;
        case 104:;
        case 105:;
        case 106:;
        case 107:;
        case 108:;
        case 109:;
        case 110:;
        case 111:;
        case 112:;
        case 113:;
        case 114:;
        case 115:;
        case 116:;
        case 117:;
        case 118:;
        case 119:;
        case 120:;
        case 121:;
        case 122:;
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
        case 95:;
        case 36:;
        case 46:;
        {
            csum += c;
            hsum = ((hsum << (i64)3) + csum);
        }break;
        case 65:;
        case 66:;
        case 67:;
        case 68:;
        case 69:;
        case 70:;
        case 71:;
        case 72:;
        case 73:;
        case 74:;
        case 75:;
        case 76:;
        case 77:;
        case 78:;
        case 79:;
        case 80:;
        case 81:;
        case 82:;
        case 83:;
        case 84:;
        case 85:;
        case 86:;
        case 87:;
        case 88:;
        case 89:;
        case 90:;
        {
            (*(ax_lex_lxsptr - (i64)1)) = (u64)((c + (i64)32));
            csum += (c + (i64)32);
            hsum = ((hsum << (i64)3) + csum);
        }break;
        default: {
            --ax_lex_lxsptr;
            goto L1044 ;
        }
        } /* SW */
goto L1043 ;
L1044 :;
        ;
        ax_lex_lxlength = (ax_lex_lxsptr - pstart);
        ax_lex_lxhashvalue = ((hsum << (i64)5) ^ csum);
        if (!!(ax_lex_lookuplex((byte *)(pstart),ax_lex_lxlength))) {
            if (!!((u64)((*ax_lex_lxsymptr).ksymbol))) {
                ax_lex_lxsymbol = (i64)((*ax_lex_lxsymptr).ksymbol);
                ax_lex_lxsubcode = (i64)((*ax_lex_lxsymptr).subcode);
            } else {
                ax_lex_lxsymbol = (i64)((*ax_lex_lxsymptr).symbol);
            };
        } else {
            ax_lex_lxsymbol = (i64)17;
        };
        return;
    }break;
    case 65:;
    case 66:;
    case 67:;
    case 68:;
    case 69:;
    case 70:;
    case 71:;
    case 72:;
    case 73:;
    case 74:;
    case 75:;
    case 76:;
    case 77:;
    case 78:;
    case 79:;
    case 80:;
    case 81:;
    case 82:;
    case 83:;
    case 84:;
    case 85:;
    case 86:;
    case 87:;
    case 88:;
    case 89:;
    case 90:;
    {
        pstart = (ax_lex_lxsptr - (i64)1);
        c = (i64)((u64)(((*pstart) = (u64)(((i64)((u64)((*pstart))) + (i64)32)))));
        goto L1042 ;
;
    }break;
    case 48:;
    case 49:;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
    {
        ax_lex_readnumber(c);
        return;
    }break;
    case 96:;
    {
        pstart = ax_lex_lxsptr;
        hsum = (csum = (i64)0);
        L1045 :;
        switch ((int)(c = (i64)((*ax_lex_lxsptr)))) {
        case 65:;
        case 66:;
        case 67:;
        case 68:;
        case 69:;
        case 70:;
        case 71:;
        case 72:;
        case 73:;
        case 74:;
        case 75:;
        case 76:;
        case 77:;
        case 78:;
        case 79:;
        case 80:;
        case 81:;
        case 82:;
        case 83:;
        case 84:;
        case 85:;
        case 86:;
        case 87:;
        case 88:;
        case 89:;
        case 90:;
        case 97:;
        case 98:;
        case 99:;
        case 100:;
        case 101:;
        case 102:;
        case 103:;
        case 104:;
        case 105:;
        case 106:;
        case 107:;
        case 108:;
        case 109:;
        case 110:;
        case 111:;
        case 112:;
        case 113:;
        case 114:;
        case 115:;
        case 116:;
        case 117:;
        case 118:;
        case 119:;
        case 120:;
        case 121:;
        case 122:;
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
        case 95:;
        case 36:;
        case 46:;
        {
            ++ax_lex_lxsptr;
            csum += c;
            hsum = ((hsum << (i64)3) + csum);
        }break;
        default: {
            goto L1046 ;
        }
        } /* SW */
goto L1045 ;
L1046 :;
        ;
        ax_lex_lxsymbol = (i64)17;
        if ((pstart == ax_lex_lxsptr)) {
            ax_lex_lxerror((byte*)"NULL ` name");
        };
        ax_lex_lxlength = (ax_lex_lxsptr - pstart);
        ax_lex_lxhashvalue = ((hsum << (i64)5) ^ csum);
        if (!!(ax_lex_lookuplex((byte *)(pstart),ax_lex_lxlength))) {
            ax_lex_lxsymbol = (i64)((*ax_lex_lxsymptr).symbol);
            if ((ax_lex_lxsymbol == (i64)0)) {
                ax_lex_lxsymbol = (i64)((u64)(((*ax_lex_lxsymptr).symbol = (u64)((i64)17))));
            };
        };
        return;
    }break;
    case 33:;
    case 59:;
    case 35:;
    {
        L1047 :;
        while (!!((u64)(ax_lex_commentmap[((i64)((*ax_lex_lxsptr++)))]))) {
L1048 :;
        }L1049 :;
        ;
        if (((i64)((u64)((*(ax_lex_lxsptr - (i64)1)))) == (i64)0)) {
            --ax_lex_lxsptr;
        };
        ++ax_decls_lxlineno;
        ax_lex_lxsymbol = (i64)11;
        return;
    }break;
    case 44:;
    {
        ax_lex_lxsymbol = (i64)2;
        return;
    }break;
    case 58:;
    {
        if (((u64)((*ax_lex_lxsptr)) == (u64)58u)) {
            ax_lex_lxsymbol = (i64)4;
            ++ax_lex_lxsptr;
        } else {
            ax_lex_lxsymbol = (i64)3;
        };
        return;
    }break;
    case 91:;
    {
        ax_lex_lxsymbol = (i64)5;
        return;
    }break;
    case 93:;
    {
        ax_lex_lxsymbol = (i64)6;
        return;
    }break;
    case 43:;
    {
        ax_lex_lxsymbol = (i64)7;
        return;
    }break;
    case 45:;
    {
        ax_lex_lxsymbol = (i64)8;
        return;
    }break;
    case 42:;
    {
        ax_lex_lxsymbol = (i64)9;
        return;
    }break;
    case 61:;
    {
        ax_lex_lxsymbol = (i64)10;
        return;
    }break;
    case 39:;
    {
        pstart = ax_lex_lxsptr;
        L1050 :;
        while (1) {
            switch ((int)((*ax_lex_lxsptr++))) {
            case 39:;
            {
                goto L1051 ;
            }break;
            case 13:;
            case 10:;
            {
                ax_lex_lxerror((byte*)"String not terminated");
            }break;
            default: {
            }
            } /* SW */
;
        }L1051 :;
        ;
        length = ((ax_lex_lxsptr - pstart) - (i64)1);
        ax_lex_lxvalue = (i64)0;
        L1052 :;
        for (i=length;i>=(i64)1;i-=(i64)1) {
L1053 :;
            ax_lex_lxvalue = ((ax_lex_lxvalue << (i64)8) + (i64)((u64)((*((pstart + i) - (i64)1)))));
L1054 :;
        }L1055 :;
        ;
        ax_lex_lxsymbol = (i64)14;
        return;
    }break;
    case 34:;
    {
        pstart = ax_lex_lxsptr;
        L1056 :;
        while (1) {
            switch ((int)((*ax_lex_lxsptr++))) {
            case 34:;
            {
                ax_lex_lxsvalue = (byte *)(pstart);
                ax_lex_lxlength = ((ax_lex_lxsptr - pstart) - (i64)1);
                (*(ax_lex_lxsvalue + ax_lex_lxlength)) = (u64)0u;
                ax_lex_lxsymbol = (i64)16;
                return;
            }break;
            case 13:;
            case 10:;
            case 26:;
            case 0:;
            {
                ax_lex_lxerror((byte*)"String not terminated");
            }break;
            default: {
            }
            } /* SW */
;
        }L1057 :;
        ;
    }break;
    case 32:;
    case 9:;
    {
    }break;
    case 13:;
    {
    }break;
    case 10:;
    {
        ++ax_decls_lxlineno;
        ax_lex_lxsymbol = (i64)11;
        return;
    }break;
    case 0:;
    case 26:;
    {
        ax_lex_lxsymbol = (i64)12;
        --ax_lex_lxsptr;
        return;
    }break;
    default: {
        ax_lex_lxsymbol = (i64)1;
        ax_lex_lxvalue = c;
        return;
    }
    } /* SW */
goto L1040 ;
L1041 :;
    ;
}

void ax_lex_initlex(void) {
    i64 i;
    ax_lex_lxsubcode = (i64)0;
    ax_lex_lxsymbol = (i64)1;
    ax_decls_lxlineno = (i64)0;
    L1058 :;
    for (i=(i64)0;i<=(i64)255;i+=(i64)1) {
L1059 :;
        switch ((int)i) {
        case 65:;
        case 66:;
        case 67:;
        case 68:;
        case 69:;
        case 70:;
        case 71:;
        case 72:;
        case 73:;
        case 74:;
        case 75:;
        case 76:;
        case 77:;
        case 78:;
        case 79:;
        case 80:;
        case 81:;
        case 82:;
        case 83:;
        case 84:;
        case 85:;
        case 86:;
        case 87:;
        case 88:;
        case 89:;
        case 90:;
        case 97:;
        case 98:;
        case 99:;
        case 100:;
        case 101:;
        case 102:;
        case 103:;
        case 104:;
        case 105:;
        case 106:;
        case 107:;
        case 108:;
        case 109:;
        case 110:;
        case 111:;
        case 112:;
        case 113:;
        case 114:;
        case 115:;
        case 116:;
        case 117:;
        case 118:;
        case 119:;
        case 120:;
        case 121:;
        case 122:;
        case 36:;
        case 95:;
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
        {
            ax_lex_alphamap[(i)] = (u64)1u;
        }break;
        default: {
        }
        } /* SW */
;
        switch ((int)i) {
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
        {
            ax_lex_digitmap[(i)] = (u64)1u;
        }break;
        default: {
        }
        } /* SW */
;
        ax_lex_commentmap[(i)] = (u64)1u;
L1060 :;
    }L1061 :;
    ;
    ax_lex_commentmap[((i64)0)] = (u64)0u;
    ax_lex_commentmap[((i64)10)] = (u64)0u;
    ax_lex_inithashtable();
}

static void ax_lex_readreal(byte (*s)[],i64 slen,i64 intlen,i64 exponseen) {
    i64 i;
    i64 fractlen;
    i64 expon;
    i64 exponsign;
    i64 c;
    i64 digs;
    i64 av_1;
    i64 av_2;
    if (((intlen == (i64)0) || (intlen == slen))) {
        fractlen = (i64)0;
    } else {
        fractlen = (slen - intlen);
    };
    expon = (i64)0;
    exponsign = (i64)0;
    if (!!(exponseen)) {
        if (((c = (i64)((*ax_lex_lxsptr++)))==(i64)43)) {
        }else if (((c = (i64)((*ax_lex_lxsptr++)))==(i64)45)) {
            exponsign = (i64)1;
        } else {
            --ax_lex_lxsptr;
        };
        digs = (i64)0;
        L1062 :;
        switch ((int)(c = (i64)((*ax_lex_lxsptr++)))) {
        case 48:;
        case 49:;
        case 50:;
        case 51:;
        case 52:;
        case 53:;
        case 54:;
        case 55:;
        case 56:;
        case 57:;
        {
            expon = (((expon * (i64)10) + c) - (i64)48);
            ++digs;
        }break;
        default: {
            --ax_lex_lxsptr;
            goto L1063 ;
        }
        } /* SW */
goto L1062 ;
L1063 :;
        ;
        if ((digs == (i64)0)) {
            ax_lex_lxerror((byte*)"Exponent error");
        };
        if (!!(exponsign)) {
            expon = -(expon);
        };
    };
    expon = (expon - fractlen);
    ax_lex_lxxvalue = (double)0.;
    L1064 :;
    for (i=(i64)1;i<=slen;i+=(i64)1) {
L1065 :;
        c = (i64)((*s)[(i)-1]);
        ax_lex_lxxvalue = ((ax_lex_lxxvalue * (double)10.) + (double)((c - (i64)48)));
L1066 :;
    }L1067 :;
    ;
    if ((expon > (i64)0)) {
        av_1 = expon;
        while (av_1-- > 0) {
L1068 :;
            ax_lex_lxxvalue = (ax_lex_lxxvalue * (double)10.);
L1069 :;
        }L1070 :;
        ;
    } else if ((expon < (i64)0)) {
        av_2 = -(expon);
        while (av_2-- > 0) {
L1071 :;
            ax_lex_lxxvalue = (ax_lex_lxxvalue / (double)10.);
L1072 :;
        }L1073 :;
        ;
    };
    ax_lex_lxsymbol = (i64)15;
}

static void ax_lex_readnumber(i64 c) {
    byte str[256];
    i64 i;
    i64 d;
    i64 intlen;
    i64 slen;
    d = (i64)((*ax_lex_lxsptr));
    if ((d==(i64)120) || (d==(i64)88)) {
        if ((c==(i64)48)) {
            ++ax_lex_lxsptr;
            ax_lex_readhex();
            return;
        }else if ((c==(i64)50)) {
            ++ax_lex_lxsptr;
            ax_lex_readbinary();
            return;
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_i64(c,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            ax_lex_lxerror((byte*)"Base not supported");
        };
    };
    str[((i64)1)-1] = (u64)(c);
    slen = (i64)1;
    intlen = (i64)0;
    L1074 :;
    switch ((int)(c = (i64)((*ax_lex_lxsptr++)))) {
    case 48:;
    case 49:;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
    {
        str[(++slen)-1] = (u64)(c);
    }break;
    case 95:;
    case 39:;
    case 96:;
    {
    }break;
    case 46:;
    {
        intlen = slen;
    }break;
    case 101:;
    case 69:;
    {
        ax_lex_readreal(&str,slen,intlen,(i64)1);
        return;
    }break;
    default: {
        --ax_lex_lxsptr;
        goto L1075 ;
    }
    } /* SW */
goto L1074 ;
L1075 :;
    ;
    if (!!(intlen)) {
        ax_lex_readreal(&str,slen,intlen,(i64)0);
        return;
    };
    if (((slen > (i64)20) || ((slen == (i64)20) && (mlib_cmpstring(str,(byte*)"18446744073709551615") > (i64)0)))) {
        ax_lex_lxerror((byte*)"Overflow in 64-bit value");
    };
    ax_lex_lxsymbol = (i64)14;
    ax_lex_lxvalue = (i64)0;
    L1076 :;
    for (i=(i64)1;i<=slen;i+=(i64)1) {
L1077 :;
        ax_lex_lxvalue = (((ax_lex_lxvalue * (i64)10) + (i64)(str[(i)-1])) - (i64)48);
L1078 :;
    }L1079 :;
    ;
}

static void ax_lex_readbinary(void) {
    i64 ndigs;
    ndigs = (i64)0;
    ax_lex_lxvalue = (i64)0;
    L1080 :;
    switch ((int)((*ax_lex_lxsptr++))) {
    case 48:;
    {
        ax_lex_lxvalue = (ax_lex_lxvalue * (i64)2);
        ++ndigs;
    }break;
    case 49:;
    {
        ax_lex_lxvalue = ((ax_lex_lxvalue * (i64)2) + (i64)1);
        ++ndigs;
    }break;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
    {
        ax_lex_lxerror((byte*)"Bad binary digit");
    }break;
    case 95:;
    case 39:;
    case 96:;
    {
    }break;
    default: {
        --ax_lex_lxsptr;
        goto L1081 ;
    }
    } /* SW */
goto L1080 ;
L1081 :;
    ;
    if ((ndigs == (i64)0)) {
        ax_lex_lxerror((byte*)"No bin digits");
    } else if ((ndigs > (i64)64)) {
        ax_lex_lxerror((byte*)"Overflow in binary number");
    };
    ax_lex_lxsymbol = (i64)14;
}

static void ax_lex_readhex(void) {
    i64 ndigs;
    i64 c;
    ndigs = (i64)0;
    ax_lex_lxvalue = (i64)0;
    L1082 :;
    switch ((int)(c = (i64)((*ax_lex_lxsptr++)))) {
    case 48:;
    case 49:;
    case 50:;
    case 51:;
    case 52:;
    case 53:;
    case 54:;
    case 55:;
    case 56:;
    case 57:;
    {
        ax_lex_lxvalue = (((ax_lex_lxvalue * (i64)16) + c) - (i64)48);
        ++ndigs;
    }break;
    case 65:;
    case 66:;
    case 67:;
    case 68:;
    case 69:;
    case 70:;
    {
        ax_lex_lxvalue = ((ax_lex_lxvalue * (i64)16) + ((c - (i64)65) + (i64)10));
        ++ndigs;
    }break;
    case 97:;
    case 98:;
    case 99:;
    case 100:;
    case 101:;
    case 102:;
    {
        ax_lex_lxvalue = ((ax_lex_lxvalue * (i64)16) + ((c - (i64)97) + (i64)10));
        ++ndigs;
    }break;
    case 95:;
    case 39:;
    case 96:;
    {
    }break;
    default: {
        --ax_lex_lxsptr;
        goto L1083 ;
    }
    } /* SW */
goto L1082 ;
L1083 :;
    ;
    if ((ndigs == (i64)0)) {
        ax_lex_lxerror((byte*)"No hex digits");
    } else if ((ndigs > (i64)16)) {
        ax_lex_lxerror((byte*)"Overflow in hex number");
    };
    ax_lex_lxsymbol = (i64)14;
}

void ax_lex_ps(byte * caption) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str(caption,NULL);
    msysnewc_m_print_str((byte*)":",NULL);
    msysnewc_m_print_end();
    ;
    ax_lex_printsymbol(0);
}

void ax_lex_printsymbol(void * dev) {
    byte str[256];
    i64 av_1;
    strcpy((i8 *)(str),(i8 *)(ax_tables_symbolnames[(ax_lex_lxsymbol)-1]));
    str[(((i64)((u64)(strlen((i8 *)(str)))) - (i64)2))-1] = (u64)0u;
    msysnewc_m_print_startfile(dev);
    msysnewc_m_print_str(str,NULL);
    msysnewc_m_print_end();
    ;
    av_1 = ((i64)14 - (i64)((u64)(strlen((i8 *)(str)))));
    while (av_1-- > 0) {
L1084 :;
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((byte*)" ",NULL);
        msysnewc_m_print_end();
        ;
L1085 :;
    }L1086 :;
    ;
    if ((ax_lex_lxsymbol==(i64)17)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((*ax_lex_lxsymptr).name,NULL);
        msysnewc_m_print_end();
        ;
    }else if ((ax_lex_lxsymbol==(i64)14)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_i64(ax_lex_lxvalue,NULL);
        msysnewc_m_print_end();
        ;
    }else if ((ax_lex_lxsymbol==(i64)15)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_r64(ax_lex_lxxvalue,NULL);
        msysnewc_m_print_end();
        ;
    }else if ((ax_lex_lxsymbol==(i64)16)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str((byte*)"\"",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(ax_lex_lxsvalue,NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((byte*)"\"",NULL);
        msysnewc_m_print_end();
        ;
    }else if ((ax_lex_lxsymbol==(i64)1)) {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_i64(ax_lex_lxvalue,NULL);
        msysnewc_m_print_end();
        ;
    } else {
        msysnewc_m_print_startfile(dev);
        msysnewc_m_print_str(ax_tables_symbolnames[(ax_lex_lxsymbol)-1],NULL);
        msysnewc_m_print_end();
        ;
        if (!!(ax_lex_lxsubcode)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)" ",NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_i64(ax_lex_lxsubcode,NULL);
            msysnewc_m_print_end();
            ;
        };
    };
    msysnewc_m_print_startfile(dev);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

static void ax_lex_clearhashtable(void) {
}

static void ax_lex_inithashtable(void) {
    byte str[32];
    i64 i;
    i64 av_1;
    i64 av_2;
    i64 av_3;
    i64 av_4;
    i64 av_5;
    i64 av_6;
    i64 av_7;
    i64 av_8;
    i64 av_9;
    i64 av_10;
    if (((i64)2097152 > (i64)65536)) {
    };
    ax_lex_clearhashtable();
    L1087 :;
    for (i=(i64)1;i<=(i64)144;i+=(i64)1) {
L1088 :;
        ax_lex_addreservedword((ax_tables_mclnames[(i)-1] + (i64)2),(i64)23,i);
L1089 :;
    }L1090 :;
    ;
    L1091 :;
    for (i=(i64)1;i<=(i64)136;i+=(i64)1) {
L1092 :;
        ax_lex_addreservedword(ax_tables_dregnames[(i)-1],(i64)24,(i64)(ax_tables_regindices[(i)-1]));
        (*ax_lex_lxsymptr).regsize = (u64)(ax_tables_regsizes[(i)-1]);
L1093 :;
    }L1094 :;
    ;
    L1095 :;
    for (i=(i64)1;i<=(i64)16;i+=(i64)1) {
L1096 :;
        ax_lex_addreservedword(ax_tables_xregnames[(i)-1],(i64)25,i);
L1097 :;
    }L1098 :;
    ;
    L1099 :;
    for (i=(i64)1;i<=(i64)8;i+=(i64)1) {
L1100 :;
        ax_lex_addreservedword(ax_tables_fregnames[(i)-1],(i64)26,i);
L1101 :;
    }L1102 :;
    ;
    L1103 :;
    for (i=(i64)1;i<=(i64)8;i+=(i64)1) {
L1104 :;
        ax_lex_addreservedword(ax_tables_mregnames[(i)-1],(i64)27,i);
L1105 :;
    }L1106 :;
    ;
    L1107 :;
    for (i=(i64)1;i<=(i64)18;i+=(i64)1) {
L1108 :;
        ax_lex_addreservedword(ax_tables_jmpccnames[(i)-1],(i64)28,(i64)(ax_tables_jmpcccodes[(i)-1]));
L1109 :;
    }L1110 :;
    ;
    L1111 :;
    for (i=(i64)1;i<=(i64)18;i+=(i64)1) {
L1112 :;
        ax_lex_addreservedword(ax_tables_setccnames[(i)-1],(i64)29,(i64)(ax_tables_setcccodes[(i)-1]));
L1113 :;
    }L1114 :;
    ;
    L1115 :;
    for (i=(i64)1;i<=(i64)18;i+=(i64)1) {
L1116 :;
        ax_lex_addreservedword(ax_tables_cmovccnames[(i)-1],(i64)30,(i64)(ax_tables_cmovcccodes[(i)-1]));
L1117 :;
    }L1118 :;
    ;
    L1119 :;
    for (i=(i64)1;i<=(i64)8;i+=(i64)1) {
L1120 :;
        ax_lex_addreservedword(ax_tables_prefixnames[(i)-1],(i64)31,(i64)(ax_tables_prefixsizes[(i)-1]));
L1121 :;
    }L1122 :;
    ;
    L1123 :;
    for (i=(i64)1;i<=(i64)5;i+=(i64)1) {
L1124 :;
        strcpy((i8 *)(str),(i8 *)(ax_tables_segmentnames[(i)-1]));
        str[(((i64)((u64)(strlen((i8 *)(str)))) - (i64)3))-1] = (u64)0u;
        ax_lex_addreservedword(mlib_pcm_copyheapstring(str),(i64)32,i);
L1125 :;
    }L1126 :;
    ;
    ax_lex_addreservedword((byte*)"aframe",(i64)24,(i64)15);
    (*ax_lex_lxsymptr).regsize = (u64)((i64)4);
    ax_lex_addreservedword((byte*)"dframe",(i64)24,(i64)15);
    (*ax_lex_lxsymptr).regsize = (u64)((i64)8);
    ax_lex_addreservedword((byte*)"astack",(i64)24,(i64)16);
    (*ax_lex_lxsymptr).regsize = (u64)((i64)4);
    ax_lex_addreservedword((byte*)"dstack",(i64)24,(i64)16);
    (*ax_lex_lxsymptr).regsize = (u64)((i64)8);
    ax_lex_addreservedword((byte*)"dprog",(i64)24,(i64)9);
    (*ax_lex_lxsymptr).regsize = (u64)((i64)8);
    ax_lex_addreservedword((byte*)"dsptr",(i64)24,(i64)10);
    (*ax_lex_lxsymptr).regsize = (u64)((i64)8);
}

static void ax_lex_addreservedword(byte * name,i64 symbol,i64 subcode) {
    ax_lex_lxhashvalue = ax_lex_gethashvalue(name);
    if (!!(ax_lex_lookuplex(name,(i64)0))) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"NAME=",NULL);
        msysnewc_m_print_str(name,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        ax_lex_lxerror((byte*)"DUPL NAME");
    };
    (*ax_lex_lxsymptr).symbol = (u64)((i64)0);
    (*ax_lex_lxsymptr).ksymbol = (u64)(symbol);
    (*ax_lex_lxsymptr).subcode = (u64)(subcode);
}

void ax_lex_printhashtable(void * devx,byte * caption) {
    struct ax_decls_strec *  r;
    i64 count;
    i64 i;
    i64 av_1;
    msysnewc_m_print_startfile(devx);
    msysnewc_m_print_str(caption,NULL);
    msysnewc_m_print_str((byte*)":",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    count = (i64)0;
    L1127 :;
    for (i=(i64)0;i<=(i64)2097151;i+=(i64)1) {
L1128 :;
        r = ax_decls_lexhashtable[(i)];
        if ((!!(r) && !!((*r).name))) {
            count += (i64)1;
        };
L1129 :;
    }L1130 :;
    ;
    msysnewc_m_print_startfile(devx);
    msysnewc_m_print_i64(count,NULL);
    msysnewc_m_print_str((byte*)" items in table",NULL);
    msysnewc_m_print_i64((i64)2097152,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

static i64 ax_lex_lookuplex(byte * name,i64 length) {
    i64 j;
    i64 wrapped;
    i64 insource;
    i64 firstj;
    insource = length;
    if ((length == (i64)0)) {
        length = (i64)(strlen((i8 *)(name)));
    };
    firstj = (j = (ax_lex_lxhashvalue & (i64)2097151));
    wrapped = (i64)0;
    L1131 :;
    while (1) {
        ax_lex_lxsymptr = ax_decls_lexhashtable[(j)];
        if ((ax_lex_lxsymptr == 0)) {
            goto L1132 ;
        };
        if ((((i64)((u64)((*ax_lex_lxsymptr).namelen)) == length) && ((i64)(memcmp((void *)((*ax_lex_lxsymptr).name),(void *)(name),(u32)(length))) == (i64)0))) {
            return (i64)1;
        };
        if ((++j > (i64)2097152)) {
            if (!!(wrapped)) {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((byte*)"???????HASHTABLE FULL",NULL);
                msysnewc_m_print_i64((i64)2097152,NULL);
                msysnewc_m_print_i64(ax_decls_lxlineno,NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                exit((i64)1);
            };
            wrapped = (i64)1;
            j = (i64)1;
        };
    }L1132 :;
    ;
    if (!!(insource)) {
        name = ax_lex_makestring(name,length);
    };
    if ((ax_lex_lxsymptr == 0)) {
        ax_lex_lxsymptr = (struct ax_decls_strec *)(mlib_pcm_allocz((i64)104));
        ax_decls_lexhashtable[(j)] = ax_lex_lxsymptr;
    };
    (*ax_lex_lxsymptr).name = name;
    (*ax_lex_lxsymptr).namelen = (u64)(length);
    (*ax_lex_lxsymptr).symbol = (u64)((i64)17);
    (*ax_lex_lxsymptr).ksymbol = (u64)((i64)0);
    (*ax_lex_lxsymptr).htindex = (u64)(j);
    (*ax_lex_lxsymptr).htfirstindex = (u64)(firstj);
    (*ax_lex_lxsymptr).moduleno = ax_decls_currmoduleno;
    return (i64)0;
}

void ax_lex_initsourcefile(byte * source) {
    ax_lex_lxstart = (ax_lex_lxsptr = (byte *)(source));
    ax_decls_lxlineno = (i64)1;
}

struct ax_decls_strec * ax_lex_addnamestr(byte * name) {
    ax_lex_lxhashvalue = ax_lex_gethashvalue(name);
    ax_lex_lookuplex(mlib_pcm_copyheapstring(name),(i64)0);
    return ax_lex_lxsymptr;
}

void ax_lex_lxerror(byte * m) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_setfmt((byte*)"\r\n\r\n Lexical Error\n*** # *** on line #");
    msysnewc_m_print_str(m,NULL);
    msysnewc_m_print_i64(ax_decls_lxlineno,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    exit((i64)1);
}

static i64 ax_lex_gethashvalue(byte * s) {
    i64 hsum;
    i64 csum;
    i64 c;
    hsum = (csum = (i64)0);
    L1133 :;
    while (!!((c = (i64)((*s++))))) {
        csum += c;
        hsum = ((hsum << (i64)3) + csum);
L1134 :;
    }L1135 :;
    ;
    return ((hsum << (i64)5) ^ csum);
}

void ax_lex_skiptoeol(void) {
    L1136 :;
    do {
        ax_lex_lex();
L1137 :;
    } while (!((ax_lex_lxsymbol == (i64)11) || (ax_lex_lxsymbol == (i64)12)));L1138 :;
    ;
}

static byte * ax_lex_makestring(byte * p,i64 length) {
    byte *  s;
    s = (byte *)(mlib_pcm_alloc((length + (i64)1)));
    memcpy((void *)(s),(void *)(p),(u32)(length));
    (*(s + length)) = (u64)0u;
    return s;
}

void ax_parse_readmodule(i64 moduleno) {
    struct ax_decls_strec *  symptr;
    i64 sym;
    ax_lex_initsourcefile(ax_decls_moduletable[(moduleno)-1].source);
    ax_lex_lxsymbol = (i64)11;
    ax_lib_genmc((i64)115,ax_lib_genint((i64)1,(i64)4),(struct ax_decls_opndrec *)(0));
    L1139 :;
    while ((ax_lex_lxsymbol == (i64)11)) {
        ax_lex_lex();
        switch ((int)ax_lex_lxsymbol) {
        case 23:;
        {
            ax_parse_readinstr();
        }break;
        case 17:;
        {
            symptr = ax_lex_lxsymptr;
            ax_lex_lex();
            sym = ax_lex_lxsymbol;
            if ((sym==(i64)10)) {
                ax_lex_lex();
                ax_lib_createnamedconst(symptr,ax_parse_readexpression());
            }else if ((sym==(i64)3) || (sym==(i64)4)) {
                ax_lib_createlabel(symptr,((sym == (i64)3)?(i64)20:(i64)22));
                ax_lib_genmc((i64)4,ax_lib_genlab(symptr,(i64)4),(struct ax_decls_opndrec *)(0));
                (*symptr).reftype = (u64)((i64)1);
                ax_lex_lxsymbol = (i64)11;
                goto L1139 ;
            } else {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((*symptr).name,NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
                ax_lib_serror((byte*)"colon expected after label");
            };
        }break;
        case 19:;
        {
            symptr = ax_lex_lxsymptr;
            ax_lex_lex();
            if ((ax_lex_lxsymbol==(i64)10)) {
                ax_lib_serror_s((byte*)"Redefining label as const: %s",(*symptr).name);
            }else if ((ax_lex_lxsymbol==(i64)3) || (ax_lex_lxsymbol==(i64)4)) {
                (*symptr).fwdrefs = (struct ax_decls_fwdrec *)(0);
                ax_lib_genmc((i64)4,ax_lib_genlab(symptr,(i64)4),(struct ax_decls_opndrec *)(0));
                (*symptr).symbol = ((ax_lex_lxsymbol == (i64)3)?(u64)((i64)20):(u64)((i64)22));
                (*symptr).reftype = (u64)((i64)1);
                ax_lex_lxsymbol = (i64)11;
                goto L1139 ;
            } else {
                ax_lib_serror((byte*)"Instruction expected");
            };
        }break;
        case 21:;
        {
            ax_lib_serror_s((byte*)"Defining imported name: %s",(*symptr).name);
        }break;
        case 20:;
        case 22:;
        {
            ax_lib_serror_s((byte*)"Redefining symbol: %s",(*symptr).name);
        }break;
        case 18:;
        {
            ax_lib_serror_s((byte*)"2:Const redefined: %s",(*symptr).name);
        }break;
        case 28:;
        {
            ax_parse_readcondinstr((i64)23);
        }break;
        case 29:;
        {
            ax_parse_readcondinstr((i64)55);
        }break;
        case 30:;
        {
            ax_parse_readcondinstr((i64)13);
        }break;
        case 11:;
        {
        }break;
        case 12:;
        {
            return;
        }break;
        default: {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)"Unknown symbol:",NULL);
            msysnewc_m_print_str(ax_tables_symbolnames[(ax_lex_lxsymbol)-1],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        }
        } /* SW */
;
L1140 :;
    }L1141 :;
    ;
    ax_lib_serror((byte*)"EOL expected");
}

void ax_parse_checkundefined(void) {
    struct ax_decls_strec *  d;
    d = ax_decls_modulenamelist;
    L1142 :;
    while (!!(d)) {
        if (((i64)((u64)((*d).symbol)) == (i64)19)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)"Undefined:",NULL);
            msysnewc_m_print_str(mlib_padstr((*d).name,(i64)20,(byte*)" "),NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            ++ax_decls_nundefined;
        };
        d = (*d).nextdef;
L1143 :;
    }L1144 :;
    ;
}

static void ax_parse_checksymbol(i64 symbol) {
    byte str[265];
    if ((ax_lex_lxsymbol != symbol)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_setfmt((byte*)"# expected not #");
        msysnewc_m_print_str(ax_tables_symbolnames[(symbol)-1],NULL);
        msysnewc_m_print_str(ax_tables_symbolnames[(ax_lex_lxsymbol)-1],NULL);
        msysnewc_m_print_end();
        ;
        ax_lib_serror(str);
    };
}

static void ax_parse_readinstr(void) {
    i64 opcode;
    struct ax_decls_opndrec *  a;
    struct ax_decls_opndrec *  b;
    struct ax_decls_opndrec *  c;
    opcode = ax_lex_lxsubcode;
    ax_lex_lex();
    switch ((int)opcode) {
    case 110:;
    case 111:;
    case 112:;
    case 113:;
    case 114:;
    {
        L1145 :;
        while (1) {
            if ((ax_lex_lxsymbol == (i64)16)) {
                a = ax_lib_genstrimm(ax_lex_lxsvalue);
                ax_lex_lex();
                ax_lib_genmc(opcode,a,(struct ax_decls_opndrec *)(0));
            } else {
                a = ax_parse_readoperand();
                ax_lib_genmc(opcode,a,(struct ax_decls_opndrec *)(0));
            };
            if ((ax_lex_lxsymbol == (i64)2)) {
                ax_lex_lex();
            } else {
                goto L1146 ;
            };
        }L1146 :;
        ;
    }break;
    case 115:;
    {
        ax_parse_checksymbol((i64)32);
        ax_lib_genmc((i64)115,ax_lib_genint(ax_lex_lxsubcode,(i64)4),(struct ax_decls_opndrec *)(0));
        ax_lex_lex();
    }break;
    case 116:;
    {
        ax_lib_genmc((i64)115,ax_lib_genint((i64)2,(i64)4),(struct ax_decls_opndrec *)(0));
    }break;
    case 117:;
    {
        ax_lib_genmc((i64)115,ax_lib_genint((i64)3,(i64)4),(struct ax_decls_opndrec *)(0));
    }break;
    case 118:;
    {
        ax_lib_genmc((i64)115,ax_lib_genint((i64)1,(i64)4),(struct ax_decls_opndrec *)(0));
    }break;
    case 32:;
    {
        a = ax_parse_readoperand();
        ax_parse_checksymbol((i64)2);
        ax_lex_lex();
        b = ax_parse_readoperand();
        ax_parse_checksymbol((i64)2);
        ax_lex_lex();
        c = ax_parse_readoperand();
        ax_lib_serror((byte*)"IMUL3 CAN'T DO 3 OPNDS");
    }break;
    case 86:;
    case 87:;
    {
        a = ax_parse_readoperand();
        ax_parse_checksymbol((i64)2);
        ax_lex_lex();
        b = ax_parse_readoperand();
        ax_parse_checksymbol((i64)2);
        ax_lex_lex();
        c = ax_parse_readoperand();
        if (((i64)((u64)((*c).mode)) != (i64)2)) {
            ax_lib_serror((byte*)"pcmpistr/not int");
        };
        ax_lib_genmc(opcode,a,b);
        (*ax_lib_mccodex).c = (u64)((*c).value);
    }break;
    case 8:;
    {
        L1147 :;
        do {
            ax_lex_lex();
L1148 :;
        } while (!(ax_lex_lxsymbol == (i64)11));L1149 :;
        ;
    }break;
    default: {
        a = (b = (struct ax_decls_opndrec *)(0));
        if ((ax_lex_lxsymbol != (i64)11)) {
            a = ax_parse_readoperand();
            if ((ax_lex_lxsymbol == (i64)2)) {
                ax_lex_lex();
                b = ax_parse_readoperand();
            };
        };
        ax_lib_genmc(opcode,a,b);
    }
    } /* SW */
;
}

static void ax_parse_readcondinstr(i64 opc) {
    struct ax_decls_opndrec *  a;
    struct ax_decls_opndrec *  b;
    a = ax_lib_genint(ax_lex_lxsubcode,(i64)4);
    ax_lex_lex();
    b = ax_parse_readoperand();
    if (((ax_lex_lxsymbol == (i64)2) && (opc == (i64)13))) {
        ax_lib_genmc((i64)6,b,(struct ax_decls_opndrec *)(0));
        ax_lex_lex();
        b = ax_parse_readoperand();
    };
    ax_lib_genmc(opc,a,b);
}

static struct ax_decls_opndrec * ax_parse_readoperand(void) {
    struct ax_decls_opndrec *  p;
    i64 size;
    switch ((int)ax_lex_lxsymbol) {
    case 24:;
    {
        p = ax_lib_regtable[(ax_lex_lxsubcode)-1][((i64)((*ax_lex_lxsymptr).regsize))-1];
        ax_lex_lex();
        return p;
    }break;
    case 5:;
    {
        ax_lex_lex();
        return ax_parse_readaddrmode((i64)0);
    }break;
    case 25:;
    {
        p = ax_lib_genxreg(ax_lex_lxsubcode);
        ax_lex_lex();
        return p;
    }break;
    case 31:;
    {
        size = ax_lex_lxsubcode;
        ax_lex_lex();
        ax_parse_checksymbol((i64)5);
        ax_lex_lex();
        return ax_parse_readaddrmode(size);
    }break;
    default: {
        return ax_parse_readexpression();
    }
    } /* SW */
;
    return (struct ax_decls_opndrec *)(0);
}

static struct ax_decls_opndrec * ax_parse_readexpression(void) {
    struct ax_decls_strec *  labelx;
    i64 valuex;
    i64 typex;
    ax_parse_readterm();
    L1150 :;
    if ((ax_lex_lxsymbol==(i64)7)) {
        labelx = ax_parse_exprlabeldef;
        valuex = ax_parse_exprvalue;
        typex = ax_parse_exprtype;
        ax_lex_lex();
        ax_parse_readterm();
        if (!!(ax_parse_exprlabeldef)) {
            ax_lib_serror((byte*)"+label?");
        };
        ax_parse_exprlabeldef = labelx;
        if ((!!(typex) || !!(ax_parse_exprtype))) {
            ax_lib_serror((byte*)"add real");
        };
        ax_parse_exprvalue += valuex;
    }else if ((ax_lex_lxsymbol==(i64)8)) {
        labelx = ax_parse_exprlabeldef;
        valuex = ax_parse_exprvalue;
        typex = ax_parse_exprtype;
        ax_lex_lex();
        ax_parse_readterm();
        if (!!(ax_parse_exprlabeldef)) {
            ax_lib_serror((byte*)"+label?");
        };
        ax_parse_exprlabeldef = labelx;
        if ((!!(typex) || !!(ax_parse_exprtype))) {
            ax_lib_serror((byte*)"sub real");
        };
        ax_parse_exprvalue = (valuex - ax_parse_exprvalue);
    } else {
        goto L1151 ;
    }goto L1150 ;
L1151 :;
    ;
    return ax_lib_genimm_expr(ax_parse_exprlabeldef,ax_parse_exprvalue,ax_parse_exprtype,(i64)4);
}

static void ax_parse_readterm(void) {
    struct ax_decls_strec *  symptr;
    double x;
    ax_parse_exprlabeldef = (struct ax_decls_strec *)(0);
    ax_parse_exprvalue = (i64)0;
    ax_parse_exprtype = (i64)0;
    switch ((int)ax_lex_lxsymbol) {
    case 19:;
    case 20:;
    case 22:;
    {
        ax_parse_exprlabeldef = ax_lex_lxsymptr;
        ax_lex_lex();
        if ((ax_lex_lxsymbol == (i64)9)) {
            ax_lib_serror((byte*)"* applied to non-extern label or applied inconsistently");
        };
    }break;
    case 21:;
    {
        ax_parse_exprlabeldef = ax_lex_lxsymptr;
        ax_lex_lex();
        if ((ax_lex_lxsymbol != (i64)9)) {
            ax_lib_serror((byte*)"* missing or applied inconsistently");
        };
        ax_lex_lex();
    }break;
    case 18:;
    {
        ax_parse_exprlabeldef = (*(*ax_lex_lxsymptr).expr).labeldef;
        ax_parse_exprvalue = (*(*ax_lex_lxsymptr).expr).value;
        ax_parse_exprtype = (i64)((*(*ax_lex_lxsymptr).expr).valtype);
        ax_lex_lex();
    }break;
    case 17:;
    {
        symptr = ax_lex_lxsymptr;
        ax_parse_exprlabeldef = symptr;
        ax_lex_lex();
        if ((ax_lex_lxsymbol == (i64)9)) {
            ax_lib_createlabel(symptr,(i64)21);
            ax_lex_lex();
        } else {
            ax_lib_createlabel(symptr,(i64)19);
        };
    }break;
    case 14:;
    {
        ax_parse_exprvalue = ax_lex_lxvalue;
        ax_lex_lex();
    }break;
    case 15:;
    {
        ax_parse_exprvalue = *(i64*)&ax_lex_lxxvalue;
        ax_parse_exprtype = (i64)82;
        ax_lex_lex();
    }break;
    case 8:;
    {
        ax_lex_lex();
        ax_parse_readterm();
        if (!(!!(ax_parse_exprlabeldef))) {
            if (!(!!(ax_parse_exprtype))) {
                ax_parse_exprvalue = -(ax_parse_exprvalue);
            } else {
                x = -(*(double*)&ax_parse_exprvalue);
                ax_parse_exprvalue = *(i64*)&x;
            };
        } else {
            ax_lib_serror((byte*)"neg/label");
        };
    }break;
    case 7:;
    {
        ax_lex_lex();
        ax_parse_readterm();
    }break;
    default: {
        ax_lib_serror((byte*)"READTERM");
    }
    } /* SW */
;
}

static void ax_parse_readreg(i64 * reg,i64 * regsize,i64 * scale) {
    (*reg) = ax_lex_lxsubcode;
    (*regsize) = (i64)((*ax_lex_lxsymptr).regsize);
    ax_lex_lex();
    if ((ax_lex_lxsymbol == (i64)9)) {
        ax_lex_lex();
        ax_parse_checksymbol((i64)14);
        if ((ax_lex_lxvalue==(i64)1) || (ax_lex_lxvalue==(i64)2) || (ax_lex_lxvalue==(i64)4) || (ax_lex_lxvalue==(i64)8)) {
        } else {
            ax_lib_serror((byte*)"*n must be 1,2,4,8");
        };
        (*scale) = ax_lex_lxvalue;
        ax_lex_lex();
    } else {
        (*scale) = (i64)0;
    };
}

static struct ax_decls_opndrec * ax_parse_readaddrmode(i64 size) {
    i64 reg;
    i64 regsize;
    i64 scale;
    i64 regix;
    i64 regixsize;
    i64 scaleix;
    struct ax_decls_opndrec *  x;
    struct ax_decls_opndrec *  p;
    reg = (regix = (i64)0);
    regsize = (regixsize = (i64)0);
    scale = (scaleix = (i64)0);
    x = (struct ax_decls_opndrec *)(0);
    if ((ax_lex_lxsymbol == (i64)24)) {
        ax_parse_readreg(&reg,&regsize,&scale);
        if ((ax_lex_lxsymbol==(i64)7)) {
            ax_lex_lex();
            if ((ax_lex_lxsymbol == (i64)24)) {
                ax_parse_readreg(&regix,&regixsize,&scaleix);
                if ((ax_lex_lxsymbol==(i64)7) || (ax_lex_lxsymbol==(i64)8)) {
                    x = ax_parse_readexpression();
                };
            } else {
                x = ax_parse_readexpression();
            };
        }else if ((ax_lex_lxsymbol==(i64)8)) {
            x = ax_parse_readexpression();
        };
    } else {
        x = ax_parse_readexpression();
    };
    if ((!!(scale) && !!(scaleix))) {
        ax_lib_serror((byte*)"Two *N scales");
    };
    if ((((reg == (i64)0) && (regix == (i64)0)) && !!((i64)0))) {
        ax_lib_serror((byte*)"Empty address mode");
    };
    ax_parse_checksymbol((i64)6);
    ax_lex_lex();
    if ((!!(scale) && !(!!(scaleix)))) {
        {i64 temp = reg; reg = regix; regix = temp; };
        {i64 temp = regsize; regsize = regixsize; regixsize = temp; };
        {i64 temp = scale; scale = scaleix; scaleix = temp; };
    };
    if ((scaleix == (i64)0)) {
        scaleix = (i64)1;
    };
    if (((!!(regsize) && !!(regixsize)) && (regsize != regixsize))) {
        ax_lib_serror((byte*)"Addr reg size mismatch");
    };
    p = ax_lib_genindex(reg,regix,scaleix,x,size,(((regsize == (i64)4) || (regixsize == (i64)4))?(i64)4:(i64)8));
    return p;
}

void ax_lib_initlib(void) {
    i64 reg;
    i64 size;
    ax_lib_zero_opnd = ax_lib_genint((i64)0,(i64)4);
    L1152 :;
    for (reg=(i64)1;reg<=(i64)16;reg+=(i64)1) {
L1153 :;
        L1156 :;
        for (size=(i64)1;size<=(i64)8;size+=(i64)1) {
L1157 :;
            if ((size==(i64)1) || (size==(i64)2) || (size==(i64)4) || (size==(i64)8)) {
                ax_lib_regtable[(reg)-1][(size)-1] = ax_lib_genreg0(reg,size);
            };
L1158 :;
        }L1159 :;
        ;
L1154 :;
    }L1155 :;
    ;
    L1160 :;
    for (reg=(i64)17;reg<=(i64)20;reg+=(i64)1) {
L1161 :;
        ax_lib_regtable[(reg)-1][((i64)1)-1] = ax_lib_genreg0(reg,(i64)1);
L1162 :;
    }L1163 :;
    ;
    ax_decls_ss_symboltable = (struct ax_decls_strec * (*)[])(mlib_pcm_alloc((i64)65536));
    ax_decls_ss_symboltablesize = (i64)16384;
    ax_decls_ss_nsymbols = (i64)0;
}

void ax_lib_genmc(i64 opcode,struct ax_decls_opndrec * a,struct ax_decls_opndrec * b) {
    struct ax_lib_mclrec *  m;
    i64 nopnds;
    m = (struct ax_lib_mclrec *)(mlib_pcm_alloc((i64)24));
    ++ax_decls_nmclasm;
    (*m).nextmcl = (struct ax_lib_mclrec *)(0);
    if ((ax_lex_lxsymbol == (i64)11)) {
        (*m).lineno = (ax_decls_lxlineno - (i64)1);
    } else {
        (*m).lineno = ax_decls_lxlineno;
    };
    (*m).opcode = (u64)(opcode);
    nopnds = ((a == 0)?(i64)0:((b == 0)?(i64)1:(i64)2));
    if (((nopnds == (i64)2) && ((opcode == (i64)86) || (opcode == (i64)87)))) {
        nopnds = (i64)3;
    };
    if ((nopnds < (i64)((u64)(ax_tables_mclnopnds[(opcode)-1])))) {
        ax_lib_serror((byte*)"Too few operands");
    } else if ((nopnds > (i64)((u64)(ax_tables_mclnopnds[(opcode)-1])))) {
        ax_lib_serror((byte*)"Too many operands");
    };
    (*m).a = a;
    (*m).b = b;
    if (!!(ax_lib_mccode)) {
        (*ax_lib_mccodex).nextmcl = m;
        ax_lib_mccodex = m;
    } else {
        ax_lib_mccode = (ax_lib_mccodex = m);
    };
}

void ax_lib_genmcstr(i64 opcode,byte * s) {
    ax_lib_genmc(opcode,ax_lib_genstrimm(s),(struct ax_decls_opndrec *)(0));
}

static struct ax_decls_opndrec * ax_lib_newopnd(i64 mode) {
    struct ax_decls_opndrec *  a;
    ++ax_decls_nmclopndsasm;
    a = (struct ax_decls_opndrec *)(mlib_pcm_allocz((i64)20));
    (*a).mode = (u64)(mode);
    return a;
}

struct ax_decls_opndrec * ax_lib_genxreg(i64 xreg) {
    struct ax_decls_opndrec *  a;
    a = ax_lib_newopnd((i64)5);
    (*a).reg = (u64)(xreg);
    (*a).size = (u64)((i64)16);
    return a;
}

struct ax_decls_opndrec * ax_lib_genindex(i64 areg,i64 ireg,i64 scale,struct ax_decls_opndrec * x,i64 size,i64 addrsize) {
    struct ax_decls_opndrec *  a;
    if (!!(x)) {
        a = x;
        (*x).mode = (u64)((i64)3);
    } else {
        a = ax_lib_newopnd((i64)3);
    };
    (*a).reg = (u64)(areg);
    (*a).regix = (u64)(ireg);
    (*a).scale = (u64)(scale);
    (*a).size = (u64)(size);
    (*a).addrsize = (u64)(addrsize);
    return a;
}

struct mlib_strbuffer * ax_lib_writemclblock(void) {
    i64 i;
    struct ax_lib_mclrec *  m;
    mlib_gs_init(ax_lib_dest);
    mlib_gs_strln(ax_lib_dest,(byte*)"MC CODE");
    m = ax_lib_mccode;
    i = (i64)1;
    L1164 :;
    while (!!(m)) {
        ax_lib_writemcl(i,m);
        m = (*m).nextmcl;
        ++i;
L1165 :;
    }L1166 :;
    ;
    return ax_lib_dest;
}

void ax_lib_gencomment(byte * s) {
    if ((s == 0)) {
        ax_lib_genmc((i64)2,(struct ax_decls_opndrec *)(0),(struct ax_decls_opndrec *)(0));
    } else {
        ax_lib_genmcstr((i64)1,s);
    };
}

struct ax_decls_opndrec * ax_lib_genstrimm(byte * s) {
    struct ax_decls_opndrec *  a;
    a = ax_lib_newopnd((i64)6);
    (*a).svalue = s;
    return a;
}

static byte * ax_lib_getsizetag(i64 size) {
    if ((size==(i64)1)) {
        return (byte*)"b";
    }else if ((size==(i64)2)) {
        return (byte*)"h";
    }else if ((size==(i64)4)) {
        return (byte*)"w";
    }else if ((size==(i64)8)) {
        return (byte*)"d";
    };
    ax_lib_gerror((byte*)"GETSIZETAG?");
    return (byte *)(0);
}

static void ax_lib_writemcl(i64 index,struct ax_lib_mclrec * mcl) {
    byte mclstr[512];
    byte str[512];
    byte *  semi;
    strcpy((i8 *)(mclstr),(i8 *)(ax_lib_strmcl(mcl)));
    if (((i64)(mclstr[((i64)1)-1]) == (i64)0)) {
        return;
    };
    if (((i64)((*mcl).opcode)==(i64)1)) {
        semi = (byte*)";";
    } else {
        semi = (byte*)" ";
    };
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str(semi,(byte*)"z3");
    msysnewc_m_print_i64(index,(byte*)"z4");
    msysnewc_m_print_nogap();
    msysnewc_m_print_str((byte*)" ",NULL);
    msysnewc_m_print_end();
    ;
    mlib_gs_str(ax_lib_dest,str);
    mlib_gs_strln(ax_lib_dest,mclstr);
}

byte * ax_lib_strmcl(struct ax_lib_mclrec * mcl) {
    static byte str[512];
    byte str2[128];
    i64 opcode;
    i64 sizepref;
    opcode = (i64)((*mcl).opcode);
    if ((opcode==(i64)7)) {
        return (*(*mcl).a).svalue;
    }else if ((opcode==(i64)2)) {
        return (byte*)"";
    }else if ((opcode==(i64)1)) {
        strcpy((i8 *)(str),(i8 *)((byte*)";"));
        strcat((i8 *)(str),(i8 *)((*(*mcl).a).svalue));
        return str;
    }else if ((opcode==(i64)4)) {
        strcpy((i8 *)(str),(i8 *)((*(*(*mcl).a).labeldef).name));
        strcat((i8 *)(str),(i8 *)((byte*)":"));
        return str;
    };
    strcpy((i8 *)(str),(i8 *)((byte*)"\t\t"));
    if ((opcode==(i64)23)) {
        strcat((i8 *)(str),(i8 *)((byte*)"j"));
        strcat((i8 *)(str),(i8 *)(ax_tables_condnames[((*(*mcl).a).value)]));
    }else if ((opcode==(i64)55)) {
        strcat((i8 *)(str),(i8 *)((byte*)"set"));
        strcat((i8 *)(str),(i8 *)(ax_tables_condnames[((*(*mcl).a).value)]));
    }else if ((opcode==(i64)13)) {
        strcat((i8 *)(str),(i8 *)((byte*)"cmov"));
        strcat((i8 *)(str),(i8 *)(ax_tables_condnames[((*(*mcl).a).value)]));
    } else {
        strcat((i8 *)(str),(i8 *)((ax_tables_mclnames[(opcode)-1] + (i64)2)));
    };
    mlib_ipadstr(str,(i64)12,(byte*)" ");
    if ((!!((*mcl).a) && !!((*mcl).b))) {
        sizepref = ax_lib_needsizeprefix((i64)((*mcl).opcode),(*mcl).a,(*mcl).b);
        strcat((i8 *)(str),(i8 *)(ax_lib_stropnd((*mcl).a,sizepref)));
        strcat((i8 *)(str),(i8 *)((byte*)",\t"));
        strcat((i8 *)(str),(i8 *)(ax_lib_stropnd((*mcl).b,sizepref)));
    } else if (!!((*mcl).a)) {
        if (((i64)((u64)((*mcl).opcode)) == (i64)19)) {
            strcat((i8 *)(str),(i8 *)(ax_lib_stropnd((*mcl).a,(i64)0)));
        } else {
            strcat((i8 *)(str),(i8 *)(ax_lib_stropnd((*mcl).a,(i64)1)));
        };
    };
    if ((opcode==(i64)86) || (opcode==(i64)87)) {
        msysnewc_m_print_startstr(str2);
        msysnewc_m_print_setfmt((byte*)", #");
        msysnewc_m_print_u64((*mcl).c,NULL);
        msysnewc_m_print_end();
        ;
        strcat((i8 *)(str),(i8 *)(str2));
    };
    return str;
}

byte * ax_lib_stropnd(struct ax_decls_opndrec * a,i64 sizeprefix) {
    static byte str[256];
    byte *  plus;
    byte *  s;
    i64 value;
    struct ax_decls_strec *  d;
    if (((i64)((*a).mode)==(i64)1)) {
        return ax_lib_getregname((i64)((*a).reg),(i64)((*a).size));
    }else if (((i64)((*a).mode)==(i64)2)) {
        d = (*a).labeldef;
        value = (*a).value;
        if (!!(d)) {
            if (((i64)((u64)((*d).symbol)) == (i64)18)) {
                return ax_lib_inttostr((*(*d).expr).value);
            };
            s = ax_lib_getfullname(d);
            if (!!(value)) {
                if ((value > (i64)0)) {
                    strcpy((i8 *)(str),(i8 *)(s));
                    strcat((i8 *)(str),(i8 *)((byte*)"+"));
                    strcat((i8 *)(str),(i8 *)(ax_lib_inttostr(value)));
                } else {
                    strcpy((i8 *)(str),(i8 *)(s));
                    strcat((i8 *)(str),(i8 *)(ax_lib_inttostr(value)));
                };
                return str;
            } else {
                strcpy((i8 *)(str),(i8 *)(s));
                return str;
            };
        };
        if (((i64)((u64)((*a).valtype)) == (i64)0)) {
            return ax_lib_inttostr(value);
        } else {
            return ax_lib_realtostr(*(double*)&value);
        };
    }else if (((i64)((*a).mode)==(i64)3)) {
        str[((i64)1)-1] = (u64)0u;
        strcat((i8 *)(str),(i8 *)(ax_lib_getsizeprefix((i64)((*a).size),sizeprefix)));
        strcat((i8 *)(str),(i8 *)((byte*)"["));
        plus = (byte*)"";
        if (!!((u64)((*a).reg))) {
            strcat((i8 *)(str),(i8 *)(ax_lib_getregname((i64)((*a).reg),(i64)((*a).addrsize))));
            plus = (byte*)"+";
        };
        if (!!((u64)((*a).regix))) {
            strcat((i8 *)(str),(i8 *)(plus));
            strcat((i8 *)(str),(i8 *)(ax_lib_getregname((i64)((*a).regix),(i64)((*a).addrsize))));
            plus = (byte*)"+";
            if (((i64)((u64)((*a).scale)) > (i64)1)) {
                strcat((i8 *)(str),(i8 *)((byte*)"*"));
                strcat((i8 *)(str),(i8 *)(ax_lib_inttostr((i64)((*a).scale))));
            };
        };
        if (!!((*a).labeldef)) {
            strcat((i8 *)(str),(i8 *)(plus));
            strcat((i8 *)(str),(i8 *)(ax_lib_strdef((*a).labeldef)));
            plus = (byte*)"+";
        };
        if (((*a).value > (i64)0)) {
            strcat((i8 *)(str),(i8 *)(plus));
            strcat((i8 *)(str),(i8 *)(ax_lib_inttostr((*a).value)));
        } else if (((*a).value < (i64)0)) {
            strcat((i8 *)(str),(i8 *)(ax_lib_inttostr((*a).value)));
        };
        strcat((i8 *)(str),(i8 *)((byte*)"]"));
    }else if (((i64)((*a).mode)==(i64)6)) {
        if (((i64)((u64)(strlen((i8 *)((*a).svalue)))) >= (i64)256)) {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_str((byte*)"\"<Long string>\"",NULL);
            msysnewc_m_print_end();
            ;
        } else {
            msysnewc_m_print_startstr(str);
            msysnewc_m_print_str((byte*)"\"",NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str((*a).svalue,NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str((byte*)"\"",NULL);
            msysnewc_m_print_end();
            ;
        };
    }else if (((i64)((*a).mode)==(i64)4)) {
        return ax_lib_opndnames[((*a).value)];
    }else if (((i64)((*a).mode)==(i64)5)) {
        return ax_lib_xgetregname((i64)((*a).reg));
    } else {
        return (byte*)"<BAD OPND>";
    };
    return str;
}

static byte * ax_lib_strdef(struct ax_decls_strec * def) {
    if (((i64)((u64)((*def).symbol)) == (i64)18)) {
        return ax_lib_inttostr((*(*def).expr).value);
    };
    return ax_lib_getfullname(def);
}

void ax_lib_setsegment(i64 seg) {
    if ((seg == ax_lib_currsegment)) {
        return;
    };
    if ((seg==(i64)68)) {
        ax_lib_genmcstr((i64)115,(byte*)".data");
    }else if ((seg==(i64)90)) {
        ax_lib_genmcstr((i64)115,(byte*)".bss");
    }else if ((seg==(i64)67)) {
        ax_lib_genmcstr((i64)115,(byte*)".text");
    }else if ((seg==(i64)82)) {
        ax_lib_genmcstr((i64)115,(byte*)".rodata");
    };
    ax_lib_currsegment = seg;
}

static byte * ax_lib_getsizeprefix(i64 size,i64 enable) {
    if (!(!!(enable))) {
        return (byte*)"";
    };
    if ((size==(i64)1)) {
        return (byte*)"byte ";
    }else if ((size==(i64)2)) {
        return (byte*)"word ";
    }else if ((size==(i64)4)) {
        return (byte*)"dword ";
    }else if ((size==(i64)8)) {
        return (byte*)"qword ";
    }else if ((size==(i64)0)) {
        return (byte*)"";
    };
    return (byte*)"N:";
}

static i64 ax_lib_needsizeprefix(i64 opcode,struct ax_decls_opndrec * a,struct ax_decls_opndrec * b) {
    if ((opcode==(i64)16) || (opcode==(i64)17)) {
        return (i64)1;
    }else if ((opcode==(i64)80) || (opcode==(i64)81)) {
        return (i64)1;
    };
    if ((((((i64)((u64)((*a).mode)) == (i64)1) || ((i64)((u64)((*a).mode)) == (i64)5)) || ((i64)((u64)((*b).mode)) == (i64)1)) || ((i64)((u64)((*b).mode)) == (i64)5))) {
        return (i64)0;
    };
    return (i64)1;
}

struct ax_decls_opndrec * ax_lib_genimm_expr(struct ax_decls_strec * d,i64 value,i64 t,i64 size) {
    struct ax_decls_opndrec *  a;
    a = ax_lib_newopnd((i64)2);
    (*a).size = (u64)(size);
    (*a).labeldef = d;
    (*a).value = value;
    (*a).valtype = (u64)(t);
    return a;
}

struct ax_decls_opndrec * ax_lib_genint(i64 x,i64 size) {
    struct ax_decls_opndrec *  a;
    a = ax_lib_newopnd((i64)2);
    (*a).size = (u64)(size);
    (*a).value = x;
    return a;
}

struct ax_decls_opndrec * ax_lib_genlab(struct ax_decls_strec * d,i64 size) {
    struct ax_decls_opndrec *  a;
    a = ax_lib_newopnd((i64)2);
    (*a).size = (u64)(size);
    (*a).labeldef = d;
    return a;
}

struct ax_decls_opndrec * ax_lib_genmem(struct ax_decls_strec * d,i64 size) {
    struct ax_decls_opndrec *  a;
    a = ax_lib_genlab(d,size);
    (*a).mode = (u64)((i64)3);
    return a;
}

struct ax_decls_opndrec * ax_lib_genreg0(i64 reg,i64 size) {
    struct ax_decls_opndrec *  a;
    a = ax_lib_newopnd((i64)1);
    (*a).reg = (u64)(reg);
    (*a).size = (u64)(size);
    return a;
}

byte * ax_lib_getfullname(struct ax_decls_strec * d) {
    static byte str[256];
    byte *  ms;
    ms = (byte*)"";
    if (!!((*d).basedef)) {
        ms = (*(*d).basedef).name;
    };
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_setfmt((byte*)"<# : ## &:# SYM:## M:#>");
    msysnewc_m_print_str((*d).name,NULL);
    msysnewc_m_print_str((byte*)"#",NULL);
    msysnewc_m_print_i64((*d).moduleno,NULL);
    msysnewc_m_print_ptr(d,(byte*)"8");
    msysnewc_m_print_i64(((i64)((u64)(strlen((i8 *)(ax_tables_symbolnames[((i64)((*d).symbol))-1])))) - (i64)3),(byte*)"v");
    msysnewc_m_print_str(ax_tables_symbolnames[((i64)((*d).symbol))-1],(byte*)".*");
    msysnewc_m_print_str(ms,NULL);
    msysnewc_m_print_end();
    ;
    return str;
    return (*d).name;
}

byte * ax_lib_getregname(i64 reg,i64 size) {
    byte *  prefix;
    byte *  rs;
    static byte str[32];
    if ((reg==(i64)0)) {
        return (byte*)"-";
    }else if ((reg==(i64)15)) {
        rs = (byte*)"frame";
    }else if ((reg==(i64)16)) {
        rs = (byte*)"stack";
    } else {
        rs = ax_lib_inttostr((reg - (i64)1));
    };
    if ((size==(i64)1)) {
        prefix = (byte*)"B";
    }else if ((size==(i64)2)) {
        prefix = (byte*)"W";
    }else if ((size==(i64)4)) {
        prefix = (byte*)"A";
    } else {
        prefix = (byte*)"D";
    };
    strcpy((i8 *)(str),(i8 *)(prefix));
    strcat((i8 *)(str),(i8 *)(rs));
    return str;
}

byte * ax_lib_xgetregname(i64 reg) {
    static byte str[16];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str((byte*)"xmm",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_i64((reg - (i64)1),NULL);
    msysnewc_m_print_end();
    ;
    return str;
}

void ax_lib_printst(void * f) {
    struct ax_decls_strec *  r;
    r = ax_decls_modulenamelist;
    L1167 :;
    while (!!(r)) {
        ax_lib_printstrec(f,r);
        r = (*r).nextdef;
L1168 :;
    }L1169 :;
    ;
}

void ax_lib_printstrec(void * f,struct ax_decls_strec * d) {
    if (((i64)((*d).symbol)==(i64)19) || ((i64)((*d).symbol)==(i64)20) || ((i64)((*d).symbol)==(i64)22)) {
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_str((byte*)"Label:       ",NULL);
        msysnewc_m_print_str(mlib_padstr((*d).name,(i64)16,(byte*)" "),NULL);
        msysnewc_m_print_str((((i64)((u64)((*d).scope)) == (i64)1)?(byte*)"U":(byte*)"-"),NULL);
        msysnewc_m_print_str(ax_tables_symbolnames[((i64)((*d).symbol))-1],NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((byte*)"\t",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(mlib_padstr((!!((u64)((*d).segment))?ax_tables_segmentnames[((i64)((*d).segment))-1]:(byte*)"no seg"),(i64)12,(byte*)" "),NULL);
        msysnewc_m_print_i64((*d).offset,NULL);
        msysnewc_m_print_ptr((*d).fwdrefs,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    }else if (((i64)((*d).symbol)==(i64)21)) {
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_str((byte*)"Label:       ",NULL);
        msysnewc_m_print_str(mlib_padstr((*d).name,(i64)16,(byte*)" "),NULL);
        msysnewc_m_print_str((byte*)"EXTERN",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    }else if (((i64)((*d).symbol)==(i64)18)) {
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_str((byte*)"Named const: ",NULL);
        msysnewc_m_print_str(mlib_padstr((*d).name,(i64)16,(byte*)" "),NULL);
        msysnewc_m_print_str((byte*)"=",NULL);
        msysnewc_m_print_str(ax_lib_stropnd((*d).expr,(i64)0),NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    } else {
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_str((byte*)"??",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
}

void ax_lib_adddef(struct ax_decls_strec * d) {
    (*d).nextdef = ax_decls_modulenamelist;
    ax_decls_modulenamelist = d;
}

void ax_lib_addimport(struct ax_decls_strec * d) {
    struct ax_decls_stlistrec *  p;
    p = (struct ax_decls_stlistrec *)(mlib_pcm_alloc((i64)8));
    (*p).def = d;
    (*p).nextitem = ax_decls_globalimportlist;
    ax_decls_globalimportlist = p;
}

void ax_lib_createlabel(struct ax_decls_strec * symptr,i64 symbol) {
    (*symptr).symbol = (u64)(symbol);
    (*symptr).stindex = (i64)0;
    (*symptr).moduleno = ax_decls_currmoduleno;
    ax_lib_adddef(symptr);
}

void ax_lib_createnamedconst(struct ax_decls_strec * symptr,struct ax_decls_opndrec * expr) {
    (*symptr).symbol = (u64)((i64)18);
    (*symptr).expr = expr;
    ax_lib_adddef(symptr);
}

void ax_lib_gerror(byte * mess) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"SS code gen error:",NULL);
    msysnewc_m_print_str(mess,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"On line:",NULL);
    msysnewc_m_print_i64(ax_decls_alineno,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    msysnewc_m_print_startcon();
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    exit((i64)1);
}

void ax_lib_serror(byte * mess) {
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"Syntax error: '",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str(mess,NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_str((byte*)"' on line",NULL);
    msysnewc_m_print_i64(ax_decls_lxlineno,NULL);
    msysnewc_m_print_str(ax_decls_moduletable[(ax_decls_currmoduleno)-1].name,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    exit((i64)1);
}

void ax_lib_serror_s(byte * mess,byte * param) {
    byte str[256];
    sprintf((i8 *)(str),(i8 *)(mess),param);
    ax_lib_serror(str);
}

static byte * ax_lib_inttostr(i64 a) {
    static byte str[64];
    msysnewc_getstrint(a,str);
    return str;
}

static byte * ax_lib_realtostr(double a) {
    static byte str[64];
    strcpy((i8 *)(str),(i8 *)(msysnewc_strreal(a,(byte *)(0))));
    return str;
}

struct ax_decls_dbuffer * ax_lib_buffercreate(i64 size) {
    struct ax_decls_dbuffer *  a;
    a = (struct ax_decls_dbuffer *)(mlib_pcm_alloc((i64)20));
    (*a).alloc = size;
    (*a).pstart = ((*a).pcurr = (byte *)(mlib_pcm_alloc((*a).alloc)));
    (*a).pend = ((*a).pstart + (*a).alloc);
    return a;
}

static void ax_lib_bufferexpand(struct ax_decls_dbuffer * a) {
    i64 newalloc;
    i64 usedbytes;
    byte *  p;
    newalloc = ((*a).alloc * (i64)2);
    usedbytes = ((*a).pcurr - (*a).pstart);
    if ((usedbytes > (*a).alloc)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"dbuffer error",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        exit(0);
    };
    p = (byte *)(mlib_pcm_alloc(newalloc));
    memcpy((void *)(p),(void *)((*a).pstart),(u32)(usedbytes));
    (*a).pstart = p;
    (*a).pcurr = (p + usedbytes);
    (*a).alloc = newalloc;
    (*a).pend = (p + newalloc);
}

void ax_lib_buffercheck(struct ax_decls_dbuffer * a,i64 n) {
    L1170 :;
    while ((((*a).pend - (*a).pcurr) < n)) {
        ax_lib_bufferexpand(a);
L1171 :;
    }L1172 :;
    ;
}

i64 ax_lib_bufferlength(struct ax_decls_dbuffer * a) {
    return ((*a).pcurr - (*a).pstart);
}

void * ax_lib_bufferelemptr(struct ax_decls_dbuffer * a,i64 offset) {
    return (void *)(((*a).pstart + offset));
}

void ax_lib_addbyte(struct ax_decls_dbuffer * a,i64 x) {
    (*(*a).pcurr) = (u64)(x);
    ++(*a).pcurr;
}

void ax_lib_addword(struct ax_decls_dbuffer * a,i64 x) {
    (*(*a).pcurr16) = (u64)(x);
    ++(*a).pcurr16;
}

void ax_lib_adddword(struct ax_decls_dbuffer * a,i64 x) {
    (*(*a).pcurr32) = (u64)(x);
    ++(*a).pcurr32;
}

void ax_lib_addqword(struct ax_decls_dbuffer * a,i64 x) {
    (*(*a).pcurr64) = (u64)(x);
    ++(*a).pcurr64;
}

void ax_lib_printmodulesymbols(void * f) {
    struct ax_decls_strec *  d;
    struct ax_decls_strec *  e;
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_str((byte*)"MODULE SYMBOLS IN",NULL);
    msysnewc_m_print_str(ax_decls_moduletable[(ax_decls_currmoduleno)-1].name,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    d = ax_decls_modulenamelist;
    L1173 :;
    while (!!(d)) {
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_str((byte*)"   ",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(mlib_padstr((*d).name,(i64)14,(byte*)" "),NULL);
        msysnewc_m_print_str(mlib_padstr(ax_tables_symbolnames[((i64)((*d).symbol))-1],(i64)12,(byte*)" "),NULL);
        msysnewc_m_print_end();
        ;
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_setfmt((byte*)"|| # # #");
        msysnewc_m_print_u64((*d).htfirstindex,(byte*)"6");
        msysnewc_m_print_u64((*d).htindex,(byte*)"6");
        msysnewc_m_print_ptr(d,(byte*)"8H");
        msysnewc_m_print_end();
        ;
        e = ax_decls_dupltable[((i64)((*d).htfirstindex))];
        if (!!(e)) {
            msysnewc_m_print_startfile(f);
            msysnewc_m_print_str((byte*)"||",NULL);
            msysnewc_m_print_end();
            ;
            L1176 :;
            while (!!(e)) {
                msysnewc_m_print_startfile(f);
                msysnewc_m_print_str((byte*)"(",NULL);
                msysnewc_m_print_nogap();
                msysnewc_m_print_str((*e).name,NULL);
                msysnewc_m_print_nogap();
                msysnewc_m_print_str((byte*)")",NULL);
                msysnewc_m_print_end();
                ;
                e = (*e).nextdupl;
L1177 :;
            }L1178 :;
            ;
        };
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_str((byte*)" BASE:",NULL);
        msysnewc_m_print_str((!!((*d).basedef)?(*(*d).basedef).name:(byte*)""),NULL);
        msysnewc_m_print_ptr((*d).basedef,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        d = (*d).nextdef;
L1174 :;
    }L1175 :;
    ;
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

void ax_lib_printimportsymbols(void * f) {
    struct ax_decls_strec *  d;
    struct ax_decls_stlistrec *  p;
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_str((byte*)"GLOBAL IMPORT TABLE",NULL);
    msysnewc_m_print_ptr(ax_decls_globalimportlist,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    p = ax_decls_globalimportlist;
    L1179 :;
    while (!!(p)) {
        d = (*p).def;
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_str((byte*)"   ",NULL);
        msysnewc_m_print_nogap();
        msysnewc_m_print_str(mlib_padstr((*d).name,(i64)14,(byte*)" "),NULL);
        msysnewc_m_print_str(mlib_padstr(ax_tables_symbolnames[((i64)((*d).symbol))-1],(i64)12,(byte*)" "),NULL);
        msysnewc_m_print_end();
        ;
        msysnewc_m_print_startfile(f);
        msysnewc_m_print_str((byte*)"D^.OFFSET=",NULL);
        msysnewc_m_print_i64((*d).offset,NULL);
        msysnewc_m_print_str(ax_tables_reftypenames[((i64)((*d).reftype))],NULL);
        msysnewc_m_print_ptr((void *)(d),NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        p = (*p).nextitem;
L1180 :;
    }L1181 :;
    ;
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

void ax_lib_printdupltable(void * f) {
    byte str[256];
    struct ax_decls_strec *  d;
    i64 i;
    i64 av_1;
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_str((byte*)"DUPL TABLE",NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    L1182 :;
    for (i=(i64)0;i<=(i64)2097151;i+=(i64)1) {
L1183 :;
        if (!!(ax_decls_dupltable[(i)])) {
            d = ax_decls_dupltable[(i)];
            msysnewc_m_print_startfile(f);
            msysnewc_m_print_str((byte*)"\t",NULL);
            msysnewc_m_print_u64((*d).htfirstindex,NULL);
            msysnewc_m_print_nogap();
            msysnewc_m_print_str((byte*)":",NULL);
            msysnewc_m_print_end();
            ;
            L1186 :;
            while (!!(d)) {
                msysnewc_m_print_startstr(str);
                msysnewc_m_print_setfmt((byte*)"(# # (#) #) ");
                msysnewc_m_print_u64((*d).htindex,(byte*)"6");
                msysnewc_m_print_str((*d).name,NULL);
                msysnewc_m_print_str(ax_decls_moduletable[((i64)((*d).moduleno))-1].name,NULL);
                msysnewc_m_print_ptr(d,(byte*)"8H");
                msysnewc_m_print_end();
                ;
                d = (*d).nextdupl;
L1187 :;
            }L1188 :;
            ;
            msysnewc_m_print_startfile(f);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        };
L1184 :;
    }L1185 :;
    ;
    msysnewc_m_print_startfile(f);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
}

void ax_genss_genss(void) {
    i64 index;
    struct ax_lib_mclrec *  m;
    ax_decls_ss_zdatalen = (i64)0;
    ax_decls_ss_zdata = ax_lib_buffercreate((i64)1024);
    ax_decls_ss_idata = ax_lib_buffercreate((i64)1024);
    ax_decls_ss_code = ax_lib_buffercreate((i64)1024);
    ax_decls_ss_idatarelocs = (struct ax_decls_relocrec *)(0);
    ax_decls_ss_coderelocs = (struct ax_decls_relocrec *)(0);
    ax_decls_ss_nsymbols = (i64)0;
    ax_genss_switchseg((i64)1);
    ax_decls_alineno = (i64)9999;
    ax_genss_extraparam = (struct ax_decls_opndrec *)(0);
    m = ax_lib_mccode;
    index = (i64)0;
    L1189 :;
    while (!!(m)) {
        ax_decls_alineno = (*m).lineno;
        ax_genss_doinstr(m,++index);
        m = (*m).nextmcl;
L1190 :;
    }L1191 :;
    ;
    ax_genss_switchseg((i64)0);
    if (!!(ax_lib_bufferlength(ax_decls_ss_zdata))) {
        ax_lib_gerror((byte*)"Zdata contains code or data");
    };
}

static void ax_genss_doinstr(struct ax_lib_mclrec * m,i64 index) {
    struct ax_decls_opndrec *  a;
    struct ax_decls_opndrec *  b;
    struct ax_decls_strec *  d;
    i64 x;
    i64 offset;
    i64 shortjmp;
    i64 n;
    i64 av_1;
    i64 av_2;
    ax_genss_currmcl = m;
    ax_lib_buffercheck(ax_genss_currdata,(i64)1024);
    ax_genss_rex = (ax_genss_sizeoverride = (ax_genss_addroverride = (ax_genss_f2override = (ax_genss_f3override = (i64)0))));
    a = (*m).a;
    b = (*m).b;
    switch ((int)((*m).opcode)) {
    case 4:;
    {
        d = (*a).labeldef;
        (*d).reftype = (u64)((i64)2);
        (*d).segment = (u64)(ax_genss_currseg);
        (*d).offset = ax_genss_getcurrdatalen((i64)6);
        if (((i64)((u64)((*d).symbol)) == (i64)22)) {
            ax_genss_getstindex(d);
        };
        ax_genss_dofwdrefs(d);
    }break;
    case 19:;
    {
        ax_genss_do_call(a);
    }break;
    case 22:;
    {
        ax_genss_do_jmp(a,m);
    }break;
    case 23:;
    {
        offset = ax_genss_getrel32((*b).labeldef,(ax_genss_getcurrdatalen((i64)7) + (i64)1));
        if ((offset < (i64)0)) {
            if ((offset < (i64)-126)) {
                ax_genss_genbyte((i64)15);
                ax_genss_genbyte(((i64)128 + (*a).value));
                ax_genss_gendword((offset - (i64)4));
            } else {
                ax_genss_genbyte(((i64)112 + (*(*m).a).value));
                ax_genss_genbyte(offset);
            };
        } else {
            shortjmp = ax_genss_checkshortjump(m,(*b).labeldef);
            if (!(!!(shortjmp))) {
                ax_genss_genbyte((i64)15);
                ax_genss_genbyte(((i64)128 + (*a).value));
                ax_genss_genrel32(b);
            } else {
                ax_genss_genbyte(((i64)112 + (*a).value));
                ax_genss_genrel8(b);
            };
        };
    }break;
    case 110:;
    {
        ax_genss_genopnd(a,(i64)1);
    }break;
    case 111:;
    {
        ax_genss_genopnd(a,(i64)2);
    }break;
    case 112:;
    {
        ax_genss_genopnd(a,(i64)4);
    }break;
    case 113:;
    {
        ax_genss_genopnd(a,(i64)8);
    }break;
    case 114:;
    {
        ax_genss_genrel32(a);
    }break;
    case 115:;
    {
        ax_genss_switchseg((*a).value);
    }break;
    case 5:;
    case 144:;
    {
        ax_genss_genbyte((i64)(ax_tables_mclcodes[((i64)((*m).opcode))-1]));
    }break;
    case 51:;
    {
        ax_genss_genbyte((i64)102);
        ax_genss_genbyte((i64)152);
    }break;
    case 52:;
    {
        ax_genss_genbyte((i64)102);
        ax_genss_genbyte((i64)153);
    }break;
    case 53:;
    {
        ax_genss_genbyte((i64)153);
    }break;
    case 54:;
    {
        ax_genss_genbyte((i64)72);
        ax_genss_genbyte((i64)153);
    }break;
    case 20:;
    {
        ax_genss_genbyte((i64)195);
    }break;
    case 21:;
    {
        if (((i64)((u64)((*a).mode)) != (i64)2)) {
            ax_lib_gerror((byte*)"retn?");
        };
        ax_genss_genbyte((i64)194);
        ax_genss_genword((*a).value);
    }break;
    case 10:;
    {
        ax_genss_do_push(a);
    }break;
    case 11:;
    {
        ax_genss_do_pop(a);
    }break;
    case 49:;
    case 50:;
    {
        ax_genss_do_inc(a,(i64)(ax_tables_mclcodes[((i64)((*m).opcode))-1]));
    }break;
    case 47:;
    case 48:;
    case 30:;
    case 29:;
    case 34:;
    case 33:;
    {
        ax_genss_do_neg(a,(i64)(ax_tables_mclcodes[((i64)((*m).opcode))-1]));
    }break;
    case 25:;
    case 26:;
    case 35:;
    case 36:;
    case 37:;
    case 27:;
    case 28:;
    case 39:;
    {
        ax_genss_do_arith(a,b,(i64)(ax_tables_mclcodes[((i64)((*m).opcode))-1]));
    }break;
    case 9:;
    {
        ax_genss_do_mov(a,b);
    }break;
    case 12:;
    {
        ax_genss_do_lea(a,b);
    }break;
    case 16:;
    {
        ax_genss_do_movsx(a,b,(i64)190);
    }break;
    case 17:;
    {
        ax_genss_do_movsx(a,b,(i64)182);
    }break;
    case 18:;
    {
        ax_genss_do_movsxd(a,b);
    }break;
    case 24:;
    {
        ax_genss_do_exch(a,b);
    }break;
    case 31:;
    {
        ax_genss_do_imul2(a,b);
    }break;
    case 120:;
    case 121:;
    case 122:;
    case 123:;
    {
        if (((i64)((u64)((*a).mode)) == (i64)2)) {
            n = ((*a).value * (i64)((u64)(ax_tables_mclcodes[((i64)((*m).opcode))-1])));
            if ((ax_genss_currseg==(i64)1)) {
                av_1 = n;
                while (av_1-- > 0) {
L1192 :;
                    ax_genss_genbyte((i64)144);
L1193 :;
                }L1194 :;
                ;
            }else if ((ax_genss_currseg==(i64)2)) {
                av_2 = n;
                while (av_2-- > 0) {
L1195 :;
                    ax_genss_genbyte((i64)0);
L1196 :;
                }L1197 :;
                ;
            } else {
                ax_decls_ss_zdatalen += n;
            };
        } else {
            ax_lib_gerror((byte*)"resb?");
        };
    }break;
    case 119:;
    {
        if (((i64)((u64)((*a).mode)) == (i64)2)) {
            x = (*a).value;
            if (((x < (i64)1) || (x > (i64)16384))) {
                ax_lib_gerror((byte*)"align2");
            };
            if ((ax_genss_currseg != (i64)3)) {
                L1198 :;
                while (!!((ax_lib_bufferlength(ax_genss_currdata) % x))) {
                    ax_genss_genbyte(((ax_genss_currseg == (i64)1)?(i64)144:(i64)0));
L1199 :;
                }L1200 :;
                ;
            } else {
                L1201 :;
                while (!!((ax_decls_ss_zdatalen % x))) {
                    ++ax_decls_ss_zdatalen;
L1202 :;
                }L1203 :;
                ;
            };
        } else {
            ax_lib_gerror((byte*)"align?");
        };
    }break;
    case 40:;
    case 42:;
    case 41:;
    case 43:;
    case 44:;
    case 45:;
    case 46:;
    {
        ax_genss_do_shift(a,b,(i64)(ax_tables_mclcodes[((i64)((*m).opcode))-1]));
    }break;
    case 38:;
    {
        ax_genss_do_test(a,b);
    }break;
    case 127:;
    case 126:;
    case 125:;
    {
        ax_genss_do_loop(a,(i64)(ax_tables_mclcodes[((i64)((*m).opcode))-1]));
    }break;
    case 128:;
    {
        ax_genss_do_jcxz(a,(i64)4);
    }break;
    case 129:;
    {
        ax_genss_do_jcxz(a,(i64)8);
    }break;
    case 124:;
    {
        ax_genss_genbyte((i64)215);
    }break;
    case 55:;
    {
        ax_genss_do_setcc(a,b);
    }break;
    case 14:;
    {
        ax_genss_do_movxmm(a,b,(i64)4);
    }break;
    case 15:;
    {
        ax_genss_do_movxmm(a,b,(i64)8);
    }break;
    case 60:;
    case 61:;
    case 62:;
    case 63:;
    case 59:;
    case 106:;
    case 107:;
    {
        ax_genss_do_arithxmm(a,b,(i64)243,(i64)(ax_tables_mclcodes[((i64)((*m).opcode))-1]));
    }break;
    case 64:;
    case 65:;
    case 66:;
    case 67:;
    case 58:;
    case 108:;
    case 109:;
    {
        ax_genss_do_arithxmm(a,b,(i64)242,(i64)(ax_tables_mclcodes[((i64)((*m).opcode))-1]));
    }break;
    case 73:;
    case 71:;
    {
        ax_genss_do_logicxmm(a,b,(i64)(ax_tables_mclcodes[((i64)((*m).opcode))-1]),(i64)4);
    }break;
    case 72:;
    case 70:;
    case 75:;
    case 74:;
    {
        ax_genss_do_logicxmm(a,b,(i64)(ax_tables_mclcodes[((i64)((*m).opcode))-1]),(i64)8);
    }break;
    case 86:;
    case 87:;
    {
        ax_genss_do_pcmpistri(a,b,(i64)((*m).c),(i64)(ax_tables_mclcodes[((i64)((*m).opcode))-1]));
    }break;
    case 68:;
    {
        ax_genss_do_arithxmm(a,b,(i64)0,(i64)47);
    }break;
    case 69:;
    {
        ax_genss_do_arithxmm(a,b,(i64)102,(i64)47);
    }break;
    case 83:;
    {
        ax_genss_do_convertfloat(a,b,(i64)243);
    }break;
    case 82:;
    {
        ax_genss_do_convertfloat(a,b,(i64)242);
    }break;
    case 76:;
    {
        ax_genss_do_fix(a,b,(i64)243,(i64)45);
    }break;
    case 77:;
    {
        ax_genss_do_fix(a,b,(i64)242,(i64)45);
    }break;
    case 78:;
    {
        ax_genss_do_fix(a,b,(i64)243,(i64)44);
    }break;
    case 79:;
    {
        ax_genss_do_fix(a,b,(i64)242,(i64)44);
    }break;
    case 80:;
    {
        ax_genss_do_float(a,b,(i64)243);
    }break;
    case 81:;
    {
        ax_genss_do_float(a,b,(i64)242);
    }break;
    case 6:;
    {
        ax_genss_extraparam = a;
    }break;
    case 13:;
    {
        ax_genss_do_cmovcc(a,ax_genss_extraparam,b);
    }break;
    case 98:;
    case 99:;
    case 100:;
    case 101:;
    case 102:;
    case 103:;
    case 104:;
    case 105:;
    {
        ax_genss_genbyte((i64)217);
        ax_genss_genbyte((i64)(ax_tables_mclcodes[((i64)((*m).opcode))-1]));
    }break;
    case 88:;
    case 89:;
    case 90:;
    {
        ax_genss_do_fmem(a,(i64)1,(i64)(ax_tables_mclcodes[((i64)((*m).opcode))-1]));
    }break;
    case 91:;
    case 92:;
    case 93:;
    {
        ax_genss_do_fmem(a,(i64)0,(i64)(ax_tables_mclcodes[((i64)((*m).opcode))-1]));
    }break;
    case 94:;
    case 95:;
    case 96:;
    case 97:;
    {
        ax_genss_genbyte((i64)222);
        ax_genss_genbyte((i64)(ax_tables_mclcodes[((i64)((*m).opcode))-1]));
    }break;
    case 130:;
    {
        ax_genss_genbyte((i64)166);
    }break;
    case 131:;
    {
        ax_genss_genbyte((i64)102);
        ax_genss_genbyte((i64)167);
    }break;
    case 132:;
    {
        ax_genss_genbyte((i64)167);
    }break;
    case 133:;
    {
        ax_genss_genbyte((i64)72);
        ax_genss_genbyte((i64)167);
    }break;
    case 134:;
    {
        ax_genss_genbyte((i64)15);
        ax_genss_genbyte((i64)(ax_tables_mclcodes[((i64)((*m).opcode))-1]));
    }break;
    case 84:;
    case 85:;
    {
        ax_genss_do_movdqx(a,b,(i64)(ax_tables_mclcodes[((i64)((*m).opcode))-1]));
    }break;
    case 136:;
    {
        ax_genss_genbyte((i64)219);
        ax_genss_genbyte((i64)227);
    }break;
    case 137:;
    case 138:;
    case 139:;
    case 140:;
    case 141:;
    case 142:;
    case 143:;
    {
        ax_genss_genbyte((i64)217);
        ax_genss_genbyte((i64)(ax_tables_mclcodes[((i64)((*m).opcode))-1]));
    }break;
    case 135:;
    {
        ax_genss_do_popcnt(a,b);
    }break;
    case 56:;
    case 57:;
    {
        ax_genss_do_bsf(a,b,(i64)(ax_tables_mclcodes[((i64)((*m).opcode))-1]));
    }break;
    default: {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"*** CAN'T DO OPCODE",NULL);
        msysnewc_m_print_str(ax_tables_mclnames[((i64)((*m).opcode))-1],NULL);
        msysnewc_m_print_str((byte*)"line",NULL);
        msysnewc_m_print_i64(ax_decls_alineno,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    }
    } /* SW */
;
}

static void ax_genss_genbyte(i64 x) {
    (*(*ax_genss_currdata).pcurr++) = (u64)(x);
}

static void ax_genss_genword(i64 x) {
    ax_lib_addword(ax_genss_currdata,x);
}

static void ax_genss_gendword(i64 x) {
    ax_lib_adddword(ax_genss_currdata,x);
}

static void ax_genss_genqword(i64 x) {
    ax_lib_addqword(ax_genss_currdata,x);
}

static void ax_genss_genopnd(struct ax_decls_opndrec * a,i64 size) {
    byte *  s;
    i64 x;
    i64 length;
    if ((size == (i64)0)) {
        size = (i64)((*a).size);
    };
    switch ((int)((*a).mode)) {
    case 2:;
    case 3:;
    {
    }break;
    case 6:;
    {
        s = (*a).svalue;
        length = (i64)(strlen((i8 *)(s)));
        if ((length > (i64)100)) {
            ax_lib_buffercheck(ax_genss_currdata,msysnewc_m_imax((i64)1024,(length + (i64)1)));
        };
        L1204 :;
        while (!!((u64)((*s)))) {
            ax_genss_genbyte((i64)((*s++)));
L1205 :;
        }L1206 :;
        ;
        return;
    }break;
    default: {
        ax_lib_gerror((byte*)"GENOPND/bad opnd");
    }
    } /* SW */
;
    if ((!!((*a).labeldef) && (size <= (i64)2))) {
        ax_lib_gerror((byte*)"8/16-BIT RELOC");
    };
    if ((size==(i64)1)) {
        ax_genss_genbyte((*a).value);
    }else if ((size==(i64)2)) {
        ax_genss_genword((*a).value);
    }else if ((size==(i64)4)) {
        if (!!((*a).labeldef)) {
            ax_genss_genabs32(a);
        } else {
            if (!!((u64)((*a).valtype))) {
                ax_genss_gendword(ax_genss_getr32bits((*a).xvalue));
            } else {
                ax_genss_gendword((*a).value);
            };
        };
    }else if ((size==(i64)8)) {
        if (!!((*a).labeldef)) {
            ax_genss_genabs64(a);
        } else {
            x = (*a).value;
            if (!!((u64)((*a).valtype))) {
                ax_genss_genqword(*(i64*)&x);
            } else {
                ax_genss_genqword(x);
            };
        };
    };
}

static void ax_genss_addrelocitem(i64 reloctype,struct ax_decls_strec * d) {
    struct ax_decls_relocrec *  r;
    i64 stindex;
    i64 adjust;
    stindex = ax_genss_getstindex(d);
    adjust = (i64)4;
    if ((reloctype == (i64)1)) {
        adjust = (i64)8;
    };
    r = (struct ax_decls_relocrec *)(mlib_pcm_alloc((i64)28));
    (*r).nextreloc = ax_genss_currrelocs;
    (*r).reloctype = reloctype;
    (*r).offset = (ax_genss_getcurrdatalen((i64)1) - adjust);
    (*r).stindex = stindex;
    ++ax_genss_nrelocs;
    ax_genss_currrelocs = r;
}

static i64 ax_genss_getstindex(struct ax_decls_strec * d) {
    if (((i64)((*d).stindex) == (i64)0)) {
        if ((ax_decls_ss_nsymbols >= ax_decls_ss_symboltablesize)) {
            ax_genss_extendsymboltable();
        };
        (*d).stindex = ++ax_decls_ss_nsymbols;
        (*ax_decls_ss_symboltable)[((i64)((*d).stindex))-1] = d;
    };
    return (i64)((*d).stindex);
}

static void ax_genss_genrel32(struct ax_decls_opndrec * a) {
    struct ax_decls_strec *  d;
    d = (*a).labeldef;
    if ((d == 0)) {
        ax_genss_gendword((*a).value);
        return;
    };
    if (((i64)((*d).reftype)==(i64)2)) {
        if (((i64)((u64)((*d).segment)) != ax_genss_currseg)) {
            ax_lib_gerror((byte*)"Rel label across segments");
        };
        ax_genss_gendword(((i64)((*d).offset) - (ax_genss_getcurrdatalen((i64)2) + (i64)4)));
    }else if (((i64)((*d).reftype)==(i64)1)) {
        (*d).fwdrefs = ax_genss_addfwdref((*d).fwdrefs,ax_genss_getcurrdatalen((i64)3),(i64)4,(i64)0);
        ax_genss_gendword((i64)0);
    } else {
        ax_genss_gendword((*a).value);
        ax_genss_addrelocitem((i64)4,d);
    };
}

static void ax_genss_genabs32(struct ax_decls_opndrec * a) {
    struct ax_decls_strec *  d;
    d = (*a).labeldef;
    if (((i64)((*d).reftype)==(i64)2)) {
        ax_genss_gendword(((i64)((*d).offset) + (*a).value));
        ax_genss_addrelocitem((i64)2,d);
    }else if (((i64)((*d).reftype)==(i64)1)) {
        (*d).fwdrefs = ax_genss_addfwdref((*d).fwdrefs,ax_genss_getcurrdatalen((i64)4),(i64)2,ax_genss_currseg);
        ax_genss_gendword((*a).value);
        ax_genss_addrelocitem((i64)2,d);
    } else {
        ax_genss_gendword((*a).value);
        ax_genss_addrelocitem((i64)2,d);
    };
}

static void ax_genss_genabs64(struct ax_decls_opndrec * a) {
    struct ax_decls_strec *  d;
    d = (*a).labeldef;
    if (((i64)((*d).reftype)==(i64)2)) {
        ax_genss_genqword(((i64)((*d).offset) + (*a).value));
        ax_genss_addrelocitem((i64)1,d);
    }else if (((i64)((*d).reftype)==(i64)1)) {
        (*d).fwdrefs = ax_genss_addfwdref((*d).fwdrefs,ax_genss_getcurrdatalen((i64)5),(i64)2,ax_genss_currseg);
        ax_genss_genqword((*a).value);
        ax_genss_addrelocitem((i64)1,d);
    } else {
        ax_genss_genqword((*a).value);
        ax_genss_addrelocitem((i64)1,d);
    };
}

static i64 ax_genss_getrel32(struct ax_decls_strec * d,i64 offset) {
    if (((i64)((u64)((*d).reftype)) == (i64)2)) {
        if (((i64)((u64)((*d).segment)) != ax_genss_currseg)) {
            ax_lib_gerror((byte*)"Rel label across segments2");
        };
        return ((i64)((*d).offset) - (offset + (i64)1));
    } else {
        return (i64)2147483647;
    };
}

static void ax_genss_dofwdrefs(struct ax_decls_strec * d) {
    struct ax_decls_fwdrec *  f;
    i64 offset;
    byte *  p8;
    i32 *  p32;
    i64 *  p64;
    struct ax_decls_dbuffer *  data;
    if (((*d).fwdrefs == 0)) {
        return;
    };
    f = (*d).fwdrefs;
    L1207 :;
    while (!!(f)) {
        offset = (i64)((*f).offset);
        if (((i64)((*f).reltype)==(i64)4)) {
            p32 = (i32 *)(ax_lib_bufferelemptr(ax_genss_currdata,offset));
            (*p32) = (((i64)((*d).offset) - offset) - (i64)4);
        }else if (((i64)((*f).reltype)==(i64)2) || ((i64)((*f).reltype)==(i64)1)) {
            if (((i64)((*f).seg)==(i64)1)) {
                data = ax_decls_ss_code;
            }else if (((i64)((*f).seg)==(i64)3)) {
                ax_lib_gerror((byte*)"Fwd ref in zdata");
            }else if (((i64)((*f).seg)==(i64)2)) {
                data = ax_decls_ss_idata;
            };
            p32 = (i32 *)(ax_lib_bufferelemptr(data,offset));
            if (((i64)((*f).reltype) == (i64)2)) {
                (*p32) = ((i64)((*p32)) + (i64)((*d).offset));
            } else {
                p64 = (i64 *)(p32);
                (*p64) = ((*p64) + (i64)((*d).offset));
            };
        }else if (((i64)((*f).reltype)==(i64)6)) {
            p8 = (byte *)(ax_lib_bufferelemptr(ax_genss_currdata,offset));
            (*p8) = (u64)((((i64)((*d).offset) - offset) - (i64)1));
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(ax_objdecls_relocnames[((i64)((*f).reltype))],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            ax_lib_gerror((byte*)"DOFWDREFS/CAN'T DO RELTYPE");
        };
        f = (*f).nextfwd;
L1208 :;
    }L1209 :;
    ;
}

static void ax_genss_genrex(void) {
    if (!!(ax_genss_sizeoverride)) {
        ax_genss_genbyte((i64)102);
    };
    if (!!(ax_genss_addroverride)) {
        ax_genss_genbyte((i64)103);
    };
    if (!!(ax_genss_rex)) {
        if ((ax_genss_rex < (i64)64)) {
            ax_genss_genbyte(((i64)64 + ax_genss_rex));
        } else {
            ax_genss_genbyte(ax_genss_rex);
        };
    };
}

static i64 ax_genss_isbytesized(i64 x) {
    return (((i64)-128 <= x) && (x <= (i64)127));
}

static i64 ax_genss_isdwordsized(i64 x) {
    return (((i64)-2147483648LL <= x) && (x <= (i64)2147483647));
}

static void ax_genss_do_push(struct ax_decls_opndrec * a) {
    i64 code;
    i64 am;
    if (((i64)((*a).mode)==(i64)1)) {
        if (((i64)((u64)((*a).size)) != (i64)8)) {
            ax_lib_gerror((byte*)"pushreg not 64-bit");
        };
        code = (i64)(ax_tables_regcodes[((i64)((*a).reg))]);
        if ((code >= (i64)8)) {
            ax_genss_rex = (i64)1;
            code &= (i64)7;
        };
        ax_genss_genrex();
        ax_genss_genbyte(((i64)80 + code));
    }else if (((i64)((*a).mode)==(i64)2)) {
        if (!!((*a).labeldef)) {
            ax_genss_genbyte((i64)104);
            ax_genss_genopnd(a,(i64)4);
        } else if (!!(ax_genss_isbytesized((*a).value))) {
            ax_genss_genbyte((i64)106);
            ax_genss_genbyte((*a).value);
        } else if (!!(ax_genss_isdwordsized((*a).value))) {
            ax_genss_genbyte((i64)104);
            ax_genss_gendword((*a).value);
        } else {
            ax_lib_gerror((byte*)"push imm value too large");
        };
    }else if (((i64)((*a).mode)==(i64)3)) {
        if (((i64)((u64)((*a).size)) != (i64)8)) {
            ax_lib_gerror((byte*)"push not 64-bit");
        };
        am = ax_genss_genrm(a,(i64)6);
        ax_genss_genrex();
        ax_genss_genbyte((i64)255);
        ax_genss_genamode(a,am);
    } else {
        ax_lib_gerror((byte*)"push opnd?");
    };
}

static void ax_genss_do_pop(struct ax_decls_opndrec * a) {
    i64 code;
    i64 am;
    if (((i64)((*a).mode)==(i64)1)) {
        if (((i64)((u64)((*a).size)) != (i64)8)) {
            ax_lib_gerror((byte*)"popreg not 64-bit");
        };
        code = (i64)(ax_tables_regcodes[((i64)((*a).reg))]);
        if ((code >= (i64)8)) {
            ax_genss_rex = (i64)1;
            code &= (i64)7;
        };
        ax_genss_genrex();
        ax_genss_genbyte(((i64)88 + code));
    }else if (((i64)((*a).mode)==(i64)3)) {
        if (((i64)((u64)((*a).size)) != (i64)8)) {
            ax_lib_gerror((byte*)"pop not 64-bit");
        };
        am = ax_genss_genrm(a,(i64)0);
        ax_genss_genrex();
        ax_genss_genbyte((i64)143);
        ax_genss_genamode(a,am);
    } else {
        ax_lib_gerror((byte*)"pop opnd?");
    };
}

static void ax_genss_do_inc(struct ax_decls_opndrec * a,i64 code) {
    i64 opc;
    i64 am;
    opc = (((i64)((u64)((*a).size)) == (i64)1)?(i64)254:(i64)255);
    if (((i64)((*a).mode)==(i64)1) || ((i64)((*a).mode)==(i64)3)) {
        am = ax_genss_genrm(a,code);
        ax_genss_checkhighreg(a);
        ax_genss_setopsize(a);
        ax_genss_genrex();
        ax_genss_genbyte(opc);
        ax_genss_genamode(a,am);
    } else {
        ax_lib_gerror((byte*)"inc/opnd?");
    };
}

static void ax_genss_do_neg(struct ax_decls_opndrec * a,i64 code) {
    i64 opc;
    i64 am;
    opc = (((i64)((u64)((*a).size)) == (i64)1)?(i64)246:(i64)247);
    if (((i64)((*a).mode)==(i64)1) || ((i64)((*a).mode)==(i64)3)) {
        am = ax_genss_genrm(a,code);
        ax_genss_checkhighreg(a);
        ax_genss_setopsize(a);
        ax_genss_genrex();
        ax_genss_genbyte(opc);
        ax_genss_genamode(a,am);
    } else {
        ax_lib_gerror((byte*)"neg/div/etc opnd?");
    };
}

static void ax_genss_genamode(struct ax_decls_opndrec * a,i64 am) {
    i64 sib;
    i64 mode;
    i64 dispsize;
    sib = (am >> (i64)16);
    mode = ((am >> (i64)8) & (i64)255);
    dispsize = (am & (i64)255);
    ax_genss_genbyte(mode);
    if ((sib >= (i64)0)) {
        ax_genss_genbyte(sib);
    };
    if ((dispsize==(i64)0)) {
    }else if ((dispsize==(i64)1)) {
        ax_genss_genbyte((*a).value);
    }else if ((dispsize==(i64)4)) {
        if (!!((*a).labeldef)) {
            ax_genss_genabs32(a);
        } else {
            ax_genss_gendword((*a).value);
        };
    } else {
        ax_lib_gerror((byte*)"genamode size 2/8");
    };
}

static i64 ax_genss_makemodrm(i64 mode,i64 opc,i64 rm) {
    return (((mode << (i64)6) + (opc << (i64)3)) + rm);
}

static void ax_genss_setopsize(struct ax_decls_opndrec * a) {
    if (((i64)((*a).size)==(i64)1)) {
    }else if (((i64)((*a).size)==(i64)2)) {
        ax_genss_sizeoverride = (i64)1;
    }else if (((i64)((*a).size)==(i64)8)) {
        ax_genss_rex |= (i64)8;
    }else if (((i64)((*a).size)==(i64)4)) {
    } else {
        ax_lib_gerror((byte*)"Operand size not set");
    };
}

static void ax_genss_setaddrsize(struct ax_decls_opndrec * a) {
    if ((((i64)((u64)((*a).mode)) == (i64)3) && ((i64)((u64)((*a).addrsize)) == (i64)4))) {
        ax_genss_addroverride = (i64)1;
    };
}

static i64 ax_genss_getdispsize(struct ax_decls_opndrec * a,i64 mand) {
    if (!!((*a).labeldef)) {
        return (i64)4;
    };
    if ((!!((*a).value) || !!(mand))) {
        return (!!(ax_genss_isbytesized((*a).value))?(i64)1:(i64)4);
    } else {
        return (i64)0;
    };
}

static i64 ax_genss_genrm(struct ax_decls_opndrec * a,i64 opc) {
    static i64 scaletable[8] = {(i64)0,(i64)1,(i64)0,(i64)2,(i64)0,(i64)0,(i64)0,(i64)3};
    i64 mode;
    i64 rm;
    i64 scale;
    i64 dispsize;
    i64 needsib;
    i64 sib;
    i64 index;
    i64 base;
    i64 reg;
    i64 regix;
    i64 code;
    mode = (rm = (i64)0);
    scale = (i64)0;
    dispsize = (i64)0;
    needsib = (i64)0;
    sib = (i64)-1;
    if ((((i64)((u64)((*a).mode)) == (i64)3) && ((i64)((u64)((*a).addrsize)) == (i64)4))) {
        ax_genss_addroverride = (i64)1;
    };
    if (((i64)((*a).mode)==(i64)1)) {
        code = ax_genss_getregcodeb((i64)((*a).reg));
        return ax_genss_makeam(ax_genss_makemodrm((i64)3,opc,code),sib,dispsize);
    }else if (((i64)((*a).mode)==(i64)3)) {
    }else if (((i64)((*a).mode)==(i64)5)) {
        code = ax_genss_getregcodebx((i64)((*a).reg));
        return ax_genss_makeam(ax_genss_makemodrm((i64)3,opc,code),sib,dispsize);
    } else {
        ax_lib_gerror((byte*)"genrm not mem");
    };
    reg = (i64)((*a).reg);
    regix = (i64)((*a).regix);
    if (((reg == regix) && (regix == (i64)0))) {
        mode = (i64)0;
        rm = (i64)4;
        scale = (i64)1;
        index = (i64)4;
        base = (i64)5;
        dispsize = (i64)4;
    } else if ((((i64)((u64)((*a).scale)) <= (i64)1) && (regix == (i64)0))) {
        dispsize = ax_genss_getdispsize(a,(i64)0);
        if (!!(dispsize)) {
            mode = ((dispsize == (i64)1)?(i64)1:(i64)2);
        };
        rm = (i64)(ax_tables_regcodes[(reg)]);
        if (((rm != (i64)4) && (rm != (i64)12))) {
            base = rm;
            if ((((rm == (i64)5) || (rm == (i64)13)) && (dispsize == (i64)0))) {
                mode = (i64)1;
                dispsize = (i64)1;
            };
            index = (i64)0;
        } else {
            index = (i64)4;
            base = rm;
            scale = (i64)1;
        };
    } else if ((!!(regix) && (reg == (i64)0))) {
        dispsize = (i64)4;
        mode = (i64)0;
        rm = (i64)4;
        scale = (!!((u64)((*a).scale))?(i64)((*a).scale):(i64)1);
        base = (i64)5;
        index = (i64)(ax_tables_regcodes[(regix)]);
        if ((regix == (i64)16)) {
            ax_lib_gerror((byte*)"Scaled rstack?");
        };
    } else {
        dispsize = ax_genss_getdispsize(a,(i64)0);
        if (!!(dispsize)) {
            mode = ((dispsize == (i64)1)?(i64)1:(i64)2);
        };
        rm = (i64)4;
        scale = (!!((u64)((*a).scale))?(i64)((*a).scale):(i64)1);
        if ((reg == (i64)0)) {
            base = (i64)5;
        } else {
            if (((reg == (i64)15) && (dispsize == (i64)0))) {
                mode = (i64)1;
                dispsize = (i64)1;
            };
            base = (i64)(ax_tables_regcodes[(reg)]);
        };
        if ((regix == (i64)0)) {
            index = (i64)4;
        } else {
            index = (i64)(ax_tables_regcodes[(regix)]);
        };
        if ((!!(regix) && !(!!(reg)))) {
            dispsize = (i64)4;
        };
        if (((regix == (i64)16) && (scale > (i64)1))) {
            ax_lib_gerror((byte*)"Can't scale rstack");
        };
    };
    if ((index >= (i64)8)) {
        ax_genss_rex |= (i64)2;
        index &= (i64)7;
    };
    if ((base >= (i64)8)) {
        ax_genss_rex |= (i64)1;
        base &= (i64)7;
    };
    if (!!(scale)) {
        sib = (((scaletable[(scale)-1] << (i64)6) + (index << (i64)3)) + base);
    };
    rm &= (i64)7;
    return ax_genss_makeam(ax_genss_makemodrm(mode,opc,rm),sib,dispsize);
}

static void ax_genss_genrmbyte(i64 mode,i64 opc,i64 rm) {
    ax_genss_genbyte((((mode << (i64)6) + (opc << (i64)3)) + rm));
}

static i64 ax_genss_makeam(i64 m,i64 s,i64 d) {
    return (((s << (i64)16) + (m << (i64)8)) + d);
}

static void ax_genss_do_arith(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 code) {
    i64 am;
    i64 regcode;
    i64 opc;
    i64 dispsize;
    i64 x;
    if (((i64)((*a).mode)==(i64)1)) {
        if (((i64)((*b).mode)==(i64)1) || ((i64)((*b).mode)==(i64)3)) {
            regcode = ax_genss_getregcoder((i64)((*a).reg));
            am = ax_genss_genrm(b,regcode);
            ax_genss_checkhighreg(a);
            ax_genss_checkhighreg(b);
            ax_genss_setopsize(a);
            opc = ((code << (i64)3) | (((i64)((u64)((*a).size)) == (i64)1)?(i64)2:(i64)3));
            ax_genss_genrex();
            ax_genss_genbyte(opc);
            ax_genss_genamode(b,am);
        }else if (((i64)((*b).mode)==(i64)2)) {
            /*doregimm:*/
L1210 :;
;
            if (!!((*b).labeldef)) {
                if (((code < (i64)0) || (code > (i64)7))) {
                    ax_lib_gerror((byte*)"non-add arith/label");
                };
                if (((i64)((u64)((*a).size)) < (i64)4)) {
                    ax_lib_gerror((byte*)"add imm/size");
                };
                am = ax_genss_genrm(a,code);
                ax_genss_setopsize(a);
                ax_genss_genrex();
                ax_genss_genbyte((i64)129);
                ax_genss_genamode(a,am);
                ax_genss_genopnd(b,(i64)4);
                return;
            };
            x = (*b).value;
            dispsize = (i64)1;
            if (((i64)((u64)((*a).size)) == (i64)1)) {
                opc = (i64)128;
            } else if ((((i64)-128 <= x) && (x <= (i64)127))) {
                opc = (i64)131;
            } else {
                if (!((((i64)-2147483648LL <= x) && (x <= (i64)4294967295LL)))) {
                    ax_lib_gerror((byte*)"3:exceeding word32 value");
                };
                opc = (i64)129;
                dispsize = (((i64)((u64)((*a).size)) == (i64)2)?(i64)2:(i64)4);
            };
            am = ax_genss_genrm(a,code);
            ax_genss_checkhighreg(a);
            ax_genss_setopsize(a);
            ax_genss_genrex();
            ax_genss_genbyte(opc);
            ax_genss_genamode(a,am);
            if ((dispsize==(i64)1)) {
                ax_genss_genbyte(x);
            }else if ((dispsize==(i64)2)) {
                ax_genss_genword(x);
            }else if ((dispsize==(i64)4)) {
                ax_genss_gendword(x);
            };
        } else {
            ax_lib_gerror((byte*)"ADD reg,???");
        };
    }else if (((i64)((*a).mode)==(i64)3)) {
        if (((i64)((*b).mode)==(i64)1)) {
            regcode = ax_genss_getregcoder((i64)((*b).reg));
            am = ax_genss_genrm(a,regcode);
            ax_genss_checkhighreg(b);
            ax_genss_setopsize(b);
            opc = ((code << (i64)3) | (((i64)((u64)((*b).size)) == (i64)1)?(i64)0:(i64)1));
            ax_genss_genrex();
            ax_genss_genbyte(opc);
            ax_genss_genamode(a,am);
        }else if (((i64)((*b).mode)==(i64)2)) {
            goto L1210 ;
;
        } else {
            ax_lib_gerror((byte*)"ADD mem,???");
        };
    } else {
        ax_lib_gerror((byte*)"Can't add to this opnd");
    };
}

static void ax_genss_do_mov(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b) {
    i64 regcode;
    i64 am;
    i64 value;
    if (((i64)((*a).mode)==(i64)1)) {
        if (((i64)((*b).mode)==(i64)1) || ((i64)((*b).mode)==(i64)3)) {
            if ((((u64)((*a).size) != (u64)((*b).size)) && !!((u64)((*b).size)))) {
                ax_lib_gerror((byte*)"Opnd size mismatch");
            };
            ax_genss_checkhighreg(a);
            ax_genss_checkhighreg(b);
            regcode = ax_genss_getregcoder((i64)((*a).reg));
            am = ax_genss_genrm(b,regcode);
            ax_genss_setopsize(a);
            ax_genss_genrex();
            ax_genss_genbyte((((i64)((u64)((*a).size)) == (i64)1)?(i64)138:(i64)139));
            ax_genss_genamode(b,am);
        }else if (((i64)((*b).mode)==(i64)2)) {
            value = (*b).value;
            regcode = ax_genss_getregcodeb((i64)((*a).reg));
            if ((!!((*b).labeldef) && ((i64)((u64)((*a).size)) <= (i64)2))) {
                ax_lib_gerror((byte*)"mov imm?");
            };
            if (((i64)((*a).size)==(i64)1)) {
                ax_genss_checkhighreg(a);
                if (((i64)((*a).reg)==(i64)3) || ((i64)((*a).reg)==(i64)4) || ((i64)((*a).reg)==(i64)15) || ((i64)((*a).reg)==(i64)16)) {
                    ax_genss_rex |= (i64)64;
                };
                if (!((((i64)-128 <= value) && (value <= (i64)255)))) {
                    ax_lib_gerror((byte*)"exceeding byte value");
                };
                ax_genss_genrex();
                ax_genss_genbyte(((i64)176 + regcode));
                ax_genss_genbyte(value);
            }else if (((i64)((*a).size)==(i64)2)) {
                if (!((((i64)-32768 <= value) && (value <= (i64)65535)))) {
                    ax_lib_gerror((byte*)"exceeding word16 value");
                };
                ax_genss_genbyte((i64)102);
                ax_genss_genrex();
                ax_genss_genbyte(((i64)184 + regcode));
                ax_genss_genword(value);
            }else if (((i64)((*a).size)==(i64)4)) {
                if (!!((*b).labeldef)) {
                    ax_genss_genrex();
                    ax_genss_genbyte(((i64)184 + regcode));
                    ax_genss_genopnd(b,(i64)4);
                } else {
                    if (!((((i64)-2147483648LL <= value) && (value <= (i64)((u64)4294967295u))))) {
                        msysnewc_m_print_startcon();
                        msysnewc_m_print_i64(value,NULL);
                        msysnewc_m_print_ptr((void *)(u32)(value),NULL);
                        msysnewc_m_print_newline();
                        msysnewc_m_print_end();
                        ;
                        ax_lib_gerror((byte*)"1:exceeding word32 value");
                    };
                    /*doreg32:*/
L1211 :;
;
                    ax_genss_genrex();
                    ax_genss_genbyte(((i64)184 + regcode));
                    ax_genss_gendword(value);
                };
            } else {
                if (!!((*b).labeldef)) {
                    ax_genss_rex |= (i64)8;
                    ax_genss_genrex();
                    ax_genss_genbyte(((i64)184 + regcode));
                    ax_genss_genopnd(b,(i64)8);
                } else {
                    if (((value >= (i64)0) && (value <= (i64)4294967295LL))) {
                        goto L1211 ;
;
                    };
                    ax_genss_rex |= (i64)8;
                    ax_genss_genrex();
                    ax_genss_genbyte(((i64)184 + regcode));
                    ax_genss_genqword(value);
                };
            };
        } else {
            ax_lib_gerror((byte*)"MOV REG/??");
        };
    }else if (((i64)((*a).mode)==(i64)3)) {
        if (((i64)((*b).mode)==(i64)1)) {
            if ((((u64)((*a).size) != (u64)((*b).size)) && !!((u64)((*a).size)))) {
                ax_lib_gerror((byte*)"Opnd size mismatch");
            };
            regcode = ax_genss_getregcoder((i64)((*b).reg));
            ax_genss_checkhighreg(b);
            am = ax_genss_genrm(a,regcode);
            ax_genss_setopsize(b);
            ax_genss_genrex();
            ax_genss_genbyte((((i64)((u64)((*b).size)) == (i64)1)?(i64)136:(i64)137));
            ax_genss_genamode(a,am);
        }else if (((i64)((*b).mode)==(i64)2)) {
            value = (*b).value;
            am = ax_genss_genrm(a,(i64)0);
            if ((!!((*b).labeldef) && ((i64)((u64)((*a).size)) <= (i64)2))) {
                ax_lib_gerror((byte*)"mov imm?");
            };
            if (((i64)((u64)((*a).size)) == (i64)0)) {
                (*a).size = (u64)((i64)1);
            };
            if (((i64)((*a).size)==(i64)0) || ((i64)((*a).size)==(i64)1)) {
                if (!((((i64)-128 <= value) && (value <= (i64)255)))) {
                    ax_lib_gerror((byte*)"exceeding byte value");
                };
                ax_genss_setopsize(a);
                ax_genss_genrex();
                ax_genss_genbyte((i64)198);
                ax_genss_genamode(a,am);
                ax_genss_genbyte(value);
            }else if (((i64)((*a).size)==(i64)2)) {
                if (!((((i64)-32768 <= value) && (value <= (i64)65535)))) {
                    ax_lib_gerror((byte*)"exceeding word16 value");
                };
                ax_genss_setopsize(a);
                ax_genss_genrex();
                ax_genss_genbyte((i64)199);
                ax_genss_genamode(a,am);
                ax_genss_genword(value);
            }else if (((i64)((*a).size)==(i64)4) || ((i64)((*a).size)==(i64)8)) {
                if (!(!!((*b).labeldef))) {
                    if (!((((i64)-2147483647 <= value) && (value <= (i64)4294967295LL)))) {
                        ax_lib_gerror((byte*)"2:exceeding word32 value");
                    };
                };
                ax_genss_setopsize(a);
                ax_genss_genrex();
                ax_genss_genbyte((i64)199);
                ax_genss_genamode(a,am);
                ax_genss_genopnd(b,(i64)4);
            };
        } else {
            ax_lib_gerror((byte*)"MOV MEM/?");
        };
    } else {
        ax_lib_gerror((byte*)"MOV ?/..");
    };
}

static i64 ax_genss_getregcoder(i64 reg) {
    i64 regcode;
    regcode = (i64)(ax_tables_regcodes[(reg)]);
    if ((regcode >= (i64)8)) {
        regcode -= (i64)8;
        ax_genss_rex |= (i64)4;
    };
    return regcode;
}

static i64 ax_genss_getregcodeb(i64 reg) {
    i64 regcode;
    regcode = (i64)(ax_tables_regcodes[(reg)]);
    if ((regcode >= (i64)8)) {
        regcode -= (i64)8;
        ax_genss_rex |= (i64)1;
    };
    return regcode;
}

static i64 ax_genss_getregcodebx(i64 reg) {
    i64 regcode;
    regcode = (reg - (i64)1);
    if ((regcode >= (i64)8)) {
        regcode -= (i64)8;
        ax_genss_rex |= (i64)1;
    };
    return regcode;
}

static i64 ax_genss_getregcoderx(i64 reg) {
    i64 regcode;
    regcode = (reg - (i64)1);
    if ((regcode >= (i64)8)) {
        regcode -= (i64)8;
        ax_genss_rex |= (i64)4;
    };
    return regcode;
}

static void ax_genss_do_lea(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b) {
    i64 regcode;
    i64 am;
    if (!((((i64)((u64)((*a).mode)) == (i64)1) && ((i64)((u64)((*b).mode)) == (i64)3)))) {
        ax_lib_gerror((byte*)"LEA not reg/mem");
    };
    if (((i64)((u64)((*a).size)) < (i64)4)) {
        ax_lib_gerror((byte*)"LEA size error");
    };
    regcode = ax_genss_getregcoder((i64)((*a).reg));
    am = ax_genss_genrm(b,regcode);
    ax_genss_setopsize(a);
    ax_genss_genrex();
    ax_genss_genbyte((i64)141);
    ax_genss_genamode(b,am);
}

static void ax_genss_do_movsx(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 opc) {
    i64 am;
    i64 regcode;
    if (((i64)((u64)((*a).mode)) != (i64)1)) {
        ax_lib_gerror((byte*)"movsx not reg");
    };
    if ((((i64)((u64)((*a).size)) == (i64)8) && ((i64)((u64)((*b).size)) == (i64)4))) {
        if ((opc == (i64)190)) {
            ax_genss_do_movsxd(a,b);
        } else {
            a = ax_lib_regtable[((i64)((*a).reg))-1][((i64)4)-1];
            ax_genss_do_mov(a,b);
        };
        return;
    };
    if ((((i64)((u64)((*a).size)) == (i64)1) || ((u64)((*a).size) <= (u64)((*b).size)))) {
        ax_lib_gerror((byte*)"movsx size error");
    };
    if (((opc == (i64)182) && ((i64)((u64)((*b).size)) == (i64)4))) {
        ax_lib_gerror((byte*)"movsx 4=>8 bytes?");
    };
    if (((i64)((*b).mode)==(i64)1)) {
    }else if (((i64)((*b).mode)==(i64)3)) {
        if (((i64)((u64)((*b).size)) == (i64)0)) {
            ax_lib_gerror((byte*)"movsx need size prefix");
        };
        if (((i64)((u64)((*b).size)) == (i64)8)) {
            ax_lib_gerror((byte*)"movsx size 8");
        };
    } else {
        ax_lib_gerror((byte*)"movsx not reg/mem");
    };
    regcode = ax_genss_getregcoder((i64)((*a).reg));
    am = ax_genss_genrm(b,regcode);
    ax_genss_setopsize(a);
    ax_genss_checkhighreg(b);
    ax_genss_genrex();
    ax_genss_genbyte((i64)15);
    ax_genss_genbyte((((i64)((u64)((*b).size)) == (i64)1)?opc:(opc + (i64)1)));
    ax_genss_genamode(b,am);
}

static void ax_genss_checkhighreg(struct ax_decls_opndrec * a) {
    if (((i64)((u64)((*a).mode)) == (i64)1)) {
        if (((i64)((*a).reg)==(i64)3) || ((i64)((*a).reg)==(i64)4) || ((i64)((*a).reg)==(i64)15) || ((i64)((*a).reg)==(i64)16)) {
            ax_genss_rex |= (i64)64;
        };
    };
}

static void ax_genss_do_exch(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b) {
    i64 regcode;
    i64 am;
    if ((((((i64)((u64)((*a).mode)) == (i64)1) && ((i64)((u64)((*b).mode)) == (i64)1)) && (((i64)((u64)((*a).reg)) == (i64)1) || ((i64)((u64)((*b).reg)) == (i64)1))) && ((i64)((u64)((*a).size)) != (i64)1))) {
        if (((i64)((u64)((*a).reg)) != (i64)1)) {
            {struct ax_decls_opndrec *  temp = a; a = b; b = temp; };
        };
        if (((u64)((*a).size) != (u64)((*b).size))) {
            ax_lib_gerror((byte*)"exch size");
        };
        ax_genss_setopsize(a);
        regcode = ax_genss_getregcodeb((i64)((*b).reg));
        ax_genss_genrex();
        ax_genss_genbyte(((i64)144 + regcode));
        return;
    };
    if (((i64)((u64)((*a).mode)) == (i64)3)) {
        {struct ax_decls_opndrec *  temp = a; a = b; b = temp; };
    };
    if (!((((i64)((u64)((*a).mode)) == (i64)1) && (((i64)((u64)((*b).mode)) == (i64)1) || ((i64)((u64)((*b).mode)) == (i64)3))))) {
        ax_lib_gerror((byte*)"exch opnds");
    };
    if ((((i64)((u64)((*b).size)) == (i64)0) && ((i64)((u64)((*b).mode)) == (i64)3))) {
        (*b).size = (u64)((*a).size);
    };
    if (((u64)((*a).size) != (u64)((*b).size))) {
        ax_lib_gerror((byte*)"exch size");
    };
    if (((i64)((u64)((*a).size)) == (i64)1)) {
        ax_genss_checkhighreg(a);
        ax_genss_checkhighreg(b);
    };
    regcode = ax_genss_getregcoder((i64)((*a).reg));
    am = ax_genss_genrm(b,regcode);
    ax_genss_setopsize(a);
    ax_genss_genrex();
    ax_genss_genbyte((((i64)((u64)((*a).size)) == (i64)1)?(i64)134:(i64)135));
    ax_genss_genamode(b,am);
}

static void ax_genss_do_movsxd(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b) {
    i64 regcode;
    i64 am;
    if ((((i64)((u64)((*b).mode)) == (i64)3) && ((i64)((u64)((*b).size)) == (i64)0))) {
        (*b).size = (u64)((i64)4);
    };
    if ((((i64)((u64)((*a).size)) != (i64)8) || ((i64)((u64)((*b).size)) > (i64)4))) {
        ax_lib_gerror((byte*)"movsxd size");
    };
    if ((((i64)((u64)((*a).mode)) != (i64)1) || (((i64)((u64)((*b).mode)) != (i64)1) && ((i64)((u64)((*b).mode)) != (i64)3)))) {
        ax_lib_gerror((byte*)"movsxd opnds");
    };
    regcode = ax_genss_getregcoder((i64)((*a).reg));
    am = ax_genss_genrm(b,regcode);
    ax_genss_setopsize(a);
    ax_genss_genrex();
    ax_genss_genbyte((i64)99);
    ax_genss_genamode(b,am);
}

static void ax_genss_do_imul2(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b) {
    i64 regcode;
    i64 am;
    i64 opc;
    i64 value;
    if (((i64)((u64)((*a).mode)) != (i64)1)) {
        ax_lib_gerror((byte*)"imul2 opnds");
    };
    if (((i64)((u64)((*b).size)) == (i64)0)) {
        (*b).size = (u64)((*a).size);
    };
    if (((i64)((u64)((*a).size)) == (i64)1)) {
        ax_lib_gerror((byte*)"imul2 byte");
    };
    if (((i64)((*b).mode)==(i64)1) || ((i64)((*b).mode)==(i64)3)) {
        if (((u64)((*a).size) != (u64)((*b).size))) {
            ax_lib_gerror((byte*)"imul2 size");
        };
        regcode = ax_genss_getregcoder((i64)((*a).reg));
        am = ax_genss_genrm(b,regcode);
        ax_genss_setopsize(a);
        ax_genss_genrex();
        ax_genss_genbyte((i64)15);
        ax_genss_genbyte((i64)175);
        ax_genss_genamode(b,am);
    }else if (((i64)((*b).mode)==(i64)2)) {
        if (!!((*b).labeldef)) {
            ax_lib_gerror((byte*)"mul/label");
        };
        value = (*b).value;
        regcode = ax_genss_getregcoder((i64)((*a).reg));
        regcode = ax_genss_getregcodeb((i64)((*a).reg));
        opc = (((i64)192 + (regcode << (i64)3)) + regcode);
        ax_genss_setopsize(a);
        ax_genss_genrex();
        if ((((i64)-128 <= value) && (value <= (i64)127))) {
            ax_genss_genbyte((i64)107);
            ax_genss_genbyte(opc);
            ax_genss_genbyte(value);
        } else if (((i64)((u64)((*a).size)) == (i64)2)) {
            ax_genss_genbyte((i64)105);
            ax_genss_genbyte(opc);
            ax_genss_genword(value);
        } else {
            ax_genss_genbyte((i64)105);
            ax_genss_genbyte(opc);
            ax_genss_gendword(value);
        };
    } else {
        ax_lib_gerror((byte*)"imul2 opnds");
    };
}

static void ax_genss_do_imul3(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,struct ax_decls_opndrec * c) {
    i64 value;
    i64 regcode1;
    i64 regcode2;
    i64 opc;
    if ((((i64)((u64)((*a).mode)) != (i64)1) || ((i64)((u64)((*b).mode)) != (i64)1))) {
        ax_lib_gerror((byte*)"imul3 opnds");
    };
    if (((i64)((u64)((*a).size)) == (i64)1)) {
        ax_lib_gerror((byte*)"imul3 byte");
    };
    if (((i64)((u64)((*c).mode)) != (i64)2)) {
        ax_lib_gerror((byte*)"imul3 not imm");
    };
    value = (*c).value;
    regcode1 = ax_genss_getregcoder((i64)((*a).reg));
    regcode2 = ax_genss_getregcodeb((i64)((*b).reg));
    opc = (((i64)192 + (regcode1 << (i64)3)) + regcode2);
    ax_genss_setopsize(a);
    ax_genss_genrex();
    if ((((i64)-128 <= value) && (value <= (i64)127))) {
        ax_genss_genbyte((i64)107);
        ax_genss_genbyte(opc);
        ax_genss_genbyte(value);
    } else if (((i64)((u64)((*a).size)) == (i64)2)) {
        ax_genss_genbyte((i64)105);
        ax_genss_genbyte(opc);
        ax_genss_genword(value);
    } else {
        ax_genss_genbyte((i64)105);
        ax_genss_genbyte(opc);
        ax_genss_gendword(value);
    };
}

static void ax_genss_do_shift(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 opc) {
    i64 am;
    i64 w;
    if ((((i64)((u64)((*a).mode)) != (i64)1) && ((i64)((u64)((*a).mode)) != (i64)3))) {
        ax_lib_gerror((byte*)"shift opnds1?");
    };
    am = ax_genss_genrm(a,opc);
    ax_genss_checkhighreg(a);
    ax_genss_setopsize(a);
    ax_genss_genrex();
    w = (((i64)((u64)((*a).size)) == (i64)1)?(i64)0:(i64)1);
    if (((i64)((*b).mode)==(i64)2)) {
        if (!!((*b).labeldef)) {
            ax_lib_gerror((byte*)"shift/label");
        };
        if (((*b).value == (i64)1)) {
            ax_genss_genbyte(((i64)208 + w));
            ax_genss_genamode(a,am);
        } else {
            ax_genss_genbyte(((i64)192 + w));
            ax_genss_genamode(a,am);
            ax_genss_genbyte((*b).value);
        };
    }else if (((i64)((*b).mode)==(i64)1)) {
        if ((((i64)((u64)((*b).reg)) != (i64)11) || ((i64)((u64)((*b).size)) != (i64)1))) {
            ax_lib_gerror((byte*)"cl or b10 needed");
        };
        ax_genss_genbyte(((i64)210 + w));
        ax_genss_genamode(a,am);
    } else {
        ax_lib_gerror((byte*)"shift opnds2?");
    };
}

static void ax_genss_do_test(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b) {
    i64 value;
    i64 opc;
    i64 am;
    i64 regcode;
    if (((((i64)((u64)((*a).mode)) == (i64)1) && ((i64)((u64)((*a).reg)) == (i64)1)) && ((i64)((u64)((*b).mode)) == (i64)2))) {
        value = (*b).value;
        if (((i64)((*a).size)==(i64)1)) {
            ax_genss_genbyte((i64)168);
            ax_genss_genbyte(value);
        }else if (((i64)((*a).size)==(i64)2)) {
            ax_genss_genbyte((i64)102);
            ax_genss_genbyte((i64)169);
            ax_genss_genword(value);
        }else if (((i64)((*a).size)==(i64)4)) {
            ax_genss_genbyte((i64)169);
            ax_genss_gendword(value);
        } else {
            ax_genss_genbyte((i64)72);
            ax_genss_genbyte((i64)169);
            ax_genss_gendword(value);
        };
    } else if (((((i64)((u64)((*a).mode)) == (i64)1) || ((i64)((u64)((*a).mode)) == (i64)3)) && ((i64)((u64)((*b).mode)) == (i64)2))) {
        opc = (((i64)((u64)((*a).size)) == (i64)1)?(i64)246:(i64)247);
        value = (*b).value;
        am = ax_genss_genrm(a,(i64)0);
        ax_genss_checkhighreg(a);
        ax_genss_setopsize(a);
        ax_genss_genrex();
        ax_genss_genbyte(opc);
        ax_genss_genamode(a,am);
        if (((i64)((*a).size)==(i64)1)) {
            ax_genss_genbyte(value);
        }else if (((i64)((*a).size)==(i64)2)) {
            ax_genss_genword(value);
        } else {
            ax_genss_gendword(value);
        };
    } else if ((((i64)((u64)((*a).mode)) == (i64)1) && (((i64)((u64)((*b).mode)) == (i64)1) || ((i64)((u64)((*b).mode)) == (i64)3)))) {
        /*doregmem:*/
L1212 :;
;
        regcode = ax_genss_getregcoder((i64)((*a).reg));
        am = ax_genss_genrm(b,regcode);
        ax_genss_checkhighreg(a);
        ax_genss_checkhighreg(b);
        ax_genss_setopsize(a);
        ax_genss_genrex();
        ax_genss_genbyte((((i64)((u64)((*a).size)) == (i64)1)?(i64)132:(i64)133));
        ax_genss_genamode(b,am);
    } else if ((((i64)((u64)((*a).mode)) == (i64)3) && ((i64)((u64)((*b).mode)) == (i64)1))) {
        {struct ax_decls_opndrec *  temp = a; a = b; b = temp; };
        goto L1212 ;
;
    } else {
        ax_lib_gerror((byte*)"test opnds");
    };
}

static void ax_genss_do_loop(struct ax_decls_opndrec * a,i64 opc) {
    i64 offset;
    offset = ax_genss_getrel32((*a).labeldef,(ax_genss_getcurrdatalen((i64)9) + (i64)1));
    if ((offset < (i64)0)) {
        if ((offset < (i64)-126)) {
            ax_lib_gerror((byte*)"loop jmp out of range");
        };
        ax_genss_genbyte(opc);
        ax_genss_genbyte(offset);
    } else {
        ax_lib_gerror((byte*)"Can't do loopxx fwd jump");
    };
}

static void ax_genss_do_jcxz(struct ax_decls_opndrec * a,i64 opsize) {
    i64 offset;
    offset = ax_genss_getrel32((*a).labeldef,(ax_genss_getcurrdatalen((i64)10) + (i64)1));
    if ((offset < (i64)0)) {
        if ((offset < (i64)-126)) {
            ax_lib_gerror((byte*)"jcxz jmp out of range");
        };
        if ((opsize == (i64)4)) {
            ax_genss_genbyte((i64)103);
        };
        ax_genss_genbyte((i64)227);
        ax_genss_genbyte(offset);
    } else {
        ax_lib_gerror((byte*)"Can't do jcxz fwd jump");
    };
}

static void ax_genss_do_setcc(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b) {
    i64 am;
    if (((((i64)((u64)((*b).mode)) != (i64)1) && ((i64)((u64)((*b).reg)) != (i64)3)) || ((i64)((u64)((*b).size)) > (i64)1))) {
        ax_lib_gerror((byte*)"setcc opnd/size");
    };
    am = ax_genss_genrm(b,(i64)0);
    ax_genss_checkhighreg(b);
    ax_genss_genrex();
    ax_genss_genbyte((i64)15);
    ax_genss_genbyte(((i64)144 + (*a).value));
    ax_genss_genamode(b,am);
}

static void ax_genss_do_movxmm(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 size) {
    i64 am;
    i64 regcode;
    i64 regcode1;
    i64 regcode2;
    if (((i64)((*a).mode)==(i64)1)) {
        if (((i64)((*b).mode)==(i64)5)) {
            if (((i64)((u64)((*a).size)) != size)) {
                ax_lib_gerror((byte*)"1:movdq size");
            };
            regcode = ax_genss_getregcoderx((i64)((*b).reg));
            am = ax_genss_genrm(a,regcode);
            ax_genss_setopsize(a);
            ax_genss_genbyte((i64)102);
            ax_genss_genrex();
            ax_genss_genbyte((i64)15);
            ax_genss_genbyte((i64)126);
            ax_genss_genamode(b,am);
        } else {
            ax_lib_gerror((byte*)"movdq reg,?");
        };
    }else if (((i64)((*a).mode)==(i64)5)) {
        if (((i64)((*b).mode)==(i64)1)) {
            if (((i64)((u64)((*b).size)) != size)) {
                ax_lib_gerror((byte*)"3:movdq size");
            };
            regcode = ax_genss_getregcoderx((i64)((*a).reg));
            am = ax_genss_genrm(b,regcode);
            ax_genss_setopsize(b);
            ax_genss_genbyte((i64)102);
            ax_genss_genrex();
            ax_genss_genbyte((i64)15);
            ax_genss_genbyte((i64)110);
            ax_genss_genamode(a,am);
        }else if (((i64)((*b).mode)==(i64)5)) {
            regcode1 = ax_genss_getregcoderx((i64)((*a).reg));
            regcode2 = ax_genss_getregcodebx((i64)((*b).reg));
            ax_genss_genbyte((i64)243);
            ax_genss_genrex();
            ax_genss_genbyte((i64)15);
            ax_genss_genbyte((i64)126);
            ax_genss_genbyte((((i64)192 + (regcode1 << (i64)3)) + regcode2));
        }else if (((i64)((*b).mode)==(i64)3)) {
            if ((!!((u64)((*b).size)) && ((i64)((u64)((*b).size)) != size))) {
                ax_lib_gerror((byte*)"4:movdq size");
            };
            regcode = ax_genss_getregcoderx((i64)((*a).reg));
            am = ax_genss_genrm(b,regcode);
            if ((size == (i64)4)) {
                ax_genss_genbyte((i64)102);
                ax_genss_genrex();
                ax_genss_genbyte((i64)15);
                ax_genss_genbyte((i64)110);
            } else {
                ax_genss_genbyte((i64)243);
                ax_genss_genrex();
                ax_genss_genbyte((i64)15);
                ax_genss_genbyte((i64)126);
            };
            ax_genss_genamode(b,am);
        } else {
            ax_lib_gerror((byte*)"movdq xreg,?");
        };
    }else if (((i64)((*a).mode)==(i64)3)) {
        if (((i64)((*b).mode)==(i64)5)) {
            if ((!!((u64)((*a).size)) && ((i64)((u64)((*a).size)) != size))) {
                ax_lib_gerror((byte*)"5:movdq size");
            };
            regcode = ax_genss_getregcoderx((i64)((*b).reg));
            am = ax_genss_genrm(a,regcode);
            if ((size == (i64)4)) {
                ax_genss_genbyte((i64)102);
                ax_genss_genrex();
                ax_genss_genbyte((i64)15);
                ax_genss_genbyte((i64)126);
            } else {
                ax_genss_genbyte((i64)102);
                ax_genss_genrex();
                ax_genss_genbyte((i64)15);
                ax_genss_genbyte((i64)214);
            };
            ax_genss_genamode(a,am);
        } else {
            ax_lib_gerror((byte*)"movdq mem,?");
        };
    } else {
        ax_lib_gerror((byte*)"movdq opnds");
    };
}

static void ax_genss_do_arithxmm(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 prefix,i64 opc) {
    i64 am;
    i64 regcode;
    if ((((i64)((u64)((*a).mode)) != (i64)5) || (((i64)((u64)((*b).mode)) != (i64)5) && ((i64)((u64)((*b).mode)) != (i64)3)))) {
        ax_lib_gerror((byte*)"arithxmm opnds");
    };
    if (((i64)((u64)((*b).mode)) == (i64)5)) {
        regcode = ax_genss_getregcoderx((i64)((*a).reg));
        am = ax_genss_genrm(b,regcode);
        if (!!(prefix)) {
            ax_genss_genbyte(prefix);
        };
        ax_genss_genrex();
        ax_genss_genbyte((i64)15);
        ax_genss_genbyte(opc);
        ax_genss_genamode(a,am);
    } else {
        regcode = ax_genss_getregcoderx((i64)((*a).reg));
        am = ax_genss_genrm(b,regcode);
        if (!!(prefix)) {
            ax_genss_genbyte(prefix);
        };
        ax_genss_genrex();
        ax_genss_genbyte((i64)15);
        ax_genss_genbyte(opc);
        ax_genss_genamode(b,am);
    };
}

static void ax_genss_do_logicxmm(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 opc,i64 size) {
    i64 am;
    i64 regcode;
    if ((((i64)((u64)((*a).mode)) != (i64)5) || (((i64)((u64)((*b).mode)) != (i64)5) && ((i64)((u64)((*b).mode)) != (i64)3)))) {
        ax_lib_gerror((byte*)"logicxmm opnds");
    };
    if ((size == (i64)8)) {
        ax_genss_genbyte((i64)102);
    };
    if (((i64)((u64)((*b).mode)) == (i64)5)) {
        regcode = ax_genss_getregcoderx((i64)((*a).reg));
        am = ax_genss_genrm(b,regcode);
        ax_genss_genrex();
        ax_genss_genbyte((i64)15);
        ax_genss_genbyte(opc);
        ax_genss_genamode(b,am);
    } else {
        regcode = ax_genss_getregcoderx((i64)((*a).reg));
        am = ax_genss_genrm(b,regcode);
        ax_genss_genrex();
        ax_genss_genbyte((i64)15);
        ax_genss_genbyte(opc);
        ax_genss_genamode(b,am);
    };
}

static void ax_genss_do_convertfloat(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 prefix) {
    i64 am;
    i64 regcode;
    if ((((i64)((u64)((*a).mode)) != (i64)5) || (((i64)((u64)((*b).mode)) != (i64)5) && ((i64)((u64)((*b).mode)) != (i64)3)))) {
        ax_lib_gerror((byte*)"convertfloat opnds");
    };
    ax_genss_genbyte(prefix);
    if (((i64)((u64)((*a).mode)) == (i64)5)) {
        regcode = ax_genss_getregcoderx((i64)((*a).reg));
        am = ax_genss_genrm(b,regcode);
        ax_genss_genrex();
        ax_genss_genbyte((i64)15);
        ax_genss_genbyte((i64)90);
        ax_genss_genamode(b,am);
    } else {
        regcode = ax_genss_getregcoderx((i64)((*b).reg));
        am = ax_genss_genrm(a,regcode);
        ax_genss_genrex();
        ax_genss_genbyte((i64)15);
        ax_genss_genbyte((i64)90);
        ax_genss_genamode(b,am);
    };
}

static void ax_genss_do_fix(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 prefix,i64 opc) {
    i64 am;
    i64 regcode;
    if ((((i64)((u64)((*a).mode)) != (i64)1) || (((i64)((u64)((*b).mode)) != (i64)5) && ((i64)((u64)((*b).mode)) != (i64)3)))) {
        ax_lib_gerror((byte*)"fix opnds");
    };
    ax_genss_genbyte(prefix);
    if (((i64)((u64)((*b).mode)) == (i64)5)) {
        regcode = ax_genss_getregcoder((i64)((*a).reg));
        am = ax_genss_genrm(b,regcode);
        ax_genss_setopsize(a);
    } else {
        regcode = ax_genss_getregcoder((i64)((*a).reg));
        am = ax_genss_genrm(b,regcode);
        ax_genss_setopsize(a);
    };
    ax_genss_genrex();
    ax_genss_genbyte((i64)15);
    ax_genss_genbyte(opc);
    ax_genss_genamode(b,am);
}

static void ax_genss_do_float(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 prefix) {
    i64 am;
    i64 regcode;
    if ((((i64)((u64)((*a).mode)) != (i64)5) || (((i64)((u64)((*b).mode)) != (i64)1) && ((i64)((u64)((*b).mode)) != (i64)3)))) {
        ax_lib_gerror((byte*)"float opnds");
    };
    if (((i64)((u64)((*b).mode)) == (i64)3)) {
        if (((i64)((u64)((*b).size)) == (i64)0)) {
            (*b).size = (u64)((i64)4);
        };
        if ((((i64)((u64)((*b).size)) != (i64)4) && ((i64)((u64)((*b).size)) != (i64)8))) {
            ax_lib_gerror((byte*)"float size");
        };
    };
    ax_genss_genbyte(prefix);
    regcode = ax_genss_getregcoderx((i64)((*a).reg));
    am = ax_genss_genrm(b,regcode);
    ax_genss_setopsize(b);
    ax_genss_genrex();
    ax_genss_genbyte((i64)15);
    ax_genss_genbyte((i64)42);
    ax_genss_genamode(b,am);
}

static void ax_genss_do_call(struct ax_decls_opndrec * a) {
    i64 am;
    if (((i64)((*a).mode)==(i64)2)) {
        ax_genss_genbyte((i64)232);
        ax_genss_genrel32(a);
    } else {
        if (((i64)((*a).size)==(i64)0)) {
            (*a).size = (u64)((i64)8);
        }else if (((i64)((*a).size)==(i64)1) || ((i64)((*a).size)==(i64)2) || ((i64)((*a).size)==(i64)4)) {
            ax_lib_gerror((byte*)"call[]size");
        };
        am = ax_genss_genrm(a,(i64)2);
        ax_genss_setopsize(a);
        ax_genss_setaddrsize(a);
        ax_genss_genrex();
        ax_genss_genbyte((i64)255);
        ax_genss_genamode(a,am);
    };
}

static void ax_genss_do_jmp(struct ax_decls_opndrec * a,struct ax_lib_mclrec * m) {
    i64 am;
    i64 offset;
    i64 shortjmp;
    if (((i64)((*a).mode)==(i64)2)) {
        offset = ax_genss_getrel32((*a).labeldef,(ax_genss_getcurrdatalen((i64)11) + (i64)1));
        if (((offset < (i64)0) && (offset > (i64)-126))) {
            ax_genss_genbyte((i64)235);
            ax_genss_genbyte(offset);
        } else {
            shortjmp = (i64)0;
            if ((offset > (i64)0)) {
                shortjmp = ax_genss_checkshortjump(m,(*a).labeldef);
            };
            if (!(!!(shortjmp))) {
                ax_genss_genbyte((i64)233);
                ax_genss_genrel32(a);
            } else {
                ax_genss_genbyte((i64)235);
                ax_genss_genrel8(a);
            };
        };
    } else {
        if (((i64)((*a).size)==(i64)0)) {
            (*a).size = (u64)((i64)8);
        }else if (((i64)((*a).size)==(i64)1) || ((i64)((*a).size)==(i64)2) || ((i64)((*a).size)==(i64)4)) {
            ax_lib_gerror((byte*)"jmp[]size");
        };
        am = ax_genss_genrm(a,(i64)4);
        ax_genss_setopsize(a);
        ax_genss_setaddrsize(a);
        ax_genss_genrex();
        ax_genss_genbyte((i64)255);
        ax_genss_genamode(a,am);
    };
}

static i64 ax_genss_getcurrdatalen(i64 id) {
    if ((ax_genss_currseg == (i64)3)) {
        return ax_decls_ss_zdatalen;
    };
    return ax_lib_bufferlength(ax_genss_currdata);
}

static void ax_genss_do_cmovcc(struct ax_decls_opndrec * c,struct ax_decls_opndrec * a,struct ax_decls_opndrec * b) {
    i64 am;
    i64 regcode;
    if ((((u64)((*a).size) != (u64)((*b).size)) && !!((u64)((*b).size)))) {
        ax_lib_gerror((byte*)"Opnd size mismatch");
    };
    if (((i64)((u64)((*a).size)) == (i64)1)) {
        ax_lib_gerror((byte*)"cmov/byte");
    };
    regcode = ax_genss_getregcoder((i64)((*a).reg));
    am = ax_genss_genrm(b,regcode);
    ax_genss_setopsize(a);
    ax_genss_genrex();
    ax_genss_genbyte((i64)15);
    ax_genss_genbyte(((i64)64 + (*c).value));
    ax_genss_genamode(b,am);
}

static void ax_genss_do_fmem(struct ax_decls_opndrec * a,i64 freal,i64 code) {
    i64 am;
    i64 mf;
    if (((i64)((u64)((*a).mode)) != (i64)3)) {
        ax_lib_gerror((byte*)"fmem/not mem");
    };
    if (!!(freal)) {
        if (((i64)((*a).size)==(i64)4)) {
            mf = (i64)0;
        }else if (((i64)((*a).size)==(i64)8)) {
            mf = (i64)2;
        }else if (((i64)((*a).size)==(i64)16)) {
            mf = (i64)1;
            if ((code==(i64)0)) {
                code = (i64)5;
            }else if ((code==(i64)3)) {
                code = (i64)7;
            } else {
                ax_lib_gerror((byte*)"r80 not allowed");
            };
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)"SIZE=",NULL);
            msysnewc_m_print_u64((*a).size,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            ax_lib_gerror((byte*)"fmem size");
        };
    } else {
        if (((i64)((*a).size)==(i64)2)) {
            mf = (i64)3;
        }else if (((i64)((*a).size)==(i64)4)) {
            mf = (i64)1;
        }else if (((i64)((*a).size)==(i64)8)) {
            mf = (i64)3;
            if ((code==(i64)0)) {
                code = (i64)5;
            }else if ((code==(i64)3)) {
                code = (i64)7;
            } else {
                ax_lib_gerror((byte*)"fst i64?");
            };
        } else {
            ax_lib_gerror((byte*)"fmem int size");
        };
    };
    am = ax_genss_genrm(a,code);
    ax_genss_genrex();
    ax_genss_genbyte(((i64)217 + (mf << (i64)1)));
    ax_genss_genamode(a,am);
}

static i64 ax_genss_getr32bits(double x) {
    float sx;
    sx = (float)(x);
    return (i64)(*(i32*)&sx);
}

static void ax_genss_genrel8(struct ax_decls_opndrec * a) {
    struct ax_decls_strec *  d;
    d = (*a).labeldef;
    if (((i64)((u64)((*d).reftype)) == (i64)1)) {
        (*d).fwdrefs = ax_genss_addfwdref((*d).fwdrefs,ax_genss_getcurrdatalen((i64)3),(i64)6,(i64)0);
        ax_genss_genbyte((i64)0);
    } else {
        ax_lib_gerror((byte*)"genrel8");
    };
}

static i64 ax_genss_checkshortjump(struct ax_lib_mclrec * m,struct ax_decls_strec * d) {
    i64 n;
    return (i64)0;
    n = (i64)0;
    m = (*m).nextmcl;
    L1213 :;
    while ((!!(m) && (n <= (i64)8))) {
        ++n;
        if ((((i64)((u64)((*m).opcode)) == (i64)4) && ((*(*m).a).labeldef == d))) {
            return (i64)1;
        };
        m = (*m).nextmcl;
L1214 :;
    }L1215 :;
    ;
    return (i64)0;
}

static struct ax_decls_fwdrec * ax_genss_addfwdref(struct ax_decls_fwdrec * p,i64 offset,i64 reltype,i64 seg) {
    struct ax_decls_fwdrec *  q;
    q = (struct ax_decls_fwdrec *)(mlib_pcm_alloc((i64)12));
    (*q).nextfwd = p;
    (*q).offset = offset;
    (*q).reltype = reltype;
    (*q).seg = seg;
    return q;
}

static void ax_genss_switchseg(i64 newseg) {
    if ((newseg == ax_genss_currseg)) {
        return;
    };
    if ((ax_genss_currseg==(i64)1)) {
        ax_decls_ss_coderelocs = ax_genss_currrelocs;
        ax_decls_ss_ncoderelocs = ax_genss_nrelocs;
    }else if ((ax_genss_currseg==(i64)2)) {
        ax_decls_ss_idatarelocs = ax_genss_currrelocs;
        ax_decls_ss_nidatarelocs = ax_genss_nrelocs;
    };
    ax_genss_currseg = newseg;
    if ((ax_genss_currseg==(i64)1)) {
        ax_genss_currdata = ax_decls_ss_code;
        ax_genss_currrelocs = ax_decls_ss_coderelocs;
        ax_genss_nrelocs = ax_decls_ss_ncoderelocs;
    }else if ((ax_genss_currseg==(i64)2)) {
        ax_genss_currdata = ax_decls_ss_idata;
        ax_genss_currrelocs = ax_decls_ss_idatarelocs;
        ax_genss_nrelocs = ax_decls_ss_nidatarelocs;
    }else if ((ax_genss_currseg==(i64)3)) {
        ax_genss_currdata = ax_decls_ss_zdata;
    };
}

static void ax_genss_do_movdqx(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 opc) {
    i64 am;
    i64 regcode;
    if (((i64)((*a).mode)==(i64)5)) {
        if (((i64)((*b).mode)==(i64)5)) {
            regcode = ax_genss_getregcodebx((i64)((*b).reg));
            am = ax_genss_genrm(a,regcode);
            ax_genss_genbyte(opc);
            ax_genss_genrex();
            ax_genss_genbyte((i64)15);
            ax_genss_genbyte((i64)111);
            ax_genss_genamode(a,am);
        }else if (((i64)((*b).mode)==(i64)3)) {
            regcode = ax_genss_getregcoderx((i64)((*a).reg));
            am = ax_genss_genrm(b,regcode);
            ax_genss_genbyte(opc);
            ax_genss_genrex();
            ax_genss_genbyte((i64)15);
            ax_genss_genbyte((i64)111);
            ax_genss_genamode(b,am);
        } else {
            ax_lib_gerror((byte*)"movdqx?");
        };
    }else if (((i64)((*a).mode)==(i64)3)) {
        if (((i64)((*b).mode)==(i64)5)) {
            regcode = ax_genss_getregcoderx((i64)((*b).reg));
            am = ax_genss_genrm(a,regcode);
            ax_genss_genbyte(opc);
            ax_genss_genrex();
            ax_genss_genbyte((i64)15);
            ax_genss_genbyte((i64)127);
            ax_genss_genamode(a,am);
        } else {
            ax_lib_gerror((byte*)"movdqx");
        };
    } else {
        ax_lib_gerror((byte*)"movdqx");
    };
}

static void ax_genss_do_popcnt(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b) {
    i64 am;
    i64 regcode;
    if (((i64)((u64)((*b).mode)) == (i64)3)) {
        if (((i64)((u64)((*b).size)) == (i64)0)) {
            (*b).size = (u64)((i64)8);
        };
    };
    ax_genss_genbyte((i64)243);
    regcode = ax_genss_getregcodebx((i64)((*a).reg));
    am = ax_genss_genrm(b,regcode);
    ax_genss_setopsize(a);
    ax_genss_genrex();
    ax_genss_genbyte((i64)15);
    ax_genss_genbyte((i64)184);
    ax_genss_genamode(b,am);
}

static void ax_genss_do_bsf(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 opc) {
    i64 am;
    i64 regcode;
    if (((i64)((u64)((*b).mode)) == (i64)3)) {
        if (((i64)((u64)((*b).size)) == (i64)0)) {
            (*b).size = (u64)((i64)8);
        };
    };
    if (((u64)((*a).size) != (u64)((*b).size))) {
        ax_lib_gerror((byte*)"bsf size");
    };
    regcode = ax_genss_getregcodebx((i64)((*a).reg));
    am = ax_genss_genrm(b,regcode);
    ax_genss_setopsize(a);
    ax_genss_genrex();
    ax_genss_genbyte((i64)15);
    ax_genss_genbyte(opc);
    ax_genss_genamode(b,am);
}

static void ax_genss_extendsymboltable(void) {
    struct ax_decls_strec * (*oldsymboltable)[];
    i64 oldsymboltablesize;
    i64 i;
    oldsymboltablesize = ax_decls_ss_symboltablesize;
    oldsymboltable = ax_decls_ss_symboltable;
    ax_decls_ss_symboltablesize *= (i64)2;
    msysnewc_m_print_startcon();
    msysnewc_m_print_str((byte*)"EXTENDING SYMBOL TABLE TO",NULL);
    msysnewc_m_print_i64(ax_decls_ss_symboltablesize,NULL);
    msysnewc_m_print_newline();
    msysnewc_m_print_end();
    ;
    ax_decls_ss_symboltable = (struct ax_decls_strec * (*)[])(mlib_pcm_alloc(((i64)4 * ax_decls_ss_symboltablesize)));
    L1216 :;
    for (i=(i64)1;i<=ax_decls_ss_nsymbols;i+=(i64)1) {
L1217 :;
        (*ax_decls_ss_symboltable)[(i)-1] = (*oldsymboltable)[(i)-1];
L1218 :;
    }L1219 :;
    ;
    mlib_pcm_free((void *)(oldsymboltable),((i64)4 * oldsymboltablesize));
}

static void ax_genss_do_pcmpistri(struct ax_decls_opndrec * a,struct ax_decls_opndrec * b,i64 c,i64 opc) {
    i64 am;
    i64 regcode;
    if ((((i64)((u64)((*a).mode)) != (i64)5) || (((i64)((u64)((*b).mode)) != (i64)5) && ((i64)((u64)((*b).mode)) != (i64)3)))) {
        ax_lib_gerror((byte*)"pcmpistrx opnds");
    };
    ax_genss_genbyte((i64)102);
    if (((i64)((u64)((*b).mode)) == (i64)5)) {
        {struct ax_decls_opndrec *  temp = a; a = b; b = temp; };
        regcode = ax_genss_getregcoderx((i64)((*b).reg));
        am = ax_genss_genrm(a,regcode);
        ax_genss_genrex();
        ax_genss_genbyte((i64)15);
        ax_genss_genbyte((i64)58);
        ax_genss_genbyte(opc);
        ax_genss_genamode(a,am);
    } else {
        regcode = ax_genss_getregcoderx((i64)((*a).reg));
        am = ax_genss_genrm(b,regcode);
        ax_genss_genrex();
        ax_genss_genbyte((i64)15);
        ax_genss_genbyte((i64)58);
        ax_genss_genbyte(opc);
        ax_genss_genamode(b,am);
    };
    ax_genss_genbyte(c);
}

void ax_writeexe_writeexe(byte * outfile) {
    i64 i;
    ax_writeexe_datastart = (ax_writeexe_dataptr = (byte *)(mlib_pcm_allocz(ax_writeexe_filesize)));
    ax_writeexe_writedosstub();
    ax_writeexe_writepesig();
    ax_writeexe_writefileheader();
    ax_writeexe_writeoptheader();
    L1220 :;
    for (i=(i64)1;i<=ax_writeexe_nsections;i+=(i64)1) {
L1221 :;
        ax_writeexe_writesectionheader(&ax_writeexe_sectiontable[(i)-1]);
L1222 :;
    }L1223 :;
    ;
    ax_writeexe_writepadding(ax_writeexe_sectiontable[((i64)1)-1].rawoffset);
    L1224 :;
    for (i=(i64)1;i<=ax_writeexe_nsections;i+=(i64)1) {
L1225 :;
        ax_writeexe_writesectiondata(&ax_writeexe_sectiontable[(i)-1]);
L1226 :;
    }L1227 :;
    ;
    if (!!(ax_decls_fverbose)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"Writing file:",NULL);
        msysnewc_m_print_str(outfile,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    if ((mlib_writefile(outfile,ax_writeexe_datastart,(ax_writeexe_dataptr - ax_writeexe_datastart)) == (i64)0)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"Error writing exe file (possibly still running)",NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        exit((i64)1);
    };
}

void ax_writeexe_genexe(byte * entrypoint) {
    ax_writeexe_userentrypoint = entrypoint;
    ax_writeexe_loadlibs();
    ax_writeexe_scanst();
    ax_writeexe_getoffsets();
    ax_writeexe_relocdata(&ax_writeexe_sectiontable[((i64)1)-1]);
    ax_writeexe_relocdata(&ax_writeexe_sectiontable[((i64)2)-1]);
}

static void ax_writeexe_loadlibs(void) {
    i64 i;
    i64 hinst;
    byte filename[300];
    L1228 :;
    for (i=(i64)1;i<=ax_decls_nsearchlibs;i+=(i64)1) {
L1229 :;
        strcpy((i8 *)(filename),(i8 *)(ax_decls_searchlibs[(i)-1]));
        strcat((i8 *)(filename),(i8 *)((byte*)".dll"));
        hinst = (i64)(osnos_os_getdllinst(filename));
        if ((hinst == (i64)0)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(ax_decls_searchlibs[(i)-1],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            ax_lib_gerror((byte*)"Can't load search lib");
        };
        ax_writeexe_libinsttable[(i)-1] = hinst;
        ax_writeexe_libinstnames[(i)-1] = mlib_pcm_copyheapstring(filename);
L1230 :;
    }L1231 :;
    ;
}

struct mlib_strbuffer * ax_writeexe_writessdata(i64 fexe) {
    mlib_gs_init(ax_lib_dest);
    ax_writeexe_showssdata(fexe);
    mlib_gs_line(ax_lib_dest);
    return ax_lib_dest;
}

void ax_writeexe_initsectiontable(void) {
    ax_writeexe_sectiontable[((i64)1)-1].name = (byte*)".text";
    ax_writeexe_sectiontable[((i64)1)-1].segtype = (i64)1;
    ax_writeexe_sectiontable[((i64)1)-1].data = ax_decls_ss_code;
    ax_writeexe_sectiontable[((i64)1)-1].virtsize = ax_lib_bufferlength(ax_decls_ss_code);
    if ((ax_lib_bufferlength(ax_decls_ss_idata) == (i64)0)) {
        ax_lib_addqword(ax_decls_ss_idata,(i64)0);
    };
    ax_writeexe_sectiontable[((i64)2)-1].name = (byte*)".data";
    ax_writeexe_sectiontable[((i64)2)-1].segtype = (i64)2;
    ax_writeexe_sectiontable[((i64)2)-1].data = ax_decls_ss_idata;
    ax_writeexe_sectiontable[((i64)2)-1].virtsize = ax_lib_bufferlength(ax_decls_ss_idata);
    ax_writeexe_sectiontable[((i64)2)-1].rawsize = ax_writeexe_roundtoblock(ax_writeexe_sectiontable[((i64)2)-1].virtsize,(i64)512);
    ax_writeexe_sectiontable[((i64)2)-1].nrelocs = ax_decls_ss_nidatarelocs;
    ax_writeexe_sectiontable[((i64)2)-1].relocs = ax_decls_ss_idatarelocs;
    if ((ax_decls_ss_zdatalen == (i64)0)) {
        ax_decls_ss_zdatalen = (i64)16;
    };
    ax_writeexe_sectiontable[((i64)3)-1].name = (byte*)".bss";
    ax_writeexe_sectiontable[((i64)3)-1].segtype = (i64)3;
    ax_writeexe_sectiontable[((i64)3)-1].virtsize = ax_decls_ss_zdatalen;
    ax_writeexe_sectiontable[((i64)1)-1].rawsize = ax_writeexe_roundtoblock(ax_writeexe_sectiontable[((i64)1)-1].virtsize,(i64)512);
    ax_writeexe_sectiontable[((i64)1)-1].nrelocs = ax_decls_ss_ncoderelocs;
    ax_writeexe_sectiontable[((i64)1)-1].relocs = ax_decls_ss_coderelocs;
    ax_writeexe_sectiontable[((i64)4)-1].name = (byte*)".idata";
    ax_writeexe_sectiontable[((i64)4)-1].segtype = (i64)5;
    ax_writeexe_sectiontable[((i64)4)-1].virtsize = (i64)0;
    ax_writeexe_sectiontable[((i64)4)-1].rawsize = (i64)0;
    ax_writeexe_nsections = (i64)4;
}

static void ax_writeexe_showssdata(i64 fexe) {
    mlib_gs_strln(ax_lib_dest,(!!(fexe)?(byte*)"EXE FORMAT":(byte*)"AFTER GENSS"));
    ax_writeexe_showsections();
    mlib_gs_line(ax_lib_dest);
    ax_writeexe_showsectionrelocs2((byte*)"Idata",ax_decls_ss_idatarelocs,ax_decls_ss_nidatarelocs);
    ax_writeexe_showsectionrelocs2((byte*)"Code",ax_decls_ss_coderelocs,ax_decls_ss_ncoderelocs);
    mlib_gs_str(ax_lib_dest,(byte*)"proc Section Zdata: ");
    mlib_gs_strint(ax_lib_dest,ax_decls_ss_zdatalen);
    mlib_gs_line(ax_lib_dest);
    ax_writeexe_showsectiondata(&ax_writeexe_sectiontable[((i64)2)-1]);
    ax_writeexe_showsectioncode(&ax_writeexe_sectiontable[((i64)1)-1]);
    if (!!(fexe)) {
        ax_writeexe_showsectiondata(&ax_writeexe_sectiontable[((i64)4)-1]);
    };
    ax_writeexe_showsymboltable2();
    ax_writeexe_showimporttable();
    mlib_gs_strln(ax_lib_dest,(byte*)"END OF GENSS");
}

static void ax_writeexe_showsectiondata(struct ax_writeexe_sectionrec * d) {
    i64 i;
    i64 k;
    i64 length;
    i64 bb;
    byte str[128];
    byte str2[128];
    byte *  p;
    byte *  baseaddr;
    i64 av_1;
    mlib_gs_str(ax_lib_dest,(byte*)"proc Section ");
    mlib_gs_str(ax_lib_dest,(*d).name);
    mlib_gs_str(ax_lib_dest,(byte*)" Size:");
    mlib_gs_strint(ax_lib_dest,(*d).virtsize);
    mlib_gs_line(ax_lib_dest);
    mlib_gs_line(ax_lib_dest);
    k = (i64)0;
    if (((*d).segtype != (i64)5)) {
        p = (byte *)(ax_lib_bufferelemptr((*d).data,(i64)0));
    } else {
        p = (*d).bytedata;
    };
    length = (*d).virtsize;
    str[((i64)1)-1] = (u64)0u;
    baseaddr = (byte *)(u32)(((i64)4194304 + (*d).virtoffset));
    msysnewc_m_print_startstr(str2);
    msysnewc_m_print_ptr(baseaddr,(byte*)"Z8H");
    msysnewc_m_print_nogap();
    msysnewc_m_print_str((byte*)": ",NULL);
    msysnewc_m_print_end();
    ;
    mlib_gs_str(ax_lib_dest,str2);
    L1232 :;
    for (i=(i64)1;i<=length;i+=(i64)1) {
L1233 :;
        bb = (i64)((*p++));
        msysnewc_m_print_startstr(str2);
        msysnewc_m_print_i64(bb,(byte*)"z2H");
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((byte*)" ",NULL);
        msysnewc_m_print_end();
        ;
        mlib_gs_str(ax_lib_dest,str2);
        if ((((i64)32 <= bb) && (bb <= (i64)127))) {
            str2[((i64)1)-1] = (u64)(bb);
            str2[((i64)2)-1] = (u64)0u;
            strcat((i8 *)(str),(i8 *)(str2));
        } else {
            strcat((i8 *)(str),(i8 *)((byte*)"."));
        };
        if (((++k == (i64)16) || (i == length))) {
            if ((k < (i64)16)) {
                av_1 = ((i64)16 - k);
                while (av_1-- > 0) {
L1236 :;
                    mlib_gs_str(ax_lib_dest,(byte*)"   ");
                    strcat((i8 *)(str),(i8 *)((byte*)" "));
L1237 :;
                }L1238 :;
                ;
            };
            mlib_gs_str(ax_lib_dest,(byte*)"\t[");
            mlib_gs_str(ax_lib_dest,str);
            mlib_gs_strln(ax_lib_dest,(byte*)"]");
            k = (i64)0;
            str[((i64)1)-1] = (u64)0u;
            baseaddr += (i64)16;
            msysnewc_m_print_startstr(str2);
            msysnewc_m_print_ptr(baseaddr,(byte*)"z8h");
            msysnewc_m_print_nogap();
            msysnewc_m_print_str((byte*)": ",NULL);
            msysnewc_m_print_end();
            ;
            mlib_gs_str(ax_lib_dest,str2);
        };
L1234 :;
    }L1235 :;
    ;
    if ((k == (i64)0)) {
        mlib_gs_line(ax_lib_dest);
    };
    mlib_gs_line(ax_lib_dest);
    if (!!(k)) {
        mlib_gs_line(ax_lib_dest);
    };
}

static void ax_writeexe_showsectioncode(struct ax_writeexe_sectionrec * p) {
    byte *  codeptr;
    byte *  codeend;
    byte *  codestart;
    i64 length;
    i64 offset;
    byte *  s;
    byte str[16];
    byte *  baseaddr;
    mlib_gs_strln(ax_lib_dest,(byte*)"proc Section Code");
    length = (*p).virtsize;
    codestart = (codeptr = (byte *)(ax_lib_bufferelemptr((*p).data,(i64)0)));
    codeend = (codeptr + length);
    baseaddr = (byte *)(u32)(((i64)4194304 + (*p).virtoffset));
    L1239 :;
    while ((codeptr < codeend)) {
        offset = (codeptr - codestart);
        s = ax_disasm_decodeinstr(&codeptr,(baseaddr + offset));
        if ((s == 0)) {
            goto L1241 ;
        };
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_i64(offset,(byte*)"4");
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((byte*)" ",NULL);
        msysnewc_m_print_end();
        ;
        mlib_gs_str(ax_lib_dest,str);
        mlib_gs_strln(ax_lib_dest,s);
L1240 :;
    }L1241 :;
    ;
    mlib_gs_line(ax_lib_dest);
}

static void ax_writeexe_showsectionrelocs2(byte * caption,struct ax_decls_relocrec * relocs,i64 nrelocs) {
    struct ax_decls_relocrec *  r;
    mlib_gs_str(ax_lib_dest,(byte*)"proc Section Relocs: ");
    mlib_gs_str(ax_lib_dest,caption);
    mlib_gs_str(ax_lib_dest,(byte*)" ");
    mlib_gs_strint(ax_lib_dest,nrelocs);
    mlib_gs_line(ax_lib_dest);
    r = relocs;
    L1242 :;
    while (!!(r)) {
        mlib_gs_str(ax_lib_dest,(byte*)"Reloc: ");
        mlib_gs_str(ax_lib_dest,ax_objdecls_relocnames[((*r).reloctype)]);
        mlib_gs_str(ax_lib_dest,(byte*)" Offset: ");
        mlib_gs_strint(ax_lib_dest,(*r).offset);
        mlib_gs_str(ax_lib_dest,(byte*)" ST Index: ");
        mlib_gs_strint(ax_lib_dest,(*r).stindex);
        mlib_gs_str(ax_lib_dest,(byte*)" ");
        mlib_gs_str(ax_lib_dest,(*(*ax_decls_ss_symboltable)[((*r).stindex)-1]).name);
        mlib_gs_line(ax_lib_dest);
        r = (*r).nextreloc;
L1243 :;
    }L1244 :;
    ;
    mlib_gs_line(ax_lib_dest);
}

static void ax_writeexe_gs_value(byte * caption,i64 value) {
    byte str[256];
    strcpy((i8 *)(str),(i8 *)(caption));
    strcat((i8 *)(str),(i8 *)((byte*)":"));
    mlib_ipadstr(str,(i64)20,(byte*)" ");
    mlib_gs_str(ax_lib_dest,str);
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_setfmt((byte*)"0x# #");
    msysnewc_m_print_i64(value,(byte*)"H");
    msysnewc_m_print_i64(value,NULL);
    msysnewc_m_print_end();
    ;
    mlib_gs_strln(ax_lib_dest,str);
}

static void ax_writeexe_showsymboltable2(void) {
    i64 i;
    mlib_gs_strln(ax_lib_dest,(byte*)"Proc Symbol Table");
    L1245 :;
    for (i=(i64)1;i<=ax_decls_ss_nsymbols;i+=(i64)1) {
L1246 :;
        mlib_gs_strint(ax_lib_dest,i);
        mlib_gs_str(ax_lib_dest,(byte*)": ");
        mlib_gs_strln(ax_lib_dest,(*(*ax_decls_ss_symboltable)[(i)-1]).name);
L1247 :;
    }L1248 :;
    ;
    mlib_gs_line(ax_lib_dest);
}

static void ax_writeexe_showimporttable(void) {
    byte str[256];
    struct ax_writeexe_importrec p;
    i64 i;
    mlib_gs_strln(ax_lib_dest,(byte*)"Proc Dll List");
    L1249 :;
    for (i=(i64)1;i<=ax_writeexe_ndlls;i+=(i64)1) {
L1250 :;
        mlib_gs_strint(ax_lib_dest,i);
        mlib_gs_str(ax_lib_dest,(byte*)": ");
        mlib_gs_str(ax_lib_dest,ax_writeexe_dlltable[(i)-1].name);
        mlib_gs_str(ax_lib_dest,(byte*)" ");
        mlib_gs_strint(ax_lib_dest,ax_writeexe_dlltable[(i)-1].nprocs);
        mlib_gs_line(ax_lib_dest);
        ax_writeexe_gs_value((byte*)"\t\tName Table Offset",ax_writeexe_dlltable[(i)-1].nametableoffset);
        ax_writeexe_gs_value((byte*)"\t\tAddr Table Offset",ax_writeexe_dlltable[(i)-1].addrtableoffset);
        ax_writeexe_gs_value((byte*)"\t\tDLL Name Offset  ",ax_writeexe_dlltable[(i)-1].dllnameoffset);
L1251 :;
    }L1252 :;
    ;
    mlib_gs_line(ax_lib_dest);
    mlib_gs_strln(ax_lib_dest,(byte*)"Proc Import List");
    L1253 :;
    for (i=(i64)1;i<=ax_writeexe_nimports;i+=(i64)1) {
L1254 :;
        p = ax_writeexe_importtable[(i)-1];
        mlib_gs_strint(ax_lib_dest,i);
        mlib_gs_str(ax_lib_dest,(byte*)": ");
        if (!!(p.libno)) {
            strcpy((i8 *)(str),(i8 *)(p.name));
            mlib_ipadstr(str,(i64)16,(byte*)" ");
            mlib_gs_str(ax_lib_dest,str);
            mlib_gs_str(ax_lib_dest,(byte*)" (");
            mlib_gs_str(ax_lib_dest,ax_writeexe_dlltable[(p.libno)-1].name);
            mlib_gs_strln(ax_lib_dest,(byte*)")");
            ax_writeexe_gs_value((byte*)"\tIAT Offset        ",p.iatoffset);
            ax_writeexe_gs_value((byte*)"\tThunk Offset      ",p.thunkoffset);
            ax_writeexe_gs_value((byte*)"\tHint/Name Offset  ",p.hintnameoffset);
        } else {
            strcpy((i8 *)(str),(i8 *)(p.name));
            mlib_ipadstr(str,(i64)20,(byte*)" ");
            mlib_gs_str(ax_lib_dest,str);
            mlib_gs_strln(ax_lib_dest,(byte*)" (---)");
        };
L1255 :;
    }L1256 :;
    ;
    mlib_gs_line(ax_lib_dest);
}

static i64 ax_writeexe_roundtoblock(i64 n,i64 align) {
    if (((n & (align - (i64)1)) == (i64)0)) {
        return n;
    };
    return (n + (align - (n & (align - (i64)1))));
}

static void ax_writeexe_showsections(void) {
    struct ax_writeexe_sectionrec s;
    i64 i;
    mlib_gs_strln(ax_lib_dest,(byte*)"proc Section Headersxxx");
    mlib_gs_line(ax_lib_dest);
    L1257 :;
    for (i=(i64)1;i<=ax_writeexe_nsections;i+=(i64)1) {
L1258 :;
        s = ax_writeexe_sectiontable[(i)-1];
        mlib_gs_str(ax_lib_dest,(byte*)"Section ");
        mlib_gs_strint(ax_lib_dest,i);
        mlib_gs_str(ax_lib_dest,(byte*)": ");
        mlib_gs_str(ax_lib_dest,s.name);
        mlib_gs_str(ax_lib_dest,(byte*)"  (");
        mlib_gs_str(ax_lib_dest,ax_tables_segmentnames[(s.segtype)-1]);
        mlib_gs_strln(ax_lib_dest,(byte*)")");
        ax_writeexe_gs_value((byte*)"    Raw Offset",s.rawoffset);
        ax_writeexe_gs_value((byte*)"    Raw Size",s.rawsize);
        ax_writeexe_gs_value((byte*)"    Virtual Offset",s.virtoffset);
        ax_writeexe_gs_value((byte*)"    Virtual Size",s.virtsize);
        ax_writeexe_gs_value((byte*)"    Nrelocs",s.nrelocs);
        ax_writeexe_gs_value((byte*)"    Data",(i64)(u32)(s.data));
        mlib_gs_line(ax_lib_dest);
L1259 :;
    }L1260 :;
    ;
}

static byte * ax_writeexe_extractlibname(byte * name,i64 * libno,i64 moduleno) {
    byte *  s;
    byte *  name2;
    byte str[256];
    i64 i;
    i64 n;
    name2 = (byte *)(0);
    /*reenter:*/
L1261 :;
;
    s = name;
    (*libno) = (i64)0;
    L1262 :;
    while (!!((u64)((*s)))) {
        if (((u64)((*s)) == '.')) {
            memcpy((void *)(str),(void *)(name),(u32)((s - name)));
            str[(((s - name) + (i64)1))-1] = (u64)0u;
            strcat((i8 *)(str),(i8 *)((byte*)".dll"));
            L1265 :;
            for (i=(i64)1;i<=ax_writeexe_ndlls;i+=(i64)1) {
L1266 :;
                if (!!(mlib_eqstring(str,ax_writeexe_dlltable[(i)-1].name))) {
                    (*libno) = i;
                    ++ax_writeexe_dlltable[((*libno))-1].nprocs;
                    return (!!(name2)?name2:(s + (i64)1));
                };
L1267 :;
            }L1268 :;
            ;
            if ((ax_writeexe_ndlls >= (i64)50)) {
                ax_lib_gerror((byte*)"Too many libs");
            };
            (*libno) = ++ax_writeexe_ndlls;
            ax_writeexe_dlltable[((*libno))-1].name = mlib_pcm_copyheapstring(str);
            ax_writeexe_dlltable[((*libno))-1].nprocs = (i64)1;
            return (!!(name2)?name2:(s + (i64)1));
        };
        ++s;
L1263 :;
    }L1264 :;
    ;
    L1269 :;
    for (i=(i64)1;i<=ax_decls_nsearchlibs;i+=(i64)1) {
L1270 :;
        if (!!(osnos_os_getdllprocaddr((i32)(ax_writeexe_libinsttable[(i)-1]),name))) {
            n = i;
            goto L1272 ;
        };
L1271 :;
    }
    {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str(name,NULL);
        msysnewc_m_print_str(ax_decls_moduletable[(moduleno)-1].name,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
        ax_lib_gerror((byte*)"Can't find external function");
    }L1272 :;
    ;
    if (!!(((*libno) = ax_writeexe_libnotable[(n)-1]))) {
        ++ax_writeexe_dlltable[((*libno))-1].nprocs;
        return name;
    };
    strcpy((i8 *)(str),(i8 *)(ax_decls_searchlibs[(n)-1]));
    strcat((i8 *)(str),(i8 *)((byte*)".dll"));
    if ((ax_writeexe_ndlls >= (i64)50)) {
        ax_lib_gerror((byte*)"2:Too many libs");
    };
    (*libno) = ++ax_writeexe_ndlls;
    ax_writeexe_dlltable[((*libno))-1].name = mlib_pcm_copyheapstring(str);
    ax_writeexe_dlltable[((*libno))-1].nprocs = (i64)1;
    ax_writeexe_libnotable[(n)-1] = (*libno);
    return name;
}

static void ax_writeexe_scanst(void) {
    i64 i;
    i64 libno;
    struct ax_decls_strec *  d;
    byte *  name;
    L1273 :;
    for (i=(i64)1;i<=ax_decls_ss_nsymbols;i+=(i64)1) {
L1274 :;
        d = (*ax_decls_ss_symboltable)[(i)-1];
        if (((i64)((*d).symbol)==(i64)21)) {
            if ((ax_writeexe_nimports >= (i64)3000)) {
                ax_lib_gerror((byte*)"genexe: Too many imports");
            };
            ++ax_writeexe_nimports;
            name = ax_writeexe_extractlibname((*d).name,&libno,(i64)((*d).moduleno));
            ax_writeexe_importtable[(ax_writeexe_nimports)-1].libno = libno;
            ax_writeexe_importtable[(ax_writeexe_nimports)-1].name = name;
            ax_writeexe_importtable[(ax_writeexe_nimports)-1].def = d;
            (*d).importindex = ax_writeexe_nimports;
        }else if (((i64)((*d).symbol)==(i64)22)) {
            if (!!(ax_writeexe_userentrypoint)) {
                if (!!(mlib_eqstring((*d).name,ax_writeexe_userentrypoint))) {
                    ax_writeexe_stentrypoint = d;
                };
            } else {
                if (!!(mlib_eqstring((*d).name,(byte*)"main"))) {
                    ax_writeexe_stentrypoint = d;
                } else if (!!(mlib_eqstring((*d).name,(byte*)"start"))) {
                    ax_writeexe_stentrypoint2 = d;
                } else if (!!(mlib_eqstring((*d).name,(byte*)"WinMain"))) {
                    ax_writeexe_stentrypoint3 = d;
                };
            };
        };
L1275 :;
    }L1276 :;
    ;
}

static void ax_writeexe_relocdata(struct ax_writeexe_sectionrec * s) {
    struct ax_writeexe_sectionrec *  u;
    struct ax_decls_relocrec *  r;
    byte *  p;
    u32 *  p32;
    struct ax_decls_strec *  d;
    i64 index;
    i64 thunkoffset;
    p = (byte *)(ax_lib_bufferelemptr((*s).data,(i64)0));
    r = (*s).relocs;
    L1277 :;
    while (!!(r)) {
        d = (*ax_decls_ss_symboltable)[((*r).stindex)-1];
        index = (i64)((*d).importindex);
        thunkoffset = ax_writeexe_importtable[(index)-1].thunkoffset;
        if (((*r).reloctype==(i64)4)) {
            if (((i64)((u64)((*d).symbol)) != (i64)21)) {
                ax_lib_gerror((byte*)"rel32/not imported");
            };
            (*(u32 *)((p + (*r).offset))) = (u64)(((thunkoffset - (*r).offset) - (i64)4));
        }else if (((*r).reloctype==(i64)2) || ((*r).reloctype==(i64)1)) {
            if (((i64)((u64)((*d).symbol)) == (i64)21)) {
                (*(u32 *)((p + (*r).offset))) = (u64)((((i64)4194304 + thunkoffset) + ax_writeexe_sectiontable[((i64)1)-1].virtoffset));
            } else {
                if (((i64)((*d).segment)==(i64)3)) {
                    u = &ax_writeexe_sectiontable[((i64)3)-1];
                }else if (((i64)((*d).segment)==(i64)2)) {
                    u = &ax_writeexe_sectiontable[((i64)2)-1];
                }else if (((i64)((*d).segment)==(i64)1)) {
                    u = &ax_writeexe_sectiontable[((i64)1)-1];
                };
                p32 = (u32 *)((p + (*r).offset));
                (*p32) = (u64)((((i64)((u64)((*p32))) + (*u).virtoffset) + (i64)4194304));
            };
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(ax_objdecls_relocnames[((*r).reloctype)],NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            ax_lib_gerror((byte*)"Can't do this rel type");
        };
        r = (*r).nextreloc;
L1278 :;
    }L1279 :;
    ;
}

static void ax_writeexe_writerecordx(void * r,i64 length) {
    memcpy((void *)(ax_writeexe_dataptr),r,(u32)(length));
    ax_writeexe_dataptr += length;
}

static void ax_writeexe_writedosstub(void) {
    static byte stubdata[128] = {
    (u8)77u,
    (u8)90u,
    (u8)144u,
    (u8)0u,
    (u8)3u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)4u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)255u,
    (u8)255u,
    (u8)0u,
    (u8)0u,
    (u8)184u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)64u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)128u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)14u,
    (u8)31u,
    (u8)186u,
    (u8)14u,
    (u8)0u,
    (u8)180u,
    (u8)9u,
    (u8)205u,
    (u8)33u,
    (u8)184u,
    (u8)1u,
    (u8)76u,
    (u8)205u,
    (u8)33u,
    (u8)84u,
    (u8)104u,
    (u8)105u,
    (u8)115u,
    (u8)32u,
    (u8)112u,
    (u8)114u,
    (u8)111u,
    (u8)103u,
    (u8)114u,
    (u8)97u,
    (u8)109u,
    (u8)32u,
    (u8)99u,
    (u8)97u,
    (u8)110u,
    (u8)110u,
    (u8)111u,
    (u8)116u,
    (u8)32u,
    (u8)98u,
    (u8)101u,
    (u8)32u,
    (u8)114u,
    (u8)117u,
    (u8)110u,
    (u8)32u,
    (u8)105u,
    (u8)110u,
    (u8)32u,
    (u8)68u,
    (u8)79u,
    (u8)83u,
    (u8)32u,
    (u8)109u,
    (u8)111u,
    (u8)100u,
    (u8)101u,
    (u8)46u,
    (u8)13u,
    (u8)13u,
    (u8)10u,
    (u8)36u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u,
    (u8)0u
};
    ax_writeexe_writerecordx((void *)(&stubdata),(i64)128);
}

static void ax_writeexe_writepesig(void) {
    (*ax_writeexe_dataptr++) = (u64)80u;
    (*ax_writeexe_dataptr++) = (u64)69u;
    (*ax_writeexe_dataptr++) = (u64)((i64)0);
    (*ax_writeexe_dataptr++) = (u64)((i64)0);
}

static void ax_writeexe_writepadding(i64 offset) {
    ax_writeexe_dataptr = (ax_writeexe_datastart + offset);
}

static void ax_writeexe_writefileheader(void) {
    struct ax_objdecls_imagefileheader header;
    memset((void *)(&header),(i32)0,(u32)20u);
    header.machine = (u64)((i64)34404);
    header.nsections = (u64)(ax_writeexe_nsections);
    header.optheadersize = (u64)((i64)240);
    header.characteristics = (u64)((i64)559);
    ax_writeexe_writerecordx((void *)(&header),(i64)20);
}

static void ax_writeexe_writeoptheader(void) {
    struct ax_objdecls_optionalheader header;
    memset((void *)(&header),(i32)0,(u32)240u);
    header.magic = (u64)((i64)523);
    header.majorlv = (u64)((i64)1);
    header.minorlv = (u64)((i64)0);
    header.codesize = (u64)(ax_writeexe_sectiontable[((i64)1)-1].rawsize);
    header.idatasize = (u64)((ax_writeexe_sectiontable[((i64)2)-1].rawsize + ax_writeexe_sectiontable[((i64)4)-1].rawsize));
    header.zdatasize = (u64)(ax_writeexe_roundtoblock(ax_writeexe_sectiontable[((i64)3)-1].virtsize,(i64)512));
    if ((ax_writeexe_stentrypoint == 0)) {
        ax_writeexe_stentrypoint = ax_writeexe_stentrypoint2;
        if ((ax_writeexe_stentrypoint == 0)) {
            ax_writeexe_stentrypoint = ax_writeexe_stentrypoint3;
            if (!!(ax_writeexe_stentrypoint)) {
                msysnewc_m_print_startcon();
                msysnewc_m_print_str((byte*)"Using tertiary 'WinMain' entry point",NULL);
                msysnewc_m_print_newline();
                msysnewc_m_print_end();
                ;
            };
        };
    };
    if ((ax_writeexe_stentrypoint == 0)) {
        if (!!(ax_writeexe_userentrypoint)) {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str(ax_writeexe_userentrypoint,NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
            ax_lib_gerror((byte*)"User entry point not found");
        } else {
            ax_lib_gerror((byte*)"Entry point not found: main or start");
        };
    };
    header.entrypoint = (u64)((ax_writeexe_sectiontable[((i64)1)-1].virtoffset + (i64)((*ax_writeexe_stentrypoint).offset)));
    header.codebase = (u64)((i64)4096);
    header.imagebase = (u64)((i64)4194304);
    header.sectionalignment = (u64)((i64)4096);
    header.filealignment = (u64)((i64)512);
    header.majorosv = (u64)((i64)4);
    header.minorosv = (u64)((i64)0);
    header.majorssv = (u64)((i64)5);
    header.minorssv = (u64)((i64)2);
    header.imagesize = (u64)(ax_writeexe_imagesize);
    header.headerssize = (u64)(ax_writeexe_sectiontable[((i64)1)-1].rawoffset);
    header.subsystem = (u64)((i64)3);
    header.stackreserve = (u64)((i64)4194304);
    header.stackcommit = (u64)((i64)2097152);
    header.heapreserve = (u64)((i64)1048576);
    header.heapcommit = (u64)((i64)4096);
    header.rvadims = (u64)((i64)16);
    header.importtable.virtualaddr = (u64)(ax_writeexe_sectiontable[((i64)4)-1].virtoffset);
    header.importtable.size = (u64)((i64)128);
    header.iat.virtualaddr = (u64)(ax_writeexe_fileiatoffset);
    header.iat.size = (u64)(ax_writeexe_fileiatsize);
    ax_writeexe_writerecordx((void *)(&header),(i64)240);
}

static void ax_writeexe_writesectionheader(struct ax_writeexe_sectionrec * s) {
    struct ax_objdecls_imagesectionheader sheader;
    i64 aa;
    memset((void *)(&sheader),(i32)0,(u32)40u);
    strcpy((i8 *)(&sheader.name[((i64)1)-1]),(i8 *)((*s).name));
    sheader.virtual_size = (u64)((*s).virtsize);
    sheader.virtual_address = (u64)((*s).virtoffset);
    sheader.rawdata_offset = (u64)((*s).rawoffset);
    sheader.rawdata_size = (u64)((*s).rawsize);
    if (((*s).segtype==(i64)3)) {
        aa = (i64)3226468480LL;
        sheader.characteristics = (u64)(aa);
    }else if (((*s).segtype==(i64)2)) {
        aa = (i64)3226468416LL;
        sheader.characteristics = (u64)(aa);
    }else if (((*s).segtype==(i64)1)) {
        aa = (i64)1615855648;
        sheader.characteristics = (u64)(aa);
    }else if (((*s).segtype==(i64)5)) {
        aa = (i64)3224371264LL;
        sheader.characteristics = (u64)(aa);
    };
    ax_writeexe_writerecordx((void *)(&sheader),(i64)40);
}

static void ax_writeexe_writesectiondata(struct ax_writeexe_sectionrec * s) {
    if (((*s).segtype==(i64)5)) {
        ax_writeexe_writerecordx((void *)((*s).bytedata),(*s).virtsize);
        if (((*s).rawsize > (*s).virtsize)) {
            ax_writeexe_dataptr += ((*s).rawsize - (*s).virtsize);
        };
    }else if (((*s).segtype==(i64)3)) {
    } else {
        ax_writeexe_writerecordx(ax_lib_bufferelemptr((*s).data,(i64)0),(*s).rawsize);
    };
}

static void ax_writeexe_getoffsets(void) {
    i64 fileoffset;
    i64 imageoffset;
    i64 i;
    i64 diroffset;
    i64 impdirno;
    i64 hinttableoffset;
    i64 j;
    i64 codesize;
    i64 length;
    i64 thunkoffset;
    i64 offset;
    i64 dirstartoffset;
    byte *  pcode;
    byte *  pimpdir;
    struct ax_objdecls_importdirrec *  pdir;
    i64 *  paddr;
    i64 *  pname;
    i64 iatoffset;
    byte *  phint;
    u32 *  pextra;
    i64 xxx;
    i64 av_1;
    byte *  thunkptr;
    byte *  codebase;
    i64 thunkaddr;
    fileoffset = (i64)392;
    fileoffset += ((i64)40 * ax_writeexe_nsections);
    fileoffset = ax_writeexe_roundtoblock(fileoffset,(i64)512);
    imageoffset = (i64)4096;
    codesize = ax_writeexe_sectiontable[((i64)1)-1].virtsize;
    pcode = (byte *)(ax_lib_bufferelemptr(ax_decls_ss_code,codesize));
    L1280 :;
    while (!!((codesize & (i64)7))) {
        (*pcode++) = (u64)((i64)144);
        ++codesize;
L1281 :;
    }L1282 :;
    ;
    thunkoffset = codesize;
    codesize += (ax_writeexe_nimports * (i64)8);
    ax_writeexe_sectiontable[((i64)1)-1].virtsize = codesize;
    ax_writeexe_sectiontable[((i64)1)-1].rawsize = ax_writeexe_roundtoblock(codesize,(i64)512);
    ax_lib_buffercheck(ax_decls_ss_code,((codesize - thunkoffset) + (i64)16));
    L1283 :;
    for (i=(i64)1;i<=ax_writeexe_nsections;i+=(i64)1) {
L1284 :;
        if ((ax_writeexe_sectiontable[(i)-1].segtype != (i64)3)) {
            ax_writeexe_sectiontable[(i)-1].rawoffset = fileoffset;
        };
        if ((ax_writeexe_sectiontable[(i)-1].segtype != (i64)3)) {
            fileoffset = ax_writeexe_roundtoblock((fileoffset + ax_writeexe_sectiontable[(i)-1].virtsize),(i64)512);
        };
        ax_writeexe_sectiontable[(i)-1].virtoffset = imageoffset;
        if ((ax_writeexe_sectiontable[(i)-1].segtype == (i64)5)) {
            diroffset = imageoffset;
            impdirno = i;
        };
        imageoffset = ax_writeexe_roundtoblock((imageoffset + ax_writeexe_sectiontable[(i)-1].virtsize),(i64)4096);
L1285 :;
    }L1286 :;
    ;
    diroffset += ((ax_writeexe_ndlls + (i64)1) * (i64)20);
    L1287 :;
    for (i=(i64)1;i<=ax_writeexe_ndlls;i+=(i64)1) {
L1288 :;
        ax_writeexe_dlltable[(i)-1].nametableoffset = diroffset;
        diroffset += ((ax_writeexe_dlltable[(i)-1].nprocs + (i64)1) * (i64)8);
L1289 :;
    }L1290 :;
    ;
    ax_writeexe_fileiatoffset = diroffset;
    L1291 :;
    for (i=(i64)1;i<=ax_writeexe_ndlls;i+=(i64)1) {
L1292 :;
        ax_writeexe_dlltable[(i)-1].addrtableoffset = diroffset;
        diroffset += ((ax_writeexe_dlltable[(i)-1].nprocs + (i64)1) * (i64)8);
L1293 :;
    }L1294 :;
    ;
    ax_writeexe_fileiatsize = (diroffset - ax_writeexe_fileiatoffset);
    hinttableoffset = diroffset;
    L1295 :;
    for (i=(i64)1;i<=ax_writeexe_nimports;i+=(i64)1) {
L1296 :;
        length = ((i64)((u64)(strlen((i8 *)(ax_writeexe_importtable[(i)-1].name)))) + (i64)3);
        if (!!((length & (i64)1))) {
            ++length;
        };
        ax_writeexe_importtable[(i)-1].hintnameoffset = diroffset;
        diroffset += length;
L1297 :;
    }L1298 :;
    ;
    diroffset = ax_writeexe_roundtoblock(diroffset,(i64)4);
    L1299 :;
    for (i=(i64)1;i<=ax_writeexe_ndlls;i+=(i64)1) {
L1300 :;
        length = ((i64)((u64)(strlen((i8 *)(ax_writeexe_dlltable[(i)-1].name)))) + (i64)1);
        if (!!((length & (i64)1))) {
            ++length;
        };
        ax_writeexe_dlltable[(i)-1].dllextraoffset = diroffset;
        diroffset += (ax_writeexe_dlltable[(i)-1].nprocs * (i64)4);
        ax_writeexe_dlltable[(i)-1].dllnameoffset = diroffset;
        diroffset += length;
L1301 :;
    }L1302 :;
    ;
    dirstartoffset = ax_writeexe_sectiontable[(impdirno)-1].virtoffset;
    offset = (diroffset - dirstartoffset);
    ax_writeexe_sectiontable[(impdirno)-1].virtsize = offset;
    ax_writeexe_sectiontable[(impdirno)-1].rawsize = ax_writeexe_roundtoblock(offset,(i64)512);
    ax_writeexe_filesize = ax_writeexe_roundtoblock((fileoffset + offset),(i64)512);
    ax_writeexe_imagesize = ax_writeexe_roundtoblock((imageoffset + (diroffset - dirstartoffset)),(i64)4096);
    pimpdir = (ax_writeexe_sectiontable[(impdirno)-1].bytedata = (byte *)(mlib_pcm_allocz(offset)));
    pdir = (struct ax_objdecls_importdirrec *)(pimpdir);
    L1303 :;
    for (i=(i64)1;i<=ax_writeexe_ndlls;i+=(i64)1) {
L1304 :;
        (*pdir).implookuprva = (u64)(ax_writeexe_dlltable[(i)-1].nametableoffset);
        (*pdir).impaddressrva = (u64)(ax_writeexe_dlltable[(i)-1].addrtableoffset);
        (*pdir).namerva = (u64)(ax_writeexe_dlltable[(i)-1].dllnameoffset);
        ++pdir;
        iatoffset = ax_writeexe_dlltable[(i)-1].addrtableoffset;
        paddr = (i64 *)(((pimpdir + iatoffset) - dirstartoffset));
        pname = (i64 *)(((pimpdir + ax_writeexe_dlltable[(i)-1].nametableoffset) - dirstartoffset));
        L1307 :;
        for (j=(i64)1;j<=ax_writeexe_nimports;j+=(i64)1) {
L1308 :;
            if ((ax_writeexe_importtable[(j)-1].libno == i)) {
                (*pname) = ((*paddr) = ax_writeexe_importtable[(j)-1].hintnameoffset);
                ax_writeexe_importtable[(j)-1].iatoffset = iatoffset;
                iatoffset += (i64)8;
                ++pname;
                ++paddr;
            };
L1309 :;
        }L1310 :;
        ;
L1305 :;
    }L1306 :;
    ;
    L1311 :;
    for (i=(i64)1;i<=ax_writeexe_nimports;i+=(i64)1) {
L1312 :;
        phint = ((pimpdir + ax_writeexe_importtable[(i)-1].hintnameoffset) - dirstartoffset);
        phint += (i64)2;
        strcpy((i8 *)(phint),(i8 *)(ax_writeexe_importtable[(i)-1].name));
L1313 :;
    }L1314 :;
    ;
    xxx = dirstartoffset;
    L1315 :;
    for (i=(i64)1;i<=ax_writeexe_ndlls;i+=(i64)1) {
L1316 :;
        pextra = (u32 *)(((pimpdir + ax_writeexe_dlltable[(i)-1].dllextraoffset) - dirstartoffset));
        L1319 :;
        for (j=(i64)1;j<=ax_writeexe_dlltable[(i)-1].nprocs;j+=(i64)1) {
L1320 :;
            (*pextra) = (u64)(xxx);
            ++pextra;
L1321 :;
        }L1322 :;
        ;
        xxx += (i64)20;
        phint = ((pimpdir + ax_writeexe_dlltable[(i)-1].dllnameoffset) - dirstartoffset);
        strcpy((i8 *)(phint),(i8 *)(ax_writeexe_dlltable[(i)-1].name));
L1317 :;
    }L1318 :;
    ;
    thunkptr = (byte *)(ax_lib_bufferelemptr(ax_decls_ss_code,thunkoffset));
    codebase = (byte *)(ax_lib_bufferelemptr(ax_decls_ss_code,(i64)0));
    L1323 :;
    for (i=(i64)1;i<=ax_writeexe_nimports;i+=(i64)1) {
L1324 :;
        ax_writeexe_importtable[(i)-1].thunkoffset = (thunkptr - codebase);
        (*thunkptr++) = (u64)((i64)72);
        (*thunkptr++) = (u64)((i64)255);
        (*thunkptr++) = (u64)((i64)36);
        (*thunkptr++) = (u64)((i64)37);
        thunkaddr = ((i64)4194304 + ax_writeexe_importtable[(i)-1].iatoffset);
        (*(i32 *)(thunkptr)) = thunkaddr;
        thunkptr += (i64)4;
L1325 :;
    }L1326 :;
    ;
}

byte * ax_disasm_decodeinstr(byte * * cptr,byte * baseaddr) {
    i64 n;
    i64 w;
    i64 opc;
    i64 reg;
    i64 op;
    byte *  pstart;
    static byte str[256];
    byte str2[128];
    i64 av_1;
    i64 av_2;
    ax_disasm_deststr[((i64)1)-1] = (u64)0u;
    pstart = (ax_disasm_codeptr = (*cptr));
    ax_disasm_rex = (i64)0;
    ax_disasm_opsize = (i64)1;
    ax_disasm_f2override = (ax_disasm_f3override = (ax_disasm_sizeoverride = (ax_disasm_addroverride = (i64)0)));
    ax_disasm_basereg = (ax_disasm_indexreg = (ax_disasm_offset = (i64)0));
    /*retry:*/
L1327 :;
;
    switch ((int)(opc = (i64)((*ax_disasm_codeptr++)))) {
    case 0:;
    case 1:;
    case 8:;
    case 9:;
    case 16:;
    case 17:;
    case 24:;
    case 25:;
    case 32:;
    case 33:;
    case 40:;
    case 41:;
    case 48:;
    case 49:;
    case 56:;
    case 57:;
    {
        op = (opc >> (i64)3);
        ax_disasm_decodeaddr((opc & (i64)1));
        ax_disasm_getsilx(&ax_disasm_basereg);
        ax_disasm_getsil(&ax_disasm_rmreg);
        ax_disasm_genstr(ax_disasm_opnames[(op)]);
        ax_disasm_printaddrmode((i64)0);
        ax_disasm_genstr((byte*)", ");
        ax_disasm_genstr(ax_disasm_strreg(ax_disasm_rmreg,ax_disasm_opsize));
    }break;
    case 2:;
    case 3:;
    case 10:;
    case 11:;
    case 18:;
    case 19:;
    case 26:;
    case 27:;
    case 34:;
    case 35:;
    case 42:;
    case 43:;
    case 50:;
    case 51:;
    case 58:;
    case 59:;
    {
        op = (opc >> (i64)3);
        ax_disasm_decodeaddr((opc & (i64)1));
        ax_disasm_genstr(ax_disasm_opnames[(op)]);
        ax_disasm_genstr((byte*)" ");
        ax_disasm_getsil(&ax_disasm_rmreg);
        ax_disasm_genstr(ax_disasm_strreg(ax_disasm_rmreg,ax_disasm_opsize));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_printaddrmode((i64)0);
    }break;
    case 4:;
    case 5:;
    case 12:;
    case 13:;
    case 20:;
    case 21:;
    case 28:;
    case 29:;
    case 36:;
    case 37:;
    case 44:;
    case 45:;
    case 52:;
    case 53:;
    case 60:;
    case 61:;
    {
        ax_disasm_genstr(ax_disasm_opnames[((opc >> (i64)3))]);
        ax_disasm_genstr((byte*)" ");
        if (!!((opc & (i64)1))) {
            ax_disasm_opsize = (i64)4;
            if (!!(ax_disasm_sizeoverride)) {
                ax_disasm_opsize = (i64)2;
            };
            if (!!((ax_disasm_rex & (i64)8))) {
                ax_disasm_opsize = (i64)8;
            };
        };
        ax_disasm_genstr(ax_disasm_strreg((i64)1,ax_disasm_opsize));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_genintd(ax_disasm_readimm());
    }break;
    case 15:;
    {
        ax_disasm_decodetwobyteinstr();
    }break;
    case 64:;
    case 65:;
    case 66:;
    case 67:;
    case 68:;
    case 69:;
    case 70:;
    case 71:;
    case 72:;
    case 73:;
    case 74:;
    case 75:;
    case 76:;
    case 77:;
    case 78:;
    case 79:;
    {
        ax_disasm_rex = opc;
        goto L1327 ;
;
    }break;
    case 80:;
    case 81:;
    case 82:;
    case 83:;
    case 84:;
    case 85:;
    case 86:;
    case 87:;
    {
        reg = ax_disasm_getreg((opc & (i64)7),(ax_disasm_rex & (i64)1));
        ax_disasm_genstr((byte*)"push ");
        ax_disasm_genstr(ax_disasm_strreg(reg,(i64)8));
    }break;
    case 88:;
    case 89:;
    case 90:;
    case 91:;
    case 92:;
    case 93:;
    case 94:;
    case 95:;
    {
        reg = ax_disasm_getreg((opc & (i64)7),(ax_disasm_rex & (i64)1));
        ax_disasm_genstr((byte*)"pop ");
        ax_disasm_genstr(ax_disasm_strreg(reg,(i64)8));
    }break;
    case 99:;
    {
        ax_disasm_decodeaddr((i64)1);
        ax_disasm_genstr((byte*)"movsxd ");
        ax_disasm_genstr(ax_disasm_strreg(ax_disasm_rmreg,ax_disasm_opsize));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_opsize = (i64)4;
        ax_disasm_printaddrmode((i64)0);
    }break;
    case 102:;
    {
        ax_disasm_sizeoverride = (i64)1;
        goto L1327 ;
;
    }break;
    case 103:;
    {
        ax_disasm_addroverride = (i64)1;
        goto L1327 ;
;
    }break;
    case 104:;
    {
        ax_disasm_genstr((byte*)"push ");
        ax_disasm_genintd(ax_disasm_readint32());
    }break;
    case 106:;
    {
        ax_disasm_genstr((byte*)"push ");
        ax_disasm_genintd(ax_disasm_readsbyte());
    }break;
    case 105:;
    case 107:;
    {
        ax_disasm_decodeaddr((i64)1);
        if ((ax_disasm_basereg != ax_disasm_rmreg)) {
            ax_disasm_genstr((byte*)"imul3");
            ax_disasm_genstr((byte*)" ");
            ax_disasm_genstr(ax_disasm_strreg(ax_disasm_rmreg,ax_disasm_opsize));
            ax_disasm_genstr((byte*)", ");
        } else {
            ax_disasm_genstr((byte*)"imul2");
        };
        ax_disasm_printaddrmode((i64)0);
        ax_disasm_genstr((byte*)", ");
        ax_disasm_opsize = (!!((opc & (i64)2))?(i64)1:ax_disasm_opsize);
        ax_disasm_genintd(ax_disasm_readimm());
    }break;
    case 112:;
    case 113:;
    case 114:;
    case 115:;
    case 116:;
    case 117:;
    case 118:;
    case 119:;
    case 120:;
    case 121:;
    case 122:;
    case 123:;
    case 124:;
    case 125:;
    case 126:;
    case 127:;
    {
        ax_disasm_genstr((byte*)"j");
        ax_disasm_genstr(ax_disasm_condnames[((opc & (i64)15))]);
        ax_disasm_genstr((byte*)" ");
        ax_disasm_genintd(ax_disasm_readsbyte());
    }break;
    case 128:;
    case 129:;
    case 130:;
    case 131:;
    {
        ax_disasm_decodeaddr((opc & (i64)1));
        ax_disasm_genstr(ax_disasm_opnames[(ax_disasm_rmopc)]);
        ax_disasm_getsilx(&ax_disasm_basereg);
        ax_disasm_printaddrmode((i64)0);
        ax_disasm_genstr((byte*)", ");
        if ((opc != (i64)131)) {
            ax_disasm_genintd(ax_disasm_readimm());
        } else {
            ax_disasm_genintd(ax_disasm_readsbyte());
        };
    }break;
    case 132:;
    case 133:;
    {
        ax_disasm_decodeaddr((opc & (i64)1));
        ax_disasm_getsilx(&ax_disasm_basereg);
        ax_disasm_getsil(&ax_disasm_rmreg);
        ax_disasm_genstr((byte*)"test ");
        ax_disasm_printaddrmode((i64)0);
        ax_disasm_genstr((byte*)", ");
        ax_disasm_genstr(ax_disasm_strreg(ax_disasm_rmreg,ax_disasm_opsize));
    }break;
    case 134:;
    case 135:;
    {
        ax_disasm_decodeaddr((opc & (i64)1));
        ax_disasm_genstr((byte*)"exch2 ");
        ax_disasm_getsilx(&ax_disasm_basereg);
        ax_disasm_getsil(&ax_disasm_rmreg);
        ax_disasm_genstr(ax_disasm_strreg(ax_disasm_rmreg,ax_disasm_opsize));
        ax_disasm_genstr((byte*)",");
        ax_disasm_printaddrmode((i64)0);
    }break;
    case 136:;
    case 137:;
    {
        ax_disasm_decodeaddr((opc & (i64)1));
        ax_disasm_genstr((byte*)"mov");
        ax_disasm_getsilx(&ax_disasm_basereg);
        ax_disasm_getsil(&ax_disasm_rmreg);
        ax_disasm_printaddrmode((i64)0);
        ax_disasm_genstr((byte*)", ");
        ax_disasm_genstr(ax_disasm_strreg(ax_disasm_rmreg,ax_disasm_opsize));
    }break;
    case 138:;
    case 139:;
    {
        ax_disasm_decodeaddr((opc & (i64)1));
        ax_disasm_genstr((byte*)"mov ");
        ax_disasm_getsilx(&ax_disasm_basereg);
        ax_disasm_getsil(&ax_disasm_rmreg);
        ax_disasm_genstr(ax_disasm_strreg(ax_disasm_rmreg,ax_disasm_opsize));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_printaddrmode((i64)0);
    }break;
    case 141:;
    {
        ax_disasm_decodeaddr((i64)1);
        ax_disasm_genstr((byte*)"lea ");
        ax_disasm_genstr(ax_disasm_strreg(ax_disasm_rmreg,ax_disasm_opsize));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_printaddrmode((i64)0);
    }break;
    case 143:;
    {
        ax_disasm_decodeaddr((i64)1);
        ax_disasm_opsize = (i64)1;
        ax_disasm_genstr((byte*)"pop");
        ax_disasm_printaddrmode((i64)0);
    }break;
    case 144:;
    {
        if (!!(ax_disasm_rex)) {
            goto L1328 ;
;
        };
        ax_disasm_genstr((byte*)"nop");
    }break;
    case 145:;
    case 146:;
    case 147:;
    case 148:;
    case 149:;
    case 150:;
    case 151:;
    {
        /*doexch:*/
L1328 :;
;
        reg = ((opc & (i64)7) + (i64)1);
        if (!!((ax_disasm_rex & (i64)1))) {
            reg += (i64)8;
        };
        ax_disasm_opsize = (!!(ax_disasm_sizeoverride)?(i64)2:(i64)4);
        if (!!((ax_disasm_rex & (i64)8))) {
            ax_disasm_opsize = (i64)8;
        };
        ax_disasm_genstr((byte*)"xchg ");
        ax_disasm_genstr(ax_disasm_strreg((i64)1,ax_disasm_opsize));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_genstr(ax_disasm_strreg(reg,ax_disasm_opsize));
    }break;
    case 152:;
    {
        if (!!(ax_disasm_sizeoverride)) {
            ax_disasm_genstr((byte*)"cbw");
        } else {
            ax_disasm_genstr((byte*)"cbw???");
        };
    }break;
    case 153:;
    {
        if (!!(ax_disasm_sizeoverride)) {
            ax_disasm_genstr((byte*)"cwd");
        } else if (!!((ax_disasm_rex & (i64)8))) {
            ax_disasm_genstr((byte*)"cqo");
        } else {
            ax_disasm_genstr((byte*)"cdq");
        };
    }break;
    case 155:;
    {
        ax_disasm_genstr((byte*)"wait");
    }break;
    case 156:;
    {
        ax_disasm_genstr((byte*)"pushf");
    }break;
    case 157:;
    {
        ax_disasm_genstr((byte*)"popf");
    }break;
    case 158:;
    {
        ax_disasm_genstr((byte*)"sahf");
    }break;
    case 159:;
    {
        ax_disasm_genstr((byte*)"lahf");
    }break;
    case 164:;
    case 165:;
    case 166:;
    case 167:;
    case 170:;
    case 171:;
    case 172:;
    case 173:;
    case 174:;
    case 175:;
    {
        ax_disasm_genstr((((opc >> (i64)1) & (i64)7)==1?(byte*)"?":(((opc >> (i64)1) & (i64)7)==2?(byte*)"movs":(((opc >> (i64)1) & (i64)7)==3?(byte*)"cmps":(((opc >> (i64)1) & (i64)7)==4?(byte*)"?":(((opc >> (i64)1) & (i64)7)==5?(byte*)"stos":(((opc >> (i64)1) & (i64)7)==6?(byte*)"lods":(((opc >> (i64)1) & (i64)7)==7?(byte*)"scas":(byte*)"?"))))))));
        if (((opc & (i64)1) == (i64)0)) {
            ax_disasm_genstr((byte*)"b");
        } else {
            if (!!((ax_disasm_rex & (i64)8))) {
                ax_disasm_genstr((byte*)"q");
            } else if (!!(ax_disasm_sizeoverride)) {
                ax_disasm_genstr((byte*)"w");
            } else {
                ax_disasm_genstr((byte*)"d");
            };
        };
    }break;
    case 168:;
    case 169:;
    {
        ax_disasm_genstr((byte*)"test ");
        if (!!((opc & (i64)1))) {
            ax_disasm_opsize = (!!(ax_disasm_sizeoverride)?(i64)2:(i64)4);
            if (!!((ax_disasm_rex & (i64)8))) {
                ax_disasm_opsize = (i64)8;
            };
        };
        ax_disasm_genstr(ax_disasm_strreg((i64)1,ax_disasm_opsize));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_genintd(ax_disasm_readimm());
    }break;
    case 176:;
    case 177:;
    case 178:;
    case 179:;
    case 180:;
    case 181:;
    case 182:;
    case 183:;
    case 184:;
    case 185:;
    case 186:;
    case 187:;
    case 188:;
    case 189:;
    case 190:;
    case 191:;
    {
        reg = ((opc & (i64)7) + (i64)1);
        if (!!((ax_disasm_rex & (i64)1))) {
            reg += (i64)8;
        };
        if (!!((opc & (i64)8))) {
            ax_disasm_opsize = (!!(ax_disasm_sizeoverride)?(i64)2:(i64)4);
            if (!!((ax_disasm_rex & (i64)8))) {
                ax_disasm_opsize = (i64)8;
            };
        };
        ax_disasm_genstr((byte*)"mov ");
        ax_disasm_getsil(&reg);
        ax_disasm_genstr(ax_disasm_strreg(reg,ax_disasm_opsize));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_genintd(ax_disasm_readimm8());
    }break;
    case 192:;
    case 193:;
    case 208:;
    case 209:;
    case 210:;
    case 211:;
    {
        ax_disasm_decodeaddr((opc & (i64)1));
        ax_disasm_getsilx(&ax_disasm_basereg);
        ax_disasm_genstr(((ax_disasm_rmopc + (i64)1)==1?(byte*)"rol":((ax_disasm_rmopc + (i64)1)==2?(byte*)"ror":((ax_disasm_rmopc + (i64)1)==3?(byte*)"rcl":((ax_disasm_rmopc + (i64)1)==4?(byte*)"rcr":((ax_disasm_rmopc + (i64)1)==5?(byte*)"shl":((ax_disasm_rmopc + (i64)1)==6?(byte*)"shr":((ax_disasm_rmopc + (i64)1)==7?(byte*)"?":((ax_disasm_rmopc + (i64)1)==8?(byte*)"sar":(byte*)"?")))))))));
        ax_disasm_printaddrmode((i64)0);
        if ((opc <= (i64)193)) {
            ax_disasm_genstr((byte*)", ");
            ax_disasm_genintd(ax_disasm_readbyte());
        } else {
            ax_disasm_genstr((!!((opc & (i64)2))?(byte*)", cl":(byte*)", 1"));
        };
    }break;
    case 194:;
    {
        ax_disasm_genstr((byte*)"retn ");
        ax_disasm_genintd((i64)(ax_disasm_readword16()));
    }break;
    case 195:;
    {
        ax_disasm_genstr((byte*)"ret");
    }break;
    case 198:;
    case 199:;
    {
        ax_disasm_decodeaddr((opc & (i64)1));
        ax_disasm_genstr((byte*)"mov");
        ax_disasm_printaddrmode((i64)0);
        ax_disasm_genstr((byte*)", ");
        ax_disasm_genintd(ax_disasm_readimm());
    }break;
    case 215:;
    {
        ax_disasm_genstr((byte*)"xlat");
    }break;
    case 216:;
    case 217:;
    case 218:;
    case 219:;
    case 220:;
    case 221:;
    case 222:;
    case 223:;
    {
        ax_disasm_decode8087((opc & (i64)7));
    }break;
    case 224:;
    {
        ax_disasm_genstr((byte*)"loopnz ");
        ax_disasm_genintd(ax_disasm_readsbyte());
    }break;
    case 225:;
    {
        ax_disasm_genstr((byte*)"loopz ");
        ax_disasm_genintd(ax_disasm_readsbyte());
    }break;
    case 226:;
    {
        ax_disasm_genstr((byte*)"loop ");
        ax_disasm_genintd(ax_disasm_readsbyte());
    }break;
    case 227:;
    {
        if (!!(ax_disasm_addroverride)) {
            ax_disasm_genstr((byte*)"jecxz ");
        } else {
            ax_disasm_genstr((byte*)"jrcxz ");
        };
        ax_disasm_genintd(ax_disasm_readsbyte());
    }break;
    case 232:;
    {
        ax_disasm_genstr((byte*)"call ");
        ax_disasm_genintd(ax_disasm_readint32());
    }break;
    case 233:;
    {
        ax_disasm_genstr((byte*)"[4] jmp ");
        ax_disasm_genintd(ax_disasm_readint32());
    }break;
    case 235:;
    {
        ax_disasm_genstr((byte*)"jmp ");
        ax_disasm_genintd(ax_disasm_readsbyte());
    }break;
    case 242:;
    {
        if ((((i64)((u64)((*ax_disasm_codeptr))) != (i64)15) && (((i64)((u64)((*ax_disasm_codeptr))) < (i64)64) && ((i64)((u64)((*ax_disasm_codeptr))) > (i64)79)))) {
            ax_disasm_genstr((byte*)"repne");
        } else {
            ax_disasm_f2override = (i64)1;
            goto L1327 ;
;
        };
    }break;
    case 243:;
    {
        if ((((i64)((u64)((*ax_disasm_codeptr))) != (i64)15) && (((i64)((u64)((*ax_disasm_codeptr))) < (i64)64) && ((i64)((u64)((*ax_disasm_codeptr))) > (i64)79)))) {
            ax_disasm_genstr((byte*)"repe");
        } else {
            ax_disasm_f3override = (i64)1;
            goto L1327 ;
;
        };
    }break;
    case 244:;
    {
        return (byte *)(0);
    }break;
    case 246:;
    case 247:;
    {
        ax_disasm_decodeaddr((opc & (i64)1));
        ax_disasm_getsilx(&ax_disasm_basereg);
        ax_disasm_genstr(((ax_disasm_rmopc + (i64)1)==1?(byte*)"test":((ax_disasm_rmopc + (i64)1)==2?(byte*)"?":((ax_disasm_rmopc + (i64)1)==3?(byte*)"not":((ax_disasm_rmopc + (i64)1)==4?(byte*)"neg":((ax_disasm_rmopc + (i64)1)==5?(byte*)"mul":((ax_disasm_rmopc + (i64)1)==6?(byte*)"imul":((ax_disasm_rmopc + (i64)1)==7?(byte*)"div":((ax_disasm_rmopc + (i64)1)==8?(byte*)"idiv":(byte*)"?")))))))));
        ax_disasm_printaddrmode((i64)0);
        if ((ax_disasm_rmopc == (i64)0)) {
            if ((ax_disasm_opsize == (i64)8)) {
                ax_disasm_opsize = (i64)4;
            };
            ax_disasm_genstr((byte*)", ");
            ax_disasm_genintd(ax_disasm_readimm());
        };
    }break;
    case 254:;
    {
        w = (i64)0;
        goto L1329 ;
;
    }break;
    case 255:;
    {
        w = (i64)1;
        /*doff:*/
L1329 :;
;
        ax_disasm_decodeaddr(w);
        if ((ax_disasm_rmopc==(i64)0)) {
            ax_disasm_getsilx(&ax_disasm_basereg);
            ax_disasm_genstr((byte*)"inc");
        }else if ((ax_disasm_rmopc==(i64)1)) {
            ax_disasm_getsilx(&ax_disasm_basereg);
            ax_disasm_genstr((byte*)"dec");
        }else if ((ax_disasm_rmopc==(i64)2)) {
            ax_disasm_opsize = (i64)8;
            ax_disasm_genstr((byte*)"icall");
        }else if ((ax_disasm_rmopc==(i64)4)) {
            ax_disasm_opsize = (i64)8;
            ax_disasm_genstr((byte*)"jmp");
        }else if ((ax_disasm_rmopc==(i64)6)) {
            ax_disasm_opsize = (i64)8;
            ax_disasm_genstr((byte*)"push");
        } else {
            msysnewc_m_print_startcon();
            msysnewc_m_print_str((byte*)"FFxx?",NULL);
            msysnewc_m_print_newline();
            msysnewc_m_print_end();
            ;
        };
        ax_disasm_printaddrmode((i64)0);
    }break;
    default: {
        ax_disasm_genstr((byte*)"Unknown opcode: ");
        ax_disasm_genhex(opc);
    }
    } /* SW */
;
    if (!!(baseaddr)) {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_ptr(baseaddr,(byte*)"z6h");
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((byte*)": ",NULL);
        msysnewc_m_print_end();
        ;
    } else {
        msysnewc_m_print_startstr(str);
        msysnewc_m_print_ptr(pstart,(byte*)"z6h");
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((byte*)": ",NULL);
        msysnewc_m_print_end();
        ;
    };
    n = (ax_disasm_codeptr - pstart);
    av_1 = n;
    while (av_1-- > 0) {
L1330 :;
        msysnewc_m_print_startstr(str2);
        msysnewc_m_print_i64((i64)((*pstart++)),(byte*)"z2H");
        msysnewc_m_print_nogap();
        msysnewc_m_print_str((byte*)" ",NULL);
        msysnewc_m_print_end();
        ;
        strcat((i8 *)(str),(i8 *)(str2));
L1331 :;
    }L1332 :;
    ;
    av_2 = ((i64)14 - n);
    while (av_2-- > 0) {
L1333 :;
        strcat((i8 *)(str),(i8 *)((byte*)"-- "));
L1334 :;
    }L1335 :;
    ;
    strcat((i8 *)(str),(i8 *)(ax_disasm_deststr));
    (*cptr) = ax_disasm_codeptr;
    return str;
}

static void ax_disasm_decodetwobyteinstr(void) {
    i64 opc;
    i64 rhssize;
    i64 third;
    i64 imm;
    byte *  opcstr;
    switch ((int)(opc = (i64)((*ax_disasm_codeptr++)))) {
    case 42:;
    {
        ax_disasm_decodeaddr((i64)1);
        if (!!(ax_disasm_f3override)) {
            ax_disasm_genstr((byte*)"cvtsi2ss ");
        } else {
            ax_disasm_genstr((byte*)"cvtsi2sd ");
        };
        ax_disasm_genstr(ax_disasm_strxmm(ax_disasm_rmreg));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_printaddrmode((i64)0);
    }break;
    case 44:;
    {
        ax_disasm_decodeaddr((i64)1);
        if (!!(ax_disasm_f3override)) {
            ax_disasm_genstr((byte*)"cvttss2si ");
            rhssize = (i64)4;
        } else {
            ax_disasm_genstr((byte*)"cvttsd2si ");
            rhssize = (i64)8;
        };
        if (!!((ax_disasm_rex & (i64)8))) {
            ax_disasm_genstr(ax_disasm_strreg(ax_disasm_rmreg,(i64)8));
        } else {
            ax_disasm_genstr(ax_disasm_strreg(ax_disasm_rmreg,(i64)4));
        };
        ax_disasm_genstr((byte*)", ");
        ax_disasm_opsize = rhssize;
        ax_disasm_printaddrmode((i64)1);
    }break;
    case 45:;
    {
        ax_disasm_decodeaddr((i64)1);
        if (!!(ax_disasm_f3override)) {
            ax_disasm_genstr((byte*)"cvtss2si ");
            rhssize = (i64)4;
        } else {
            ax_disasm_genstr((byte*)"cvtsd2si ");
            rhssize = (i64)8;
        };
        if (!!((ax_disasm_rex & (i64)8))) {
            ax_disasm_genstr(ax_disasm_strreg(ax_disasm_rmreg,(i64)8));
        } else {
            ax_disasm_genstr(ax_disasm_strreg(ax_disasm_rmreg,(i64)4));
        };
        ax_disasm_genstr((byte*)", ");
        ax_disasm_opsize = rhssize;
        ax_disasm_printaddrmode((i64)1);
    }break;
    case 47:;
    {
        ax_disasm_decodeaddr((i64)1);
        if (!!(ax_disasm_sizeoverride)) {
            ax_disasm_opsize = (i64)8;
            ax_disasm_genstr((byte*)"comisd ");
        } else {
            ax_disasm_opsize = (i64)4;
            ax_disasm_genstr((byte*)"comiss ");
        };
        ax_disasm_genstr(ax_disasm_strxmm(ax_disasm_rmreg));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_printaddrmode((i64)1);
    }break;
    case 58:;
    {
        third = (i64)((*ax_disasm_codeptr++));
        if ((third==(i64)99)) {
            ax_disasm_genstr((byte*)"pcmpistri ");
        }else if ((third==(i64)98)) {
            ax_disasm_genstr((byte*)"pcmpistrm ");
        } else {
            ax_disasm_genstr((byte*)"Unknown opcode 2-byte opcode: 0F ");
            ax_disasm_genhex(opc);
            return;
        };
        ax_disasm_decodeaddr((i64)1);
        ax_disasm_genstr(ax_disasm_strxmm(ax_disasm_rmreg));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_printaddrmode((i64)1);
        ax_disasm_genstr((byte*)", ");
        imm = (i64)((*ax_disasm_codeptr++));
        ax_disasm_genintd(imm);
    }break;
    case 64:;
    case 65:;
    case 66:;
    case 67:;
    case 68:;
    case 69:;
    case 70:;
    case 71:;
    case 72:;
    case 73:;
    case 74:;
    case 75:;
    case 76:;
    case 77:;
    case 78:;
    case 79:;
    {
        ax_disasm_decodeaddr((i64)1);
        ax_disasm_genstr((byte*)"cmov");
        ax_disasm_genstr(ax_disasm_condnames[((opc & (i64)15))]);
        ax_disasm_genstr((byte*)" ");
        ax_disasm_genstr(ax_disasm_strreg(ax_disasm_rmreg,ax_disasm_opsize));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_printaddrmode((i64)0);
    }break;
    case 81:;
    {
        ax_disasm_decodeaddr((i64)1);
        ax_disasm_opsize = (!!(ax_disasm_f3override)?(i64)4:(i64)8);
        ax_disasm_genstr(((ax_disasm_opsize == (i64)4)?(byte*)"sqrtss ":(byte*)"sqrtsd "));
        ax_disasm_genstr(ax_disasm_strxmm(ax_disasm_rmreg));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_printaddrmode((i64)1);
    }break;
    case 84:;
    {
        ax_disasm_decodeaddr((i64)1);
        ax_disasm_genstr((!!(ax_disasm_sizeoverride)?(byte*)"andpd ":(byte*)"andps "));
        ax_disasm_genstr(ax_disasm_strxmm(ax_disasm_rmreg));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_opsize = (!!(ax_disasm_sizeoverride)?(i64)8:(i64)4);
        ax_disasm_printaddrmode((i64)1);
    }break;
    case 87:;
    {
        ax_disasm_decodeaddr((i64)1);
        ax_disasm_genstr((!!(ax_disasm_sizeoverride)?(byte*)"xorpd ":(byte*)"xorps "));
        ax_disasm_genstr(ax_disasm_strxmm(ax_disasm_rmreg));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_opsize = (!!(ax_disasm_sizeoverride)?(i64)8:(i64)4);
        ax_disasm_printaddrmode((i64)1);
    }break;
    case 88:;
    {
        opcstr = (byte*)"adds";
        /*doarith:*/
L1336 :;
;
        ax_disasm_genstr(opcstr);
        ax_disasm_decodeaddr((i64)1);
        if (!!(ax_disasm_f2override)) {
            ax_disasm_opsize = (i64)8;
            ax_disasm_genstr((byte*)"d ");
        } else {
            ax_disasm_opsize = (i64)4;
            ax_disasm_genstr((byte*)"s ");
        };
        ax_disasm_genstr(ax_disasm_strxmm(ax_disasm_rmreg));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_printaddrmode((i64)1);
    }break;
    case 89:;
    {
        opcstr = (byte*)"muls";
        goto L1336 ;
;
    }break;
    case 90:;
    {
        ax_disasm_decodeaddr((i64)1);
        if (!!(ax_disasm_f3override)) {
            ax_disasm_genstr((byte*)"cvtss2sd ");
            rhssize = (i64)4;
        } else {
            ax_disasm_genstr((byte*)"cvtsd2ss ");
            rhssize = (i64)8;
        };
        ax_disasm_genstr(ax_disasm_strxmm(ax_disasm_rmreg));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_opsize = rhssize;
        ax_disasm_printaddrmode((i64)1);
    }break;
    case 92:;
    {
        opcstr = (byte*)"subs";
        goto L1336 ;
;
    }break;
    case 93:;
    {
        opcstr = (byte*)"mins";
        goto L1336 ;
;
    }break;
    case 94:;
    {
        opcstr = (byte*)"divs";
        goto L1336 ;
;
    }break;
    case 95:;
    {
        opcstr = (byte*)"maxs";
        goto L1336 ;
;
    }break;
    case 110:;
    {
        ax_disasm_decodeaddr((i64)1);
        ax_disasm_opsize = (!!((ax_disasm_rex & (i64)8))?(i64)8:(i64)4);
        ax_disasm_genstr(((ax_disasm_opsize == (i64)4)?(byte*)"movd ":(byte*)"movq "));
        if (!!(ax_disasm_sizeoverride)) {
            ax_disasm_genstr(ax_disasm_strxmm(ax_disasm_rmreg));
        } else {
            ax_disasm_genstr(ax_disasm_strmmx(ax_disasm_rmreg));
        };
        ax_disasm_genstr((byte*)", ");
        ax_disasm_printaddrmode((i64)0);
    }break;
    case 111:;
    {
        ax_disasm_decodeaddr((i64)1);
        ax_disasm_opsize = (i64)16;
        if (!!(ax_disasm_sizeoverride)) {
            ax_disasm_genstr((byte*)"movdqa ");
        } else if (!!(ax_disasm_f3override)) {
            ax_disasm_genstr((byte*)"movdqu ");
        } else {
            ax_disasm_genstr((byte*)"No 66/F3 ");
        };
        ax_disasm_genstr(ax_disasm_strxmm(ax_disasm_rmreg));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_printaddrmode((i64)1);
    }break;
    case 126:;
    {
        ax_disasm_decodeaddr((i64)1);
        if (!!(ax_disasm_f3override)) {
            ax_disasm_opsize = (i64)8;
            ax_disasm_genstr((byte*)"movq ");
            ax_disasm_genstr(ax_disasm_strxmm(ax_disasm_rmreg));
            ax_disasm_genstr((byte*)", ");
            ax_disasm_printaddrmode((i64)1);
        } else if (!!((ax_disasm_rex & (i64)8))) {
            ax_disasm_opsize = (i64)8;
            ax_disasm_genstr((byte*)"movq ");
            ax_disasm_printaddrmode((i64)0);
            ax_disasm_genstr((byte*)", ");
            ax_disasm_genstr(ax_disasm_strxmm(ax_disasm_rmreg));
        } else {
            ax_disasm_opsize = (i64)4;
            ax_disasm_genstr((byte*)"movd ");
            ax_disasm_printaddrmode((i64)0);
            ax_disasm_genstr((byte*)", ");
            if (!!(ax_disasm_sizeoverride)) {
                ax_disasm_genstr(ax_disasm_strxmm(ax_disasm_rmreg));
            } else {
                ax_disasm_genstr(ax_disasm_strmmx(ax_disasm_rmreg));
            };
        };
    }break;
    case 127:;
    {
        ax_disasm_decodeaddr((i64)1);
        ax_disasm_opsize = (i64)16;
        if (!!(ax_disasm_sizeoverride)) {
            ax_disasm_genstr((byte*)"movdqa ");
        } else if (!!(ax_disasm_f3override)) {
            ax_disasm_genstr((byte*)"movdqu ");
        } else {
            ax_disasm_genstr((byte*)"No 66/F3 ");
        };
        ax_disasm_printaddrmode((i64)1);
        ax_disasm_genstr((byte*)", ");
        ax_disasm_genstr(ax_disasm_strxmm(ax_disasm_rmreg));
    }break;
    case 128:;
    case 129:;
    case 130:;
    case 131:;
    case 132:;
    case 133:;
    case 134:;
    case 135:;
    case 136:;
    case 137:;
    case 138:;
    case 139:;
    case 140:;
    case 141:;
    case 142:;
    case 143:;
    {
        ax_disasm_genstr((byte*)"[long] j");
        ax_disasm_genstr(ax_disasm_condnames[((opc & (i64)15))]);
        ax_disasm_genstr((byte*)" ");
        if (!!(ax_disasm_sizeoverride)) {
            ax_disasm_genintd(ax_disasm_readint16());
        } else {
            ax_disasm_genintd(ax_disasm_readint32());
        };
    }break;
    case 144:;
    case 145:;
    case 146:;
    case 147:;
    case 148:;
    case 149:;
    case 150:;
    case 151:;
    case 152:;
    case 153:;
    case 154:;
    case 155:;
    case 156:;
    case 157:;
    case 158:;
    case 159:;
    {
        ax_disasm_decodeaddr((i64)0);
        ax_disasm_genstr((byte*)"set");
        ax_disasm_genstr(ax_disasm_condnames[((opc & (i64)15))]);
        ax_disasm_genstr((byte*)" ");
        ax_disasm_getsilx(&ax_disasm_basereg);
        ax_disasm_printaddrmode((i64)0);
    }break;
    case 175:;
    {
        ax_disasm_decodeaddr((i64)1);
        ax_disasm_genstr((byte*)"imul ");
        ax_disasm_genstr(ax_disasm_strreg(ax_disasm_rmreg,ax_disasm_opsize));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_printaddrmode((i64)0);
    }break;
    case 182:;
    case 183:;
    case 190:;
    case 191:;
    {
        ax_disasm_decodeaddr((i64)1);
        ax_disasm_genstr(((opc < (i64)190)?(byte*)"movzx ":(byte*)"movsx "));
        ax_disasm_genstr(ax_disasm_strreg(ax_disasm_rmreg,ax_disasm_opsize));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_opsize = (!!((opc & (i64)1))?(i64)2:(i64)1);
        ax_disasm_printaddrmode((i64)0);
    }break;
    case 184:;
    {
        ax_disasm_decodeaddr((i64)1);
        ax_disasm_genstr((byte*)"popcnt ");
        ax_disasm_genstr(ax_disasm_strreg(ax_disasm_rmreg,ax_disasm_opsize));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_printaddrmode((i64)0);
    }break;
    case 188:;
    case 189:;
    {
        ax_disasm_decodeaddr((i64)1);
        ax_disasm_genstr(((opc == (i64)188)?(byte*)"bsf ":(byte*)"bsr "));
        ax_disasm_genstr(ax_disasm_strreg(ax_disasm_rmreg,ax_disasm_opsize));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_printaddrmode((i64)0);
    }break;
    case 214:;
    {
        ax_disasm_decodeaddr((i64)1);
        ax_disasm_opsize = (i64)8;
        ax_disasm_genstr((byte*)"movq ");
        ax_disasm_printaddrmode((i64)1);
        ax_disasm_genstr((byte*)",");
        ax_disasm_genstr(ax_disasm_strxmm(ax_disasm_rmreg));
    }break;
    case 219:;
    {
        ax_disasm_decodeaddr((i64)1);
        ax_disasm_genstr((byte*)"pand ");
        ax_disasm_genstr(ax_disasm_strxmm(ax_disasm_rmreg));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_opsize = (i64)8;
        ax_disasm_printaddrmode((i64)1);
    }break;
    case 239:;
    {
        ax_disasm_decodeaddr((i64)1);
        ax_disasm_genstr((byte*)"pxor ");
        ax_disasm_genstr(ax_disasm_strxmm(ax_disasm_rmreg));
        ax_disasm_genstr((byte*)", ");
        ax_disasm_opsize = (i64)8;
        ax_disasm_printaddrmode((i64)1);
    }break;
    default: {
        /*error:*/
L1337 :;
;
        ax_disasm_genstr((byte*)"Unknown opcode 2-byte opcode: 0F ");
        ax_disasm_genhex(opc);
    }
    } /* SW */
;
}

static void ax_disasm_decodeaddr(i64 w) {
    i64 modrm;
    i64 xxx;
    i64 mode;
    i64 sib;
    i64 rm;
    ax_disasm_basereg = (ax_disasm_indexreg = (i64)0);
    ax_disasm_scale = (i64)1;
    ax_disasm_offset = (i64)0;
    if (!!(w)) {
        ax_disasm_opsize = (!!(ax_disasm_sizeoverride)?(i64)2:(i64)4);
        if (!!((ax_disasm_rex & (i64)8))) {
            ax_disasm_opsize = (i64)8;
        };
    } else {
        ax_disasm_opsize = (i64)1;
    };
    modrm = (i64)((*ax_disasm_codeptr++));
    mode = (modrm >> (i64)6);
    xxx = ((modrm >> (i64)3) & (i64)7);
    rm = (modrm & (i64)7);
    if ((mode == (i64)3)) {
        ax_disasm_basereg = (rm + (i64)1);
        ax_disasm_addrmode = (i64)1;
    } else if ((rm != (i64)4)) {
        if (((mode == (i64)0) && (rm == (i64)5))) {
            ax_disasm_offset = ax_disasm_readint32();
            ax_disasm_addrmode = (i64)2;
        } else {
            ax_disasm_basereg = (rm + (i64)1);
            ax_disasm_addrmode = (i64)2;
            if ((mode==(i64)1)) {
                ax_disasm_offset = ax_disasm_readsbyte();
            }else if ((mode==(i64)2)) {
                ax_disasm_offset = ax_disasm_readint32();
            };
        };
    } else {
        ax_disasm_addrmode = (i64)2;
        sib = ax_disasm_readbyte();
        ax_disasm_indexreg = (((sib >> (i64)3) & (i64)7) + (i64)1);
        ax_disasm_basereg = ((sib & (i64)7) + (i64)1);
        ax_disasm_scale = (((sib >> (i64)6) + (i64)1)==1?(i64)1:(((sib >> (i64)6) + (i64)1)==2?(i64)2:(((sib >> (i64)6) + (i64)1)==3?(i64)4:(((sib >> (i64)6) + (i64)1)==4?(i64)8:(i64)0))));
        if (((mode == (i64)0) && (ax_disasm_basereg == (i64)6))) {
            ax_disasm_basereg = (i64)0;
            ax_disasm_offset = ax_disasm_readint32();
        } else {
            if ((mode==(i64)1)) {
                ax_disasm_offset = ax_disasm_readsbyte();
            }else if ((mode==(i64)2)) {
                ax_disasm_offset = ax_disasm_readint32();
            };
        };
        if ((ax_disasm_indexreg == (i64)5)) {
            ax_disasm_indexreg = (i64)0;
        };
    };
    if ((!!(ax_disasm_basereg) && !!((ax_disasm_rex & (i64)1)))) {
        ax_disasm_basereg += (i64)8;
    };
    if ((!!(ax_disasm_indexreg) && !!((ax_disasm_rex & (i64)2)))) {
        ax_disasm_indexreg += (i64)8;
    };
    ax_disasm_rmreg = (xxx + (i64)1);
    if (!!((ax_disasm_rex & (i64)4))) {
        ax_disasm_rmreg += (i64)8;
    };
    ax_disasm_rmopc = xxx;
}

static i64 ax_disasm_readbyte(void) {
    return (i64)((*ax_disasm_codeptr++));
}

static i64 ax_disasm_readsbyte(void) {
    return (i64)((*(i8 *)(ax_disasm_codeptr++)));
}

static u64 ax_disasm_readword16(void) {
    u64 a;
    a = (u64)((*(u16 *)(ax_disasm_codeptr)));
    ax_disasm_codeptr += (i64)2;
    return a;
}

static i64 ax_disasm_readint16(void) {
    i64 a;
    a = (i64)((*(i16 *)(ax_disasm_codeptr)));
    ax_disasm_codeptr += (i64)2;
    return a;
}

static u64 ax_disasm_readword32(void) {
    u64 a;
    a = (u64)((*(u32 *)(ax_disasm_codeptr)));
    ax_disasm_codeptr += (i64)4;
    return a;
}

static i64 ax_disasm_readint32(void) {
    i64 a;
    a = (i64)((*(i32 *)(ax_disasm_codeptr)));
    ax_disasm_codeptr += (i64)4;
    return a;
}

static i64 ax_disasm_readint64(void) {
    i64 a;
    a = (*(i64 *)(ax_disasm_codeptr));
    ax_disasm_codeptr += (i64)8;
    return a;
}

static i64 ax_disasm_getreg(i64 regcode,i64 upper) {
    if (!!(upper)) {
        return ((regcode + (i64)8) + (i64)1);
    };
    return (regcode + (i64)1);
}

static byte * ax_disasm_strreg(i64 reg,i64 opsize) {
    static byte *  regnames8[20] = {
    (byte*)"al",
    (byte*)"cl",
    (byte*)"dl",
    (byte*)"bl",
    (byte*)"ah",
    (byte*)"ch",
    (byte*)"dh",
    (byte*)"bh",
    (byte*)"r8b",
    (byte*)"r9b",
    (byte*)"r10b",
    (byte*)"r11b",
    (byte*)"r12b",
    (byte*)"r13b",
    (byte*)"r14b",
    (byte*)"r15b",
    (byte*)"spl",
    (byte*)"bpl",
    (byte*)"sil",
    (byte*)"dil"
};
    static byte *  regnames16[16] = {
    (byte*)"ax",
    (byte*)"cx",
    (byte*)"dx",
    (byte*)"bx",
    (byte*)"sp",
    (byte*)"bp",
    (byte*)"si",
    (byte*)"di",
    (byte*)"r8w",
    (byte*)"r9w",
    (byte*)"r10w",
    (byte*)"r11w",
    (byte*)"r12w",
    (byte*)"r13w",
    (byte*)"r14w",
    (byte*)"r15w"
};
    static byte *  regnames32[16] = {
    (byte*)"eax",
    (byte*)"ecx",
    (byte*)"edx",
    (byte*)"ebx",
    (byte*)"esp",
    (byte*)"ebp",
    (byte*)"esi",
    (byte*)"edi",
    (byte*)"r8d",
    (byte*)"r9d",
    (byte*)"r10d",
    (byte*)"r11d",
    (byte*)"r12d",
    (byte*)"r13d",
    (byte*)"r14d",
    (byte*)"r15d"
};
    static byte *  regnames64[16] = {
    (byte*)"rax",
    (byte*)"rcx",
    (byte*)"rdx",
    (byte*)"rbx",
    (byte*)"rsp",
    (byte*)"rbp",
    (byte*)"rsi",
    (byte*)"rdi",
    (byte*)"r8",
    (byte*)"r9",
    (byte*)"r10",
    (byte*)"r11",
    (byte*)"r12",
    (byte*)"r13",
    (byte*)"r14",
    (byte*)"r15"
};
    static byte *  mregnames8[20] = {
    (byte*)"B0",
    (byte*)"B10",
    (byte*)"B11",
    (byte*)"B1",
    (byte*)"B16",
    (byte*)"B18",
    (byte*)"B19",
    (byte*)"B17",
    (byte*)"B12",
    (byte*)"B13",
    (byte*)"B4",
    (byte*)"B5",
    (byte*)"B6",
    (byte*)"B7",
    (byte*)"B8",
    (byte*)"B9",
    (byte*)"B14",
    (byte*)"B15",
    (byte*)"B2",
    (byte*)"B3"
};
    static byte *  mregnames16[16] = {
    (byte*)"W0",
    (byte*)"W10",
    (byte*)"W11",
    (byte*)"W1",
    (byte*)"Wsp",
    (byte*)"Wbp",
    (byte*)"W2",
    (byte*)"W3",
    (byte*)"W12",
    (byte*)"W13",
    (byte*)"W4",
    (byte*)"W5",
    (byte*)"W6",
    (byte*)"W7",
    (byte*)"W8",
    (byte*)"W9"
};
    static byte *  mregnames32[16] = {
    (byte*)"A0",
    (byte*)"A10",
    (byte*)"A11",
    (byte*)"A1",
    (byte*)"Astack",
    (byte*)"Aframe",
    (byte*)"A2",
    (byte*)"A3",
    (byte*)"A12",
    (byte*)"A13",
    (byte*)"A4",
    (byte*)"A5",
    (byte*)"A6",
    (byte*)"A7",
    (byte*)"A8",
    (byte*)"A9"
};
    static byte *  mregnames64[16] = {
    (byte*)"D0",
    (byte*)"D10",
    (byte*)"D11",
    (byte*)"D1",
    (byte*)"Dstack",
    (byte*)"Dframe",
    (byte*)"D2",
    (byte*)"D3",
    (byte*)"D12",
    (byte*)"D13",
    (byte*)"D4",
    (byte*)"D5",
    (byte*)"D6",
    (byte*)"D7",
    (byte*)"D8",
    (byte*)"D9"
};
    if ((reg == (i64)0)) {
        return (byte*)"<>";
    };
    if (!!((i64)0)) {
        if ((opsize==(i64)1)) {
            return mregnames8[(reg)-1];
        }else if ((opsize==(i64)2)) {
            return mregnames16[(reg)-1];
        }else if ((opsize==(i64)4)) {
            return mregnames32[(reg)-1];
        }else if ((opsize==(i64)8)) {
            return mregnames64[(reg)-1];
        };
    } else {
        if ((opsize==(i64)1)) {
            return regnames8[(reg)-1];
        }else if ((opsize==(i64)2)) {
            return regnames16[(reg)-1];
        }else if ((opsize==(i64)4)) {
            return regnames32[(reg)-1];
        }else if ((opsize==(i64)8)) {
            return regnames64[(reg)-1];
        };
    };
    return (byte*)"";
}

static byte * ax_disasm_strfreg(i64 freg) {
    static byte *  fregnames[8] = {(byte*)"st0",(byte*)"st1",(byte*)"st2",(byte*)"st3",(byte*)"st4",(byte*)"st5",(byte*)"st6",(byte*)"st7"};
    return fregnames[(freg)-1];
}

static void ax_disasm_printaddrmode(i64 xmm) {
    byte *  plus;
    i64 addrsize;
    ax_disasm_genstr((byte*)" ");
    if ((ax_disasm_addrmode==(i64)1)) {
        if (!!(xmm)) {
            ax_disasm_genstr(ax_disasm_strxmm(ax_disasm_basereg));
        } else {
            ax_disasm_getsilx(&ax_disasm_basereg);
            ax_disasm_genstr(ax_disasm_strreg(ax_disasm_basereg,ax_disasm_opsize));
        };
        return;
    };
    if ((ax_disasm_opsize==(i64)1)) {
        ax_disasm_genstr((byte*)"byte ");
    }else if ((ax_disasm_opsize==(i64)2)) {
        ax_disasm_genstr((byte*)"word ");
    }else if ((ax_disasm_opsize==(i64)4)) {
        ax_disasm_genstr((byte*)"dword ");
    }else if ((ax_disasm_opsize==(i64)8)) {
        ax_disasm_genstr((byte*)"qword ");
    }else if ((ax_disasm_opsize==(i64)10)) {
        ax_disasm_genstr((byte*)"tword ");
    }else if ((ax_disasm_opsize==(i64)16)) {
        ax_disasm_genstr((byte*)"oword ");
    } else {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"///OPSIZE",NULL);
        msysnewc_m_print_i64(ax_disasm_opsize,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    ax_disasm_genstr((byte*)"[");
    plus = (byte*)"";
    addrsize = (!!(ax_disasm_addroverride)?(i64)4:(i64)8);
    if (!!(ax_disasm_basereg)) {
        ax_disasm_genstr(ax_disasm_strreg(ax_disasm_basereg,addrsize));
        plus = (byte*)"+";
    };
    if (!!(ax_disasm_indexreg)) {
        ax_disasm_genstr(plus);
        ax_disasm_genstr(ax_disasm_strreg(ax_disasm_indexreg,addrsize));
        if ((ax_disasm_scale > (i64)1)) {
            ax_disasm_genstr((byte*)"*");
            ax_disasm_genintd(ax_disasm_scale);
        };
        plus = (byte*)"+";
    };
    if ((!!(ax_disasm_offset) || ((ax_disasm_basereg == (i64)0) && (ax_disasm_indexreg == (i64)0)))) {
        if (((ax_disasm_basereg == (i64)0) && (ax_disasm_indexreg == (i64)0))) {
            ax_disasm_genhex(ax_disasm_offset);
        } else {
            if ((ax_disasm_offset > (i64)0)) {
                ax_disasm_genstr(plus);
            };
            ax_disasm_genintd(ax_disasm_offset);
        };
    };
    ax_disasm_genstr((byte*)"]");
    if ((ax_disasm_addrmode == (i64)3)) {
        ax_disasm_genstr((byte*)"+RIP");
    };
}

static void ax_disasm_genstr(byte * s) {
    strcat((i8 *)(ax_disasm_deststr),(i8 *)(s));
}

static void ax_disasm_genintd(i64 a) {
    ax_disasm_genstr(msysnewc_strint(a,(byte *)(0)));
}

static void ax_disasm_genhex(i64 a) {
    ax_disasm_genstr(msysnewc_strint(a,(byte*)"h"));
}

static i64 ax_disasm_readimm(void) {
    if ((ax_disasm_opsize==(i64)1)) {
        return ax_disasm_readsbyte();
    }else if ((ax_disasm_opsize==(i64)2)) {
        return ax_disasm_readint16();
    }else if ((ax_disasm_opsize==(i64)4) || (ax_disasm_opsize==(i64)8)) {
        return ax_disasm_readint32();
    };
    return (i64)0;
}

static i64 ax_disasm_readimm8(void) {
    if ((ax_disasm_opsize < (i64)8)) {
        return ax_disasm_readimm();
    };
    return ax_disasm_readint64();
}

static byte * ax_disasm_strxmm(i64 reg) {
    static byte str[32];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str((byte*)"xmm",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_i64((reg - (i64)1),NULL);
    msysnewc_m_print_end();
    ;
    return str;
}

static byte * ax_disasm_strmmx(i64 reg) {
    static byte str[32];
    msysnewc_m_print_startstr(str);
    msysnewc_m_print_str((byte*)"mmx",NULL);
    msysnewc_m_print_nogap();
    msysnewc_m_print_i64((reg - (i64)1),NULL);
    msysnewc_m_print_end();
    ;
    return str;
}

static void ax_disasm_decode8087(i64 ttt) {
    byte bb;
    i64 longopc;
    i64 freg;
    i64 shortopc;
    bb = (u64)((*ax_disasm_codeptr++));
    longopc = ((ttt << (i64)8) + (i64)((u64)(bb)));
    freg = (((i64)((u64)(bb)) & (i64)7) + (i64)1);
    if ((longopc==(i64)1753)) {
        ax_disasm_genstr((byte*)"fcompp");
    }else if ((longopc==(i64)484)) {
        ax_disasm_genstr((byte*)"ftst");
    }else if ((longopc==(i64)485)) {
        ax_disasm_genstr((byte*)"fxam");
    }else if ((longopc==(i64)494)) {
        ax_disasm_genstr((byte*)"fldz");
    }else if ((longopc==(i64)488)) {
        ax_disasm_genstr((byte*)"fld1");
    }else if ((longopc==(i64)491)) {
        ax_disasm_genstr((byte*)"fldpi");
    }else if ((longopc==(i64)489)) {
        ax_disasm_genstr((byte*)"fldl2t");
    }else if ((longopc==(i64)490)) {
        ax_disasm_genstr((byte*)"fldl2e");
    }else if ((longopc==(i64)492)) {
        ax_disasm_genstr((byte*)"fldlg2");
    }else if ((longopc==(i64)493)) {
        ax_disasm_genstr((byte*)"fldln2");
    }else if ((longopc==(i64)506)) {
        ax_disasm_genstr((byte*)"fsqrt");
    }else if ((longopc==(i64)510)) {
        ax_disasm_genstr((byte*)"fsin");
    }else if ((longopc==(i64)511)) {
        ax_disasm_genstr((byte*)"fcos");
    }else if ((longopc==(i64)507)) {
        ax_disasm_genstr((byte*)"fsincos");
    }else if ((longopc==(i64)509)) {
        ax_disasm_genstr((byte*)"fscale");
    }else if ((longopc==(i64)504)) {
        ax_disasm_genstr((byte*)"fprem");
    }else if ((longopc==(i64)508)) {
        ax_disasm_genstr((byte*)"frndint");
    }else if ((longopc==(i64)500)) {
        ax_disasm_genstr((byte*)"fxtract");
    }else if ((longopc==(i64)481)) {
        ax_disasm_genstr((byte*)"fabs");
    }else if ((longopc==(i64)480)) {
        ax_disasm_genstr((byte*)"fchs");
    }else if ((longopc==(i64)498)) {
        ax_disasm_genstr((byte*)"fptan");
    }else if ((longopc==(i64)499)) {
        ax_disasm_genstr((byte*)"fpatan");
    }else if ((longopc==(i64)496)) {
        ax_disasm_genstr((byte*)"f2xm1");
    }else if ((longopc==(i64)497)) {
        ax_disasm_genstr((byte*)"fyl2x");
    }else if ((longopc==(i64)505)) {
        ax_disasm_genstr((byte*)"fyl2xp1");
    }else if ((longopc==(i64)995)) {
        ax_disasm_genstr((byte*)"finit");
    }else if ((longopc==(i64)992)) {
        ax_disasm_genstr((byte*)"feni");
    }else if ((longopc==(i64)993)) {
        ax_disasm_genstr((byte*)"fdisi");
    }else if ((longopc==(i64)994)) {
        ax_disasm_genstr((byte*)"fclex");
    }else if ((longopc==(i64)503)) {
        ax_disasm_genstr((byte*)"fincstp");
    }else if ((longopc==(i64)502)) {
        ax_disasm_genstr((byte*)"fdecstp");
    }else if ((longopc==(i64)464)) {
        ax_disasm_genstr((byte*)"fnop");
    } else {
        if (((longopc & (i64)2040)==(i64)448)) {
            ax_disasm_genstr((byte*)"fld ");
            ax_disasm_genstr(ax_disasm_strfreg(freg));
        }else if (((longopc & (i64)2040)==(i64)1488)) {
            ax_disasm_genstr((byte*)"fst ");
            ax_disasm_genstr(ax_disasm_strfreg(freg));
        }else if (((longopc & (i64)2040)==(i64)1496)) {
            ax_disasm_genstr((byte*)"fstp ");
            ax_disasm_genstr(ax_disasm_strfreg(freg));
        }else if (((longopc & (i64)2040)==(i64)456)) {
            ax_disasm_genstr((byte*)"fxch ");
            ax_disasm_genstr(ax_disasm_strfreg(freg));
        }else if (((longopc & (i64)2040)==(i64)208)) {
            ax_disasm_genstr((byte*)"fcom ");
            ax_disasm_genstr(ax_disasm_strfreg(freg));
        }else if (((longopc & (i64)2040)==(i64)216)) {
            ax_disasm_genstr((byte*)"fcomp ");
            ax_disasm_genstr(ax_disasm_strfreg(freg));
        }else if (((longopc & (i64)2040)==(i64)1472)) {
            ax_disasm_genstr((byte*)"ffree ");
            ax_disasm_genstr(ax_disasm_strfreg(freg));
        } else {
            if (((longopc & (i64)504)==(i64)192)) {
                ax_disasm_do87arith((byte*)"fadd",ttt,freg);
            }else if (((longopc & (i64)504)==(i64)224)) {
                ax_disasm_do87arith((byte*)"fsub",ttt,freg);
            }else if (((longopc & (i64)504)==(i64)232)) {
                ax_disasm_do87arith((byte*)"fsubr",ttt,freg);
            }else if (((longopc & (i64)504)==(i64)200)) {
                ax_disasm_do87arith((byte*)"fmul",ttt,freg);
            }else if (((longopc & (i64)504)==(i64)240)) {
                ax_disasm_do87arith((byte*)"fdiv",ttt,freg);
            }else if (((longopc & (i64)504)==(i64)248)) {
                ax_disasm_do87arith((byte*)"fdivr",ttt,freg);
            } else {
                --ax_disasm_codeptr;
                ax_disasm_decodeaddr((i64)0);
                shortopc = ((ttt << (i64)3) + ax_disasm_rmopc);
                if ((shortopc==(i64)61)) {
                    ax_disasm_do87mem((byte*)"fld",(i64)4);
                }else if ((shortopc==(i64)29)) {
                    ax_disasm_do87mem((byte*)"fld",(i64)5);
                }else if ((shortopc==(i64)60)) {
                    ax_disasm_do87mem((byte*)"fldbcd",(i64)-1);
                }else if ((shortopc==(i64)63)) {
                    ax_disasm_do87mem((byte*)"fstp",(i64)4);
                }else if ((shortopc==(i64)31)) {
                    ax_disasm_do87mem((byte*)"fstp",(i64)5);
                }else if ((shortopc==(i64)62)) {
                    ax_disasm_do87mem((byte*)"fstpbcd",(i64)-1);
                }else if ((shortopc==(i64)13)) {
                    ax_disasm_do87mem((byte*)"fldcw",(i64)-1);
                }else if ((shortopc==(i64)15)) {
                    ax_disasm_do87mem((byte*)"fstcw",(i64)-1);
                }else if ((shortopc==(i64)47)) {
                    ax_disasm_do87mem((byte*)"fstsw",(i64)-1);
                }else if ((shortopc==(i64)14)) {
                    ax_disasm_do87mem((byte*)"fstenv",(i64)-1);
                }else if ((shortopc==(i64)12)) {
                    ax_disasm_do87mem((byte*)"fldenv",(i64)-1);
                }else if ((shortopc==(i64)46)) {
                    ax_disasm_do87mem((byte*)"fsave",(i64)-1);
                }else if ((shortopc==(i64)44)) {
                    ax_disasm_do87mem((byte*)"frstor",(i64)-1);
                } else {
                    if (((shortopc & (i64)15)==(i64)8)) {
                        ax_disasm_do87mem((byte*)"fld",(ttt >> (i64)1));
                    }else if (((shortopc & (i64)15)==(i64)10)) {
                        ax_disasm_do87mem((byte*)"fst",(ttt >> (i64)1));
                    }else if (((shortopc & (i64)15)==(i64)11)) {
                        ax_disasm_do87mem((byte*)"fstp",(ttt >> (i64)1));
                    }else if (((shortopc & (i64)15)==(i64)2)) {
                        ax_disasm_do87mem((byte*)"fcom",(ttt >> (i64)1));
                    }else if (((shortopc & (i64)15)==(i64)3)) {
                        ax_disasm_do87mem((byte*)"fcomp",(ttt >> (i64)1));
                    }else if (((shortopc & (i64)15)==(i64)0)) {
                        ax_disasm_do87mem((byte*)"fadd",(ttt >> (i64)1));
                    }else if (((shortopc & (i64)15)==(i64)4)) {
                        ax_disasm_do87mem((byte*)"fsub",(ttt >> (i64)1));
                    }else if (((shortopc & (i64)15)==(i64)5)) {
                        ax_disasm_do87mem((byte*)"fsubr",(ttt >> (i64)1));
                    }else if (((shortopc & (i64)15)==(i64)1)) {
                        ax_disasm_do87mem((byte*)"fmul",(ttt >> (i64)1));
                    }else if (((shortopc & (i64)15)==(i64)6)) {
                        ax_disasm_do87mem((byte*)"fdiv",(ttt >> (i64)1));
                    }else if (((shortopc & (i64)15)==(i64)7)) {
                        ax_disasm_do87mem((byte*)"fdivr",(ttt >> (i64)1));
                    } else {
                        ax_disasm_genstr((byte*)"UNKNOWN x87 OPCODE");
                    };
                };
            };
        };
    };
}

static void ax_disasm_do87arith(byte * opcstr,i64 ttt,i64 freg) {
    i64 d;
    i64 p;
    d = (ttt & (i64)4);
    p = (ttt & (i64)2);
    ax_disasm_genstr(opcstr);
    if (!!(p)) {
        ax_disasm_genstr((byte*)"p");
    };
    ax_disasm_genstr((byte*)" ");
    if ((d == (i64)0)) {
        ax_disasm_genstr((byte*)"st0, ");
        ax_disasm_genstr(ax_disasm_strfreg(freg));
    } else {
        ax_disasm_genstr(ax_disasm_strfreg(freg));
        ax_disasm_genstr((byte*)", st0");
    };
}

static void ax_disasm_do87mem(byte * opcstr,i64 mf) {
    ax_disasm_genstr((byte*)"f");
    if ((mf==(i64)0)) {
        ax_disasm_opsize = (i64)4;
    }else if ((mf==(i64)1)) {
        ax_disasm_genstr((byte*)"i");
        ax_disasm_opsize = (i64)4;
    }else if ((mf==(i64)2)) {
        ax_disasm_opsize = (i64)8;
    }else if ((mf==(i64)3)) {
        ax_disasm_genstr((byte*)"i");
        ax_disasm_opsize = (i64)2;
    }else if ((mf==(i64)4)) {
        ax_disasm_genstr((byte*)"i");
        ax_disasm_opsize = (i64)8;
    }else if ((mf==(i64)5)) {
        ax_disasm_opsize = (i64)10;
    };
    ax_disasm_genstr((opcstr + (i64)1));
    ax_disasm_genstr((byte*)" ");
    ax_disasm_printaddrmode((i64)0);
}

static void ax_disasm_getsil(i64 * reg) {
    if (((((ax_disasm_opsize == (i64)1) && !!(ax_disasm_rex)) && ((*reg) >= (i64)5)) && ((*reg) <= (i64)8))) {
        (*reg) += (i64)12;
    };
}

static void ax_disasm_getsilx(i64 * reg) {
    if ((((((ax_disasm_addrmode == (i64)1) && (ax_disasm_opsize == (i64)1)) && !!(ax_disasm_rex)) && ((*reg) >= (i64)5)) && ((*reg) <= (i64)8))) {
        (*reg) += (i64)12;
    };
}

void ax_writeobj_writess(byte * outfile) {
    ax_writeobj_writecoff(outfile);
}

static void ax_writeobj_writerecord(void * r,i64 length) {
    memcpy((void *)(ax_writeobj_dataptr),r,(u32)(length));
    ax_writeobj_dataptr += length;
}

static void ax_writeobj_writerelocs(struct ax_decls_relocrec * r,i64 nrelocs) {
    static struct ax_objdecls_coffrelocrec s;
    struct ax_decls_strec *  d;
    if ((nrelocs == (i64)0)) {
        return;
    };
    L1338 :;
    while (!!(r)) {
        if (((*r).reloctype==(i64)2) || ((*r).reloctype==(i64)1)) {
            d = (*ax_decls_ss_symboltable)[((*r).stindex)-1];
            if (((i64)((*d).segment)==(i64)3)) {
                s.stindex = (i64)2;
            }else if (((i64)((*d).segment)==(i64)2)) {
                s.stindex = (i64)4;
            }else if (((i64)((*d).segment)==(i64)1)) {
                s.stindex = (i64)6;
            }else if (((i64)((*d).segment)==(i64)0)) {
                s.stindex = ((*r).stindex + ax_writeobj_stoffset);
            } else {
                ax_lib_gerror((byte*)"wrelocs/bad seg");
            };
        } else {
            s.stindex = ((*r).stindex + ax_writeobj_stoffset);
        };
        s.reloctype = (*r).reloctype;
        s.virtualaddr = (*r).offset;
        memcpy((void *)(ax_writeobj_dataptr),(void *)(&s),(u32)10u);
        ax_writeobj_dataptr += (i64)10;
        r = (*r).nextreloc;
L1339 :;
    }L1340 :;
    ;
}

static void ax_writeobj_writedata(struct ax_decls_dbuffer * data) {
    memcpy((void *)(ax_writeobj_dataptr),ax_lib_bufferelemptr(data,(i64)0),(u32)(ax_lib_bufferlength(data)));
    ax_writeobj_dataptr += ax_lib_bufferlength(data);
}

static void ax_writeobj_writesymboltable(void) {
    i64 i;
    L1341 :;
    for (i=(i64)1;i<=ax_writeobj_nsymbols;i+=(i64)1) {
L1342 :;
        ax_writeobj_writerecord((void *)(&ax_writeobj_symboltable[(i)]),(i64)18);
L1343 :;
    }L1344 :;
    ;
}

static void ax_writeobj_writestringtable(void) {
    i32 *  p;
    i64 i;
    i64 n;
    p = (i32 *)(ax_writeobj_dataptr);
    (*p) = ax_writeobj_nextstringoffset;
    ax_writeobj_dataptr += (i64)4;
    L1345 :;
    for (i=(i64)1;i<=ax_writeobj_nstrings;i+=(i64)1) {
L1346 :;
        n = (ax_writeobj_stringlengths[(i)-1] + (i64)1);
        memcpy((void *)(ax_writeobj_dataptr),(void *)(ax_writeobj_stringtable[(i)-1]),(u32)(n));
        ax_writeobj_dataptr += n;
L1347 :;
    }L1348 :;
    ;
}

static struct ax_objdecls_imagesymbol * ax_writeobj_makesymbol(byte * name,i64 namelen,i64 value,i64 sectionno,i64 symtype,i64 storage,i64 naux) {
    static struct ax_objdecls_imagesymbol r;
    if ((namelen == (i64)0)) {
        namelen = (i64)(strlen((i8 *)(name)));
    };
    if ((namelen < (i64)8)) {
        strcpy((i8 *)(&r.shortname[((i64)1)-1]),(i8 *)(name));
    } else if ((namelen == (i64)8)) {
        memcpy((void *)(&r.shortname[((i64)1)-1]),(void *)(name),(u32)(namelen));
    } else {
        r.shortx = (u64)((i64)0);
        r.longx = (u64)(ax_writeobj_addstringentry(name,namelen));
    };
    r.value = (u64)(value);
    r.sectionno = sectionno;
    r.symtype = (u64)(symtype);
    r.storageclass = (u64)(storage);
    r.nauxsymbols = (u64)(naux);
    return &r;
}

static void ax_writeobj_addsymbol(struct ax_objdecls_imagesymbol * r) {
    if ((ax_writeobj_nsymbols >= (i64)10001)) {
        ax_lib_gerror((byte*)"as:Too many symbols");
    };
    memcpy((void *)(&ax_writeobj_symboltable[(++ax_writeobj_nsymbols)]),(void *)(r),(u32)18u);
}

static void ax_writeobj_initsymboltable(byte * filename) {
    ax_writeobj_nsymbols = (i64)0;
    ax_writeobj_addsymbol(ax_writeobj_makesymbol((byte*)".file",(i64)0,(i64)0,(i64)-2,(i64)0,(i64)103,(i64)1));
    ax_writeobj_addsymbol(ax_writeobj_strtoaux(filename));
    ax_writeobj_addsymbol(ax_writeobj_makesymbol((byte*)".bss",(i64)0,(i64)0,(i64)1,(i64)0,(i64)3,(i64)1));
    ax_writeobj_addsymbol((struct ax_objdecls_imagesymbol *)(ax_writeobj_sectiontoaux((struct ax_decls_dbuffer *)(0),(i64)0)));
    ax_writeobj_addsymbol(ax_writeobj_makesymbol((byte*)".data",(i64)0,(i64)0,(i64)2,(i64)0,(i64)3,(i64)1));
    ax_writeobj_addsymbol((struct ax_objdecls_imagesymbol *)(ax_writeobj_sectiontoaux(ax_decls_ss_idata,ax_decls_ss_nidatarelocs)));
    ax_writeobj_addsymbol(ax_writeobj_makesymbol((byte*)".text",(i64)0,(i64)0,(i64)3,(i64)0,(i64)3,(i64)1));
    ax_writeobj_addsymbol((struct ax_objdecls_imagesymbol *)(ax_writeobj_sectiontoaux(ax_decls_ss_code,ax_decls_ss_ncoderelocs)));
}

static struct ax_objdecls_imagesymbol * ax_writeobj_strtoaux(byte * s) {
    static struct ax_objdecls_imagesymbol r;
    byte *  p;
    i64 n;
    p = (byte *)(&r);
    memset((void *)(p),(i32)0,(u32)18u);
    n = (i64)0;
    L1349 :;
    while ((((i64)((*s)) != (i64)0) && (n < (i64)18))) {
        (*p++) = (u64)((*s++));
        ++n;
L1350 :;
    }L1351 :;
    ;
    return &r;
}

static struct ax_objdecls_auxsectionrec * ax_writeobj_sectiontoaux(struct ax_decls_dbuffer * data,i64 nrelocs) {
    static struct ax_objdecls_auxsectionrec r;
    memset((void *)(&r),(i32)0,(u32)18u);
    if ((data == 0)) {
        r.length = ax_decls_ss_zdatalen;
    } else {
        r.length = ax_lib_bufferlength(data);
    };
    r.nrelocs = nrelocs;
    return &r;
}

static i64 ax_writeobj_addstringentry(byte * s,i64 length) {
    i64 offset;
    offset = ax_writeobj_nextstringoffset;
    if ((ax_writeobj_nstrings > (i64)5000)) {
        ax_lib_gerror((byte*)"W:too many strings");
    };
    ax_writeobj_stringtable[(++ax_writeobj_nstrings)-1] = s;
    ax_writeobj_stringlengths[(ax_writeobj_nstrings)-1] = length;
    ax_writeobj_nextstringoffset += (length + (i64)1);
    return offset;
}

static void ax_writeobj_convertsymboltable(void) {
    struct ax_decls_strec *  s;
    byte *  name;
    i64 i;
    i64 sect;
    i64 scope;
    ax_writeobj_stoffset = (ax_writeobj_nsymbols - (i64)1);
    ax_writeobj_nstrings = (i64)0;
    ax_writeobj_nextstringoffset = (i64)4;
    L1352 :;
    for (i=(i64)1;i<=ax_decls_ss_nsymbols;i+=(i64)1) {
L1353 :;
        s = (*ax_decls_ss_symboltable)[(i)-1];
        name = (*s).name;
        if (((i64)((*s).segment)==(i64)3)) {
            sect = (i64)1;
        }else if (((i64)((*s).segment)==(i64)2)) {
            sect = (i64)2;
        }else if (((i64)((*s).segment)==(i64)1)) {
            sect = (i64)3;
        } else {
            sect = (i64)0;
        };
        if (((i64)((*s).symbol)==(i64)19) || ((i64)((*s).symbol)==(i64)20)) {
            scope = (i64)3;
        }else if (((i64)((*s).symbol)==(i64)21) || ((i64)((*s).symbol)==(i64)22)) {
            scope = (i64)2;
        } else {
            scope = (i64)0;
        };
        ax_writeobj_addsymbol(ax_writeobj_makesymbol((*s).name,(i64)((*s).namelen),(i64)((*s).offset),sect,(i64)0,scope,(i64)0));
L1354 :;
    }L1355 :;
    ;
}

static void ax_writeobj_writecoff(byte * outfile) {
    struct ax_objdecls_imagefileheader header;
    struct ax_objdecls_imagesectionheader zsection;
    struct ax_objdecls_imagesectionheader isection;
    struct ax_objdecls_imagesectionheader csection;
    i64 offset;
    memset((void *)(&header),(i32)0,(u32)20u);
    memset((void *)(&zsection),(i32)0,(u32)40u);
    memset((void *)(&isection),(i32)0,(u32)40u);
    memset((void *)(&csection),(i32)0,(u32)40u);
    header.machine = (u64)((i64)34404);
    header.nsections = (u64)((i64)3);
    strcpy((i8 *)(&zsection.name[((i64)1)-1]),(i8 *)((byte*)".bss"));
    zsection.rawdata_size = (u64)(ax_decls_ss_zdatalen);
    zsection.characteristics = (u64)((i64)3225419904LL);
    if (((ax_decls_ss_nidatarelocs >= (i64)65536) || (ax_decls_ss_ncoderelocs >= (i64)65536))) {
        ax_lib_gerror((byte*)"Too many relocs (exceeds 16-bit field)");
    };
    strcpy((i8 *)(&isection.name[((i64)1)-1]),(i8 *)((byte*)".data"));
    isection.rawdata_size = (u64)(ax_lib_bufferlength(ax_decls_ss_idata));
    isection.nrelocs = (u64)(ax_decls_ss_nidatarelocs);
    isection.characteristics = (u64)((i64)3226468416LL);
    strcpy((i8 *)(&csection.name[((i64)1)-1]),(i8 *)((byte*)".text"));
    csection.rawdata_size = (u64)(ax_lib_bufferlength(ax_decls_ss_code));
    csection.nrelocs = (u64)(ax_decls_ss_ncoderelocs);
    csection.characteristics = (u64)((i64)1615855648);
    ax_writeobj_initsymboltable(outfile);
    ax_writeobj_convertsymboltable();
    offset = (i64)20;
    offset += (i64)120;
    if (!!((u64)(isection.nrelocs))) {
        isection.relocations_ptr = (u64)(offset);
        offset += ((i64)((u64)(isection.nrelocs)) * (i64)10);
    };
    if (!!((u64)(csection.nrelocs))) {
        csection.relocations_ptr = (u64)(offset);
        offset += ((i64)((u64)(csection.nrelocs)) * (i64)10);
    };
    isection.rawdata_offset = (u64)(offset);
    offset += (i64)(isection.rawdata_size);
    csection.rawdata_offset = (u64)(offset);
    offset += (i64)(csection.rawdata_size);
    header.symtaboffset = (u64)(offset);
    offset += (ax_writeobj_nsymbols * (i64)18);
    header.nsymbols = (u64)(ax_writeobj_nsymbols);
    offset += ax_writeobj_nextstringoffset;
    ax_writeobj_datastart = (ax_writeobj_dataptr = (byte *)(malloc((u64)(offset))));
    ax_writeobj_writerecord((void *)(&header),(i64)20);
    ax_writeobj_writerecord((void *)(&zsection),(i64)40);
    ax_writeobj_writerecord((void *)(&isection),(i64)40);
    ax_writeobj_writerecord((void *)(&csection),(i64)40);
    ax_writeobj_writerelocs(ax_decls_ss_idatarelocs,ax_decls_ss_nidatarelocs);
    ax_writeobj_writerelocs(ax_decls_ss_coderelocs,ax_decls_ss_ncoderelocs);
    ax_writeobj_writedata(ax_decls_ss_idata);
    ax_writeobj_writedata(ax_decls_ss_code);
    ax_writeobj_writesymboltable();
    ax_writeobj_writestringtable();
    if (!!(ax_decls_fverbose)) {
        msysnewc_m_print_startcon();
        msysnewc_m_print_str((byte*)"Writing file:",NULL);
        msysnewc_m_print_str(outfile,NULL);
        msysnewc_m_print_newline();
        msysnewc_m_print_end();
        ;
    };
    mlib_writefile(outfile,ax_writeobj_datastart,(ax_writeobj_dataptr - ax_writeobj_datastart));
}


/* ********** End of C Code ********** */
